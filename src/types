mk_julia_flisp_boot.scm:(make-system-image (cadddr *argv*))
crc32c.c:/* crc32c.c -- compute CRC-32C using software table or available hardware instructions
crc32c.c: *    http://stackoverflow.com/questions/17645167/implementing-sse-4-2s-crc32c-in-software
crc32c.c: *    - exported function renamed to jl_crc32c, DLL exports added.
crc32c.c: *    - removed main() function
crc32c.c: *    - architecture and compiler detection
crc32c.c: *    - precompute crc32c tables and store in a generated .c file
crc32c.c: *    - ARMv8 support
crc32c.c:  This software is provided 'as-is', without any express or implied
crc32c.c:/* This computes a CRC-32C, *not* the CRC-32 used by Ethernet and zip, gzip, etc.
crc32c.c: * A software version is provided as a fall-back, as well as for speed comparisons. */
crc32c.c:/* CRC-32C (iSCSI) polynomial in reversed bit order. */
crc32c.c:/* Block sizes for three-way parallel crc computation.  LONG and SHORT must
crc32c.c:#include "crc32c-tables.c"
crc32c.c:/* Compute CRC-32C using the SSE4.2 hardware instruction. */
crc32c.c:    /* pre-process the crc */
crc32c.c:       to an eight-byte boundary */
crc32c.c:        len--;
crc32c.c:       instructions, each on LONG bytes -- this is optimized for the Nehalem,
crc32c.c:        len -= LONG * 3;
crc32c.c:        len -= SHORT * 3;
crc32c.c:    /* compute the crc on the remaining eight-byte units less than a SHORT*3
crc32c.c:    const char *end = buf + (len - (len & 7));
crc32c.c:        len--;
crc32c.c:    /* return a post-processed crc */
crc32c.c:/* Compute CRC-32C using the ARMv8 CRC32 extension. */
crc32c.c:    /* pre-process the crc */
crc32c.c:    // on Cortex-A57
crc32c.c:    // crc32c has a latency of 3 and throughput of 1 on Cortex-A57
crc32c.c:    // The latency and throughput are 2 and 1 on Cortex-A72
crc32c.c:        len -= LONG * 3;
crc32c.c:        len -= SHORT * 3;
crc32c.c:        len -= SHORT * 2;
crc32c.c:    /* compute the crc on the remaining eight-byte units less than a SHORT*2
crc32c.c:    const char *end = buf + len - 8;
crc32c.c:    /* return a post-processed crc */
crc32c.c:/* Compute a CRC-32C. Do a lazy dispatch based on hardware features */
crc32c.c:/* Table-driven software version as a fall-back.  This is about 15 times slower
crc32c.c:   than using the hardware instructions.  This computes a little-endian
crc32c.c:   CRC32c, equivalent to the little-endian CRC of the SSE4.2 or ARMv8 instructions,
crc32c.c:        len--;
crc32c.c:        len -= 8;
crc32c.c:        len--;
crc32c.c:/* Compile with -DGEN_CRC32C_TABLES to generate header file containing
crc32c.c:// $ gcc src/crc32c.c -o main -DGEN_CRC32C_TABLES -I src -I src/support
crc32c.c:// $ ./main > src/crc32c-tables.c
crc32c.c:/* Table for a quadword-at-a-time software crc. */
crc32c.c:/* Construct table for software CRC-32C calculation. */
crc32c.c:    uint32_t odd[32];       /* odd-power-of-two zeros operator */
crc32c.c:    odd[0] = POLY;              /* CRC-32C polynomial */
crc32c.c:       in even -- next square puts operator for two zero bytes in odd, and so
crc32c.c:    /* answer ended up in odd -- copy to even */
crc32c.c:   for that length, byte-by-byte on the operand. */
crc32c.c:        printf(" }%s", i == m-1 ? "\n" : ",\n");
crc32c.c:    printf("/* Pregenerated tables for crc32c.c, produced by compiling with -DGEN_CRC32C_TABLES. */\n"
abi_ppc64le.cpp://===-- abi_ppc64le.cpp - Power v2 ABI description ---------------------*- C++ -*-===//
abi_ppc64le.cpp:// This file is distributed under the BSD-style LDC license:
abi_ppc64le.cpp:// Copyright (c) 2007-2012 LDC Team.
abi_ppc64le.cpp://===----------------------------------------------------------------------===//
abi_ppc64le.cpp:// The ABI implementation used for 64 bit little-endian PowerPC targets.
abi_ppc64le.cpp://===----------------------------------------------------------------------===//
abi_ppc64le.cpp:    size_t i, l = ty->layout->nfields;
abi_ppc64le.cpp:        else if (*hva || ty->size != (*ty0)->size)
abi_ppc64le.cpp:    if (!jl_is_datatype(fld0) || ty->name == jl_vecelement_typename)
abi_ppc64le.cpp:    if (fld0->name == jl_vecelement_typename) {
abi_ppc64le.cpp:        else if (!*hva || ty->size != (*ty0)->size)
abi_ppc64le.cpp:        if (!jl_is_datatype(fld) || ((jl_datatype_t*)fld)->layout == NULL || jl_is_layout_opaque(((jl_datatype_t*)fld)->layout))
abi_ppc64le.cpp:            assert(jl_is_datatype(vecty) && vecty->name == jl_vecelement_typename);
abi_ppc64le.cpp:    // rewrite integer-sized (non-HFA) struct to an array
julia_version.h:#define JULIA_VERSION_STRING "1.8.0-DEV"
llvm-multiversioning.cpp:// Function multi-versioning
llvm-multiversioning.cpp:#include "llvm-version.h"
llvm-multiversioning.cpp:#include <llvm-c/Core.h>
llvm-multiversioning.cpp:#include <llvm-c/Types.h>
llvm-multiversioning.cpp:            val(cast<T>(use->getUser())),
llvm-multiversioning.cpp:            cur(this->val->use_empty() ? nullptr : &*this->val->use_begin()),
llvm-multiversioning.cpp:            _next(cur ? cur->getNext() : nullptr)
llvm-multiversioning.cpp:            _next = cur->getNext();
llvm-multiversioning.cpp:        if (!frame->samebits) {
llvm-multiversioning.cpp:            auto layout = DL.getStructLayout(strct->getType());
llvm-multiversioning.cpp:            push(use, strct, frame->offset + layout->getElementOffset(use->getOperandNo()), true);
llvm-multiversioning.cpp:            auto elty = ary->getType()->getElementType();
llvm-multiversioning.cpp:            push(use, ary, frame->offset + DL.getTypeAllocSize(elty) * use->getOperandNo(), true);
llvm-multiversioning.cpp:            auto elty = vec->getType()->getElementType();
llvm-multiversioning.cpp:            push(use, vec, frame->offset + DL.getTypeAllocSize(elty) * use->getOperandNo(), true);
llvm-multiversioning.cpp:        if (!frame->samebits) {
llvm-multiversioning.cpp:        auto opcode = expr->getOpcode();
llvm-multiversioning.cpp:            push(use, expr, frame->offset, true);
llvm-multiversioning.cpp:        auto use = frame->cur;
llvm-multiversioning.cpp:        auto user = use->getUser();
llvm-multiversioning.cpp:        frame->next();
llvm-multiversioning.cpp:            return cast<Function>(vmap->lookup(orig_f));
llvm-multiversioning.cpp:    // GV addresses and their corresponding function id (i.e. 0-based index in `fvars`)
llvm-multiversioning.cpp:    // Mapping from function id (i.e. 0-based index in `fvars`) to GVs to be initialized.
llvm-multiversioning.cpp:    assert(gv && gv->hasInitializer());
llvm-multiversioning.cpp:    auto *ary = cast<ConstantArray>(gv->getInitializer());
llvm-multiversioning.cpp:    unsigned nele = ary->getNumOperands();
llvm-multiversioning.cpp:        res[i] = cast<T>(ary->getOperand(i)->stripPointerCasts());
llvm-multiversioning.cpp:    assert(gv->use_empty());
llvm-multiversioning.cpp:    gv->eraseFromParent();
llvm-multiversioning.cpp:    if (ary->use_empty())
llvm-multiversioning.cpp:        ary->destroyConstant();
llvm-multiversioning.cpp:      T_pvoidfunc(FunctionType::get(T_void, false)->getPointerTo()),
llvm-multiversioning.cpp:    // Workaround LLVM `CloneFunctionInfo` bug (?) pre-5.0
llvm-multiversioning.cpp:    Function::arg_iterator DestI = new_f->arg_begin();
llvm-multiversioning.cpp:    for (Function::const_arg_iterator J = F->arg_begin(); J != F->arg_end(); ++J) {
llvm-multiversioning.cpp:        DestI->setName(J->getName());
llvm-multiversioning.cpp:        // Fill in old->new mapping. We need to do this before cloning the function so that
llvm-multiversioning.cpp:            Function *new_f = Function::Create(F->getFunctionType(), F->getLinkage(),
llvm-multiversioning.cpp:                                               F->getName() + suffix, &M);
llvm-multiversioning.cpp:            new_f->copyAttributesFrom(F);
llvm-multiversioning.cpp:    if (ty->getReturnType()->isVectorTy())
llvm-multiversioning.cpp:    for (auto arg: ty->params()) {
llvm-multiversioning.cpp:        if (arg->isVectorTy()) {
llvm-multiversioning.cpp:    if (!pass->getAnalysis<LoopInfoWrapperPass>(F).getLoopInfo().empty())
llvm-multiversioning.cpp:                if (is_vector(call->getFunctionType())) {
llvm-multiversioning.cpp:                if (auto callee = call->getCalledFunction()) {
llvm-multiversioning.cpp:                    auto name = callee->getName();
llvm-multiversioning.cpp:                if (store->getValueOperand()->getType()->isVectorTy()) {
llvm-multiversioning.cpp:            else if (I.getType()->isVectorTy()) {
llvm-multiversioning.cpp:                if (mathOp->getFastMathFlags().any()) {
llvm-multiversioning.cpp:        // Fill in old->new mapping. We need to do this before cloning the function so that
llvm-multiversioning.cpp:        Function *new_f = Function::Create(F->getFunctionType(), F->getLinkage(),
llvm-multiversioning.cpp:                                           F->getName() + suffix, &M);
llvm-multiversioning.cpp:        new_f->copyAttributesFrom(F);
llvm-multiversioning.cpp:    auto &graph = pass->getAnalysis<CallGraphWrapperPass>().getCallGraph();
llvm-multiversioning.cpp:    while (!cur_set->empty()) {
llvm-multiversioning.cpp:                auto orig_child_f = child_node->getFunction();
llvm-multiversioning.cpp:                    auto orig_child_f2 = I2.second->getFunction();
llvm-multiversioning.cpp:                next_set->insert(orig_child_f);
llvm-multiversioning.cpp:                Function *new_f = Function::Create(child_f->getFunctionType(),
llvm-multiversioning.cpp:                                                   child_f->getLinkage(),
llvm-multiversioning.cpp:                                                   child_f->getName() + suffix, &M);
llvm-multiversioning.cpp:                new_f->copyAttributesFrom(child_f);
llvm-multiversioning.cpp:        next_set->clear();
llvm-multiversioning.cpp:    auto attr = F->getFnAttribute("target-features");
llvm-multiversioning.cpp:        F->addFnAttr("target-features", new_features);
llvm-multiversioning.cpp:        F->addFnAttr("target-features", features);
llvm-multiversioning.cpp:    F->addFnAttr("target-cpu", name);
llvm-multiversioning.cpp:    if (!F->hasFnAttribute(Attribute::OptimizeNone)) {
llvm-multiversioning.cpp:            F->addFnAttr(Attribute::OptimizeForSize);
llvm-multiversioning.cpp:            F->addFnAttr(Attribute::MinSize);
llvm-multiversioning.cpp:    return ref - 1;
llvm-multiversioning.cpp:    Constant *res = ConstantPointerNull::get(cast<PointerType>(stack[0].val->getType()));
llvm-multiversioning.cpp:        unsigned idx = use->getOperandNo();
llvm-multiversioning.cpp:        unsigned nargs = val->getNumOperands();
llvm-multiversioning.cpp:                args[j] = cast<Constant>(val->getOperand(j));
llvm-multiversioning.cpp:            res = expr->getWithOperands(args);
llvm-multiversioning.cpp:            res = ConstantArray::get(ary->getType(), args);
llvm-multiversioning.cpp:            res = ConstantStruct::get(strct->getType(), args);
llvm-multiversioning.cpp:            // And only for non-constant global variable initializers
llvm-multiversioning.cpp:            assert(info.use->getOperandNo() == 0);
llvm-multiversioning.cpp:            assert(!val->isConstant());
llvm-multiversioning.cpp:            val->setInitializer(rewrite_gv_init(stack));
llvm-multiversioning.cpp:                                  F->getName() + ".reloc_slot");
llvm-multiversioning.cpp:        unsigned idx = use->getOperandNo();
llvm-multiversioning.cpp:            auto inst = expr->getAsInstruction();
llvm-multiversioning.cpp:            inst->replaceUsesOfWith(val->getOperand(idx), replace);
llvm-multiversioning.cpp:            inst->insertBefore(insert_before);
llvm-multiversioning.cpp:        unsigned nargs = val->getNumOperands();
llvm-multiversioning.cpp:            auto op = val->getOperand(j);
llvm-multiversioning.cpp:                args[j] = UndefValue::get(op->getType());
llvm-multiversioning.cpp:            replace = InsertValueInst::Create(ConstantArray::get(ary->getType(), args),
llvm-multiversioning.cpp:            replace = InsertValueInst::Create(ConstantStruct::get(strct->getType(), args),
llvm-multiversioning.cpp:                    auto use_f = use_i->getFunction();
llvm-multiversioning.cpp:                    if (!use_f->getName().endswith(suffix))
llvm-multiversioning.cpp:                        insert_before = phi->getIncomingBlock(*info.use)->getTerminator();
llvm-multiversioning.cpp:                    ptr->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);
llvm-multiversioning.cpp:                    ptr->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(ctx, None));
llvm-multiversioning.cpp:                    ptr = new BitCastInst(ptr, F->getType(), "", insert_before);
llvm-multiversioning.cpp:                    use_i->setOperand(info.use->getOperandNo(),
llvm-multiversioning.cpp:    Comdat *jl_Comdat = G->getParent()->getOrInsertComdat(G->getName());
llvm-multiversioning.cpp:    jl_Comdat->setSelectionKind(Comdat::NoDuplicates);
llvm-multiversioning.cpp:    G->setComdat(jl_Comdat);
llvm-multiversioning.cpp:    if (G->getLinkage() == GlobalValue::ExternalLinkage)
llvm-multiversioning.cpp:        G->setDLLStorageClass(GlobalValue::DLLExportStorageClass);
llvm-multiversioning.cpp:        G->setDLLStorageClass(GlobalValue::DefaultStorageClass);
llvm-multiversioning.cpp:    if (ptr->getType()->isPointerTy())
llvm-multiversioning.cpp:        add_comdat(new GlobalVariable(M, value->getType(), true,
llvm-multiversioning.cpp:                values.push_back(get_ptrdiff32(it->second, gbase));
llvm-multiversioning.cpp:                    if (shared_relocs.count(j) || tgt->relocs.count(j)) {
llvm-multiversioning.cpp:                        offsets.push_back(get_ptrdiff32(grp->base_func(fvars[j]), fbase));
llvm-multiversioning.cpp:                    auto base_f = grp->base_func(fvars[j]);
llvm-multiversioning.cpp:                        auto f = map_get(*tgt->vmap, base_f, base_f);
llvm-multiversioning.cpp:                    else if (auto f = map_get(*tgt->vmap, base_f)) {
llvm-multiversioning.cpp:                        idxs.push_back(tgt->relocs.count(j) ? (jl_sysimg_tag_mask | j) : j);
llvm-multiversioning.cpp:        add_comdat(new GlobalVariable(M, idxval->getType(), true,
llvm-multiversioning.cpp:    //     * Original function -> ID (initialize from `fvars` and allocate ID lazily)
llvm-multiversioning.cpp:    //     * Cloned function -> Original function (add as we clone functions)
llvm-multiversioning.cpp:    //     * Original function -> Base function (target specific and updated by LLVM)
llvm-multiversioning.cpp:    //     * ID -> relocation slots (const).
llvm-multiversioning.cpp:    // and collected all the shared/target-specific relocations.
llvm-multiversioning.cpp:    unwrap(PM)->add(createMultiVersioningPass());
abi_x86.cpp://===-- abi_x86.cpp - x86 ABI description -----------------------*- C++ -*-===//
abi_x86.cpp:// This file is distributed under the BSD-style LDC license:
abi_x86.cpp:// Copyright (c) 2007-2012 LDC Team.
abi_x86.cpp://===----------------------------------------------------------------------===//
abi_x86.cpp://===----------------------------------------------------------------------===//
abi_x86.cpp:    return jl_is_datatype(dt) && dt->name->name == Complex_sym && dt->name->module == jl_base_module;
safepoint.c:    if (--jl_safepoint_enable_cnt[idx] != 0) {
safepoint.c:    // Now that we are requested to un-mprotect the page and no one else
safepoint.c:                             MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
safepoint.c:    assert(jl_atomic_load_relaxed(&jl_current_task->ptls->gc_state) == JL_GC_STATE_WAITING);
safepoint.c:    assert(jl_atomic_load_relaxed(&jl_current_task->ptls->gc_state) != 0);
runtime_intrinsics.c:// this file assumes a little-endian processor, although that isn't too hard to fix
runtime_intrinsics.c:// TODO: add half-float support
runtime_intrinsics.c:#include "APInt-C.h"
runtime_intrinsics.c:// TODO: use LLVM's compiler-rt
runtime_intrinsics.c:            exp = ((-14 - n_bit + 127) << 23);
runtime_intrinsics.c:            sig = ((sig & (~bit)) << n_bit) << (23 - 10);
runtime_intrinsics.c:            ret = 0x7fc00000 | (sign << 31) | (sig << (23 - 10));
runtime_intrinsics.c:        exp = ((exp - 15 + 127) << 23);
runtime_intrinsics.c:        sig = sig << (23 - 10);
runtime_intrinsics.c://   ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf
runtime_intrinsics.c:// With adjustments for round-to-nearest, ties to even.
runtime_intrinsics.c:    int nextbit = (f >> (sh - 1)) & 1;
runtime_intrinsics.c:        if ((h & 1) == 1 || (f & ((1 << (sh - 1)) - 1)) != 0)
runtime_intrinsics.c:#if !defined(_OS_DARWIN_)   // xcode already links compiler-rt
runtime_intrinsics.c:        jl_value_t **pp = (jl_value_t**)(jl_unbox_long(p) + (jl_unbox_long(i)-1)*sizeof(void*));
runtime_intrinsics.c:        char *pp = (char*)jl_unbox_long(p) + (jl_unbox_long(i)-1)*nb;
runtime_intrinsics.c:// run time version of pointerset intrinsic (warning: x is not gc-rooted)
runtime_intrinsics.c:        jl_value_t **pp = (jl_value_t**)(jl_unbox_long(p) + (jl_unbox_long(i)-1)*sizeof(void*));
runtime_intrinsics.c:        char *pp = (char*)jl_unbox_long(p) + (jl_unbox_long(i)-1)*nb;
runtime_intrinsics.c:        if ((nb & (nb - 1)) != 0 || nb > MAX_POINTERATOMIC_SIZE)
runtime_intrinsics.c:        if ((nb & (nb - 1)) != 0 || nb > MAX_POINTERATOMIC_SIZE)
runtime_intrinsics.c:        if ((nb & (nb - 1)) != 0 || nb > MAX_POINTERATOMIC_SIZE)
runtime_intrinsics.c:        if ((nb & (nb - 1)) != 0 || nb > MAX_POINTERATOMIC_SIZE)
runtime_intrinsics.c:        if ((nb & (nb - 1)) != 0 || nb > MAX_POINTERATOMIC_SIZE)
runtime_intrinsics.c:    return (((signed char*)a)[bytes - 1] < 0) ? ~0 : 0;
runtime_intrinsics.c:// fast-function generators //
runtime_intrinsics.c:        /* if needed, round type up to a real c-type and set/clear the unused bits */
runtime_intrinsics.c:        /* TODO: this memcpy assumes little-endian,
runtime_intrinsics.c:         * for big-endian, need to align the copy to the other end */ \
runtime_intrinsics.c:        memset((char*)pa2 + isize, getsign(pa, isize), osize2 - isize);
runtime_intrinsics.c:    // TODO: the following assume little-endian
runtime_intrinsics.c:    // for big-endian, need to copy from the other end of cnt
runtime_intrinsics.c:    jl_value_t *newv = jl_gc_alloc(ct->ptls, osize, ty);
runtime_intrinsics.c:    memset((char*)jl_data_ptr(newv) + sizeof(cnt), 0, osize - sizeof(cnt));
runtime_intrinsics.c:    jl_value_t *newv = jl_gc_alloc(ct->ptls, sz2, ty);
runtime_intrinsics.c:    /* choose the right size c-type operation based on the input */
runtime_intrinsics.c:        /* round type up to the appropriate c-type and set/clear the unused bits */
runtime_intrinsics.c:        memset((char*)pa2 + sz, getsign(pa, sz), sz2 - sz);
runtime_intrinsics.c:        /* round type up to the appropriate c-type and set/clear/truncate the unused bits
runtime_intrinsics.c:         * (zero-extend if cvtb is set, since in that case b is unsigned while the sign of a comes from the op)
runtime_intrinsics.c:        memset((char*)pb2 + szb, cvtb ? 0 : getsign(pb, szb), sz2 - szb);
runtime_intrinsics.c:    jl_value_t *newv = jl_gc_alloc(ct->ptls, ((jl_datatype_t*)tuptyp)->size, tuptyp);
runtime_intrinsics.c:    jl_value_t *newv = jl_gc_alloc(ct->ptls, sz, ty); \
runtime_intrinsics.c:    /* choose the right size c-type operation */ \
runtime_intrinsics.c:    /* choose the right size c-type operation */ \
runtime_intrinsics.c:    jl_value_t *newv = jl_gc_alloc(ct->ptls, sz, ty); \
runtime_intrinsics.c:    /* choose the right size c-type operation */ \
runtime_intrinsics.c:#define neg(a) -a
runtime_intrinsics.c:#define neg_float(pr, a) *pr = -a
runtime_intrinsics.c:#define sub(a,b) a - b
runtime_intrinsics.c:// same-type comparisons
runtime_intrinsics.c:#define ashr_op(a,b) ((b < 0 || b >= 8 * sizeof(a)) ? a >> (8 * sizeof(a) - 1) : a >> b)
runtime_intrinsics.c: * s_typemin = - s_typemax - 1
runtime_intrinsics.c: * s_typemax = ((t)1 << (runtime_nbits - 1)) - 1
runtime_intrinsics.c: * u_typemax = ((t)1 << runtime_nbits) - 1
runtime_intrinsics.c:#define sTYPEMIN(t) -sTYPEMAX(t) - 1
runtime_intrinsics.c:         ? ((((((t)1) << (8 * sizeof(t) - 2)) - 1) << 1) + 1)      \
runtime_intrinsics.c:         : (  (((t)1) << (runtime_nbits - 1)) - 1)))
runtime_intrinsics.c:        (b >= 0) ? (a > sTYPEMAX(t) - b) : (a < sTYPEMIN(t) - b)
runtime_intrinsics.c:    a > uTYPEMAX(t) - b
runtime_intrinsics.c:    /* this test checks for (b >= 0) ? (a - b < typemin) : (a - b > typemax) ==> overflow */ \
runtime_intrinsics.c:    /* this test checks for (a - b) < typemin ==> overflow */     \
runtime_intrinsics.c:        (b >= 0) ? a : -a
ccall.cpp:// --- the ccall, cglobal, and llvm intrinsics ---
ccall.cpp:    // in pseudo-code, this function emits the following:
ccall.cpp:    llvmf_orig->setAtomic(AtomicOrdering::Unordered);
ccall.cpp:    assert(f->getParent() != NULL);
ccall.cpp:    f->getBasicBlockList().push_back(dlsym_lookup);
ccall.cpp:    store->setAtomic(AtomicOrdering::Release);
ccall.cpp:    f->getBasicBlockList().push_back(ccall_bb);
ccall.cpp:    p->addIncoming(llvmf_orig, enter_bb);
ccall.cpp:    p->addIncoming(llvmf, llvmf->getParent());
ccall.cpp:    plt->setAttributes(attrs);
ccall.cpp:        plt->setCallingConv(cc);
ccall.cpp:    store->setAtomic(AtomicOrdering::Release);
ccall.cpp:    for (Function::arg_iterator arg = plt->arg_begin(), arg_e = plt->arg_end(); arg != arg_e; ++arg)
ccall.cpp:        cast<FunctionType>(ptr->getType()->getPointerElementType()),
ccall.cpp:    ret->setAttributes(attrs);
ccall.cpp:        ret->setCallingConv(cc);
ccall.cpp:            ret->setTailCallKind(CallInst::TCK_MustTail);
ccall.cpp:        if (functype->getReturnType() == T_void) {
ccall.cpp:    assert(!functype->isVarArg());
ccall.cpp:    got_val->setAtomic(AtomicOrdering::Unordered);
ccall.cpp:// --- ABI Implementations ---
ccall.cpp:// Partially based on the LDC ABI implementations licensed under the BSD 3-clause license
ccall.cpp:    Type *from_type = v->getType();
ccall.cpp:        return UndefValue::get(target_type); // convert undef (unreachable) -> undef (target_type)
ccall.cpp:    assert(from_type->isPointerTy() == target_type->isPointerTy()); // expect that all ABIs consider all pointers to be equivalent
ccall.cpp:    if (target_type->isPointerTy())
ccall.cpp:    if (from_type->getPrimitiveSizeInBits() > 0 &&
ccall.cpp:            target_type->getPrimitiveSizeInBits() == from_type->getPrimitiveSizeInBits())
ccall.cpp:    if (target_type->isFloatingPointTy() && from_type->isFloatingPointTy()) {
ccall.cpp:        if (target_type->getPrimitiveSizeInBits() > from_type->getPrimitiveSizeInBits())
ccall.cpp:        else if (target_type->getPrimitiveSizeInBits() < from_type->getPrimitiveSizeInBits())
ccall.cpp:    if (target_type->isIntegerTy() && from_type->isIntegerTy()) {
ccall.cpp:        cast<AllocaInst>(to)->setAlignment(Align(align));
ccall.cpp:        from = emit_bitcast(ctx, to, from_type->getPointerTo());
ccall.cpp:        cast<AllocaInst>(from)->setAlignment(Align(align));
ccall.cpp:        to = emit_bitcast(ctx, from, target_type->getPointerTo());
ccall.cpp:// --- argument passing and scratch space utilities ---
ccall.cpp:        literal_pointer_val(ctx, (jl_value_t*)ctx.linfo->def.method->sig),
ccall.cpp:    call->addAttribute(AttributeList::ReturnIndex,
ccall.cpp:    Value *jl_ptr;  // if the argument is a run-time computed pointer
ccall.cpp:// --- parse :sym or (:sym, :lib) argument into address info ---
ccall.cpp:        if (jl_is_expr(arg) && ((jl_expr_t*)arg)->head == jl_call_sym && jl_expr_nargs(arg) == 3 &&
ccall.cpp:            // attempt to interpret a non-constant 2-tuple expression as (func_name, lib_name()), where
ccall.cpp:// --- code generator for cglobal ---
ccall.cpp:            llvm::Module* mod = ctx.f->getParent();
ccall.cpp:                    // libjulia-like
ccall.cpp:            llvm::Constant* gv = mod->getOrInsertGlobal(cglobalname.c_str(), julia_type_to_llvm(ctx, param_type));
ccall.cpp:// --- code generator for llvmcall ---
ccall.cpp:    // - llvmcall(ir, (rettypes...), (argtypes...), args...)
ccall.cpp:    // - llvmcall((mod, fn), (rettypes...), (argtypes...), args...)
ccall.cpp:        ir_arg = jl_arrayref((jl_array_t*)ctx.source->code, ((jl_ssavalue_t*)ir_arg)->id - 1);
ccall.cpp:    if (jl_is_ssavalue(args[2]) && !jl_is_long(ctx.source->ssavaluetypes)) {
ccall.cpp:        jl_value_t *rtt = jl_arrayref((jl_array_t*)ctx.source->ssavaluetypes, ((jl_ssavalue_t*)args[2])->id - 1);
ccall.cpp:    if (jl_is_ssavalue(args[3]) && !jl_is_long(ctx.source->ssavaluetypes)) {
ccall.cpp:        jl_value_t *att = jl_arrayref((jl_array_t*)ctx.source->ssavaluetypes, ((jl_ssavalue_t*)args[3])->id - 1);
ccall.cpp:    jl_svec_t *tt = ((jl_datatype_t*)at)->parameters;
ccall.cpp:        raw_string_ostream(ir_name) << (ctx.f->getName().str()) << "u" << globalUnique++;
ccall.cpp:        if (jl_Module->getFunction(ir_name) == NULL)
ccall.cpp:            (*it)->print(argstream);
ccall.cpp:        rettype->print(rtypename);
ccall.cpp:        Function *f = Mod->getFunction(ir_name);
ccall.cpp:        f->addFnAttr(Attribute::AlwaysInline);
ccall.cpp:        Function *f = Mod->getFunction(jl_string_data(entry));
ccall.cpp:        f->setName(ir_name);
ccall.cpp:        assert(!f->isDeclaration());
ccall.cpp:        assert(f->getReturnType() == rettype);
ccall.cpp:            assert(*it == f->getFunctionType()->getParamType(i));
ccall.cpp:    Mod->setTargetTriple(jl_Module->getTargetTriple());
ccall.cpp:    Mod->setDataLayout(jl_Module->getDataLayout());
ccall.cpp:    Function *def = Mod->getFunction(ir_name);
ccall.cpp:    def->setLinkage(GlobalVariable::LinkOnceODRLinkage);
ccall.cpp:    FunctionType *decl_typ = FunctionType::get(rettype, argtypes, def->isVarArg());
ccall.cpp:    Function *decl = Function::Create(decl_typ, def->getLinkage(), def->getAddressSpace(),
ccall.cpp:                                      def->getName(), jl_Module);
ccall.cpp:    decl->setAttributes(def->getAttributes());
ccall.cpp:    if (inst->getType() != rettype) {
ccall.cpp:        stream << "llvmcall return type " << *inst->getType()
ccall.cpp:// --- code generator for ccall itself ---
ccall.cpp:    // XXX: need to handle parameterized zero-byte types (singleton)
ccall.cpp:    unsigned nb = DL.getTypeStoreSize(result->getType());
ccall.cpp:    std::vector<bool> fargt_isboxed; // vector of whether the llvm output type is a Julia-box for each argument
ccall.cpp:        abi->use_sret(jl_nothing_type, jl_LLVMContext);
ccall.cpp:        if (!jl_is_datatype(rt) || ((jl_datatype_t*)rt)->layout == NULL || jl_is_layout_opaque(((jl_datatype_t*)rt)->layout) || jl_is_cpointer_type(rt) || retboxed) {
ccall.cpp:            abi->use_sret(jl_voidpointer_type, jl_LLVMContext);
ccall.cpp:        else if (abi->use_sret((jl_datatype_t*)rt, jl_LLVMContext)) {
ccall.cpp:            prt = abi->preferred_llvm_type((jl_datatype_t*)rt, true, jl_LLVMContext);
ccall.cpp:        if (!jl_is_datatype(tti) || ((jl_datatype_t*)tti)->layout == NULL || jl_is_layout_opaque(((jl_datatype_t*)tti)->layout)) {
ccall.cpp:        bool byRef = abi->needPassByRef((jl_datatype_t*)tti, ab, jl_LLVMContext);
ccall.cpp:            pat = abi->preferred_llvm_type((jl_datatype_t*)tti, false, jl_LLVMContext);
ccall.cpp:                if (pat->isIntegerTy() && pat->getPrimitiveSizeInBits() < sizeof(int) * 8)
ccall.cpp:                if (pat->isFloatingPointTy() && pat->getPrimitiveSizeInBits() < sizeof(double) * 8)
ccall.cpp:    // If return value is boxed it must be non-null.
ccall.cpp:                if (ua->var == (jl_tvar_t*)ref) {
ccall.cpp:                ua = (jl_unionall_t*)ua->body;
ccall.cpp:            // `rt` is gc-rooted by the caller
ccall.cpp:    args -= 1;
ccall.cpp:                // libjulia-like
ccall.cpp:    jl_unionall_t *unionall = (jl_is_method(ctx.linfo->def.method) && jl_is_unionall(ctx.linfo->def.method->sig))
ccall.cpp:        ? (jl_unionall_t*)ctx.linfo->def.method->sig
ccall.cpp:      ctx.spvals_ptr == NULL ? ctx.linfo->sparam_vals : NULL,
ccall.cpp:                "sigatomic_end called in non-sigatomic region");
ccall.cpp:                ctx.builder.CreateConstInBoundsGEP1_32(T_size, get_current_signal_page(ctx), -1),
ccall.cpp:        ctx.f->getBasicBlockList().push_back(contBB);
ccall.cpp:                V_size0, ConstantInt::get(T_size, INTPTR_MAX / sizeof(void*) - 1));
ccall.cpp:            cast<LoadInst>(len)->setMetadata(LLVMContext::MD_range, rng);
ccall.cpp:        load->setAtomic(AtomicOrdering::Unordered);
ccall.cpp:        load->setAtomic(AtomicOrdering::Unordered);
ccall.cpp:                    idx = ctx.builder.CreateAdd(idx, ConstantInt::get(T_size, ((jl_datatype_t*)ety)->layout->first_ptr));
ccall.cpp:                load->setAtomic(AtomicOrdering::Unordered);
ccall.cpp:            T_prjlvalue, obj, (sizeof(jl_sym_t) + sizeof(void*) - 1) / sizeof(void*));
ccall.cpp:    FunctionType *functype = this->functype();
ccall.cpp:        // so that the julia_to_native type checks are more likely to be doable (e.g. concrete types) at compile-time
ccall.cpp:                jl_svec_len(ctx.linfo->sparam_vals) > 0) {
ccall.cpp:            jargty_in_env = jl_instantiate_type_in_env(jargty_in_env, unionall_env, jl_svec_data(ctx.linfo->sparam_vals));
ccall.cpp:            assert(v->getType() == pargty);
ccall.cpp:        assert(v->getType() == pargty);
ccall.cpp:            llvmf = jl_Module->getOrInsertFunction(f_name, functype).getCallee();
ccall.cpp:                              cast<Function>(llvmf)->getIntrinsicID() ==
ccall.cpp:            GlobalVariable* gv = cast_or_null<GlobalVariable>(mod->getNamedValue(symarg.f_name));
ccall.cpp:            llvm::Module* mod = ctx.f->getParent();
ccall.cpp:                    // libjulia-like
ccall.cpp:            llvmf = mod->getOrInsertFunction(funcname.c_str(), functype).getCallee();
ccall.cpp:            if (functype->isVarArg())
ccall.cpp:    ((CallInst*)ret)->setAttributes(attributes);
ccall.cpp:        ((CallInst*)ret)->setCallingConv(cc);
ccall.cpp:    if (0) { // Enable this to turn on SSPREQ (-fstack-protector) on the function containing this ccall
ccall.cpp:        ctx.f->addFnAttr(Attribute::StackProtectReq);
ccall.cpp:            return mark_julia_const(((jl_datatype_t*)rt)->instance);
ccall.cpp:                auto resultTy = result->getType();
ccall.cpp:                    slot->setAlignment(Align(boxalign));
ccall.cpp:            assert(jlrt == lrt || !lrt->isStructTy()); // julia_type_to_llvm and julia_struct_to_llvm should be returning the same StructType
datatype.c:// allocating TypeNames -----------------------------------------------------------
datatype.c:        len = strlen(n) - 1;
datatype.c:        len = (end-n) - 1;  // extract `f` from `#f#...`
datatype.c:        (jl_methtable_t*)jl_gc_alloc(ct->ptls, sizeof(jl_methtable_t),
datatype.c:    mt->name = jl_demangle_typename(name);
datatype.c:    mt->module = module;
datatype.c:    jl_atomic_store_relaxed(&mt->defs, jl_nothing);
datatype.c:    jl_atomic_store_relaxed(&mt->leafcache, (jl_array_t*)jl_an_empty_vec_any);
datatype.c:    jl_atomic_store_relaxed(&mt->cache, jl_nothing);
datatype.c:    mt->max_args = 0;
datatype.c:    mt->kwsorter = NULL;
datatype.c:    mt->backedges = NULL;
datatype.c:    JL_MUTEX_INIT(&mt->writelock);
datatype.c:    mt->offs = 0;
datatype.c:    mt->frozen = 0;
datatype.c:        (jl_typename_t*)jl_gc_alloc(ct->ptls, sizeof(jl_typename_t),
datatype.c:    tn->name = name;
datatype.c:    tn->module = module;
datatype.c:    tn->wrapper = NULL;
datatype.c:    jl_atomic_store_relaxed(&tn->cache, jl_emptysvec);
datatype.c:    jl_atomic_store_relaxed(&tn->linearcache, jl_emptysvec);
datatype.c:    tn->names = NULL;
datatype.c:    tn->hash = bitmix(bitmix(module ? module->build_id : 0, name->hash), 0xa1ada1da);
datatype.c:    tn->abstract = abstract;
datatype.c:    tn->mutabl = mutabl;
datatype.c:    tn->mayinlinealloc = 0;
datatype.c:    tn->mt = NULL;
datatype.c:    tn->partial = NULL;
datatype.c:    tn->atomicfields = NULL;
datatype.c:// allocating DataTypes -----------------------------------------------------------
datatype.c:    jl_datatype_t *t = (jl_datatype_t*)jl_gc_alloc(ct->ptls, sizeof(jl_datatype_t), jl_datatype_type);
datatype.c:    t->hash = 0;
datatype.c:    t->hasfreetypevars = 0;
datatype.c:    t->isdispatchtuple = 0;
datatype.c:    t->isbitstype = 0;
datatype.c:    t->zeroinit = 0;
datatype.c:    t->has_concrete_subtype = 1;
datatype.c:    t->cached_by_hash = 0;
datatype.c:    t->name = NULL;
datatype.c:    t->super = NULL;
datatype.c:    t->parameters = NULL;
datatype.c:    t->layout = NULL;
datatype.c:    t->types = NULL;
datatype.c:    t->instance = NULL;
datatype.c:        uint32_t max_offset = desc[nfields - 1].offset;
datatype.c:        if (npointers > 0 && pointers[npointers - 1] > max_offset)
datatype.c:            max_offset = pointers[npointers - 1];
datatype.c:    // TODO: lots of these are the same--take advantage of the fact these are immutable to combine them
datatype.c:    flddesc->nfields = nfields;
datatype.c:    flddesc->alignment = alignment;
datatype.c:    flddesc->haspadding = haspadding;
datatype.c:    flddesc->fielddesc_type = fielddesc_type;
datatype.c:    flddesc->npointers = npointers;
datatype.c:    flddesc->first_ptr = (npointers > 0 ? pointers[0] : -1);
datatype.c:// A non-zero result *must* match the LLVM rules for a vector type <nfields x t>.
datatype.c:// For sake of Ahead-Of-Time (AOT) compilation, this routine has to work
datatype.c:        // Only handle power-of-two-sized elements (for now)
datatype.c:    return (!d->name->abstract && jl_datatype_size(d) == 0 && d != jl_symbol_type && d->name != jl_array_typename &&
datatype.c:            d->isconcretetype && !d->name->mutabl);
datatype.c:        // It's possible for st to already have an ->instance if it was redefined
datatype.c:        if (!st->instance)
datatype.c:            st->instance = jl_gc_permobj(0, st);
datatype.c:    if (dt->layout)
datatype.c:    assert(dt->layout);
datatype.c:    if (ty->name->mayinlinealloc && (ty->isconcretetype || ((jl_datatype_t*)jl_unwrap_unionall(ty->name->wrapper))->layout)) { // TODO: use jl_struct_try_layout(dt) (but it is a safepoint)
datatype.c:        if (ty->layout->npointers > 0) {
datatype.c:            if (ty->name->n_uninitialized != 0)
datatype.c:            if (ty->layout->fielddesc_type > 1) // GC only implements support for 8 and 16 (not array32)
datatype.c:        unsigned na = union_isinlinable(((jl_uniontype_t*)ty)->a, 1, nbytes, align, asfield);
datatype.c:        unsigned nb = union_isinlinable(((jl_uniontype_t*)ty)->b, 1, nbytes, align, asfield);
datatype.c:        t == (jl_value_t*)jl_typeofbottom_type->super)
datatype.c:            (dt->isconcretetype || jl_svec_len(dt->parameters) == 0)) {
datatype.c:    jl_errorf("type %s has field offset %d that exceeds the page size", jl_symbol_name(st->name->name), offset);
datatype.c:    const uint64_t max_offset = (((uint64_t)1) << 32) - 1;
datatype.c:    if (st->name->wrapper == NULL)
datatype.c:        return; // we got called too early--we'll be back
datatype.c:    jl_datatype_t *w = (jl_datatype_t*)jl_unwrap_unionall(st->name->wrapper);
datatype.c:    if (st == w && st->layout) {
datatype.c:        // this check allows us to force re-computation of the layout for some types during init
datatype.c:        st->layout = NULL;
datatype.c:        st->size = 0;
datatype.c:        st->zeroinit = 0;
datatype.c:        st->has_concrete_subtype = 1;
datatype.c:    int isbitstype = st->isconcretetype && st->name->mayinlinealloc;
datatype.c:    // If layout doesn't depend on type parameters, it's stored in st->name->wrapper
datatype.c:    if (w->layout) {
datatype.c:        st->layout = w->layout;
datatype.c:        st->size = w->size;
datatype.c:        st->zeroinit = w->zeroinit;
datatype.c:        st->has_concrete_subtype = w->has_concrete_subtype;
datatype.c:        if (!jl_is_layout_opaque(st->layout)) { // e.g. jl_array_typename
datatype.c:            st->isbitstype = isbitstype && st->layout->npointers == 0;
datatype.c:    assert(st->types && w->types);
datatype.c:    size_t i, nfields = jl_svec_len(st->types);
datatype.c:    assert(st->name->n_uninitialized <= nfields);
datatype.c:            // opaque layout - heap-allocated blob
datatype.c:            static const jl_datatype_layout_t opaque_byte_layout = {0, 1, -1, 1, 0, 0};
datatype.c:            st->layout = &opaque_byte_layout;
datatype.c:        else if (st == jl_simplevector_type || st == jl_module_type || st->name == jl_array_typename) {
datatype.c:            static const jl_datatype_layout_t opaque_ptr_layout = {0, 1, -1, sizeof(void*), 0, 0};
datatype.c:            st->layout = &opaque_ptr_layout;
datatype.c:            static const jl_datatype_layout_t singleton_layout = {0, 0, -1, 1, 0, 0};
datatype.c:            st->layout = &singleton_layout;
datatype.c:        for (i = 0; st->has_concrete_subtype && i < nfields - st->name->n_uninitialized; i++) {
datatype.c:            jl_value_t *fld = jl_svecref(st->types, i);
datatype.c:                st->has_concrete_subtype = 0;
datatype.c:                st->has_concrete_subtype = !jl_is_datatype(fld) || ((jl_datatype_t *)fld)->has_concrete_subtype;
datatype.c:        if (!st->isconcretetype && !jl_has_fixed_layout(st)) {
datatype.c:    if (st->layout == NULL) {
datatype.c:                    uint32_t fld_npointers = ((jl_datatype_t*)fld)->layout->npointers;
datatype.c:                    if (((jl_datatype_t*)fld)->layout->haspadding)
datatype.c:                    if (i >= nfields - st->name->n_uninitialized && fld_npointers &&
datatype.c:                        // and contains non-pointer fields of non-zero sizes.
datatype.c:                        zeroinit = ((jl_datatype_t*)fld)->zeroinit;
datatype.c:                    // this somewhat poorly named flag says whether some of the bits can be non-unique
datatype.c:            if (__unlikely(max_offset - sz < fsz))
datatype.c:            if (__unlikely(max_offset - sz < offset))
datatype.c:        st->size = LLT_ALIGN(sz, alignm);
datatype.c:        if (st->size > sz)
datatype.c:                int j, npointers = ((jl_datatype_t*)fld)->layout->npointers;
datatype.c:        st->layout = jl_get_layout(nfields, npointers, alignm, haspadding, desc, pointers);
datatype.c:        st->zeroinit = zeroinit;
datatype.c:    assert(!isbitstype || st->layout->npointers == 0); // the definition of isbits
datatype.c:    st->isbitstype = isbitstype;
datatype.c:    t->super = super;
datatype.c:    if (super != NULL) jl_gc_wb(t, t->super);
datatype.c:    t->parameters = parameters;
datatype.c:    jl_gc_wb(t, t->parameters);
datatype.c:    t->types = ftypes;
datatype.c:    if (ftypes != NULL) jl_gc_wb(t, t->types);
datatype.c:    t->size = 0;
datatype.c:    t->name = NULL;
datatype.c:        // This code-path is used by the Serialization module to by-pass normal expectations
datatype.c:        tn->abstract = abstract;
datatype.c:        tn->mutabl = mutabl;
datatype.c:            // Callable objects (including compiler-generated closures) get independent method tables
datatype.c:            tn->mt = jl_new_method_table(name, module);
datatype.c:            jl_gc_wb(tn, tn->mt);
datatype.c:                tn->mt->offs = 1;
datatype.c:            tn->mt = jl_nonfunction_mt;
datatype.c:    t->name = tn;
datatype.c:    jl_gc_wb(t, t->name);
datatype.c:    t->name->names = fnames;
datatype.c:    jl_gc_wb(t->name, t->name->names);
datatype.c:    tn->n_uninitialized = jl_svec_len(fnames) - ninitialized;
datatype.c:            fldn--;
datatype.c:    tn->atomicfields = atomicfields;
datatype.c:    if (t->name->wrapper == NULL) {
datatype.c:        t->name->wrapper = (jl_value_t*)t;
datatype.c:        jl_gc_wb(t->name, t);
datatype.c:        for (i = np - 1; i >= 0; i--) {
datatype.c:            t->name->wrapper = jl_new_struct(jl_unionall_type, jl_svecref(parameters, i), t->name->wrapper);
datatype.c:            jl_gc_wb(t->name, t->name->wrapper);
datatype.c:            tn->mayinlinealloc = 1;
datatype.c:    if (!abstract && t->types != NULL)
datatype.c:    bt->isbitstype = (parameters == jl_emptysvec);
datatype.c:    bt->size = nbytes;
datatype.c:    bt->layout = jl_get_layout(0, 0, alignm, 0, NULL, NULL);
datatype.c:    bt->instance = NULL;
datatype.c:    bt->size = large ? GC_MAX_SZCLASS+1 : 0;
datatype.c:    layout->nfields = 0;
datatype.c:    layout->alignment = sizeof(void *);
datatype.c:    layout->haspadding = 1;
datatype.c:    layout->npointers = haspointers;
datatype.c:    layout->fielddesc_type = 3;
datatype.c:    desc->markfunc = markfunc;
datatype.c:    desc->sweepfunc = sweepfunc;
datatype.c:    bt->layout = layout;
datatype.c:    bt->instance = NULL;
datatype.c:    return jl_is_datatype(dt) && dt->layout && dt->layout->fielddesc_type == 3;
datatype.c:// bits constructors ----------------------------------------------------------
datatype.c:#error 12 byte GC pool size alignment unimplemented for 32-bit
datatype.c:    if (nb == 0)               return jl_new_struct_uninit(bt); // returns bt->instance
datatype.c:    jl_value_t *v = jl_gc_alloc(ct->ptls, nb, bt);
datatype.c:    if (nb == 0)               return jl_new_struct_uninit(bt); // returns bt->instance
datatype.c:    jl_value_t *v = jl_gc_alloc(ct->ptls, nb, bt);
datatype.c:    if (nb == 0)               return jl_new_struct_uninit(bt); // returns bt->instance
datatype.c:    jl_value_t *v = jl_gc_alloc(ct->ptls, jl_datatype_size(bt), bt);
datatype.c:    jl_value_t *y = jl_gc_alloc(ct->ptls, isptr ? nb : rettyp->size, isptr ? dt : rettyp);
datatype.c:        assert(!dt->layout->haspadding);
datatype.c:        assert(!dt->layout->haspadding);
datatype.c:                if (success || !dt->layout->haspadding || !jl_egal__bits(y, expected, dt))
datatype.c:                if (success || !dt->layout->haspadding || !jl_egal__bits(y, expected, dt))
datatype.c:                if (success || !dt->layout->haspadding || !jl_egal__bits(y, expected, dt))
datatype.c:        jl_value_t *z = jl_gc_alloc(ct->ptls, rettyp->size, rettyp);
datatype.c:    jl_value_t *v = jl_gc_alloc(ct->ptls, sizeof(size_t), bt);
datatype.c:        jl_value_t *v = jl_gc_alloc(ct->ptls, nw * sizeof(void*),       \
datatype.c:        jl_value_t *v = jl_gc_alloc(ct->ptls, nw * sizeof(void*),       \
datatype.c:        jl_value_t *v = jl_gc_alloc(ct->ptls, nw * sizeof(void*),       \
datatype.c:    jl_value_t *v = jl_gc_alloc(ct->ptls, sizeof(void*), jl_char_type);
datatype.c:        boxed_int32_cache[i]  = jl_permbox32(jl_int32_type, i-NBOX_C/2);
datatype.c:        boxed_int64_cache[i]  = jl_permbox64(jl_int64_type, i-NBOX_C/2);
datatype.c:        boxed_int16_cache[i]  = jl_permbox16(jl_int16_type, i-NBOX_C/2);
datatype.c:// struct constructors --------------------------------------------------------
datatype.c:    if (type->instance != NULL) return type->instance;
datatype.c:    jl_value_t *jv = jl_gc_alloc(ct->ptls, jl_datatype_size(type), type);
datatype.c:    if (!jl_is_datatype(type) || type->layout == NULL) {
datatype.c:    if (nf - type->name->n_uninitialized > na || na > nf)
datatype.c:    if (type->instance != NULL)
datatype.c:        return type->instance;
datatype.c:    jl_value_t *jv = jl_gc_alloc(ct->ptls, jl_datatype_size(type), type);
datatype.c:            memset(data + offs, 0, jl_datatype_size(type) - offs);
datatype.c:    if (!jl_is_datatype(type) || type->layout == NULL)
datatype.c:    if (type->instance != NULL) {
datatype.c:        return type->instance;
datatype.c:    jl_value_t *jv = jl_gc_alloc(ct->ptls, size, type);
datatype.c:    if (type->zeroinit) {
datatype.c:    if (type->instance != NULL) return type->instance;
datatype.c:    jl_value_t *jv = jl_gc_alloc(ct->ptls, size, type);
datatype.c:// field access ---------------------------------------------------------------
datatype.c:        jl_errorf("type %s has no field %s", jl_symbol_name(t->name->name),
datatype.c:    return -1;
datatype.c:        uint8_t sel = ((uint8_t*)v)[offs + fsz - 1];
datatype.c:            return ((jl_datatype_t*)ty)->instance;
datatype.c:        r = jl_gc_alloc(ct->ptls, fsz, ty);
datatype.c:        nb -= nptr * sizeof(void*);
datatype.c:            uint8_t *psel = &((uint8_t*)v)[offs + fsz - 1];
datatype.c:            hasptr = ((jl_datatype_t*)ty)->layout->npointers > 0;
datatype.c:        size_t fsz = jl_datatype_size((jl_datatype_t*)rty); // need to shrink-wrap the final copy
datatype.c:            uint8_t *psel = &((uint8_t*)v)[offs + fsz - 1];
datatype.c:            hasptr = ((jl_datatype_t*)ty)->layout->npointers > 0;
datatype.c:        size_t fsz = jl_datatype_size((jl_datatype_t*)rty); // need to shrink-wrap the final copy
datatype.c:                r = jl_gc_alloc(ct->ptls, fsz, ty);
datatype.c:                hasptr = ((jl_datatype_t*)ty)->layout->npointers > 0;
datatype.c:            size_t fsz = jl_datatype_size((jl_datatype_t*)rty); // need to shrink-wrap the final copy
datatype.c:                        uint8_t *psel = &((uint8_t*)v)[offs + fsz - 1];
datatype.c:                        fsz = jl_datatype_size((jl_datatype_t*)yty); // need to shrink-wrap the final copy
datatype.c:            hasptr = ((jl_datatype_t*)ty)->layout->npointers > 0;
datatype.c:            fsz = jl_datatype_size((jl_datatype_t*)rty); // need to shrink-wrap the final copy
datatype.c:                psel = &((uint8_t*)v)[offs + fsz - 1];
datatype.c:            r = jl_gc_alloc(ct->ptls, rettyp->size, (jl_value_t*)rettyp);
datatype.c:                size_t fsz = jl_datatype_size((jl_datatype_t*)rty); // need to shrink-wrap the final copy
datatype.c:                if (((jl_datatype_t*)rty)->layout->haspadding)
datatype.c:                size_t fsz = jl_datatype_size((jl_datatype_t*)rty); // need to shrink-wrap the final copy
datatype.c:        if (!jl_is_datatype(ft) || ft->layout->first_ptr < 0)
datatype.c:        fld += ft->layout->first_ptr;
datatype.c:    if (ty->layout == NULL || field > jl_datatype_nfields(ty) || field < 1)
datatype.c:    return jl_field_offset(ty, field - 1);
gc-stacks.c:    jl_atomic_fetch_add(&num_stack_mappings, -1);
gc-stacks.c:    void* stk = mmap(0, bufsz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
gc-stacks.c:    if (mprotect(stk, jl_guard_size, PROT_NONE) == -1) {
gc-stacks.c:    jl_atomic_fetch_add(&num_stack_mappings, -1);
gc-stacks.c:    if (bufsz <= pool_sizes[JL_N_STACK_POOLS - 1]) {
gc-stacks.c:            arraylist_push(&ptls->heap.free_stacks[pool_id], stkbuf);
gc-stacks.c:    _jl_free_stack(ct->ptls, stkbuf, bufsz);
gc-stacks.c:    if (task == ptls->root_task && !task->copy_stack)
gc-stacks.c:    void *stkbuf = task->stkbuf;
gc-stacks.c:    size_t bufsz = task->bufsz;
gc-stacks.c:    if (bufsz <= pool_sizes[JL_N_STACK_POOLS - 1]) {
gc-stacks.c:            task->stkbuf = NULL;
gc-stacks.c:            arraylist_push(&ptls->heap.free_stacks[pool_id], stkbuf);
gc-stacks.c:    jl_ptls_t ptls = ct->ptls;
gc-stacks.c:    if (ssize <= pool_sizes[JL_N_STACK_POOLS - 1]) {
gc-stacks.c:        arraylist_t *pool = &ptls->heap.free_stacks[pool_id];
gc-stacks.c:        if (pool->len > 0) {
gc-stacks.c:        arraylist_t *live_tasks = &ptls->heap.live_tasks;
gc-stacks.c:    //        if (!gc-marked(t))
gc-stacks.c:    //            stkbuf = t->stkbuf
gc-stacks.c:    //            bufsz = t->bufsz
gc-stacks.c:            arraylist_t *al = &ptls2->heap.free_stacks[p];
gc-stacks.c:            if (al->len > MIN_STACK_MAPPINGS_PER_POOL) {
gc-stacks.c:                n_to_free = al->len / 2;
gc-stacks.c:                if (n_to_free > (al->len - MIN_STACK_MAPPINGS_PER_POOL))
gc-stacks.c:                    n_to_free = al->len - MIN_STACK_MAPPINGS_PER_POOL;
gc-stacks.c:        arraylist_t *live_tasks = &ptls2->heap.live_tasks;
gc-stacks.c:        size_t l = live_tasks->len;
gc-stacks.c:        void **lst = live_tasks->items;
gc-stacks.c:            if (gc_marked(jl_astaggedvalue(t)->bits.gc)) {
gc-stacks.c:                if (t->stkbuf == NULL)
gc-stacks.c:                void *stkbuf = t->stkbuf;
gc-stacks.c:                size_t bufsz = t->bufsz;
gc-stacks.c:                    t->stkbuf = NULL;
gc-stacks.c:                if (t->tsan_state) {
gc-stacks.c:                    __tsan_destroy_fiber(t->tsan_state);
gc-stacks.c:                    t->tsan_state = NULL;
gc-stacks.c:            if (n >= l - ndel)
gc-stacks.c:        live_tasks->len -= ndel;
gc-stacks.c:    jl_ptls_t ptls = ct->ptls;
gc-stacks.c:    arraylist_t *live_tasks = &ptls->heap.live_tasks;
gc-stacks.c:        l = live_tasks->len;
gc-stacks.c:    } while (l + 1 < live_tasks->len);
gc-stacks.c:    l = live_tasks->len;
gc-stacks.c:    void **lst = live_tasks->items;
gc-stacks.c:    ((void**)jl_array_data(a))[j++] = ptls->root_task;
gc-stacks.c:        if (((jl_task_t*)lst[i])->stkbuf != NULL)
gc-stacks.c:        jl_array_del_end(a, l - j);
features_aarch64.h:JL_FEATURE_DEF(lse, 8, 0) // HWCAP_ATOMICS, ARMv8.1-Atomics. Required in ARMv8.1
features_aarch64.h:JL_FEATURE_DEF(rdm, 12, 0) // HWCAP_ASIMDRDM, ARMv8.1-SIMD. Required in ARMv8.1
features_aarch64.h:JL_FEATURE_DEF(rcpc, 15, 0) // HWCAP_LRCPC, ARMv8.3-RCPC. Required in ARMv8.3
features_aarch64.h:JL_FEATURE_DEF(ccpp, 16, 0) // HWCAP_DCPOP, ARMv8.2-DCPoP. Required in ARMv8.2
features_aarch64.h:JL_FEATURE_DEF(sha3, 17, 0) // HWCAP_SHA3. ARMv8.2-SHA
features_aarch64.h:JL_FEATURE_DEF(sm4, 19, 0) // HWCAP_SM4, ARMv8.2-SM
features_aarch64.h:JL_FEATURE_DEF(dotprod, 20, 0) // HWCAP_ASIMDDP, ARMv8.2-DotProd
features_aarch64.h:JL_FEATURE_DEF(fp16fml, 23, 0) // HWCAP_ASIMDFHM, ARMv8.2-FHM
features_aarch64.h:JL_FEATURE_DEF(dit, 24, 0) // HWCAP_DIT, ARMv8.4-DIT. Required in ARMv8.4
features_aarch64.h:// JL_FEATURE_DEF(uscat, 25, UINT32_MAX) // HWCAP_USCAT, ARMv8.4-LSE
features_aarch64.h:JL_FEATURE_DEF_NAME(rcpc_immo, 26, 0, "rcpc-immo") // HWCAP_ILRCPC, ARMv8.4-RCPC. Required in ARMv8.4
features_aarch64.h:JL_FEATURE_DEF(flagm, 27, 120000) // HWCAP_FLAGM, ARMv8.4-CondM. Required in ARMv8.4
features_aarch64.h:JL_FEATURE_DEF(ccdp, 32 + 0, 0) // HWCAP2_DCPODP, ARMv8.2-DCCVADP. Required in ARMv8.5
features_aarch64.h:// JL_FEATURE_DEF_NAME(sve2_aes, 32 + 2, 0, "sve2-aes") // HWCAP2_SVEAES, Implied by `sve2-aes`
features_aarch64.h:JL_FEATURE_DEF_NAME(sve2_aes, 32 + 3, 0, "sve2-aes") // HWCAP2_SVEPMULL, ID_AA64ZFR0_EL1.AES == 2
features_aarch64.h:JL_FEATURE_DEF_NAME(sve2_bitperm, 32 + 4, 100000, "sve2-bitperm") // HWCAP2_SVEBITPERM
features_aarch64.h:JL_FEATURE_DEF_NAME(sve2_sha3, 32 + 5, 0, "sve2-sha3") // HWCAP2_SVESHA3
features_aarch64.h:JL_FEATURE_DEF_NAME(sve2_sm4, 32 + 6, 0, "sve2-sm4") // HWCAP2_SM4
features_aarch64.h:JL_FEATURE_DEF(altnzcv, 32 + 7, 0) // HWCAP2_FLAGM2, ARMv8.5-CondM. Required in ARMv8.5
features_aarch64.h:// JL_FEATURE_DEF(svei8mm, 32 + 9, UINT32_MAX) // HWCAP2_SVEI8MM, ARMv8.2-I8MM. Same as `i8mm`
features_aarch64.h:JL_FEATURE_DEF(f32mm, 32 + 10, 110000) // HWCAP2_SVEF32MM, ARMv8.2-F32MM
features_aarch64.h:JL_FEATURE_DEF(f64mm, 32 + 11, 110000) // HWCAP2_SVEF64MM, ARMv8.2-F64MM
features_aarch64.h:// JL_FEATURE_DEF(svebf16, 32 + 12, UINT32_MAX) // HWCAP2_SVEBF16, ARMv8.2-BF16. Same as `bf16`
features_aarch64.h:JL_FEATURE_DEF(i8mm, 32 + 13, 110000) // HWCAP2_I8MM, ARMv8.2-I8MM. Required in ARMv8.6
features_aarch64.h:JL_FEATURE_DEF(bf16, 32 + 14, 110000) // HWCAP2_BF16, ARMv8.2-BF16. Required in ARMv8.6
features_aarch64.h:// JL_FEATURE_DEF(dgh, 32 + 15, UINT32_MAX) // HWCAP2_DGH, ARMv8.0-DGH. Not implement in LLVM yet
features_aarch64.h:JL_FEATURE_DEF(rand, 32 + 16, 0) // HWCAP2_RNG, ARMv8.5-RNG
features_aarch64.h:JL_FEATURE_DEF(mte, 32 + 18, 0) // HWCAP2_MTE, ARMv8.5-MemTag (reserved as of kernel 5.9-rc1)
features_aarch32.h:// JL_FEATURE_DEF(vfpv3d16, 14, 0) // -d32
features_aarch32.h:JL_FEATURE_DEF_NAME(hwdiv_arm, 17, 0, "hwdiv-arm")
task.c:    if (state != &ptls->root_task->tsan_state) {
task.c:// and additionally, gc-stack reserves 64k for the guard pages
task.c:    char *stackbase = (char*)ptls->stackbase;
task.c:    size_t nb = stackbase - frame_addr;
task.c:    if (lastt->bufsz < nb) {
task.c:        lastt->stkbuf = buf;
task.c:        lastt->bufsz = nb;
task.c:        buf = lastt->stkbuf;
task.c:    *pt = NULL; // clear the gc-root for the target task before copying the stack for saving
task.c:    lastt->copy_stack = nb;
task.c:    lastt->sticky = 1;
task.c:    size_t nb = t->copy_stack;
task.c:    char *_x = (char*)ptls->stackbase - nb;
task.c:            p = (char*)alloca((char*)&_x - _x);
task.c:    void *_y = t->stkbuf;
task.c:    sanitizer_start_switch_fiber(t->stkbuf, t->bufsz);
task.c:    jl_setcontext(&t->ctx);
task.c:    jl_longjmp(t->copy_stack_ctx.uc_mcontext, 1);
task.c:    assert(t->copy_stack && !lastt->copy_stack);
task.c:    size_t nb = t->copy_stack;
task.c:    char *_x = (char*)ptls->stackbase - nb;
task.c:    void *_y = t->stkbuf;
task.c:    int r = unw_getcontext(&lastt->ctx);
task.c:    if (jl_setjmp(lastt->copy_stack_ctx.uc_mcontext, 0))
task.c:    sanitizer_start_switch_fiber(t->stkbuf, t->bufsz);
task.c:    jl_setcontext(&t->ctx);
task.c:    jl_longjmp(t->copy_stack_ctx.uc_mcontext, 1);
task.c:    if (jl_atomic_load_relaxed(&t->_isexception))
task.c:        jl_atomic_store_release(&t->_state, JL_TASK_STATE_FAILED);
task.c:        jl_atomic_store_release(&t->_state, JL_TASK_STATE_DONE);
task.c:    if (t->copy_stack) // early free of stkbuf
task.c:        t->stkbuf = NULL;
task.c:    ct->ptls->in_finalizer = 0;
task.c:    ct->ptls->in_pure_callback = 0;
task.c:    ct->world_age = jl_world_counter;
task.c:    if (jl_all_tls_states[0]->root_task == task) {
task.c:    jl_ptls_t ptls2 = task->ptls;
task.c:    *ptid = -1;
task.c:        *ptid = jl_atomic_load_relaxed(&task->tid);
task.c:        if (task->copy_stack) {
task.c:            *size = ptls2->stacksize;
task.c:            return (char *)ptls2->stackbase - *size;
task.c:    *size = task->bufsz - off;
task.c:    return (void *)((char *)task->stkbuf + off);
task.c:    if (!task->started) {
task.c:    jl_ptls_t ptls2 = task->ptls;
task.c:    if (task->copy_stack && ptls2) {
task.c:        *total_start = *active_start = (char*)ptls2->stackbase - ptls2->stacksize;
task.c:        *total_end = *active_end = (char*)ptls2->stackbase;
task.c:    else if (task->stkbuf) {
task.c:        *total_start = *active_start = (char*)task->stkbuf;
task.c:        if (jl_all_tls_states[0]->root_task == task) {
task.c:        *total_end = *active_end = (char*)task->stkbuf + task->bufsz;
task.c:        if (task->copy_stack > 1)
task.c:            *active_end = (char*)task->stkbuf + task->copy_stack;
task.c:    ptls->bt_size = rec_backtrace(ptls->bt_data, JL_MAX_BT_SIZE, skip + 1);
task.c:    jl_current_task->ptls->next_task = task;
task.c:    if (ct->ptls->next_task)
task.c:        return ct->ptls->next_task;
task.c:    jl_ptls_t ptls = lastt->ptls;
task.c:    jl_task_t **pt = &ptls->next_task;
task.c:    assert(ptls->locks.len == 0);
task.c:    if (lastt->tsan_state != __tsan_get_current_fiber()) {
task.c:        // Something went really wrong - don't even assume that we can
task.c:        write(STDERR_FILENO, tsan_state_corruption, sizeof(tsan_state_corruption) - 1);
task.c:    int killed = jl_atomic_load_relaxed(&lastt->_state) != JL_TASK_STATE_RUNNABLE;
task.c:    if (!t->started && !t->copy_stack) {
task.c:        if (t->stkbuf == NULL) {
task.c:            t->stkbuf = jl_alloc_fiber(&t->ctx, &t->bufsz, t);
task.c:            if (t->stkbuf == NULL) {
task.c:                t->copy_stack = 1;
task.c:                t->sticky = 1;
task.c:                t->bufsz = 0;
task.c:                    memcpy(&t->copy_stack_ctx, &ptls->copy_stack_ctx, sizeof(t->copy_stack_ctx));
task.c:                    memcpy(&t->ctx, &ptls->base_ctx, sizeof(t->ctx));
task.c:        *pt = NULL; // can't fail after here: clear the gc-root for the target task now
task.c:        lastt->gcstack = NULL;
task.c:        if (!lastt->copy_stack && lastt->stkbuf) {
task.c:        if (lastt->copy_stack) { // save the old copy-stack
task.c:            save_stack(ptls, lastt, pt); // allocates (gc-safepoint, and can also fail)
task.c:            if (jl_setjmp(lastt->copy_stack_ctx.uc_mcontext, 0)) {
task.c:        *pt = NULL; // can't fail after here: clear the gc-root for the target task now
task.c:        lastt->ptls = NULL;
task.c:    t->ptls = ptls;
task.c:    ptls->current_task = t;
task.c:    lastt->ptls = NULL;
task.c:    ptls->previous_task = lastt;
task.c:    jl_set_pgcstack(&t->gcstack);
task.c:    tsan_switch_to_ctx(t->tsan_state);
task.c:        tsan_destroy_ctx(ptls, &lastt->tsan_state);
task.c:    if (t->started) {
task.c:        if (t->copy_stack) {
task.c:            if (!killed && !lastt->copy_stack)
task.c:            else if (lastt->copy_stack) {
task.c:            sanitizer_start_switch_fiber(t->stkbuf, t->bufsz);
task.c:                jl_set_fiber(&t->ctx); // (doesn't return)
task.c:                if (lastt->copy_stack) {
task.c:                    jl_set_fiber(&t->ctx); // (doesn't return)
task.c:                    jl_swap_fiber(&lastt->ctx, &t->ctx);
task.c:        sanitizer_start_switch_fiber(t->stkbuf, t->bufsz);
task.c:        if (t->copy_stack && always_copy_stacks) {
task.c:            jl_setcontext(&t->ctx);
task.c:            jl_longjmp(t->copy_stack_ctx.uc_mcontext, 1);
task.c:                jl_start_fiber_set(&t->ctx); // (doesn't return)
task.c:            else if (lastt->copy_stack) {
task.c:                jl_start_fiber_set(&t->ctx); // (doesn't return)
task.c:                jl_start_fiber_swap(&lastt->ctx, &t->ctx);
task.c:    jl_ptls_t ptls = ct->ptls;
task.c:    jl_task_t *t = ptls->next_task;
task.c:    if (t->started && t->stkbuf == NULL)
task.c:    if (ptls->in_finalizer)
task.c:    if (ptls->in_pure_callback)
task.c:    if (!jl_set_task_tid(t, jl_atomic_load_relaxed(&ct->tid))) // manually yielding to a task
task.c:    sig_atomic_t defer_signal = ptls->defer_signal;
task.c:    int finalizers_inhibited = ptls->finalizers_inhibited;
task.c:    ptls->finalizers_inhibited = 0;
task.c:    jl_timing_block_t *blk = ptls->timing_stack;
task.c:    ptls->timing_stack = NULL;
task.c:    ptls = ct->ptls;
task.c:    t = ptls->previous_task;
task.c:    ptls->previous_task = NULL;
task.c:    assert(jl_atomic_load_relaxed(&t->tid) == ptls->tid);
task.c:    if (!t->sticky && !t->copy_stack)
task.c:        jl_atomic_store_release(&t->tid, -1);
task.c:    assert(ptls == ct->ptls);
task.c:           0 != ct->ptls &&
task.c:           0 == ptls->finalizers_inhibited);
task.c:    ptls->finalizers_inhibited = finalizers_inhibited;
task.c:    assert(ptls->timing_stack == NULL);
task.c:    ptls->timing_stack = blk;
task.c:    sig_atomic_t other_defer_signal = ptls->defer_signal;
task.c:    ptls->defer_signal = defer_signal;
task.c:    jl_ptls_t ptls = ct->ptls;
task.c:    ptls->io_wait = 0;
task.c:        // The temporary ptls->bt_data is rooted by special purpose code in the
task.c:        // set ptls->bt_size=0 below.
task.c:        jl_push_excstack(&ct->excstack, exception,
task.c:                          ptls->bt_data, ptls->bt_size);
task.c:        ptls->bt_size = 0;
task.c:    assert(ct->excstack && ct->excstack->top);
task.c:    jl_handler_t *eh = ct->eh;
task.c:        jl_timing_block_t *cur_block = ptls->timing_stack;
task.c:        while (cur_block && eh->timing_stack != cur_block) {
task.c:        assert(cur_block == eh->timing_stack);
task.c:        jl_longjmp(eh->eh_ctx, 1);
task.c:    record_backtrace(ct->ptls, 1);
task.c:    jl_excstack_t *excstack = ct->excstack;
task.c:    if (!excstack || excstack->top == 0)
task.c:    jl_ptls_t ptls = ct->ptls;
task.c:    jl_value_t *e = ptls->sig_exception;
task.c:    ptls->sig_exception = NULL;
task.c:    jl_excstack_t *excstack = ct->excstack;
task.c:    if (!excstack || excstack->top == 0)
task.c:    jl_excstack_raw(excstack)[excstack->top-1].jlvalue = e;
task.c:   within Julia, due to inlining and more agressive architecture-specific optimizations.
task.c:    uint64_t s0 = task->rngState0;
task.c:    uint64_t s1 = task->rngState1;
task.c:    uint64_t s2 = task->rngState2;
task.c:    uint64_t s3 = task->rngState3;
task.c:    task->rngState0 = s0;
task.c:    task->rngState1 = s1;
task.c:    task->rngState2 = s2;
task.c:    task->rngState3 = s3;
task.c:    /* TODO: consider a less ad-hoc construction
task.c:       effectively random coefficients, to break possible self-interactions.
task.c:       It is not the goal to mix bits -- we work under the assumption that the
task.c:       source is well-seeded, and its output looks effectively random.
task.c:    to->rngState0 = 0x02011ce34bce797f * jl_tasklocal_genrandom(from);
task.c:    to->rngState1 = 0x5a94851fb48a6e05 * jl_tasklocal_genrandom(from);
task.c:    to->rngState2 = 0x3688cf5d48899fa7 * jl_tasklocal_genrandom(from);
task.c:    to->rngState3 = 0x867b4bb4c42e5661 * jl_tasklocal_genrandom(from);
task.c:    jl_task_t *t = (jl_task_t*)jl_gc_alloc(ct->ptls, sizeof(jl_task_t), jl_task_type);
task.c:    t->copy_stack = 0;
task.c:            t->copy_stack = 1;
task.c:            t->bufsz = 0;
task.c:            t->bufsz = JL_STACK_SIZE;
task.c:        t->stkbuf = NULL;
task.c:        t->bufsz = ssize;
task.c:        t->stkbuf = jl_alloc_fiber(&t->ctx, &t->bufsz, t);
task.c:        if (t->stkbuf == NULL)
task.c:    t->next = jl_nothing;
task.c:    t->queue = jl_nothing;
task.c:    t->tls = jl_nothing;
task.c:    jl_atomic_store_relaxed(&t->_state, JL_TASK_STATE_RUNNABLE);
task.c:    t->start = start;
task.c:    t->result = jl_nothing;
task.c:    t->donenotify = completion_future;
task.c:    jl_atomic_store_relaxed(&t->_isexception, 0);
task.c:    t->logstate = ct->logstate;
task.c:    // Fork task-local random state from parent
task.c:    t->eh = NULL;
task.c:    t->sticky = 1;
task.c:    t->gcstack = NULL;
task.c:    t->excstack = NULL;
task.c:    t->started = 0;
task.c:    t->prio = -1;
task.c:    jl_atomic_store_relaxed(&t->tid, t->copy_stack ? jl_atomic_load_relaxed(&ct->tid) : -1); // copy_stacks are always pinned since they can't be moved
task.c:    t->ptls = NULL;
task.c:    t->world_age = ct->world_age;
task.c:    if (!t->copy_stack) {
task.c:        memset(&t->ctx, 0, sizeof(t->ctx));
task.c:            memcpy(&t->copy_stack_ctx, &ct->ptls->copy_stack_ctx, sizeof(t->copy_stack_ctx));
task.c:            memcpy(&t->ctx, &ct->ptls->base_ctx, sizeof(t->ctx));
task.c:    t->tsan_state = __tsan_create_fiber(0);
task.c:    return &t->ctx;
task.c:    return (jl_value_t*)ct->ptls->root_task;
task.c:    size_t last_age = ct->world_age;
task.c:    ct->world_age = jl_get_world_counter();
task.c:    ct->world_age = last_age;
task.c:    size_t last_age = ct->world_age;
task.c:    ct->world_age = jl_get_world_counter();
task.c:    ct->world_age = last_age;
task.c:// Do one-time initializations for task system
task.c:    jl_ptls_t ptls = ct->ptls;
task.c:    assert(ptls->finalizers_inhibited == 0);
task.c:    jl_task_t *pt = ptls->previous_task;
task.c:    ptls->previous_task = NULL;
task.c:    if (!pt->sticky && !pt->copy_stack)
task.c:        jl_atomic_store_release(&pt->tid, -1);
task.c:    ct->started = 1;
task.c:    if (jl_atomic_load_relaxed(&ct->_isexception)) {
task.c:        jl_push_excstack(&ct->excstack, ct->result,
task.c:                         ptls->bt_data, ptls->bt_size);
task.c:        res = ct->result;
task.c:            if (ptls->defer_signal) {
task.c:                ptls->defer_signal = 0;
task.c:            res = jl_apply(&ct->start, 1);
task.c:            jl_atomic_store_relaxed(&ct->_isexception, 1);
task.c:    ct->result = res;
task.c:    jl_gc_wb(ct, ct->result);
task.c:    t->uc_stack.ss_sp = stk;
task.c:    t->uc_stack.ss_size = *ssize;
task.c:    t->uc_link = NULL;
task.c:    if (jl_setjmp(lastt->uc_mcontext, 0))
task.c:    jl_longjmp(t->uc_mcontext, 1);
task.c:        stk -= sizeof(uintptr_t); \
task.c:    if (jl_setjmp(lastt->uc_mcontext, 0))
task.c:                    // because all our addresses are word-aligned.
task.c:        // Move stack (-0x30 for initial stack frame) to stack pointer
task.c:        " addi 1, %0, -0x30;\n"
task.c:    jl_ptls_t ptls = jl_current_task->ptls;
task.c:    if (jl_setjmp(ptls->base_ctx.uc_mcontext, 0))
task.c:    jl_ptls_t ptls = jl_current_task->ptls;
task.c:    memcpy(&base_ctx, &ptls->base_ctx, sizeof(ptls->base_ctx));
task.c:    if (&ptls->base_ctx != t) {
task.c:        memcpy(t, &ptls->base_ctx, sizeof(ptls->base_ctx));
task.c:        memcpy(&ptls->base_ctx, &base_ctx, sizeof(ptls->base_ctx)); // restore COPY_STACKS context
task.c:    jl_longjmp(t->uc_mcontext, 1); // (doesn't return)
task.c:    if (lastt && jl_setjmp(lastt->uc_mcontext, 0))
task.c:    if (jl_setjmp(lastt->uc_mcontext, 0))
task.c:    jl_longjmp(t->uc_mcontext, 1);
task.c:    t->stackbottom = stk;
task.c:    t->stacktop = ((char*)stk) + *ssize;
task.c:    assert(ptls->root_task == NULL);
task.c:    // we need the `Task` type itself. We use stack-allocated "raw" `jl_task_t` struct to
task.c:    // workaround this chicken-and-egg problem. Note that this relies on GC to be turned
task.c:    size_t ssize = (char*)stack_hi - (char*)stack_lo;
task.c:    if (ptls->tid == 0) {
task.c:        stack = (void*)((char*)stack - ROOT_TASK_STACK_ADJUSTMENT); // offset our guess of the address of the bottom of stack to cover the guard pages too
task.c:        ct->copy_stack = 1;
task.c:        ct->stkbuf = NULL;
task.c:        ct->bufsz = 0;
task.c:        ct->copy_stack = 0;
task.c:        ct->stkbuf = stack;
task.c:        ct->bufsz = ssize;
task.c:    ct->started = 1;
task.c:    ct->next = jl_nothing;
task.c:    ct->queue = jl_nothing;
task.c:    ct->tls = jl_nothing;
task.c:    jl_atomic_store_relaxed(&ct->_state, JL_TASK_STATE_RUNNABLE);
task.c:    ct->start = NULL;
task.c:    ct->result = jl_nothing;
task.c:    ct->donenotify = jl_nothing;
task.c:    jl_atomic_store_relaxed(&ct->_isexception, 0);
task.c:    ct->logstate = jl_nothing;
task.c:    ct->eh = NULL;
task.c:    ct->gcstack = NULL;
task.c:    ct->excstack = NULL;
task.c:    jl_atomic_store_relaxed(&ct->tid, ptls->tid);
task.c:    ct->sticky = 1;
task.c:    ct->ptls = ptls;
task.c:    ct->world_age = 1; // OK to run Julia code on this task
task.c:    ptls->root_task = ct;
task.c:    ptls->current_task = ct;
task.c:    jl_set_pgcstack(&ct->gcstack);
task.c:    ct->tsan_state = __tsan_get_current_fiber();
task.c:        ptls->stackbase = stack_hi;
task.c:        ptls->stacksize = ssize;
task.c:        ptls->copy_stack_ctx.uc_stack.ss_sp = stack_hi;
task.c:        ptls->copy_stack_ctx.uc_stack.ss_size = ssize;
task.c:        if (jl_setjmp(ptls->copy_stack_ctx.uc_mcontext, 0))
task.c:    char *stkbuf = jl_alloc_fiber(&ptls->base_ctx, &ssize, NULL);
task.c:    ptls->stackbase = stkbuf + ssize;
task.c:    ptls->stacksize = ssize;
task.c:    return t->started;
task.c:    return jl_atomic_load_relaxed(&t->tid);
task.c:    jl_safe_printf("ThreadId: %u, Stack: %p -- %p to %p, SEH: %p\n",
task.c:    jl_safe_printf("ThreadId: %u, Stack: %p -- %p to %p, SEH: %p\n",
task.c:    if (__readgs()) { // WoW64 if GS is non-zero
codegen.cpp:#include "llvm-version.h"
codegen.cpp:#include <llvm-c/Types.h>
codegen.cpp:#define jl_Module ctx.f->getParent()
codegen.cpp:#define jl_builderModule(builder) (builder).GetInsertBlock()->getParent()->getParent()
codegen.cpp:// type-based alias analysis nodes.  Indentation of comments indicates hierarchy.
codegen.cpp:// LLVM should have enough info for alias analysis of non-gcframe stack slot
codegen.cpp:    return (ty == T_void || ty->isEmptyTy());
codegen.cpp:        if (dt->name != jl_tuple_typename) {
codegen.cpp:        if (GlobalValue *V = m->getNamedValue(name))
codegen.cpp:        return new GlobalVariable(*m, _type(m->getContext()),
codegen.cpp:    add_named_global(name->name, addr);
codegen.cpp:        if (GlobalValue *V = m->getNamedValue(name))
codegen.cpp:        Function *F = Function::Create(_type(m->getContext()),
codegen.cpp:            F->setAttributes(_attrs(m->getContext()));
codegen.cpp:    add_named_global(name->name, (void*)(uintptr_t)addr);
codegen.cpp:// Symbols are not gc-tracked, but we'll treat them as callee rooted anyway,
codegen.cpp:// because they may come from a gc-rooted location
codegen.cpp:                FunctionType::get(T_pint8, { T_pint8, T_ppjlvalue }, false)->getPointerTo(), // trampoline
codegen.cpp:// --- code generation ---
codegen.cpp:    f->addAttribute(AttributeList::ReturnIndex, Kind);
codegen.cpp:// tracks whether codegen is currently able to simply stack-allocate this type
codegen.cpp:    return jl_is_immutable_datatype(t) && ((jl_datatype_t*)t)->isconcretetype;
codegen.cpp:    const jl_datatype_layout_t *layout = ((jl_datatype_t*)t)->layout;
codegen.cpp:    return layout && layout->npointers == 0;
codegen.cpp:    return (size_t)jl_datatype_size(dt) > sizeof(void*) && !T->isFloatingPointTy() && !T->isVectorTy();
codegen.cpp:    // If this is non-NULL, then, at runtime, we satisfy the invariant that (for the corresponding
codegen.cpp:    // If this is non-NULL, it is always of type `T_prjlvalue`
codegen.cpp:    Value *TIndex; // if `V` is an unboxed (tagged) Union described by `typ`, this gives the DataType index (1-based, small int) as an i8
codegen.cpp:    MDNode *tbaa; // The related tbaa node. Non-NULL iff this holds an address.
codegen.cpp:    jl_cgval_t(Value *V, Value *gcroot, bool isboxed, jl_value_t *typ, Value *tindex) : // general constructor (with pointer type auto-detect)
codegen.cpp:            assert(Vboxed->getType() == T_prjlvalue);
codegen.cpp:        assert(TIndex == NULL || TIndex->getType() == T_int8);
codegen.cpp:        constant(((jl_datatype_t*)typ)->instance),
codegen.cpp:            assert(Vboxed->getType() == T_prjlvalue);
codegen.cpp:// per-local-variable information
codegen.cpp:    int vaSlot = -1;        // name of vararg argument
codegen.cpp:    int nvargs = -1;
codegen.cpp:        assert(this->roots == NULL);
codegen.cpp:static jl_cgval_t emit_expr(jl_codectx_t &ctx, jl_value_t *expr, ssize_t ssaval = -1);
codegen.cpp:    return G->realize(M);
codegen.cpp:    return G->realize(M);
codegen.cpp:    if (G->getParent() == M)
codegen.cpp:    GlobalValue *local = M->getNamedValue(G->getName());
codegen.cpp:        GlobalVariable *proto = new GlobalVariable(*M, G->getType()->getElementType(),
codegen.cpp:                G->isConstant(), GlobalVariable::ExternalLinkage,
codegen.cpp:                nullptr, G->getName(), nullptr, G->getThreadLocalMode());
codegen.cpp:        proto->copyAttributesFrom(G);
codegen.cpp:        proto->setDLLStorageClass(GlobalValue::DefaultStorageClass);
codegen.cpp:// --- convenience functions for tagging llvm values with julia types ---
codegen.cpp:        localname = gv->getName();
codegen.cpp:        if (gv->getParent() != &M)
codegen.cpp:                val->getType(),
codegen.cpp:        gv->setUnnamedAddr(GlobalValue::UnnamedAddr::Global);
codegen.cpp:    assert(localname == gv->getName());
codegen.cpp:    assert(val == gv->getInitializer());
codegen.cpp:    assert(ptr->getType()->getPointerAddressSpace() != AddressSpace::Tracked);
codegen.cpp:    size_t first_offset = sty->layout->nfields ? jl_field_offset(sty, 0) : 0;
codegen.cpp:    size_t i, np = sty->layout->npointers;
codegen.cpp:    ptr = irbuilder.CreateBitCast(ptr, T_prjlvalue->getPointerTo(ptr->getType()->getPointerAddressSpace()));
codegen.cpp:        auto ptr = I->getOperand(0);
codegen.cpp:        if (ty->getPointerAddressSpace() == ptr->getType()->getPointerAddressSpace())
codegen.cpp:        else if (ty->getPointerElementType() == ptr->getType()->getPointerElementType())
codegen.cpp:        typ = (jl_value_t*)jl_typeofbottom_type->super;
codegen.cpp:        typ = (jl_value_t*)jl_wrap_Type(jv); // TODO: gc-root this?
codegen.cpp:    // this enables lazy-copying of immutable values and stack or argument slots
codegen.cpp:        for (const Value *elem : CC->operand_values())
codegen.cpp:        loc = emit_static_alloca(ctx, v->getType());
codegen.cpp:    if (v && !isboxed && v->getType()->isAggregateType() && !jl_is_vecelement_type(typ) && CountTrackedPointers(v->getType()).count == 0) {
codegen.cpp:        return v; // fast-path
codegen.cpp:                alwaysboxed = !((jl_datatype_t*)utyp)->name->abstract && ((jl_datatype_t*)utyp)->name->mutabl;
codegen.cpp:                // discovered that this union-split type must actually be isboxed
codegen.cpp:// --- allocating local variables ---
codegen.cpp:    return (jl_sym_t*)jl_array_ptr_ref(ctx.source->slotnames, s);
codegen.cpp:// --- utilities ---
codegen.cpp:        // make sure gc pointers (including ptr_phi of union-split) are initialized to NULL
codegen.cpp:    Function *f = irbuilder.GetInsertBlock()->getParent();
codegen.cpp:            f->getParent(),
codegen.cpp:    Function *f = irbuilder.GetInsertBlock()->getParent();
codegen.cpp:            f->getParent(),
codegen.cpp:        // compute the TIndex mapping from v.typ -> typ
codegen.cpp:            // for each old union-split value
codegen.cpp:                // for each new union-split value
codegen.cpp:                tindex_phi->addIncoming(new_tindex, currBB);
codegen.cpp:                tindex_phi->addIncoming(union_box_tindex, post_union_isaBB);
codegen.cpp:                // unboxed->boxed, or leaving an unboxed value in place.
codegen.cpp:                    slotv = emit_static_alloca(ctx, v.V->getType());
codegen.cpp:                            decay_derived(ctx, emit_bitcast(ctx, slotv, boxv->getType())));
codegen.cpp:                assert(boxv->getType() == T_prjlvalue);
codegen.cpp:        return v; // fast-path
codegen.cpp:            // discovered that this union-split type must actually be isboxed
codegen.cpp:                    // TODO: remove this branch once all consumers of v.TIndex understand how to handle a non-ispointer value
codegen.cpp:                    Value *slotv = emit_static_alloca(ctx, v.V->getType());
codegen.cpp:    if (!m->getModuleFlag("Dwarf Version")) {
codegen.cpp:        m->addModuleFlag(llvm::Module::Warning, "Dwarf Version", dwarf_version);
codegen.cpp:    if (!m->getModuleFlag("Debug Info Version"))
codegen.cpp:        m->addModuleFlag(llvm::Module::Warning, "Debug Info Version",
codegen.cpp:    m->setDataLayout(jl_data_layout);
codegen.cpp:    m->setTargetTriple(jl_TargetMachine->getTargetTriple().str());
codegen.cpp:    // tell Win32 to realign the stack to the next 16-byte boundary
codegen.cpp:    // with both MinGW-GCC (which assumes an 16-byte-aligned stack) and
codegen.cpp:    // i686 Windows (which uses a 4-byte-aligned stack)
codegen.cpp:    F->addAttributes(AttributeList::FunctionIndex, attr);
codegen.cpp:    F->setHasUWTable(); // force NeedsWinEH
codegen.cpp:    F->addFnAttr("frame-pointer", "all");
codegen.cpp:    // and Windows has platform-specific handling which causes it to mishandle
codegen.cpp:    F->addFnAttr("probe-stack", "inline-asm");
codegen.cpp:    //F->addFnAttr("stack-probe-size", 4096); // can use this to change the default
codegen.cpp:    size_t nreq = jl_is_method(lam->def.method) ? lam->def.method->nargs : 0;
codegen.cpp:    if (nreq > 0 && lam->def.method->isva) {
codegen.cpp:        nreq--;
codegen.cpp:    jl_value_t *sig = lam->specTypes;
codegen.cpp:    if (jl_is_method(lam->def.method)) {
codegen.cpp:        if ((size_t)jl_subtype_env_size(lam->def.method->sig) != jl_svec_len(lam->sparam_vals))
codegen.cpp:        for (size_t i = 0; i < jl_svec_len(lam->sparam_vals); ++i) {
codegen.cpp:            if (jl_is_typevar(jl_svecref(lam->sparam_vals, i)))
codegen.cpp:        if (jl_is_vararg(jl_tparam(sig, jl_nparams(sig) - 1)))
codegen.cpp:        std::string filename(it->first());
codegen.cpp:        std::vector<logdata_block*> &values = it->second;
codegen.cpp:                        outf << '-';
codegen.cpp:                        outf << (value - 1);
codegen.cpp:        StringRef filename = it->first();
codegen.cpp:        const std::vector<logdata_block*> &values = it->second;
codegen.cpp:                            outf << "DA:" << lno << ',' << (cov - 1) << '\n';
codegen.cpp:// --- constant determination ---
codegen.cpp:    if (b->deprecated == 1 && jl_options.depwarn) {
codegen.cpp:    size_t last_age = jl_current_task->world_age;
codegen.cpp:    jl_current_task->world_age = 1;
codegen.cpp:    jl_current_task->world_age = last_age;
codegen.cpp:        ssize_t idx = ((jl_ssavalue_t*)ex)->id - 1;
codegen.cpp:        if (b && b->constp) {
codegen.cpp:            if (b->deprecated)
codegen.cpp:            return b->value;
codegen.cpp:        if (e->head == jl_call_sym) {
codegen.cpp:                if (jl_array_dim0(e->args) == 3 && f == jl_builtin_getfield) {
codegen.cpp:                        if (b && b->constp) {
codegen.cpp:                            if (b->deprecated)
codegen.cpp:                            return b->value;
codegen.cpp:                    size_t n = jl_array_dim0(e->args)-1;
codegen.cpp:                    size_t last_age = jl_current_task->world_age;
codegen.cpp:                    jl_current_task->world_age = 1;
codegen.cpp:                    jl_current_task->world_age = last_age;
codegen.cpp:        else if (e->head == jl_static_parameter_sym) {
codegen.cpp:            if (idx <= jl_svec_len(ctx.linfo->sparam_vals)) {
codegen.cpp:                jl_value_t *e = jl_svecref(ctx.linfo->sparam_vals, idx - 1);
codegen.cpp:    return (jl_is_slot(e) || jl_is_argument(e)) && jl_slot_number(e)-1 == sl;
codegen.cpp:// --- code gen for intrinsic functions ---
codegen.cpp:// --- find volatile variables ---
codegen.cpp:        size_t alength = jl_array_dim0(ex->args);
codegen.cpp:            if (((jl_expr_t*)st)->head == jl_assign_sym) {
codegen.cpp:                    av.insert(jl_slot_number(ar)-1);
codegen.cpp:            if (((jl_expr_t*)st)->head == jl_enter_sym) {
codegen.cpp:// --- use analysis ---
codegen.cpp:        int i = jl_slot_number(expr) - 1;
codegen.cpp:        if (e->head == jl_method_sym) {
codegen.cpp:        else if (e->head == jl_assign_sym) {
codegen.cpp:            size_t i, elen = jl_array_dim0(e->args);
codegen.cpp:// --- gc root utils ---
codegen.cpp:// ---- Get Element Pointer (GEP) instructions within the GC frame ----
codegen.cpp:// --- generating function calls ---
codegen.cpp:        if (bnd != NULL && bnd->value != NULL){
codegen.cpp:            jl_value_t * bv = jl_atomic_load_relaxed(&bnd->value);
codegen.cpp:            if (bnd->constp==1 && jl_is_intrinsic(bv)){
codegen.cpp:                return mark_julia_const(bnd->value);
codegen.cpp:    if (bnd && bnd->value != NULL) {
codegen.cpp:        if (bnd->constp) {
codegen.cpp:            return mark_julia_const(bnd->value);
codegen.cpp:        v->setOrdering(AtomicOrdering::Unordered);
codegen.cpp:        if (cast<PointerType>(varg1->getType())->getAddressSpace() != cast<PointerType>(varg2->getType())->getAddressSpace()) {
codegen.cpp:    switchInst->addCase(ConstantInt::get(T_int8, 0), postBB);
codegen.cpp:    phi->addIncoming(ConstantInt::get(T_int1, 0), switchInst->getParent());
codegen.cpp:            switchInst->addCase(ConstantInt::get(T_int8, idx), tempBB);
codegen.cpp:            phi->addIncoming(cmp, tempBB);
codegen.cpp:        ctx.f->getParent(),
codegen.cpp:    if (at->isIntegerTy() || at->isPointerTy() || at->isFloatingPointTy()) {
codegen.cpp:    if (at->isVectorTy()) {
codegen.cpp:        jl_svec_t *types = ((jl_datatype_t*)arg1.typ)->types;
codegen.cpp:    if (at->isAggregateType()) { // Struct or Array
codegen.cpp:        if (sz > 512 && !sty->layout->haspadding) {
codegen.cpp:            jl_svec_t *types = sty->types;
codegen.cpp:// If either `nullcheck1` or `nullcheck2` are non-NULL, they are pointer values
codegen.cpp:// representing the undef-ness of `arg1` and `arg2`.
codegen.cpp:// Like the runtime counterpart, this is codegen guaranteed to be non-allocating and to exclude safepoints
codegen.cpp:    // handle simple static expressions with no side-effects
codegen.cpp:        return emit_nullcheck_guard2(ctx, nullcheck1, nullcheck2, [&] () -> Value* {
codegen.cpp:                if ((arg1.isboxed || arg1.constant) && (arg2.isboxed || arg2.constant)) { // aka have-fast-pointer
codegen.cpp:            cmp->addIncoming(ConstantInt::get(T_int1, 0), currBB);
codegen.cpp:            cmp->addIncoming(bitcmp, isaBB);
codegen.cpp:        ssize_t idx = -1;
codegen.cpp:                idx = i - 1;
codegen.cpp:        if (idx != -1) {
codegen.cpp:            jl_value_t *ft = jl_svecref(uty->types, idx);
codegen.cpp:                            (isatomic ? "setfield!: atomic field cannot be written non-atomically"
codegen.cpp:                                      : "setfield!: non-atomic field cannot be written atomically") :
codegen.cpp:                            (isatomic ? "replacefield!: atomic field cannot be written non-atomically"
codegen.cpp:                                      : "replacefield!: non-atomic field cannot be written atomically") :
codegen.cpp:                            (isatomic ? "swapfield!: atomic field cannot be written non-atomically"
codegen.cpp:                                      : "swapfield!: non-atomic field cannot be written atomically") :
codegen.cpp:                            (isatomic ? "modifyfield!: atomic field cannot be written non-atomically"
codegen.cpp:                                      : "modifyfield!: non-atomic field cannot be written atomically"));
codegen.cpp:                            (isatomic ? "replacefield!: atomic field cannot be accessed non-atomically"
codegen.cpp:                                      : "replacefield!: non-atomic field cannot be accessed atomically"));
codegen.cpp:            if (isa_result->getType() == T_int1)
codegen.cpp:            if (load->getPointerOperand() == ctx.slots[ctx.vaSlot].boxroot && ctx.argArray) {
codegen.cpp:                    ctx.f->getBasicBlockList().push_back(inBB);
codegen.cpp:                    ctx.f->getBasicBlockList().push_back(ansBB);
codegen.cpp:                    result->addIncoming(v_one, outBB);
codegen.cpp:                    result->addIncoming(v_sz, inBB);
codegen.cpp:                ssize_t nd = jl_is_long(ndp) ? jl_unbox_long(ndp) : -1;
codegen.cpp:                Value *idx = emit_array_nd_index(ctx, ary, ary_ex, nd, &argv[3], nargs - 2, boundscheck);
codegen.cpp:                    assert(((jl_datatype_t*)ety)->instance != NULL);
codegen.cpp:                    Type *AT = ArrayType::get(IntegerType::get(jl_LLVMContext, 8 * al), (elsz + al - 1) / al);
codegen.cpp:                    Value *data = emit_bitcast(ctx, emit_arrayptr(ctx, ary, ary_ex), AT->getPointerTo());
codegen.cpp:                    // isbits union selector bytes are stored after a->maxsize
codegen.cpp:                    Value *ndims = (nd == -1 ? emit_arrayndims(ctx, ary) : ConstantInt::get(T_int16, nd));
codegen.cpp:                    tindex->setMetadata(LLVMContext::MD_range, MDNode::get(jl_LLVMContext, {
codegen.cpp:                        lv->setAlignment(Align(al));
codegen.cpp:                ssize_t nd = jl_is_long(ndp) ? jl_unbox_long(ndp) : -1;
codegen.cpp:                Value *idx = emit_array_nd_index(ctx, ary, ary_ex, nd, &argv[4], nargs - 3, boundscheck);
codegen.cpp:                    // no-op
codegen.cpp:                    if (isboxed || (jl_is_datatype(ety) && ((jl_datatype_t*)ety)->layout->npointers > 0)) { // if elements are just bits, don't need a write barrier
codegen.cpp:                        // the owner of the data is ary itself except if ary->how == 3
codegen.cpp:                        data_owner->addIncoming(aryv, curBB);
codegen.cpp:                        data_owner->addIncoming(own_ptr, ownedBB);
codegen.cpp:                        Type *AT = ArrayType::get(IntegerType::get(jl_LLVMContext, 8 * al), (elsz + al - 1) / al);
codegen.cpp:                        Value *data = emit_bitcast(ctx, emit_arrayptr(ctx, ary, ary_ex), AT->getPointerTo());
codegen.cpp:                        Value *ndims = (nd == -1 ? emit_arrayndims(ctx, ary) : ConstantInt::get(T_int16, nd));
codegen.cpp:                            // no-op
codegen.cpp:                if (idx != -1 && !jl_has_free_typevars(jl_field_type(utt, idx))) {
codegen.cpp:                    if (load->getPointerOperand() == ctx.slots[ctx.vaSlot].boxroot && ctx.argArray) {
codegen.cpp:                    if (fld.constant && (idx = jl_unbox_long(fld.constant) - 1) < nfields) {
codegen.cpp:                if (jl_is_tuple_type(utt) && is_tupletype_homogeneous(utt->parameters, true)) {
codegen.cpp:                            emit_atomic_error(ctx, "getfield: non-atomic field cannot be accessed atomically");
codegen.cpp:                if (load->getPointerOperand() == ctx.slots[ctx.vaSlot].boxroot) {
codegen.cpp:        ssize_t nf = -1;
codegen.cpp:        if (nf != -1)
codegen.cpp:        assert(jl_string_type->name->mutabl);
codegen.cpp:                    V_size0, ConstantInt::get(T_size, INTPTR_MAX / sizeof(void*) - 1));
codegen.cpp:                cast<LoadInst>(len)->setMetadata(LLVMContext::MD_range, rng);
codegen.cpp:                cast<LoadInst>(len)->setMetadata(LLVMContext::MD_range, rng);
codegen.cpp:        if (jl_is_method(ctx.linfo->def.method)) {
codegen.cpp:            // don't bother codegen constant-folding for toplevel.
codegen.cpp:            stt == jl_module_type) { // TODO: use ->layout here instead of concrete_type
codegen.cpp:        ssize_t fieldidx = -1;
codegen.cpp:            fieldidx = jl_unbox_long(fld.constant) - 1;
codegen.cpp:            emit_atomic_error(ctx, "isdefined: non-atomic field cannot be accessed atomically");
codegen.cpp:            emit_atomic_error(ctx, "isdefined: atomic field cannot be accessed non-atomically");
codegen.cpp:        else if (fieldidx < nf - stt->name->n_uninitialized) {
codegen.cpp:                    offs += ((jl_datatype_t*)jl_field_type(stt, fieldidx))->layout->first_ptr;
codegen.cpp:                // so that LLVM may be able to load-load forward them and fold the result
codegen.cpp:                cast<LoadInst>(fldv)->setOrdering(order <= jl_memory_order_notatomic ? AtomicOrdering::Unordered : get_llvm_atomic_order(order));
codegen.cpp:        if (order > jl_memory_order_monotonic && ret->constant) {
codegen.cpp:        ctx.builder.CreateBitCast(theFptr, FTy->getPointerTo()),
codegen.cpp:    result->setCallingConv(cc);
codegen.cpp:    bool is_opaque_closure = jl_is_method(mi->def.value) && mi->def.method->is_for_opaque_closure;
codegen.cpp:    jl_returninfo_t returninfo = get_specsig_function(ctx, jl_Module, specFunctionObject, mi->specTypes, jlretty, is_opaque_closure);
codegen.cpp:    FunctionType *cft = returninfo.decl->getFunctionType();
codegen.cpp:    size_t nfargs = cft->getNumParams();
codegen.cpp:        result = emit_static_alloca(ctx, cft->getParamType(0)->getPointerElementType());
codegen.cpp:            result->setAlignment(Align(returninfo.union_align));
codegen.cpp:            jl_nth_slot_type(mi->specTypes, i);
codegen.cpp:        Type *at = cft->getParamType(idx);
codegen.cpp:        else if (et->isAggregateType()) {
codegen.cpp:                // There was a type mismatch of some sort - exit early
codegen.cpp:    call->setAttributes(returninfo.decl->getAttributes());
codegen.cpp:        jl_Module->getOrInsertFunction(specFunctionObject, jl_func_sig).getCallee());
codegen.cpp:    theFptr->addFnAttr(Thunk);
codegen.cpp:    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);
codegen.cpp:    size_t arglen = jl_array_dim0(ex->args);
codegen.cpp:    size_t nargs = arglen - 1;
codegen.cpp:            // handle self-recursion specially
codegen.cpp:            FunctionType *ft = ctx.f->getFunctionType();
codegen.cpp:            StringRef protoname = ctx.f->getName();
codegen.cpp:            jl_value_t *ci = ctx.params->lookup(mi, ctx.world, ctx.world); // TODO: need to use the right pair world here
codegen.cpp:                    ci = ctx.params->lookup(mi, ctx.world, ctx.world);
codegen.cpp:                auto invoke = jl_atomic_load_relaxed(&codeinst->invoke);
codegen.cpp:                    result = mark_julia_const(codeinst->rettype_const);
codegen.cpp:                    std::tie(specsig, needsparams) = uses_specsig(mi, codeinst->rettype, ctx.params->prefer_specsig);
codegen.cpp:                        auto invoke = jl_atomic_load_relaxed(&codeinst->invoke);
codegen.cpp:                        auto fptr = jl_atomic_load_relaxed(&codeinst->specptr.fptr);
codegen.cpp:                            if (specsig ? codeinst->isspecsig : invoke == jl_fptr_args_addr) {
codegen.cpp:                                protoname = jl_ExecutionEngine->getFunctionAtAddress((uintptr_t)fptr, codeinst);
codegen.cpp:                        result = emit_call_specfun_other(ctx, mi, codeinst->rettype, protoname, argv, nargs, &cc, &return_roots, rt);
codegen.cpp:                        result = emit_call_specfun_boxed(ctx, codeinst->rettype, protoname, argv, nargs, rt);
codegen.cpp:                        Function *trampoline_decl = cast<Function>(jl_Module->getNamedValue(protoname));
codegen.cpp:    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);
codegen.cpp:    size_t arglen = jl_array_dim0(ex->args);
codegen.cpp:    size_t nargs = arglen - 1;
codegen.cpp:        if (emit_f_opfield(ctx, &ret, jl_builtin_modifyfield, argv, nargs - 1, &lival))
codegen.cpp:        Value *oldnew = emit_jlcall(ctx, it->second, V_rnull, &argv[1], nargs - 1, JLCALL_F_CC);
codegen.cpp:        if (fi == JL_I::atomic_pointermodify && jl_intrinsic_nargs((int)fi) == nargs - 1)
codegen.cpp:            return emit_atomic_pointerop(ctx, fi, argv, nargs - 1, &lival);
codegen.cpp:    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);
codegen.cpp:    size_t nargs = jl_array_dim0(ex->args);
codegen.cpp:        return emit_intrinsic(ctx, fi, args, nargs - 1);
codegen.cpp:    jl_value_t *context = ctx.params->generic_context == jl_nothing ? nullptr : ctx.params->generic_context;
codegen.cpp:        bool handled = emit_builtin_call(ctx, &result, f.constant, argv, nargs - 1, rt, ex);
codegen.cpp:            Value *ret = emit_jlcall(ctx, it->second, V_rnull, &argv[1], nargs - 1, JLCALL_F_CC);
codegen.cpp:// --- accessing and assigning variables ---
codegen.cpp:    ctx.f->getBasicBlockList().push_back(ifok);
codegen.cpp:        if (b->owner != m) {
codegen.cpp:                    jl_symbol_name(b->owner->name), jl_symbol_name(s), jl_symbol_name(m->name));
codegen.cpp:            GlobalVariable *bindinggv = new GlobalVariable(*ctx.f->getParent(), T_pjlvalue,
codegen.cpp:            cachedval->setOrdering(AtomicOrdering::Unordered);
codegen.cpp:            ctx.f->getBasicBlockList().push_back(not_found);
codegen.cpp:            ctx.builder.CreateAlignedStore(bval, bindinggv, Align(sizeof(void*)))->setOrdering(AtomicOrdering::Release);
codegen.cpp:            ctx.f->getBasicBlockList().push_back(have_val);
codegen.cpp:            p->addIncoming(cachedval, currentbb);
codegen.cpp:            p->addIncoming(bval, not_found);
codegen.cpp:        if (b->deprecated)
codegen.cpp:        jl_value_t *bv = jl_atomic_load_relaxed(&b->value);
codegen.cpp:        if (bv!=NULL && b->constp == 1 && jl_is_intrinsic(bv)){
codegen.cpp:        if (b->constp == 1 && jl_is_intrinsic(b->value)){
codegen.cpp:            Module *M = ctx.f->getParent();
codegen.cpp:            StringRef name(jl_symbol_name(b->name));
codegen.cpp:            GlobalVariable* &gv = cast_or_null<GlobalVariable>(M->getNamedValue(name));
codegen.cpp:            gv->setMetadata("julia.intrinsic", MDNode::get(gv->getContext(), None));
codegen.cpp:        v->setVolatile(true);
codegen.cpp:    v->setOrdering(AtomicOrdering::Unordered);
codegen.cpp:    if (jl_svec_len(ctx.linfo->sparam_vals) > 0) {
codegen.cpp:        jl_value_t *e = jl_svecref(ctx.linfo->sparam_vals, i);
codegen.cpp:    jl_unionall_t *sparam = (jl_unionall_t*)ctx.linfo->def.method->sig;
codegen.cpp:        sparam = (jl_unionall_t*)sparam->body;
codegen.cpp:    undef_var_error_ifnot(ctx, isnull, sparam->var->name);
codegen.cpp:    if (jbp && jbp->value != NULL) {
codegen.cpp:        if (jbp->constp)
codegen.cpp:            return mark_julia_const(jbp->value);
codegen.cpp:        // double-check that a global variable is actually defined. this
codegen.cpp:        v->setOrdering(AtomicOrdering::Unordered);
codegen.cpp:        size_t sl = jl_slot_number(sym) - 1;
codegen.cpp:        assert(((jl_expr_t*)sym)->head == jl_static_parameter_sym && "malformed isdefined expression");
codegen.cpp:        size_t i = jl_unbox_long(jl_exprarg(sym, 0)) - 1;
codegen.cpp:        if (jl_svec_len(ctx.linfo->sparam_vals) > 0) {
codegen.cpp:            jl_value_t *e = jl_svecref(ctx.linfo->sparam_vals, i);
codegen.cpp:            if (bnd->value != NULL)
codegen.cpp:            v->setOrdering(AtomicOrdering::Unordered);
codegen.cpp:            // copy value to a non-mutable (non-volatile SSA) location
codegen.cpp:            Type *T = varslot->getAllocatedType();
codegen.cpp:            assert(!varslot->isArrayAllocation() && "variables not expected to be VLA");
codegen.cpp:            AllocaInst *ssaslot = cast<AllocaInst>(varslot->clone());
codegen.cpp:            ssaslot->insertAfter(varslot);
codegen.cpp:                Value *unbox = ctx.builder.CreateAlignedLoad(ssaslot->getAllocatedType(), varslot,
codegen.cpp:                        varslot->getAlign(),
codegen.cpp:                ctx.builder.CreateAlignedStore(unbox, ssaslot, ssaslot->getAlign());
codegen.cpp:                emit_memcpy(ctx, ssaslot, tbaa_stack, vi.value, sz, ssaslot->getAlign().value());
codegen.cpp:                    decay_derived(ctx, v.V), boxed->getType()), decay_derived(ctx, boxed));
codegen.cpp:    size_t sl = jl_slot_number(slotload) - 1;
codegen.cpp:            typ = ((jl_tvar_t*)typ)->ub;
codegen.cpp:            // all ghost values in destination - nothing to copy or store
codegen.cpp:                // all ghost values in source - nothing to copy or store
codegen.cpp:                    // isbits cast-on-assignment is invalid. this branch should be dead-code.
codegen.cpp:                        ctx.builder.CreateStore(UndefValue::get(cast<AllocaInst>(vi.value.V)->getAllocatedType()), vi.value.V);
codegen.cpp:                    Type *dest_ty = store_ty->getPointerTo();
codegen.cpp:                    if (dest_ty != dest->getType())
codegen.cpp:    jl_value_t *ssavalue_types = (jl_value_t*)ctx.source->ssavaluetypes;
codegen.cpp:    auto InsertPt = BB->getFirstInsertionPt();
codegen.cpp:            Instruction *phi = dest->clone();
codegen.cpp:            phi->insertAfter(dest);
codegen.cpp:            BB->getInstList().insert(InsertPt, Tindex_phi);
codegen.cpp:            BB->getInstList().insert(InsertPt, ptr_phi);
codegen.cpp:            BB->getInstList().insert(InsertPt, Tindex_phi);
codegen.cpp:        assert(jl_is_datatype(phiType) && ((jl_datatype_t*)phiType)->instance);
codegen.cpp:        ctx.SAvalues.at(idx) = mark_julia_const(((jl_datatype_t*)phiType)->instance);
codegen.cpp:    if (vtype->isAggregateType() && CountTrackedPointers(vtype).count == 0) {
codegen.cpp:        BB->getInstList().insert(InsertPt, value_phi);
codegen.cpp:        jl_value_t *ssavalue_types = (jl_value_t*)ctx.source->ssavaluetypes;
codegen.cpp:    // convert rval-type to lval-type
codegen.cpp:            assert(rval->getType() == T_prjlvalue);
codegen.cpp:    int sl = jl_slot_number(l) - 1;
codegen.cpp:            // memory optimization: eagerly clear this gc-root now
codegen.cpp:            Type *T = cast<AllocaInst>(vi.value.V)->getAllocatedType();
codegen.cpp:                // make sure gc pointers (including ptr_phi of union-split) are initialized to NULL
codegen.cpp:// --- convert expression to code ---
codegen.cpp:        assert(cond->getType() == T_int8);
codegen.cpp:    if (jl_is_ssavalue(expr) && ssaval_result == -1)
codegen.cpp:    if (jl_is_slot(expr) && ssaval_result == -1) {
codegen.cpp:        size_t sl = jl_slot_number(expr) - 1;
codegen.cpp:    if (jl_is_argument(expr) && ssaval_result == -1) {
codegen.cpp:        jl_varinfo_t &vi = ctx.slots[jl_slot_number(var)-1];
codegen.cpp:        assert(ssaval_result != -1);
codegen.cpp:    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);
codegen.cpp:    jl_sym_t *head = ex->head;
codegen.cpp:        assert(excstack_state.V && excstack_state.V->getType() == T_size);
codegen.cpp:        if (!jl_is_method(ctx.linfo->def.method) && !ctx.is_opaque_closure) {
codegen.cpp:            // TODO: world->setOrdering(AtomicOrdering::Monotonic);
codegen.cpp:        assert(ssaval_result != -1);
codegen.cpp:JL_GCC_IGNORE_START("-Wclobbered")
codegen.cpp:        ssize_t idx = ((jl_ssavalue_t*)expr)->id - 1;
codegen.cpp:        if (needroot && jl_is_method(ctx.linfo->def.method)) { // toplevel exprs and some integers are already rooted
codegen.cpp:    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);
codegen.cpp:    size_t nargs = jl_array_len(ex->args);
codegen.cpp:    jl_sym_t *head = ex->head;
codegen.cpp:    // this is object-disoriented.
codegen.cpp:        jl_value_t *expr_t = jl_is_long(ctx.source->ssavaluetypes) ? (jl_value_t*)jl_any_type :
codegen.cpp:            jl_array_ptr_ref(ctx.source->ssavaluetypes, ssaval);
codegen.cpp:        jl_value_t *expr_t = jl_is_long(ctx.source->ssavaluetypes) ? (jl_value_t*)jl_any_type :
codegen.cpp:            jl_array_ptr_ref(ctx.source->ssavaluetypes, ssaval);
codegen.cpp:            expr_t = jl_is_long(ctx.source->ssavaluetypes) ? (jl_value_t*)jl_any_type : jl_array_ptr_ref(ctx.source->ssavaluetypes, ssaval);
codegen.cpp:        return emit_ccall(ctx, args, jl_array_dim0(ex->args));
codegen.cpp:        return emit_sparam(ctx, jl_unbox_long(args[0]) - 1);
codegen.cpp:                    bnd->value = e;
codegen.cpp:                    bnd->constp = 1;
codegen.cpp:                int sl = jl_slot_number(mn)-1;
codegen.cpp:            return emit_new_struct(ctx, jl_tparam0(ty), nargs - 1, &argv[1]);
codegen.cpp:            // For now, we require non-constant source to be handled by using
codegen.cpp:            can_optimize &= ((jl_method_t*)source.constant)->nargs > 0 || !jl_unbox_bool(isva.constant);
codegen.cpp:                (jl_array_t*)closure_method->source);
codegen.cpp:            li->def.method = closure_method;
codegen.cpp:            size_t nsig = 1 + jl_svec_len(argt_typ->parameters);
codegen.cpp:            for (size_t i = 0; i < jl_svec_len(argt_typ->parameters); ++i) {
codegen.cpp:                jl_svecset(sig_args, 1+i, jl_svecref(argt_typ->parameters, i));
codegen.cpp:            li->specTypes = (jl_value_t*)jl_apply_tuple_type_v(jl_svec_data(sig_args), nsig);
codegen.cpp:            jl_gc_wb(li, li->specTypes);
codegen.cpp:            jl_value_t **env_component_ts = (jl_value_t**)alloca(sizeof(jl_value_t*) * (nargs-5));
codegen.cpp:            for (size_t i = 0; i < nargs - 5; ++i) {
codegen.cpp:            env_t = jl_apply_tuple_type_v(env_component_ts, nargs-5);
codegen.cpp:                env = emit_new_struct(ctx, (jl_value_t*)env_t, nargs-5, &argv.data()[5]);
codegen.cpp:                    &argv[5], nargs-5, JLCALL_F_CC);
codegen.cpp:            if (GlobalValue *V = jl_Module->getNamedValue(fname)) {
codegen.cpp:                F->setAttributes(get_func_attrs(jl_LLVMContext));
codegen.cpp:                Function *specptr = closure_m->getFunction(closure_decls.specFunctionObject);
codegen.cpp:                        closure_decls.specFunctionObject, li->specTypes, ub.constant, true);
codegen.cpp:        I->setMetadata("julia.loopinfo", MD);
codegen.cpp:        assert(token.V->getType()->isTokenTy());
codegen.cpp:            !jl_is_method(ctx.linfo->def.method)) {
codegen.cpp:// --- generate function bodies ---
codegen.cpp:        ConstantInt::get(T_size, -ptls_offset / sizeof(void *)),
codegen.cpp:    // Note: Corresponding store (`t->ptls = ptls`) happens in `ctx_switch` of tasks.c.
codegen.cpp:    assert(ctx.builder.GetInsertBlock() == ctx.pgcstack->getParent());
codegen.cpp:    f->addFnAttr(Thunk);
codegen.cpp:    //f->setAlwaysInline();
codegen.cpp:    auto invoke = jl_atomic_load_relaxed(&codeinst->invoke);
codegen.cpp:        StringRef theFptrName = jl_ExecutionEngine->getFunctionAtAddress((uintptr_t)invoke, codeinst);
codegen.cpp:            M->getOrInsertFunction(theFptrName, jlinvoke_func->_type(jl_LLVMContext)).getCallee());
codegen.cpp:        theFarg = literal_pointer_val(ctx, (jl_value_t*)codeinst->def);
codegen.cpp:    auto args = f->arg_begin();
codegen.cpp:    r->setAttributes(theFunc->getAttributes());
codegen.cpp:    Function::arg_iterator AI = gf_thunk->arg_begin();
codegen.cpp:            assert(jl_is_datatype(jt) && ((jl_datatype_t*)jt)->instance);
codegen.cpp:            myargs[i] = mark_julia_const(((jl_datatype_t*)jt)->instance);
codegen.cpp:            Type *at = arg_v->getType();
codegen.cpp:            if (!isboxed && et->isAggregateType()) {
codegen.cpp:    assert(AI == gf_thunk->arg_end());
codegen.cpp:        Type *gfrt = gf_thunk->getReturnType();
codegen.cpp:        if (gfrt->isVoidTy()) {
codegen.cpp:            gf_ret = emit_bitcast(ctx, gf_ret, gfrt->getPointerTo());
codegen.cpp:            Value *root1 = gf_thunk->arg_begin() + 1; // root1 has type [n x {}*]*
codegen.cpp:            root1 = ctx.builder.CreateConstInBoundsGEP2_32(root1->getType()->getPointerElementType(), root1, 0, 0);
codegen.cpp:        emit_memcpy(ctx, &*gf_thunk->arg_begin(), nullptr, gf_ret, nullptr, jl_datatype_size(rettype), julia_alignment(rettype));
codegen.cpp:        Type *retty = gf_thunk->getReturnType();
codegen.cpp:        prepare_call_in(gf_thunk->getParent(), jlapplygeneric_func));
codegen.cpp:    // Generate a c-callable wrapper
codegen.cpp:        name = jl_symbol_name(lam->def.method->name);
codegen.cpp:        assert(codeinst->invoke);
codegen.cpp:        if (codeinst->invoke == jl_fptr_args_addr) {
codegen.cpp:            callptr = codeinst->specptr.fptr;
codegen.cpp:        else if (codeinst->invoke == jl_fptr_const_return_addr) {
codegen.cpp:            callptr = (void*)codeinst->rettype_const;
codegen.cpp:        else if (codeinst->isspecsig) {
codegen.cpp:            callptr = codeinst->specptr.fptr;
codegen.cpp:        astrt = codeinst->rettype;
codegen.cpp:    cw->setAttributes(attributes);
codegen.cpp:    // TODO: cast<LoadInst>(world_v)->setOrdering(AtomicOrdering::Monotonic);
codegen.cpp:    Function::arg_iterator AI = cw->arg_begin();
codegen.cpp:        assert(sig.fargt_sig.at(i + sig.sret) == val->getType());
codegen.cpp:        // so that the julia_to_native type checks are more likely to be doable (e.g. concrete types) at compile-time
codegen.cpp:                    val = emit_bitcast(ctx, val, T->getPointerTo());
codegen.cpp:                BasicBlock *loadBB = BasicBlock::Create(jl_LLVMContext, "need-load", cw);
codegen.cpp:                BasicBlock *unboxedBB = BasicBlock::Create(jl_LLVMContext, "maybe-unboxed", cw);
codegen.cpp:                p->addIncoming(p1, boxedBB);
codegen.cpp:                p->addIncoming(p2, isanyBB);
codegen.cpp:                p->addIncoming(p3, unboxedBB);
codegen.cpp:                    assert(cast<PointerType>(val->getType())->getElementType() == sig.fargt[i]);
codegen.cpp:    assert(AI == cw->arg_end());
codegen.cpp:        nargs = 0; // arguments not needed -- TODO: not really true, should emit an age_ok test and jlcall
codegen.cpp:            StringRef fname = jl_ExecutionEngine->getFunctionAtAddress((uintptr_t)callptr, codeinst);
codegen.cpp:            theFptr = cast_or_null<Function>(jl_Module->getNamedValue(fname));
codegen.cpp:                assert(theFptr->getFunctionType() == jl_func_sig);
codegen.cpp:            theFptr->addFnAttr(Thunk);
codegen.cpp:            retphi->addIncoming(ret_jlcall, b_jlcall);
codegen.cpp:            retphi->addIncoming(ret, b_generic);
codegen.cpp:        bool is_opaque_closure = jl_is_method(lam->def.value) && lam->def.method->is_for_opaque_closure;
codegen.cpp:        StringRef protoname = jl_ExecutionEngine->getFunctionAtAddress((uintptr_t)callptr, codeinst);
codegen.cpp:        jl_returninfo_t returninfo = get_specsig_function(ctx, M, protoname, lam->specTypes, astrt, is_opaque_closure);
codegen.cpp:        FunctionType *cft = returninfo.decl->getFunctionType();
codegen.cpp:                result = emit_bitcast(ctx, sretPtr, cft->getParamType(0));
codegen.cpp:                result = emit_static_alloca(ctx, cft->getParamType(0)->getPointerElementType());
codegen.cpp:                jl_nth_slot_type(lam->specTypes, i);
codegen.cpp:            else if (T->isAggregateType()) {
codegen.cpp:                    T->getPointerTo());
codegen.cpp:            Function *gf_thunk = Function::Create(returninfo.decl->getFunctionType(),
codegen.cpp:            gf_thunk->setAttributes(returninfo.decl->getAttributes());
codegen.cpp:            // build a  specsig -> jl_apply_generic converter thunk
codegen.cpp:            emit_cfunc_invalidate(gf_thunk, returninfo.cc, returninfo.return_roots, lam->specTypes, codeinst->rettype, nargs + 1, ctx.emission_context);
codegen.cpp:            cast<FunctionType>(theFptr->getType()->getPointerElementType()),
codegen.cpp:        call->setAttributes(returninfo.decl->getAttributes());
codegen.cpp:                assert(box->getType() == T_prjlvalue);
codegen.cpp:            prt = sig.fargt_sig[0]->getContainedType(0); // sret is a PointerType
codegen.cpp:        GlobalAlias::create(cw->getType()->getElementType(), cw->getType()->getAddressSpace(),
codegen.cpp:        Function::arg_iterator AI = cw_make->arg_begin();
codegen.cpp:        Function *init_trampoline = Intrinsic::getDeclaration(cw_make->getParent(), Intrinsic::init_trampoline);
codegen.cpp:        Function *adjust_trampoline = Intrinsic::getDeclaration(cw_make->getParent(), Intrinsic::adjust_trampoline);
codegen.cpp:// Get the LLVM Function* for the C-callable entry point for a certain function
codegen.cpp:    jl_unionall_t *unionall_env = (jl_is_method(ctx.linfo->def.method) && jl_is_unionall(ctx.linfo->def.method->sig))
codegen.cpp:        ? (jl_unionall_t*)ctx.linfo->def.method->sig
codegen.cpp:    if (ctx.spvals_ptr == NULL && jl_svec_len(ctx.linfo->sparam_vals) > 0)
codegen.cpp:        sparam_vals = ctx.linfo->sparam_vals;
codegen.cpp:    bool isVa = (nargt > 0 && jl_is_vararg(jl_svecref(argt, nargt - 1)));
codegen.cpp:    jl_value_t *sigt = NULL; // dispatch-sig = type signature with Ref{} annotations removed and applied to the env
codegen.cpp:// do codegen to create a C-callable alias/wrapper, or if sysimg_handle is set,
codegen.cpp:    jl_value_t *ff = ft->instance;
codegen.cpp:    const char *name = jl_symbol_name(ft->name->mt->name);
codegen.cpp:    size_t nargs = jl_nparams(sigt)-1;
codegen.cpp:// generate a julia-callable function that calls f (AKA lam)
codegen.cpp:    w->addFnAttr(Thunk);
codegen.cpp:    Function::arg_iterator AI = w->arg_begin();
codegen.cpp:    assert(AI == w->arg_end());
codegen.cpp:    FunctionType *ftype = f.decl->getFunctionType();
codegen.cpp:    size_t nfargs = ftype->getNumParams();
codegen.cpp:        result = ctx.builder.CreateAlloca(ftype->getParamType(0)->getPointerElementType());
codegen.cpp:            result->setAlignment(Align(f.union_align));
codegen.cpp:    bool is_opaque_closure = jl_is_method(lam->def.value) && lam->def.method->is_for_opaque_closure;
codegen.cpp:    for (size_t i = 0; i < jl_nparams(lam->specTypes) && idx < nfargs; ++i) {
codegen.cpp:            jl_nth_slot_type(lam->specTypes, i);
codegen.cpp:            Value *argPtr = ctx.builder.CreateConstInBoundsGEP1_32(T_prjlvalue, argArray, i - 1);
codegen.cpp:            if (!lty->isAggregateType()) // keep "aggregate" type values in place as pointers
codegen.cpp:    call->setAttributes(f.decl->getAttributes());
codegen.cpp:    if (retarg != -1) {
codegen.cpp:                    ctx.builder.CreateConstInBoundsGEP1_32(T_prjlvalue, argArray, retarg - 1),
codegen.cpp:            assert(retval.Vboxed->getType() == T_prjlvalue);
codegen.cpp:            fsig.push_back(AT->getPointerTo());
codegen.cpp:            fsig.push_back(rt->getPointerTo());
codegen.cpp:        fsig.push_back(ArrayType::get(T_prjlvalue, props.return_roots)->getPointerTo(0));
codegen.cpp:        if (ty->isAggregateType()) { // aggregate types are passed by pointer
codegen.cpp:        else if (jl_is_primitivetype(jt) && ty->isIntegerTy()) {
codegen.cpp:    Function *f = M ? cast_or_null<Function>(M->getNamedValue(name)) : NULL;
codegen.cpp:        f->setAttributes(attributes);
codegen.cpp:        assert(f->getFunctionType() == ftype);
codegen.cpp:    if (isptr && Src->getType()->getPointerElementType() != T)
codegen.cpp:        Src = ctx.builder.CreateBitCast(Src, T->getPointerTo(Src->getType()->getPointerAddressSpace()));
codegen.cpp:    size_t nvargs = jl_nparams(lam->specTypes)-nreq;
codegen.cpp:    for (size_t i = nreq; i < jl_nparams(lam->specTypes); ++i) {
codegen.cpp:        jl_value_t *argType = jl_nth_slot_type(lam->specTypes, i);
codegen.cpp:        jl_svecset(tupargs, i-nreq, argType);
codegen.cpp:    ctx.code = src->code;
codegen.cpp:    ctx.module = jl_is_method(lam->def.method) ? lam->def.method->module : lam->def.module;
codegen.cpp:    if (jl_is_method(lam->def.method)) {
codegen.cpp:        ctx.nargs = nreq = lam->def.method->nargs;
codegen.cpp:        ctx.is_opaque_closure = lam->def.method->is_for_opaque_closure;
codegen.cpp:            (nreq > 0 && jl_is_method(lam->def.value) && lam->def.method->isva)) {
codegen.cpp:            nreq--;
codegen.cpp:        jl_sym_t *vn = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, ctx.nargs - 1);
codegen.cpp:            ctx.vaSlot = ctx.nargs - 1;
codegen.cpp:    toplevel = !jl_is_method(lam->def.method);
codegen.cpp:    int toplineno = -1;
codegen.cpp:    if (lam && jl_is_method(lam->def.method)) {
codegen.cpp:        toplineno = lam->def.method->line;
codegen.cpp:        ctx.file = jl_symbol_name(lam->def.method->file);
codegen.cpp:    else if (jl_array_len(src->linetable) > 0) {
codegen.cpp:        jl_value_t *locinfo = jl_array_ptr_ref(src->linetable, 0);
codegen.cpp:    // step 2. process var-info lists to see what vars need boxing
codegen.cpp:    int n_ssavalues = jl_is_long(src->ssavaluetypes) ? jl_unbox_long(src->ssavaluetypes) : jl_array_len(src->ssavaluetypes);
codegen.cpp:    size_t vinfoslen = jl_array_dim0(src->slotflags);
codegen.cpp:    assert(lam->specTypes); // the specTypes field should always be assigned
codegen.cpp:    std::tie(specsig, needsparams) = uses_specsig(lam, jlrettype, params.params->prefer_specsig);
codegen.cpp:    if (!src->inferred)
codegen.cpp:        jl_sym_t *argname = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, i);
codegen.cpp:        jl_value_t *ty = jl_nth_slot_type(lam->specTypes, i);
codegen.cpp:            if (jl_is_array(src->slottypes)) {
codegen.cpp:                ty = jl_arrayref((jl_array_t*)src->slottypes, i);
codegen.cpp:    if (va && ctx.vaSlot != -1) {
codegen.cpp:        uint8_t flags = jl_array_uint8_ref(src->slotflags, i);
codegen.cpp:        varinfo.usedUndef = (jl_vinfo_usedundef(flags) != 0) || (!varinfo.isArgument && !src->inferred);
codegen.cpp:        ctx.nReqArgs--;  // function not part of argArray in jlcall
codegen.cpp:        returninfo = get_specsig_function(ctx, M, declarations.specFunctionObject, lam->specTypes, jlrettype, ctx.is_opaque_closure);
codegen.cpp:        // case the apply-generic call can re-use the original box for the return
codegen.cpp:            int retarg = -1;
codegen.cpp:                        return -1;
codegen.cpp:                    unsigned sl = jl_slot_number(stmt) - 1;
codegen.cpp:                        return -1;
codegen.cpp:                    if (retarg == -1)
codegen.cpp:                        return -1;
codegen.cpp:        f->addFnAttr(Thunk);
codegen.cpp:        // TODO: add attributes: dereferenceable<sizeof(ft)>, readonly, nocapture - e.g. maybe_mark_argument_dereferenceable(Arg, argType);
codegen.cpp:        f->setDoesNotReturn();
codegen.cpp:        f->addFnAttr(polly::PollySkipFnAttr);
codegen.cpp:        f->addFnAttr(Attribute::NoInline);
codegen.cpp:        f->addAttribute(1, Attribute::getWithDereferenceableBytes(jl_LLVMContext, returninfo.union_bytes));
codegen.cpp:        f->addAttribute(1, Attribute::getWithAlignment(jl_LLVMContext, Align(returninfo.union_align)));
codegen.cpp:    f->addFnAttr(Attribute::StackProtectStrong);
codegen.cpp:    // TODO: enable this only when a argument like `-race` is passed to Julia
codegen.cpp:    f->addFnAttr(llvm::Attribute::SanitizeThread);
codegen.cpp:        f->addFnAttr("julia-optimization-level", optLevelStrings[optlevel]);
codegen.cpp:        DICompileUnit::DebugEmissionKind emissionKind = (DICompileUnit::DebugEmissionKind) ctx.params->debug_info_kind;
codegen.cpp:            subrty = get_specsig_di(ctx, jlrettype, lam->specTypes, dbuilder);
codegen.cpp:                                     ,f->getName()     // LinkageName
codegen.cpp:        f->setSubprogram(SP);
codegen.cpp:                jl_sym_t *argname = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, i);
codegen.cpp:                    has_sret + i + 1,                   // Argument number (1-based)
codegen.cpp:                    toplineno == -1 ? 0 : toplineno,    // Line
codegen.cpp:            if (va && ctx.vaSlot != -1) {
codegen.cpp:                    has_sret + nreq + 1,                // Argument number (1-based)
codegen.cpp:                    toplineno == -1 ? 0 : toplineno,    // Line (for now, use lineno of the function)
codegen.cpp:                jl_sym_t *s = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, i);
codegen.cpp:                    toplineno == -1 ? 0 : toplineno, // Line (for now, use lineno of the function)
codegen.cpp:        Function::arg_iterator AI = f->arg_begin();
codegen.cpp:        pargArray = ctx.builder.CreateAlloca(argArray->getType());
codegen.cpp:                lv->setName(jl_symbol_name(s));
codegen.cpp:                lv->setName(jl_symbol_name(s));
codegen.cpp:                assert((Metadata*)varinfo.dinfo->getType() != jl_pvalue_dillvmt);
codegen.cpp:            SI->insertAfter(ctx.pgcstack);
codegen.cpp:                if ((Metadata*)varinfo.dinfo->getType() == jl_pvalue_dillvmt) {
codegen.cpp:                    upsilon_to_phic[((jl_ssavalue_t*)val)->id] = i;
codegen.cpp:                jl_value_t *typ = jl_array_ptr_ref(src->ssavaluetypes, i);
codegen.cpp:    Function::arg_iterator AI = f->arg_begin();
codegen.cpp:        else if (llvmArgType->isAggregateType()) {
codegen.cpp:            theArg = mark_julia_slot(Arg, argType, NULL, tbaa_const); // this argument is by-pointer
codegen.cpp:            if (isboxed) // e.g. is-pointer
codegen.cpp:        jl_sym_t *s = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, i);
codegen.cpp:            jl_nth_slot_type(lam->specTypes, i);
codegen.cpp:                    Value *argPtr = ctx.builder.CreateInBoundsGEP(T_prjlvalue, argArray, ConstantInt::get(T_size, i-1));
codegen.cpp:                        addr.push_back((i - 1) * sizeof(void*));
codegen.cpp:                        if ((Metadata*)vi.dinfo->getType() != jl_pvalue_dillvmt)
codegen.cpp:                // keep track of original (possibly boxed) value to avoid re-boxing or moving
codegen.cpp:                        if ((Metadata*)vi.dinfo->getType() != jl_pvalue_dillvmt)
codegen.cpp:                        parg = ctx.builder.CreateAlloca(theArg.V->getType(), NULL, jl_symbol_name(s));
codegen.cpp:    if (va && ctx.vaSlot != -1) {
codegen.cpp:            ctx.nvargs = jl_nparams(lam->specTypes) - nreq;
codegen.cpp:            for (size_t i = nreq; i < jl_nparams(lam->specTypes); ++i) {
codegen.cpp:                jl_value_t *argType = jl_nth_slot_type(lam->specTypes, i);
codegen.cpp:                vargs[i - nreq] = get_specsig_arg(argType, llvmArgType, isboxed);
codegen.cpp:            // restarg = jl_f_tuple(NULL, &args[nreq], nargs - nreq)
codegen.cpp:                                  ConstantInt::get(T_size, nreq - 1)),
codegen.cpp:                                  ConstantInt::get(T_int32, nreq - 1)) });
codegen.cpp:            restTuple->setAttributes(F->getAttributes());
codegen.cpp:        assert(jl_is_array(src->linetable));
codegen.cpp:        size_t nlocs = jl_array_len(src->linetable);
codegen.cpp:            jl_value_t *locinfo = jl_array_ptr_ref(src->linetable, i);
codegen.cpp:                    method = ((jl_method_instance_t*)method)->def.value;
codegen.cpp:                    method = (jl_value_t*)((jl_method_t*)method)->name;
codegen.cpp:                if (expr->head == jl_aliasscope_sym) {
codegen.cpp:                } else if (expr->head == jl_popaliasscope_sym) {
codegen.cpp:    Instruction &prologue_end = ctx.builder.GetInsertBlock()->back();
codegen.cpp:        else if (ctx.builder.GetInsertBlock() && !ctx.builder.GetInsertBlock()->getTerminator()) {
codegen.cpp:            if (seq_next != -1 && ctx.builder.GetInsertBlock() && !ctx.builder.GetInsertBlock()->getTerminator()) {
codegen.cpp:                ctx.builder.CreateBr(nextbb->second);
codegen.cpp:            seq_next = -1;
codegen.cpp:            // if this BB is non-empty, we've visited it before so skip it
codegen.cpp:            if (!nextbb->second->getTerminator()) {
codegen.cpp:                ctx.builder.SetInsertPoint(nextbb->second);
codegen.cpp:        cursor = -1;
codegen.cpp:            unsigned newdbg = new_lineinfo[new_lineinfo.size() - dbg - 1];
codegen.cpp:    std::set<int> branch_targets; // 1-indexed
codegen.cpp:                // The next 1-indexed statement
codegen.cpp:                if (((jl_expr_t*)stmt)->head == jl_enter_sym) {
codegen.cpp:                    int dest = jl_unbox_long(jl_array_ptr_ref(((jl_expr_t*)stmt)->args, 0));
codegen.cpp:    while (cursor != -1) {
codegen.cpp:        int32_t debuginfoloc = ((int32_t*)jl_array_data(src->codelocs))[cursor];
codegen.cpp:                find_next_stmt(-1);
codegen.cpp:                find_next_stmt(-1);
codegen.cpp:            Value *sret = has_sret ? f->arg_begin() : NULL;
codegen.cpp:            Type *retty = f->getReturnType();
codegen.cpp:                        emit_sret_roots(ctx, true, data_pointer(ctx, retvalinfo), store_ty, f->arg_begin() + 1, returninfo.return_roots);
codegen.cpp:                    Type *store_ty = retvalinfo.V->getType();
codegen.cpp:                    Type *dest_ty = store_ty->getPointerTo();
codegen.cpp:                        emit_sret_roots(ctx, false, Val, store_ty, f->arg_begin() + 1, returninfo.return_roots);
codegen.cpp:                    if (dest_ty != sret->getType())
codegen.cpp:                retval->getType() == ctx.f->getReturnType());
codegen.cpp:            find_next_stmt(-1);
codegen.cpp:            find_next_stmt(lname - 1);
codegen.cpp:            workstack.push_back(lname - 1);
codegen.cpp:        else if (expr && expr->head == jl_enter_sym) {
codegen.cpp:            jl_value_t **args = (jl_value_t**)jl_array_data(expr->args);
codegen.cpp:            sj->setCanReturnTwice();
codegen.cpp:            workstack.push_back(lname - 1);
codegen.cpp:        if (!item.second->getTerminator())
codegen.cpp:            item.second->eraseFromParent();
codegen.cpp:            TerminatorInst *terminator = FromBB->getTerminator();
codegen.cpp:            if (!terminator->getParent()->getUniqueSuccessor()) {
codegen.cpp:                BasicBlock *NewBB = BasicBlock::Create(terminator->getContext(),
codegen.cpp:                   FromBB->getName() + "." + PhiBB->getName() + "_crit_edge");
codegen.cpp:                Function::iterator FBBI = FromBB->getIterator();
codegen.cpp:                ctx.f->getBasicBlockList().insert(++FBBI, NewBB); // insert after existing block
codegen.cpp:                terminator->replaceSuccessorWith(PhiBB, NewBB);
codegen.cpp:                DebugLoc Loc = terminator->getDebugLoc();
codegen.cpp:                terminator->setDebugLoc(Loc);
codegen.cpp:                terminator->removeFromParent();
codegen.cpp:                val = mark_julia_const(val.constant); // be over-conservative at making sure `.typ` is set concretely, not tindex
codegen.cpp:                        V = undef_value_for_type(VN->getType());
codegen.cpp:                    else if (VN->getType() == T_prjlvalue) {
codegen.cpp:                        V = emit_guarded_test(ctx, isvalid, undef_value_for_type(VN->getType()), [&] {
codegen.cpp:                            return emit_unbox(ctx, VN->getType(), val, phiType);
codegen.cpp:                    VN->addIncoming(V, ctx.builder.GetInsertBlock());
codegen.cpp:                        V = undef_value_for_type(VN->getType());
codegen.cpp:                    VN->addIncoming(V, ctx.builder.GetInsertBlock());
codegen.cpp:                    TindexN->addIncoming(RTindex, ctx.builder.GetInsertBlock());
codegen.cpp:                PhiBB->replacePhiUsesWith(FromBB, NewBB);
codegen.cpp:            ctx.builder.SetInsertPoint(FromBB->getTerminator());
codegen.cpp:                Value *undef = undef_value_for_type(VN->getType());
codegen.cpp:                VN->addIncoming(undef, FromBB);
codegen.cpp:                TindexN->addIncoming(RTindex, FromBB);
codegen.cpp:                if (CountTrackedPointers(dest->getAllocatedType()).count)
codegen.cpp:                    ctx.builder.CreateStore(Constant::getNullValue(dest->getAllocatedType()), dest);
codegen.cpp:        PN->replaceAllUsesWith(UndefValue::get(PN->getType()));
codegen.cpp:        PN->eraseFromParent();
codegen.cpp:                    Function *F = call->getCalledFunction();
codegen.cpp:                    if (!in_prologue || !F || !(F->isIntrinsic() || F->getName().startswith("julia.") || &I == restTuple)) {
codegen.cpp:            for (Use &U : root->uses()) {
codegen.cpp:                        store_value = dyn_cast<Instruction>(SRU->getValueOperand());
codegen.cpp:                else if (isa<LoadInst>(RU) && RU->use_empty()) {
codegen.cpp:                for (Use &U : root->uses()) {
codegen.cpp:                        use->eraseFromParent();
codegen.cpp:                    use->eraseFromParent();
codegen.cpp:                root->eraseFromParent();
codegen.cpp:                restTuple->eraseFromParent();
codegen.cpp:    // copy ctx.roots into m->roots
codegen.cpp:        jl_method_t *m = lam->def.method;
codegen.cpp:        JL_LOCK(&m->writelock);
codegen.cpp:        if (m->roots == NULL) {
codegen.cpp:            m->roots = ctx.roots;
codegen.cpp:            jl_gc_wb(m, m->roots);
codegen.cpp:            size_t j, jlen = jl_array_dim0(m->roots);
codegen.cpp:                    jl_value_t *jval = jl_array_ptr_ref(m->roots, j);
codegen.cpp:                if (j == jlen) // not found - add to array
codegen.cpp:                    jl_array_ptr_1d_push(m->roots, ival);
codegen.cpp:        JL_UNLOCK(&m->writelock);
codegen.cpp:        for (const auto &F: Mod->functions())
codegen.cpp:            jl_Module->getFunction(FN)->setLinkage(GlobalVariable::InternalLinkage);
codegen.cpp:        for (const auto &F: Mod->functions())
codegen.cpp:            jl_Module->getFunction(FN)->setLinkage(GlobalVariable::InternalLinkage);
codegen.cpp:// --- entry point ---
codegen.cpp:JL_GCC_IGNORE_START("-Wclobbered")
codegen.cpp:            jl_static_show(dump_emitted_mi_name_stream, li->specTypes);
codegen.cpp:        src = (jl_code_info_t*)codeinst->inferred;
codegen.cpp:        jl_method_t *def = codeinst->def->def.method;
codegen.cpp:    jl_compile_result_t result = jl_emit_code(codeinst->def, src, codeinst->rettype, params);
codegen.cpp:        // so we can build a reverse mapping for debug-info.
codegen.cpp:        bool toplevel = !jl_is_method(codeinst->def->def.method);
codegen.cpp:            const DataLayout &DL = m->getDataLayout();
codegen.cpp:            codeinst->inferred) {
codegen.cpp:            jl_method_t *def = codeinst->def->def.method;
codegen.cpp:                if (codeinst->inferred != (jl_value_t*)src) {
codegen.cpp:                    codeinst->inferred = (jl_value_t*)src;
codegen.cpp:                     codeinst->inferred != jl_nothing &&
codegen.cpp:                     (codeinst->invoke == jl_fptr_const_return_addr || !jl_ir_flag_inlineable((jl_array_t*)codeinst->inferred)) &&
codegen.cpp:                codeinst->inferred = jl_nothing;
codegen.cpp:        assert(codeinst->min_world <= params.world && codeinst->max_world >= params.world &&
codegen.cpp:            "invalid world for code-instance");
codegen.cpp:        auto invoke = jl_atomic_load_relaxed(&codeinst->invoke);
codegen.cpp:            auto fptr = jl_atomic_load_relaxed(&codeinst->specptr.fptr);
codegen.cpp:                preal_decl = jl_ExecutionEngine->getFunctionAtAddress((uintptr_t)fptr, codeinst);
codegen.cpp:            else if (codeinst->isspecsig) {
codegen.cpp:                preal_decl = jl_ExecutionEngine->getFunctionAtAddress((uintptr_t)fptr, codeinst);
codegen.cpp:                    codeinst->inferred && codeinst->inferred == jl_nothing) {
codegen.cpp:                    src = jl_type_infer(codeinst->def, jl_world_counter, 0);
codegen.cpp:                        result = jl_emit_code(codeinst->def, src, src->rettype, params);
codegen.cpp:                if (decls->functionObject == "jl_fptr_args") {
codegen.cpp:                    preal_decl = decls->specFunctionObject;
codegen.cpp:                else if (decls->functionObject != "jl_fptr_sparam") {
codegen.cpp:                    preal_decl = decls->specFunctionObject;
codegen.cpp:        Module *mod = protodecl->getParent();
codegen.cpp:        assert(protodecl->isDeclaration());
codegen.cpp:                // emit specsig-to-(jl)invoke conversion
codegen.cpp:                protodecl->setLinkage(GlobalVariable::InternalLinkage);
codegen.cpp:                //protodecl->setAlwaysInline();
codegen.cpp:                size_t nrealargs = jl_nparams(codeinst->def->specTypes); // number of actual arguments being passed
codegen.cpp:                // TODO: maybe this can be cached in codeinst->specfptr?
codegen.cpp:                emit_cfunc_invalidate(protodecl, proto_cc, proto_return_roots, codeinst->def->specTypes, codeinst->rettype, nrealargs, params, preal);
codegen.cpp:            // expected non-specsig
codegen.cpp:                // emit jlcall1-to-(jl)invoke conversion
codegen.cpp:                preal_decl = emit_tojlinvoke(codeinst, mod, params)->getName();
codegen.cpp:            if (Value *specfun = mod->getNamedValue(preal_decl)) {
codegen.cpp:                    protodecl->replaceAllUsesWith(specfun);
codegen.cpp:                protodecl->setName(preal_decl);
codegen.cpp:// --- initialization ---
codegen.cpp:    T_pvoidfunc = FunctionType::get(T_void, /*isVarArg*/false)->getPointerTo();
codegen.cpp:        nullptr);  // Elements - will be corrected later
codegen.cpp:    ftargs.push_back(T_pprjlvalue); // linfo->sparam_vals
codegen.cpp:char jl_using_intel_jitevents; // Non-zero if running under Intel VTune Amplifier
codegen.cpp:char jl_using_oprofile_jitevents = 0; // Non-zero if running under OProfile
codegen.cpp:    // Set preferred non-default options
codegen.cpp:    clopt = llvmopts.lookup("enable-tail-merge"); // NOO TOUCHIE; NO TOUCH! See #922
codegen.cpp:    if (clopt->getNumOccurrences() == 0)
codegen.cpp:    clopt = llvmopts.lookup("combiner-store-merge-dependence-limit");
codegen.cpp:    if (clopt && clopt->getNumOccurrences() == 0)
codegen.cpp:    // tell Win32 to assume the stack is always 16-byte aligned,
codegen.cpp:    // and to ensure that it is 16-byte aligned for out-going calls,
codegen.cpp:            TheTarget->createMCSubtargetInfo(TheTriple.str(), "", ""));
codegen.cpp:        if (!MSTI->isCPUStringValid(TheCPU))
codegen.cpp:            MSTI->setDefaultFeatures("help", "", "");
codegen.cpp:            MSTI->setDefaultFeatures("help", "");
codegen.cpp:    jl_TargetMachine = TheTarget->createTargetMachine(
codegen.cpp:    assert(jl_TargetMachine && "Failed to select target machine -"
codegen.cpp:        jl_TargetMachine->setFastISel(true);
codegen.cpp:    // Mark our address spaces as non-integral
codegen.cpp:    jl_data_layout = jl_ExecutionEngine->getDataLayout();
codegen.cpp:    std::string DL = jl_data_layout.getStringRepresentation() + "-ni:10:11:12:13";
codegen.cpp:        jl_ExecutionEngine->RegisterJITEventListener(JITEventListener::createGDBRegistrationListener());
codegen.cpp:        jl_ExecutionEngine->RegisterJITEventListener(JITEventListener::createIntelJITEventListener());
codegen.cpp:        jl_ExecutionEngine->RegisterJITEventListener(JITEventListener::createOProfileJITEventListener());
codegen.cpp:        jl_ExecutionEngine->RegisterJITEventListener(JITEventListener::createPerfJITEventListener());
codegen.cpp:    llvm_dump(cast<Instruction>(((Value*)v))->getParent()->getParent());
codegen.cpp:    llvm::WriteBitcodeToFile(*((llvm::Function*)F)->getParent(), OS);
codegen.cpp:#include <llvm-c/Core.h>
staticjit.cpp:#include "llvm-version.h"
staticjit.cpp:        if (auto G = llvm::jitlink::createLinkGraphFromObject(membuf->getMemBufferRef())) {
staticjit.cpp:    StringRef getName() const override { return G->getName(); }
staticjit.cpp:            if (Sym->getScope() == Scope::Local)
staticjit.cpp:            assert(Sym->hasName() && "Anonymous non-local symbol?");
staticjit.cpp:            if (Sym->getScope() == Scope::Default)
staticjit.cpp:            if (Sym->isCallable())
staticjit.cpp:            LGI.SymbolFlags[ES.intern(Sym->getName())] = Flags;
staticjit.cpp:        for (auto *Sym : G->defined_symbols())
staticjit.cpp:            if (Sym->getName() == *Name) {
staticjit.cpp:                assert(Sym->getLinkage() == Linkage::Weak &&
staticjit.cpp:                       "Discarding non-weak definition");
staticjit.cpp:                G->makeExternal(*Sym);
staticjit.cpp:        auto symbols = R->getRequestedSymbols();
staticjit.cpp:        cantFail(R->notifyResolved(smap));
staticjit.cpp:        cantFail(R->notifyEmitted());
staticjit.cpp:    Triple TheTriple = Triple(jl_TargetMachine->getTargetTriple());
staticjit.cpp:TM0(jl_TargetMachine->getTarget().createTargetMachine( TheTriple.getTriple(),
staticjit.cpp:jl_TargetMachine->getTargetCPU(), jl_TargetMachine->getTargetFeatureString(),
staticjit.cpp:jl_TargetMachine->Options, #if defined(_OS_LINUX_) || defined(_OS_FREEBSD_) Reloc::PIC_,
staticjit.cpp:    if (TM->addPassesToEmitFile(PM, obj_OS, nullptr, CGFT_ObjectFile, false)) {
staticjit.cpp:    auto DL = TM->createDataLayout();
staticjit.cpp:    assert(b->constp);
staticjit.cpp:    assert(jl_isa(b->value, ty));
staticjit.cpp:        jl_atomic_load_relaxed(&(stringpool_binding->value));
staticjit.cpp:        jl_atomic_load_relaxed(&(symbolpool_binding->value));
staticjit.cpp:        jl_atomic_load_relaxed(&(bitvalue_pool->value));
staticjit.cpp:        return (uint8_t)(c - '0');
staticjit.cpp:        return (uint8_t)(c - 'A' + 10);
staticjit.cpp:    assert(jl_is_immutable_datatype(_dt) && ((jl_datatype_t *)_dt)->isconcretetype);
staticjit.cpp:    if (dt->layout && nfields == 0 && dt != jl_string_type && dt != jl_symbol_type) {
staticjit.cpp:            jl_value_t *_fieldtype = jl_svec_ref(dt->types, i);
staticjit.cpp:                        len = len * 10 + (endc - '0');
staticjit.cpp:            else if (fieldtype->layout && jl_datatype_nfields(fieldtype) == 0) {
staticjit.cpp:                     ((jl_datatype_t *)_fieldtype)->isconcretetype) {
staticjit.cpp:                    (uint64_t)jl_atomic_load_relaxed(&bnd->value);
staticjit.cpp:    assert(jl_is_immutable_datatype(_dt) && ((jl_datatype_t *)_dt)->isconcretetype);
staticjit.cpp:    std::vector<uint8_t> buffer(dt->size);
staticjit.cpp:    for (auto i = SpecialJuliaRuntimeValue->begin(); i != SpecialJuliaRuntimeValue->end();
staticjit.cpp:        // llvm::errs() << "Check: " << i->first << " " << i->first.size() << "\n";
staticjit.cpp:        // llvm::errs() << "Result" << i->first.compare(s) << "\n";
staticjit.cpp:        if (i->first.compare(s) == 0) {
staticjit.cpp:            return i->second;
staticjit.cpp:            jl_StaticJuliaJIT->constpool[StaticJuliaJIT::ConstantType::Symbol];
staticjit.cpp:        size_t slen = (s.size() - offset) / 2 + 1;
staticjit.cpp:#define decode(c) ((c) >= 'A' ? (c) - 'A' + 10 : (c) - '0')
staticjit.cpp:        v[slen - 1] = '\0';
staticjit.cpp:            jl_StaticJuliaJIT->constpool[StaticJuliaJIT::ConstantType::String];
staticjit.cpp:        // ((jl_datatype_t*)dt)->isconcretetype)){
staticjit.cpp:                                     ->constpool[StaticJuliaJIT::ConstantType::BitValue],
staticjit.cpp:        std::string modname = s.substr(offset, modnameend - offset);
staticjit.cpp:        return (uint64_t)(&(b->value));
staticjit.cpp:        std::string libname_s = s.substr(offset, libnameend - offset);
staticjit.cpp:            return (uint64_t)(((jl_datatype_t *)v)->instance);
staticjit.cpp:        jl_StaticJuliaJIT->ES.intern(StringRef(jl_symbol_name((jl_sym_t *)symbol)));
staticjit.cpp:    auto symOrErr = jl_StaticJuliaJIT->ES.lookup(
staticjit.cpp:        {/*&jl_StaticJuliaJIT->JuliaBuiltinJD,*/
staticjit.cpp:         &jl_StaticJuliaJIT->finalJD,
staticjit.cpp:         /*&jl_StaticJuliaJIT->JuliaRuntimeJD*/},
staticjit.cpp:        // auto table = jl_StaticJuliaJIT->JuliaRuntimeJD.Symbols;
staticjit.cpp:            std::cout << *(*i->first).str();
staticjit.cpp:            llvm::orc::JITDylib::Sym entry = (*i->second);
staticjit.cpp:            std::cout << i->
staticjit.cpp:        // MemoryBufferRef ObjBuffer = membuf->getMemBufferRef();
staticjit.cpp:        addobject(jl_StaticJuliaJIT->ObjectLayer, jl_StaticJuliaJIT->finalJD,
staticjit.cpp:        // Ctx->notifyMaterializing(**G);
staticjit.cpp:    llvm::orc::createLinkGraphFromObject(ObjBuffer->getMemBufferRef())){ this->linkgraph_mu
staticjit.cpp:    jl_code_instance_t *codeinst = jl_atomic_load_relaxed(&mi->cache);
staticjit.cpp:        if (codeinst->min_world <= min_world && max_world <= codeinst->max_world) {
staticjit.cpp:            jl_value_t *code = codeinst->inferred;
staticjit.cpp:        codeinst = jl_atomic_load_relaxed(&codeinst->next);
staticjit.cpp:    assert(jl_is_method(mi->def.method) && jl_symbol_name(mi->def.method->name)[0] != '@');
staticjit.cpp:    assert(src->inferred);
staticjit.cpp:        jl_get_method_inferred(mi, src->rettype, src->min_world, src->max_world);
staticjit.cpp:    // Either jl_type_infer has produced and cached code info in codeinst->inferred
staticjit.cpp:    if (src->inferred && lookup_codeinst->rettype_const == NULL){
staticjit.cpp:        lookup_codeinst->rettype = src->rettype;
staticjit.cpp:        lookup_codeinst->rettype_const = src->
staticjit.cpp:    if (src->inferred && !lookup_codeinst->inferred) {
staticjit.cpp:        lookup_codeinst->inferred = jl_nothing;
staticjit.cpp:    assert((lookup_codeinst->inferred != NULL) || (lookup_codeinst->rettype_const != NULL));
staticjit.cpp:    for (auto I = M->global_objects().begin(), E = M->global_objects().end(); I != E;) {
staticjit.cpp:        if (F->isDeclaration()) {
staticjit.cpp:            if (F->use_empty()) {
staticjit.cpp:                F->eraseFromParent();
staticjit.cpp:    llvm::legacy::PassManager &PM = jl_StaticJuliaJIT->PM;
staticjit.cpp:            prepare_code_instance(curr_codeinst->def, world);
staticjit.cpp:        jl_method_instance_t *curr_methinst = curr_codeinst->def;
staticjit.cpp:        if (curr_codeinst->inferred == NULL || (jl_value_t *)curr_codeinst == jl_nothing) {
staticjit.cpp:        src = curr_codeinst->inferred;
staticjit.cpp:            src = (jl_value_t *)jl_type_infer(curr_codeinst->def, world, 0);
staticjit.cpp:        src = (jl_value_t *)jl_uncompress_ir(curr_methinst->def.method, curr_codeinst,
staticjit.cpp:        // params.params->lookup
staticjit.cpp:                                                   curr_codeinst->rettype, params);
staticjit.cpp:            jl_method_instance_t *target = std::get<0>(params.workqueue.back())->def;
staticjit.cpp:        mod->print(fos1, nullptr);
staticjit.cpp:        // PM->run(*mod);
staticjit.cpp:        std::string s2 = s.substr(0, 200) + "-optimize.ll";
staticjit.cpp:        mod->print(fos2, nullptr);
staticjit.cpp:        jl_StaticJuliaJIT->obj_Buffer.swap(emptyBuffer);
staticjit.cpp:        auto objorerr = object::ObjectFile::createObjectFile(ObjBuffer->getMemBufferRef());
staticjit.cpp:        // MemoryBufferRef ObjBuffer = membuf->getMemBufferRef();
staticjit.cpp:        llvm::MemoryBufferRef mbref(objfile.get()->getData(), name_from_method_instance());
staticjit.cpp:        getDefaultForHost(jl_StaticJuliaJIT->TM->getTargetTriple());
staticjit.cpp:        addobject(jl_StaticJuliaJIT->ObjectLayer, jl_StaticJuliaJIT->finalJD,
staticjit.cpp:        const char *mname = name_from_method_instance(i->first);
staticjit.cpp:        llvm::errs() << i->first << " : " << format("%p", (void *)i->second) << "\n";
staticjit.cpp:            SymbolStringPtr namerefptr = jl_StaticJuliaJIT->ES.intern(StringRef(s));
staticjit.cpp:            auto symOrErr = jl_StaticJuliaJIT->ES.lookup(
staticjit.cpp:                {/*&jl_StaticJuliaJIT->JuliaBuiltinJD,*/
staticjit.cpp:                 &jl_StaticJuliaJIT->finalJD,
staticjit.cpp:                 /*&jl_StaticJuliaJIT->JuliaRuntimeJD*/},
staticjit.cpp:                    jl_StaticJuliaJIT->finalJD.remove(set);
staticjit.cpp:        uint64_t &invokeptr = std::get<1>(iter->second);
staticjit.cpp://         src = (jl_code_info_t *)codeinst->inferred;
staticjit.cpp://         else if (jl_is_method(mi->def.method))
staticjit.cpp://             src = jl_uncompress_ir(mi->def.method, codeinst, (jl_array_t *)src);
staticjit.cpp://     if (src == NULL && jl_is_method(mi->def.method) &&
staticjit.cpp://         jl_symbol_name(mi->def.method->name)[0] != '@') {
staticjit.cpp://     auto PM = jl_ExecutionEngine->PM2;
staticjit.cpp://                 jl_get_method_inferred(mi, src->rettype, src->min_world, src->max_world);
staticjit.cpp://             if (src->inferred && !codeinst->inferred)
staticjit.cpp://                 codeinst->inferred = jl_nothing;
staticjit.cpp://             emit_function(codeinst->def, src, codeinst->rettype, params);
staticjit.cpp://         mod->print(fos1, nullptr);
staticjit.cpp://         std::string s2 = s.substr(0, 200) + "-optimize.ll";
staticjit.cpp://         mod->print(fos2, nullptr);
jl_exported_funcs.inc:// use YY instead of XX to avoid jl -> ijl renaming in libjulia-codegen
builtin_proto.h:// declarations for julia-callable builtin functions
processor.h: *     There can be more than one slot per-function,
llvm-julia-licm.cpp:#include "llvm-version.h"
llvm-julia-licm.cpp:#include "llvm-pass-helpers.h"
llvm-julia-licm.cpp:#define DEBUG_TYPE "julia-licm"
llvm-julia-licm.cpp:        BasicBlock *preheader = L->getLoopPreheader();
llvm-julia-licm.cpp:        BasicBlock *header = L->getHeader();
llvm-julia-licm.cpp:        initFunctions(*header->getModule());
llvm-julia-licm.cpp:        auto get_exit_pts = [&] () -> ArrayRef<Instruction*> {
llvm-julia-licm.cpp:                L->getUniqueExitBlocks(exit_bbs);
llvm-julia-licm.cpp:                    _exit_pts.push_back(&*bb->getFirstInsertionPt());
llvm-julia-licm.cpp:            for (BasicBlock::iterator II = bb->begin(), E = bb->end(); II != E;) {
llvm-julia-licm.cpp:                Value *callee = call->getCalledOperand();
llvm-julia-licm.cpp:                    for (Use &U : call->arg_operands()) {
llvm-julia-licm.cpp:                        if (!DT->properlyDominates(origin->getParent(), header)) {
llvm-julia-licm.cpp:                    call->moveBefore(preheader->getTerminator());
llvm-julia-licm.cpp:                    auto begin = cast<Instruction>(call->getArgOperand(0));
llvm-julia-licm.cpp:                    if (!DT->properlyDominates(begin->getParent(), header))
llvm-julia-licm.cpp:                        call->eraseFromParent();
llvm-julia-licm.cpp:                    call->moveBefore(exit_pts[0]);
llvm-julia-licm.cpp:    unwrap(PM)->add(createJuliaLICMPass());
llvm-ptls.cpp:#include "llvm-version.h"
llvm-ptls.cpp:#include <llvm-c/Core.h>
llvm-ptls.cpp:#include <llvm-c/Types.h>
llvm-ptls.cpp:    pgcstack->addAttribute(AttributeList::FunctionIndex, Attribute::ReadNone);
llvm-ptls.cpp:    pgcstack->addAttribute(AttributeList::FunctionIndex, Attribute::NoUnwind);
llvm-ptls.cpp:    if (insertBefore->getFunction()->callsFunctionThatReturnsTwice()) {
llvm-ptls.cpp:            args.push_back(offset->getType());
llvm-ptls.cpp:    tls = new BitCastInst(tls, T_pppjlvalue->getPointerTo(), "ppgcstack", insertBefore);
llvm-ptls.cpp:    // (can be accessed with a single PC-rel load).
llvm-ptls.cpp:    Comdat *jl_Comdat = G->getParent()->getOrInsertComdat(G->getName());
llvm-ptls.cpp:    jl_Comdat->setSelectionKind(Comdat::NoDuplicates);
llvm-ptls.cpp:    G->setComdat(jl_Comdat);
llvm-ptls.cpp:    if (G->getLinkage() == GlobalValue::ExternalLinkage)
llvm-ptls.cpp:        G->setDLLStorageClass(GlobalValue::DLLExportStorageClass);
llvm-ptls.cpp:        G->setDLLStorageClass(GlobalValue::DefaultStorageClass);
llvm-ptls.cpp:    if (pgcstack->use_empty()) {
llvm-ptls.cpp:        pgcstack->eraseFromParent();
llvm-ptls.cpp:            offset->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);
llvm-ptls.cpp:            offset->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(*ctx, None));
llvm-ptls.cpp:                                    Constant::getNullValue(offset->getType()));
llvm-ptls.cpp:            pgcstack->replaceAllUsesWith(phi);
llvm-ptls.cpp:            pgcstack->moveBefore(slowTerm);
llvm-ptls.cpp:            getter->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);
llvm-ptls.cpp:            getter->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(*ctx, None));
llvm-ptls.cpp:            pgcstack->setCalledFunction(pgcstack->getFunctionType(), getter);
llvm-ptls.cpp:            phi->addIncoming(fastTLS, fastTLS->getParent());
llvm-ptls.cpp:            phi->addIncoming(pgcstack, pgcstack->getParent());
llvm-ptls.cpp:        getter->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);
llvm-ptls.cpp:        getter->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(*ctx, None));
llvm-ptls.cpp:        key->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);
llvm-ptls.cpp:        key->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(*ctx, None));
llvm-ptls.cpp:        new_pgcstack->takeName(pgcstack);
llvm-ptls.cpp:        pgcstack->replaceAllUsesWith(new_pgcstack);
llvm-ptls.cpp:        pgcstack->eraseFromParent();
llvm-ptls.cpp:        pgcstack->setCalledFunction(pgcstack->getFunctionType(), getter);
llvm-ptls.cpp:    else if (jl_tls_offset != -1) {
llvm-ptls.cpp:        pgcstack->replaceAllUsesWith(emit_pgcstack_tp(nullptr, pgcstack));
llvm-ptls.cpp:        pgcstack->eraseFromParent();
llvm-ptls.cpp:        new_pgcstack->takeName(pgcstack);
llvm-ptls.cpp:        pgcstack->replaceAllUsesWith(new_pgcstack);
llvm-ptls.cpp:        pgcstack->eraseFromParent();
llvm-ptls.cpp:        pgcstack->setCalledFunction(pgcstack->getFunctionType(), val);
llvm-ptls.cpp:    pgcstack_getter = M->getFunction("julia.get_pgcstack");
llvm-ptls.cpp:    ctx = &M->getContext();
llvm-ptls.cpp:    T_pint8 = T_int8->getPointerTo();
llvm-ptls.cpp:    FT_pgcstack_getter = pgcstack_getter->getFunctionType();
llvm-ptls.cpp:    FT_pgcstack_getter = FunctionType::get(FT_pgcstack_getter->getReturnType(), {T_size}, false);
llvm-ptls.cpp:    T_pgcstack_getter = FT_pgcstack_getter->getPointerTo();
llvm-ptls.cpp:    T_pppjlvalue = cast<PointerType>(FT_pgcstack_getter->getReturnType());
llvm-ptls.cpp:    T_ppjlvalue = cast<PointerType>(T_pppjlvalue->getElementType());
llvm-ptls.cpp:    for (auto it = pgcstack_getter->user_begin(); it != pgcstack_getter->user_end();) {
llvm-ptls.cpp:        assert(call->getCalledOperand() == pgcstack_getter);
llvm-ptls.cpp:    assert(pgcstack_getter->use_empty());
llvm-ptls.cpp:    pgcstack_getter->eraseFromParent();
llvm-ptls.cpp:    unwrap(PM)->add(createLowerPTLSPass(imaging_mode));
method.c:// Resolve references to non-locally-defined variables to become references to global
method.c:        if (e->head == jl_global_sym && binding_effects) {
method.c:            // execute the side-effects of "global x" decl immediately:
method.c:        if (jl_is_toplevel_only_expr(expr) || e->head == jl_const_sym ||
method.c:            e->head == jl_coverageeffect_sym || e->head == jl_copyast_sym ||
method.c:            e->head == jl_quote_sym || e->head == jl_inert_sym ||
method.c:            e->head == jl_meta_sym || e->head == jl_inbounds_sym ||
method.c:            e->head == jl_boundscheck_sym || e->head == jl_loopinfo_sym ||
method.c:            e->head == jl_aliasscope_sym || e->head == jl_popaliasscope_sym ||
method.c:            e->head == jl_inline_sym || e->head == jl_noinline_sym) {
method.c:            size_t i = 0, nargs = jl_array_len(e->args);
method.c:            if (e->head == jl_opaque_closure_method_sym) {
method.c:            if (e->head == jl_cfunction_sym) {
method.c:            if (e->head == jl_foreigncall_sym) {
method.c:            if (e->head == jl_method_sym || e->head == jl_module_sym) {
method.c:            if (e->head == jl_call_sym && jl_expr_nargs(e) == 3 &&
method.c:                // for expressions pattern-matching to `getproperty(module_expr, :sym)` in a top-module
method.c:                // TODO: this was broken by linear-IR
method.c:                if (fe_mod->istopmod && !strcmp(jl_symbol_name(fe_sym), "getproperty") && jl_is_symbol(s)) {
method.c:                        if (b && b->constp) {
method.c:                            jl_value_t *v = jl_atomic_load_relaxed(&b->value);
method.c:            if (e->head == jl_call_sym && nargs > 0 &&
method.c:                    if (b && b->constp && jl_atomic_load_relaxed(&b->value) == jl_builtin_tuple) {
method.c:    jl_array_t *args = ((jl_expr_t*)expr)->args;
method.c:    li->linetable = jl_exprarg(ir, 4);
method.c:    li->codelocs = (jl_value_t*)jl_alloc_array_1d(jl_array_int32_type, nlocs);
method.c:        jl_arrayset((jl_array_t*)li->codelocs, jl_box_int32(jl_unbox_long(jl_arrayref((jl_array_t*)codelocs, j))),
method.c:    jl_array_t *body = bodyex->args;
method.c:    li->code = body;
method.c:    jl_gc_wb(li, li->code);
method.c:    jl_value_t **bd = (jl_value_t**)jl_array_ptr_data((jl_array_t*)li->code);
method.c:    li->ssaflags = jl_alloc_array_1d(jl_array_uint8_type, n);
method.c:    jl_gc_wb(li, li->ssaflags);
method.c:        if (jl_is_expr(st) && ((jl_expr_t*)st)->head == jl_meta_sym) {
method.c:            jl_array_t *meta = ((jl_expr_t*)st)->args;
method.c:                    li->pure = 1;
method.c:                    li->inlineable = 1;
method.c:                    li->propagate_inbounds = 1;
method.c:                    li->constprop = 1;
method.c:                    li->constprop = 2;
method.c:                jl_array_del_end(meta, na - ins);
method.c:        else if (jl_is_expr(st) && ((jl_expr_t*)st)->head == jl_inbounds_sym) {
method.c:                inbounds_depth -= 1;
method.c:        else if (jl_is_expr(st) && ((jl_expr_t*)st)->head == jl_inline_sym) {
method.c:        else if (jl_is_expr(st) && ((jl_expr_t*)st)->head == jl_noinline_sym) {
method.c:        else if (jl_is_expr(st) && ((jl_expr_t*)st)->head == jl_return_sym) {
method.c:            jl_array_uint8_set(li->ssaflags, j, 0);
method.c:            if (inline_flags->len > 0) {
method.c:                void* inline_flag = inline_flags->items[inline_flags->len - 1];
method.c:            jl_array_uint8_set(li->ssaflags, j, flag);
method.c:    assert(inline_flags->len == 0); // malformed otherwise
method.c:    li->slotnames = jl_alloc_array_1d(jl_array_symbol_type, nslots);
method.c:    jl_gc_wb(li, li->slotnames);
method.c:    li->slotflags = jl_alloc_array_1d(jl_array_uint8_type, nslots);
method.c:    jl_gc_wb(li, li->slotflags);
method.c:    li->ssavaluetypes = jl_box_long(nssavalue);
method.c:    jl_gc_wb(li, li->ssavaluetypes);
method.c:                else if (str[1] == 's')  // compiler-generated temporaries, #sXXX
method.c:        jl_array_ptr_set(li->slotnames, i, name);
method.c:        jl_array_uint8_set(li->slotflags, i, vinfo_mask & jl_unbox_long(jl_array_ptr_ref(vi, 2)));
method.c:        (jl_method_instance_t*)jl_gc_alloc(ct->ptls, sizeof(jl_method_instance_t),
method.c:    li->def.value = NULL;
method.c:    li->specTypes = NULL;
method.c:    li->sparam_vals = jl_emptysvec;
method.c:    li->uninferred = NULL;
method.c:    li->backedges = NULL;
method.c:    li->callbacks = NULL;
method.c:    jl_atomic_store_relaxed(&li->cache, NULL);
method.c:    li->inInference = 0;
method.c:        (jl_code_info_t*)jl_gc_alloc(ct->ptls, sizeof(jl_code_info_t),
method.c:    src->code = NULL;
method.c:    src->codelocs = NULL;
method.c:    src->ssavaluetypes = NULL;
method.c:    src->ssaflags = NULL;
method.c:    src->method_for_inference_limit_heuristics = jl_nothing;
method.c:    src->linetable = jl_nothing;
method.c:    src->slotflags = NULL;
method.c:    src->slotnames = NULL;
method.c:    src->slottypes = jl_nothing;
method.c:    src->parent = (jl_method_instance_t*)jl_nothing;
method.c:    src->rettype = (jl_value_t*)jl_any_type;
method.c:    src->min_world = 1;
method.c:    src->max_world = ~(size_t)0;
method.c:    src->inferred = 0;
method.c:    src->inlineable = 0;
method.c:    src->propagate_inbounds = 0;
method.c:    src->pure = 0;
method.c:    src->edges = jl_nothing;
method.c:    src->constprop = 0;
method.c:    jl_array_t *li = (jl_array_t*)ci->linetable;
method.c:    size_t totargs = 1 + n_sparams + nargs + def->isva;
method.c:    if (def->isva) {
method.c:        gargs[totargs-1] = jl_f_tuple(NULL, &gargs[1 + n_sparams + def->nargs - 1], nargs - (def->nargs - 1));
method.c:        gargs[1 + n_sparams + def->nargs - 1] = gargs[totargs - 1];
method.c:    jl_value_t *code = jl_apply(gargs, 1 + n_sparams + def->nargs);
method.c:// Lower `ex` into Julia IR, and (if it expands into a CodeInfo) resolve global-variable
method.c:        jl_array_t *stmts = (jl_array_t*)func->code;
method.c:    if (linfo->uninferred) {
method.c:        return (jl_code_info_t*)jl_copy_ast((jl_value_t*)linfo->uninferred);
method.c:    jl_value_t *tt = linfo->specTypes;
method.c:    jl_method_t *def = linfo->def.method;
method.c:    jl_value_t *generator = def->generator;
method.c:    int last_in = ct->ptls->in_pure_callback;
method.c:    size_t last_age = ct->world_age;
method.c:        ct->ptls->in_pure_callback = 1;
method.c:        ct->world_age = def->primary_world;
method.c:        ex = jl_call_staged(def, generator, linfo->sparam_vals, jl_svec_data(ttdt->parameters), jl_nparams(ttdt));
method.c:            jl_array_t *stmts = (jl_array_t*)func->code;
method.c:            jl_resolve_globals_in_ir(stmts, def->module, linfo->sparam_vals, 1);
method.c:            func = jl_expand_and_resolve(ex, def->module, linfo->sparam_vals);
method.c:                if (jl_is_expr(func) && ((jl_expr_t*)func)->head == jl_error_sym) {
method.c:                    ct->ptls->in_pure_callback = 0;
method.c:                    jl_toplevel_eval(def->module, (jl_value_t*)func);
method.c:        for (int i = 0; i < jl_array_len(func->code); ++i) {
method.c:            jl_value_t *stmt = jl_array_ptr_ref(func->code, i);
method.c:            if (jl_is_expr(stmt) && ((jl_expr_t*)stmt)->head == jl_new_opaque_closure_sym) {
method.c:                linfo->uninferred = jl_copy_ast((jl_value_t*)func);
method.c:                jl_gc_wb(linfo, linfo->uninferred);
method.c:        ct->ptls->in_pure_callback = last_in;
method.c:        ct->world_age = last_age;
method.c:        jl_add_function_name_to_lineinfo(func, (jl_value_t*)def->name);
method.c:        ct->ptls->in_pure_callback = last_in;
method.c:        (jl_code_info_t*)jl_gc_alloc(ct->ptls, sizeof(jl_code_info_t),
method.c:// return a new lambda-info that has some extra static parameters merged in
method.c:    assert((size_t)jl_subtype_env_size(m->sig) == jl_svec_len(sp) || sp == jl_emptysvec);
method.c:    new_linfo->def.method = m;
method.c:    new_linfo->specTypes = types;
method.c:    new_linfo->sparam_vals = sp;
method.c:    for (j = 1; j < m->nargs && j <= sizeof(m->nospecialize) * 8; j++) {
method.c:        jl_value_t *ai = jl_array_ptr_ref(src->slotnames, j);
method.c:            //int sn = j-1;
method.c:            //m->nospecialize |= (1 << sn);
method.c:            if (jl_array_uint8_ref(src->slotflags, j) & 64)
method.c:                called |= (1 << (j - 1));
method.c:    m->called = called;
method.c:    m->pure = src->pure;
method.c:    m->constprop = src->constprop;
method.c:    jl_add_function_name_to_lineinfo(src, (jl_value_t*)m->name);
method.c:    jl_svec_t *sparam_vars = jl_outer_unionall_vars(m->sig);
method.c:    assert(jl_typeis(src->code, jl_array_any_type));
method.c:    jl_array_t *stmts = (jl_array_t*)src->code;
method.c:        if (jl_is_expr(st) && ((jl_expr_t*)st)->head == jl_meta_sym) {
method.c:                    m->nospecialize = -1;
method.c:                    int sn = (int)jl_slot_number(aj) - 2;
method.c:                    if (sn > (m->nargs - 2)) {
method.c:                        jl_error("@nospecialize annotation applied to a non-argument");
method.c:                    if (sn >= sizeof(m->nospecialize) * 8) {
method.c:                                  (int)(sizeof(m->nospecialize) * 8));
method.c:                    m->nospecialize |= (1 << sn);
method.c:                    m->nospecialize = 0;
method.c:                m->generator = NULL;
method.c:                    if (jl_get_global(m->module, (jl_sym_t*)funcname) != NULL) {
method.c:                        m->generator = jl_toplevel_eval(m->module, gexpr);
method.c:                        jl_gc_wb(m, m->generator);
method.c:                if (m->generator == NULL) {
method.c:                m->nkw = jl_unbox_long(jl_exprarg(st, 1));
method.c:            st = resolve_globals(st, m->module, sparam_vars, 1, 0);
method.c:    src->code = copy;
method.c:    m->slot_syms = jl_compress_argnames(src->slotnames);
method.c:    jl_gc_wb(m, m->slot_syms);
method.c:        m->source = NULL;
method.c:        m->source = (jl_value_t*)jl_compress_ir(m, src);
method.c:    jl_gc_wb(m, m->source);
method.c:        (jl_method_t*)jl_gc_alloc(ct->ptls, sizeof(jl_method_t), jl_method_type);
method.c:    jl_atomic_store_relaxed(&m->specializations, jl_emptysvec);
method.c:    jl_atomic_store_relaxed(&m->speckeyset, (jl_array_t*)jl_an_empty_vec_any);
method.c:    m->sig = NULL;
method.c:    m->slot_syms = NULL;
method.c:    m->roots = NULL;
method.c:    m->ccallable = NULL;
method.c:    m->module = module;
method.c:    m->external_mt = NULL;
method.c:    m->source = NULL;
method.c:    jl_atomic_store_relaxed(&m->unspecialized, NULL);
method.c:    m->generator = NULL;
method.c:    m->name = NULL;
method.c:    m->file = jl_empty_sym;
method.c:    m->line = 0;
method.c:    m->called = 0xff;
method.c:    m->nospecialize = module->nospecialize;
method.c:    m->nkw = 0;
method.c:    jl_atomic_store_relaxed(&m->invokes, NULL);
method.c:    m->recursion_relation = NULL;
method.c:    m->isva = 0;
method.c:    m->nargs = 0;
method.c:    m->primary_world = 1;
method.c:    m->deleted_world = ~(size_t)0;
method.c:    m->is_for_opaque_closure = 0;
method.c:    m->constprop = 0;
method.c:    JL_MUTEX_INIT(&m->writelock);
method.c:// method definition ----------------------------------------------------------
method.c:    m->sig = (jl_value_t*)jl_anytuple_type;
method.c:    // Unused for opaque closures. va-ness is determined on construction
method.c:    m->isva = 0;
method.c:    m->is_for_opaque_closure = 1;
method.c:        m->name = jl_symbol("opaque closure");
method.c:        m->name = (jl_sym_t*)name;
method.c:    m->nargs = jl_unbox_long(nargs) + 1;
method.c:    m->file = jl_is_symbol(file) ? (jl_sym_t*)file : jl_empty_sym;
method.c:    m->line = jl_linenode_line(functionloc);
method.c:    if (bnd && jl_atomic_load_relaxed(&bnd->value) != NULL && !bnd->constp)
method.c:        jl_errorf("cannot define function %s; it already has a value", jl_symbol_name(bnd->name));
method.c:        bnd->constp = 1;
method.c:            jl_methtable_t *mt = ((jl_datatype_t*)a)->name->mt;
method.c:        return first_methtable(((jl_tvar_t*)a)->ub, got_tuple1);
method.c:        return first_methtable(((jl_unionall_t*)a)->body, got_tuple1);
method.c:        jl_methtable_t *m1 = first_methtable(u->a, got_tuple1);
method.c:            jl_methtable_t *m2 = first_methtable(u->b, got_tuple1);
method.c:    return method->external_mt ? (jl_methtable_t*)method->external_mt : jl_method_table_for(method->sig);
method.c:    int isva = jl_is_vararg(jl_svecref(atypes, nargs - 1));
method.c:    for (i = jl_svec_len(tvars); i > 0; i--) {
method.c:        jl_value_t *tv = jl_svecref(tvars, i - 1);
method.c:    if (mt->frozen)
method.c:    name = mt->name;
method.c:            name = dt->name->name;
method.c:                    name = dt->name->name;
method.c:        // this occurs when there is a closure being added to an out-of-scope function
method.c:    m->external_mt = (jl_value_t*)external_mt;
method.c:    m->sig = argtype;
method.c:    m->name = name;
method.c:    m->isva = isva;
method.c:    m->nargs = nargs;
method.c:    m->file = jl_is_symbol(file) ? (jl_sym_t*)file : jl_empty_sym;
method.c:    m->line = jl_linenode_line(functionloc);
method.c:                      jl_symbol_name(m->file),
method.c:                      m->line);
method.c:            jl_sym_t *argname = (jl_sym_t*)jl_array_ptr_ref(f->slotnames, i);
method.c:                              jl_symbol_name(m->file),
method.c:                              m->line);
method.c:                              jl_symbol_name(m->file),
method.c:                              m->line);
method.c:        if (jl_is_vararg(elt) && i < na-1)
method.c:                          "Vararg on non-final argument in method definition for %s at %s:%d",
method.c:                          jl_symbol_name(m->file),
method.c:                          m->line);
method.c:        while (jl_array_len(jl_all_methods) < m->primary_world)
jlfrontend.scm:(load "julia-parser.scm")
jlfrontend.scm:(load "julia-syntax.scm")
jlfrontend.scm:(define (error-wrap thk)
jlfrontend.scm:  (with-exception-catcher
jlfrontend.scm:     (if (and (pair? e) (memq (car e) '(error io-error)))
jlfrontend.scm:           (if (and (string? msg) (>= (string-length msg) (string-length pfx))
jlfrontend.scm:                            (substring msg 0 (string-length pfx))))
jlfrontend.scm:           ;;(print-stack-trace (stacktrace))
jlfrontend.scm:(define (defined-julia-global v) #f)
jlfrontend.scm:(define (julia-current-file) 'none)
jlfrontend.scm:(define (julia-current-line) 0)
jlfrontend.scm:(define (jl-parse-one str filename pos0 greedy)
jlfrontend.scm:  (let ((inp (open-input-string str)))
jlfrontend.scm:    (with-bindings ((current-filename (symbol filename)))
jlfrontend.scm:     (let ((expr (error-wrap (lambda ()
jlfrontend.scm:                                   (julia-parse inp parse-stmts)
jlfrontend.scm:                                   (julia-parse inp parse-atom))))))
jlfrontend.scm:(define (parse-all- io filename)
jlfrontend.scm:  (unwind-protect
jlfrontend.scm:   (with-bindings ((current-filename (symbol filename)))
jlfrontend.scm:    (let ((stream (make-token-stream io)))
jlfrontend.scm:        (let ((lineno (error-wrap
jlfrontend.scm:                         (skip-ws-and-comments io)
jlfrontend.scm:                         (input-port-line io)))))
jlfrontend.scm:                                     `(line ,(input-port-line io) ,current-filename)
jlfrontend.scm:              (let ((expr (error-wrap
jlfrontend.scm:                             (julia-parse stream)))))
jlfrontend.scm:                (if (eof-object? expr)
jlfrontend.scm:                           (lineno (if iserr (input-port-line io) lineno))
jlfrontend.scm:                                          `(line ,lineno ,current-filename)
jlfrontend.scm:(define (jl-parse-all str filename)
jlfrontend.scm:  (parse-all- (open-input-string str) filename))
jlfrontend.scm:(define (jl-parse-file filename)
jlfrontend.scm:   (parse-all- (open-input-file filename) filename)
jlfrontend.scm:;; return a lambda expression representing a thunk for a top-level expression
jlfrontend.scm:(define (expand-toplevel-expr-- e file line)
jlfrontend.scm:  (let ((ex0 (julia-expand-macroscope e)))
jlfrontend.scm:    (if (toplevel-only-expr? ex0)
jlfrontend.scm:        (let* ((ex (julia-expand0 ex0 file line))
jlfrontend.scm:               (th (julia-expand1
jlfrontend.scm:                             (scope-block
jlfrontend.scm:                        ;; 1-element body might be `return` or `goto` (issue #33227)
jlfrontend.scm:                              (simple-atom? retval)))))
jlfrontend.scm:(define (toplevel-only-expr? e)
jlfrontend.scm:(define *in-expand* #f)
jlfrontend.scm:(define (expand-toplevel-expr e file line)
jlfrontend.scm:  (cond ((or (atom? e) (toplevel-only-expr? e))
jlfrontend.scm:         (if (underscore-symbol? e)
jlfrontend.scm:             (error "all-underscore identifier used as rvalue"))
jlfrontend.scm:         (let ((last *in-expand*))
jlfrontend.scm:               (begin (reset-gensyms)
jlfrontend.scm:                      (set! *in-expand* #t)))
jlfrontend.scm:           (begin0 (expand-toplevel-expr-- e file line)
jlfrontend.scm:                   (set! *in-expand* last))))))
jlfrontend.scm:(define lowering-warning (lambda lst (void)))
jlfrontend.scm:(define (expand-to-thunk- expr file line)
jlfrontend.scm:  (error-wrap (lambda ()
jlfrontend.scm:                (expand-toplevel-expr expr file line))))
jlfrontend.scm:(define (expand-to-thunk-stmt- expr file line)
jlfrontend.scm:  (expand-to-thunk- (if (toplevel-only-expr? expr)
jlfrontend.scm:(define (jl-expand-to-thunk-warn expr file line stmt)
jlfrontend.scm:    (with-bindings
jlfrontend.scm:     ((lowering-warning (lambda lst (set! warnings (cons lst warnings)))))
jlfrontend.scm:          (expand-to-thunk-stmt- expr file line)
jlfrontend.scm:          (expand-to-thunk- expr file line))
jlfrontend.scm:      (for-each (lambda (args) (apply julia-logmsg args))
jlfrontend.scm:(define (jl-expand-to-thunk expr file line)
jlfrontend.scm:  (expand-to-thunk- expr file line))
jlfrontend.scm:(define (jl-expand-to-thunk-stmt expr file line)
jlfrontend.scm:  (expand-to-thunk-stmt- expr file line))
jlfrontend.scm:(define (jl-expand-macroscope expr)
jlfrontend.scm:  (error-wrap (lambda ()
jlfrontend.scm:                (julia-expand-macroscope expr))))
jlfrontend.scm:;; construct default definitions of `eval` for non-bare modules
jlfrontend.scm:(define (module-default-defs e)
jlfrontend.scm:  (jl-expand-to-thunk
jlfrontend.scm:  (expand-toplevel-expr (julia-parse str) 'none 0))
jlfrontend.scm:(define (profile-e s)
jlfrontend.scm:  (with-exception-catcher
jlfrontend.scm:; --- logging ---
jlfrontend.scm:(define (deprecation-message msg lno)
jlfrontend.scm:  (let* ((lf (extract-line-file lno)) (line (car lf)) (file (cadr lf)))
jlfrontend.scm:    (frontend-depwarn msg file line)))
jlfrontend.scm:(define (syntax-deprecation what instead lno)
jlfrontend.scm:  (let* ((lf (extract-line-file lno)) (line (car lf)) (file (cadr lf)))
jlfrontend.scm:    (deprecation-message (format-syntax-deprecation what instead file line #f) lno)))
jlfrontend.scm:(define (extract-line-file lno)
jlfrontend.scm:(define (format-loc lno)
jlfrontend.scm:  (let* ((lf (extract-line-file lno)) (line (car lf)) (file (cadr lf)))
jlfrontend.scm:    (format-file-line file line #f)))
jlfrontend.scm:(define (format-file-line file line exactloc)
jlfrontend.scm:(define (format-syntax-deprecation what instead file line exactloc)
jlfrontend.scm:          (format-file-line file line exactloc)
jlfrontend.scm:(define *scopewarn-opt* 1)
jlfrontend.scm:; Corresponds to --depwarn 0="no", 1="yes", 2="error"
jlfrontend.scm:(define *depwarn-opt* 1)
jlfrontend.scm:(define (frontend-depwarn msg file line)
jlfrontend.scm:  (case *depwarn-opt*
jlfrontend.scm:    (1 (julia-logmsg 1000 'depwarn (symbol (string file line)) file line msg))
rtutils.c:// exceptions -----------------------------------------------------------------
rtutils.c:    // values in v are expected to already be gc-rooted
rtutils.c:    // data is expected to be gc-safe (either gc-rooted, or alloca)
rtutils.c:    // vt is expected to be gc-rooted (in a linfo-root probably)
rtutils.c:// exceptions -----------------------------------------------------------------
rtutils.c:    eh->prev = ct->eh;
rtutils.c:    eh->gcstack = ct->gcstack;
rtutils.c:    eh->gc_state = jl_atomic_load_relaxed(&ct->ptls->gc_state);
rtutils.c:    eh->locks_len = ct->ptls->locks.len;
rtutils.c:    eh->defer_signal = ct->ptls->defer_signal;
rtutils.c:    eh->world_age = ct->world_age;
rtutils.c:    ct->eh = eh;
rtutils.c:    eh->timing_stack = ct->ptls->timing_stack;
rtutils.c:    if (ct->ptls->needs_resetstkoflw) {
rtutils.c:        ct->ptls->needs_resetstkoflw = 0;
rtutils.c:    // `eh` may be not equal to `ct->eh`. See `jl_pop_handler`
rtutils.c:    sig_atomic_t old_defer_signal = ct->ptls->defer_signal;
rtutils.c:    int8_t old_gc_state = jl_atomic_load_relaxed(&ct->ptls->gc_state);
rtutils.c:    ct->eh = eh->prev;
rtutils.c:    ct->gcstack = eh->gcstack;
rtutils.c:    small_arraylist_t *locks = &ct->ptls->locks;
rtutils.c:    int unlocks = locks->len > eh->locks_len;
rtutils.c:        for (size_t i = locks->len; i > eh->locks_len; i--)
rtutils.c:            jl_mutex_unlock_nogc((jl_mutex_t*)locks->items[i - 1]);
rtutils.c:        locks->len = eh->locks_len;
rtutils.c:    ct->world_age = eh->world_age;
rtutils.c:    ct->ptls->defer_signal = eh->defer_signal;
rtutils.c:    if (old_gc_state != eh->gc_state) {
rtutils.c:        jl_atomic_store_release(&ct->ptls->gc_state, eh->gc_state);
rtutils.c:            jl_gc_safepoint_(ct->ptls);
rtutils.c:    if (old_defer_signal && !eh->defer_signal) {
rtutils.c:        jl_sigint_safepoint(ct->ptls);
rtutils.c:    if (jl_gc_have_pending_finalizers && unlocks && eh->locks_len == 0) {
rtutils.c:    jl_handler_t *eh = ct->eh;
rtutils.c:    while (--n > 0)
rtutils.c:        eh = eh->prev;
rtutils.c:    jl_excstack_t *s = ct->excstack;
rtutils.c:    return s ? s->top : 0;
rtutils.c:    jl_excstack_t *s = ct->excstack;
rtutils.c:        assert(s->top >= state);
rtutils.c:        s->top = state;
rtutils.c:    assert(dest->reserved_size >= src->top);
rtutils.c:    memcpy(jl_excstack_raw(dest), jl_excstack_raw(src), sizeof(jl_bt_element_t)*src->top);
rtutils.c:    dest->top = src->top;
rtutils.c:    if (s && s->reserved_size >= reserved_size)
rtutils.c:    jl_excstack_t *new_s = (jl_excstack_t*)jl_gc_alloc_buf(ct->ptls, bufsz);
rtutils.c:    new_s->top = 0;
rtutils.c:    new_s->reserved_size = reserved_size;
rtutils.c:    jl_reserve_excstack(stack, (*stack ? (*stack)->top : 0) + bt_size + 2);
rtutils.c:    memcpy(rawstack + s->top, bt_data, sizeof(jl_bt_element_t)*bt_size);
rtutils.c:    s->top += bt_size + 2;
rtutils.c:    rawstack[s->top-2].uintptr = bt_size;
rtutils.c:    rawstack[s->top-1].jlvalue = exception;
rtutils.c:// conversion -----------------------------------------------------------------
rtutils.c:    return a->data;
rtutils.c:    if (!st->name->mutabl)
rtutils.c:        jl_errorf("setfield!: immutable struct of type %s cannot be changed", jl_symbol_name(st->name->name));
rtutils.c:// parsing --------------------------------------------------------------------
rtutils.c:    if (errno==ERANGE && (out==0 || out==HUGE_VAL || out==-HUGE_VAL)) {
rtutils.c:// MSVC pre-2013 did not define HUGE_VALF
rtutils.c:    if (errno==ERANGE && (out==0 || out==HUGE_VALF || out==-HUGE_VALF)) {
rtutils.c:// showing --------------------------------------------------------------------
rtutils.c:    return stdout_obj ? stdout_obj->value : NULL;
rtutils.c:    return stderr_obj ? stderr_obj->value : NULL;
rtutils.c:// toys for debugging ---------------------------------------------------------
rtutils.c:        if (i != len-1)
rtutils.c:        return first_arg_datatype(((jl_tvar_t*)a)->ub, got_tuple1);
rtutils.c:        return first_arg_datatype(((jl_unionall_t*)a)->body, got_tuple1);
rtutils.c:        jl_datatype_t *d1 = first_arg_datatype(u->a, got_tuple1);
rtutils.c:        jl_datatype_t *d2 = first_arg_datatype(u->b, got_tuple1);
rtutils.c:        if (d2 == NULL || d1->name != d2->name)
rtutils.c:    jl_sym_t *globname = dv->name->mt != NULL ? dv->name->mt->name : NULL;
rtutils.c:        !strchr(jl_symbol_name(globname), '@') && dv->name->module &&
rtutils.c:        jl_binding_resolved_p(dv->name->module, globname)) {
rtutils.c:        jl_binding_t *b = jl_get_module_binding(dv->name->module, globname);
rtutils.c:        if (b && b->value && (b->value == v || jl_typeof(b->value) == v)) {
rtutils.c:        vt = vt->super;
rtutils.c:        n += jl_static_show_func_sig(out, m->sig);
rtutils.c:        if (jl_is_method(li->def.method)) {
rtutils.c:            n += jl_static_show_func_sig(out, li->specTypes);
rtutils.c:            n += jl_static_show_func_sig(out, li->def.method->sig);
rtutils.c:            n += jl_static_show_x(out, (jl_value_t*)li->def.module, depth);
rtutils.c:            n += jl_printf(out, ".<toplevel thunk> -> ");
rtutils.c:            n += jl_static_show_x(out, li->uninferred, depth);
rtutils.c:        n += jl_static_show_x(out, jl_unwrap_unionall(((jl_typename_t*)v)->wrapper), depth);
rtutils.c:        if (vm->T) {
rtutils.c:            n += jl_static_show_x(out, vm->T, depth);
rtutils.c:            if (vm->N) {
rtutils.c:                n += jl_static_show_x(out, vm->N, depth);
rtutils.c:        jl_sym_t *sym = globfunc ? globname : dv->name->name;
rtutils.c:        if (jl_core_module && (dv->name->module != jl_core_module || !jl_module_exports_p(jl_core_module, sym))) {
rtutils.c:            n += jl_static_show_x(out, (jl_value_t*)dv->name->module, depth);
rtutils.c:        if (dv->parameters && (jl_value_t*)dv != dv->name->wrapper &&
rtutils.c:                    if (j != tlen-1)
rtutils.c:            else if (dv->name == jl_tuple_typename) {
rtutils.c:            // tail-recurse on b to flatten the printing of the Union structure in the common case
rtutils.c:            n += jl_static_show_x(out, ((jl_uniontype_t*)v)->a, depth);
rtutils.c:            v = ((jl_uniontype_t*)v)->b;
rtutils.c:        n += jl_static_show_x(out, ua->body, depth);
rtutils.c:        n += jl_static_show_x(out, (jl_value_t*)ua->var, depth->prev);
rtutils.c:        n += jl_static_show_x(out, jl_unwrap_unionall(((jl_typename_t*)v)->wrapper), depth);
rtutils.c:        // show type-var bounds only if they aren't going to be printed by UnionAll later
rtutils.c:        for (p = depth; p != NULL; p = p->prev) {
rtutils.c:            if (jl_is_unionall(p->v) && ((jl_unionall_t*)p->v)->var == var) {
rtutils.c:        jl_value_t *lb = var->lb, *ub = var->ub;
rtutils.c:            // show type-var lower bound if it is defined
rtutils.c:        n += jl_static_show_x_sym_escaped(out, var->name);
rtutils.c:            // show type-var upper bound if it is defined, or if we showed the lower bound
rtutils.c:        if (m->parent != m && m->parent != jl_main_module) {
rtutils.c:            n += jl_static_show_x(out, (jl_value_t*)m->parent, depth);
rtutils.c:        n += jl_printf(out, "%s", jl_symbol_name(m->name));
rtutils.c:                       (uintptr_t)((jl_ssavalue_t*)v)->id);
rtutils.c:        if (e->head == jl_assign_sym && jl_array_len(e->args) == 2) {
rtutils.c:            n += jl_printf(out, "Expr(:%s", jl_symbol_name(e->head));
rtutils.c:            size_t i, len = jl_array_len(e->args);
rtutils.c:        if (av->flags.ptrarray) {
rtutils.c:            if (av->flags.ptrarray) {
rtutils.c:                char *ptr = ((char*)av->data) + j * av->elsize;
rtutils.c:            if (j != tlen - 1)
rtutils.c:        jl_sym_t *sym = dv->name->mt->name;
rtutils.c:        if (jl_core_module && (dv->name->module != jl_core_module || !jl_module_exports_p(jl_core_module, sym))) {
rtutils.c:            n += jl_static_show_x(out, (jl_value_t*)dv->name->module, depth);
rtutils.c:            for(int i = nb - 1; i >= 0; --i)
rtutils.c:                        uint8_t sel = ((uint8_t*)fld_ptr)[jl_field_size(vt, i) - 1];
rtutils.c:                else if (i != tlen - 1)
rtutils.c:                n += jl_static_show_next_(out, (jl_value_t*)((jl_typemap_entry_t*)v)->next, v, depth);
rtutils.c:            jl_value_t *m = p->v;
rtutils.c:                    return jl_printf(out, "<typemap reference #%u @-%u ", nid, dist) +
rtutils.c:                           jl_static_show_x(out, (jl_value_t*)((jl_typemap_entry_t*)m)->sig, depth) +
rtutils.c:                jl_value_t *mnext = (jl_value_t*)((jl_typemap_entry_t*)m)->next;
rtutils.c:                jl_value_t *m2 = p->v;
rtutils.c:                    jl_value_t *mnext2 = (jl_value_t*)((jl_typemap_entry_t*)m2)->next;
rtutils.c:        if (p->v == v)
rtutils.c:            return jl_printf(out, "<circular reference @-%u>", dist);
rtutils.c:        p = p->prev;
rtutils.c:            depth[i].prev = i == 0 ? NULL : &depth[i - 1];
rtutils.c:            type = ((jl_unionall_t*)type)->body;
rtutils.c:        depth += nvars - 1;
rtutils.c:    if (jl_nparams(ftype) == 0 || ftype == ((jl_datatype_t*)ftype)->name->wrapper) {
rtutils.c:        n += jl_printf(s, "%s", jl_symbol_name(((jl_datatype_t*)ftype)->name->mt->name));
rtutils.c:        if (i != tl - 1) {
rtutils.c:        depth -= nvars - 1;
rtutils.c:            n += jl_static_show_x(s, (jl_value_t*)tvars->var, first ? NULL : depth);
rtutils.c:            tvars = (jl_unionall_t*)tvars->body;
rtutils.c:        jl_printf((JL_STREAM*)STDERR_FILENO, "\n!!! ERROR in jl_ -- ABORTING !!!\n");
rtutils.c:// logging tools --------------------------------------------------------------
llvm-remove-ni.cpp:#include "llvm-version.h"
llvm-remove-ni.cpp:    auto nistart = dlstr.find("-ni:");
llvm-remove-ni.cpp:        if (dlstr[niend] == '-') {
llvm-remove-ni.cpp:    dlstr.erase(nistart, niend - nistart);
llvm-remove-ni.cpp:          "Remove non-integral address space.",
llvm-remove-ni.cpp:    unwrap(PM)->add(createRemoveNIPass());
signals-unix.c:// Note that this file is `#include`d by "signal-handling.c"
signals-unix.c:#ifdef __APPLE__ // Darwin's mach ports allow signal-free thread management
signals-unix.c:    return (bt_context_t*)&((ucontext64_t*)sigctx)->uc_mcontext64->__ss;
signals-unix.c:    return (bt_context_t*)&ctx->uc_mcontext.arm_r0;
signals-unix.c:    return ctx->uc_mcontext.gregs[REG_RSP];
signals-unix.c:    return ctx->uc_mcontext.gregs[REG_ESP];
signals-unix.c:    return ctx->uc_mcontext.sp;
signals-unix.c:    return ctx->uc_mcontext.arm_sp;
signals-unix.c:    return ctx->uc_mcontext64->__ss.__rsp;
signals-unix.c:    return ctx->uc_mcontext64->__ss.__sp;
signals-unix.c:    return ctx->uc_mcontext.mc_rsp;
signals-unix.c:    return !((char*)ptr < (char*)ptls->signal_stack - jl_page_size ||
signals-unix.c:             (char*)ptr > (char*)ptls->signal_stack + sig_stack_size);
signals-unix.c:    if (!ptls || !ptls->signal_stack) {
signals-unix.c:        rsp = (rsp - 256) & ~(uintptr_t)15; // redzone and re-alignment
signals-unix.c:        rsp = (uintptr_t)ptls->signal_stack + sig_stack_size;
signals-unix.c:    rsp -= sizeof(void*);
signals-unix.c:    ctx->uc_mcontext.gregs[REG_RSP] = rsp;
signals-unix.c:    ctx->uc_mcontext.gregs[REG_RIP] = (uintptr_t)fptr;
signals-unix.c:    rsp -= sizeof(void*);
signals-unix.c:    ctx->uc_mcontext.mc_rsp = rsp;
signals-unix.c:    ctx->uc_mcontext.mc_rip = (uintptr_t)fptr;
signals-unix.c:    rsp -= sizeof(void*);
signals-unix.c:    ctx->uc_mcontext.gregs[REG_ESP] = rsp;
signals-unix.c:    ctx->uc_mcontext.gregs[REG_EIP] = (uintptr_t)fptr;
signals-unix.c:    rsp -= sizeof(void*);
signals-unix.c:    ctx->uc_mcontext.mc_esp = rsp;
signals-unix.c:    ctx->uc_mcontext.mc_eip = (uintptr_t)fptr;
signals-unix.c:    ctx->uc_mcontext.sp = rsp;
signals-unix.c:    ctx->uc_mcontext.regs[29] = 0; // Clear link register (x29)
signals-unix.c:    ctx->uc_mcontext.pc = (uintptr_t)fptr;
signals-unix.c:    uintptr_t cpsr = ctx->uc_mcontext.arm_cpsr;
signals-unix.c:    ctx->uc_mcontext.arm_cpsr = cpsr;
signals-unix.c:    ctx->uc_mcontext.arm_sp = rsp;
signals-unix.c:    ctx->uc_mcontext.arm_lr = 0; // Clear link register
signals-unix.c:    ctx->uc_mcontext.arm_pc = target;
signals-unix.c:    // from a divide-by-zero exception, which is now handled by
signals-unix.c:    rsp -= sizeof(void*);
signals-unix.c:    ctx->uc_mcontext64->__ss.__rsp = rsp;
signals-unix.c:    ctx->uc_mcontext64->__ss.__rip = (uintptr_t)fptr;
signals-unix.c:    ctx->uc_mcontext64->__ss.__sp = rsp;
signals-unix.c:    ctx->uc_mcontext64->__ss.__pc = (uintptr_t)fptr;
signals-unix.c:    ctx->uc_mcontext64->__ss.__lr = 0;
signals-unix.c:#warning "julia: throw-in-context not supported on this platform"
signals-unix.c:    jl_ptls_t ptls = ct->ptls;
signals-unix.c:        ptls->bt_size =
signals-unix.c:            rec_backtrace_ctx(ptls->bt_data, JL_MAX_BT_SIZE, jl_to_bt_context(sigctx),
signals-unix.c:                              ct->gcstack);
signals-unix.c:        ptls->sig_exception = e;
signals-unix.c:    if (ct->copy_stack) {
signals-unix.c:        jl_ptls_t ptls = ct->ptls;
signals-unix.c:        return ((char*)addr > (char*)ptls->stackbase - ptls->stacksize &&
signals-unix.c:                (char*)addr < (char*)ptls->stackbase);
signals-unix.c:    return ((char*)addr > (char*)ct->stkbuf &&
signals-unix.c:            (char*)addr < (char*)ct->stkbuf + ct->bufsz);
signals-unix.c:    // fall-through return to re-execute faulting statement (but without the error handler)
signals-unix.c:#include "signals-mach.c"
signals-unix.c:    return exc_reg_is_write_fault(ctx->uc_mcontext.gregs[REG_ERR]);
signals-unix.c:        (struct linux_aarch64_ctx_header *)ctx->uc_mcontext.__reserved;
signals-unix.c:    while (extra->magic != 0) {
signals-unix.c:        if (extra->magic == linux_esr_magic) {
signals-unix.c:            (((uint8_t*)extra) + extra->size);
signals-unix.c:    return exc_reg_is_write_fault(ctx->uc_mcontext.mc_err);
signals-unix.c:    if (jl_addr_is_safepoint((uintptr_t)info->si_addr)) {
signals-unix.c:        if (jl_atomic_load_relaxed(&ct->tid) != 0)
signals-unix.c:        if (ct->ptls->defer_signal) {
signals-unix.c:    if (is_addr_on_stack(ct, info->si_addr)) { // stack overflow
signals-unix.c:    else if (jl_is_on_sigstack(ct->ptls, info->si_addr, context)) {
signals-unix.c:    else if (sig == SIGSEGV && info->si_code == SEGV_ACCERR && is_write_fault(context)) {  // writing to read-only memory (e.g., mmap)
signals-unix.c:    jl_atomic_store_release(&ptls2->signal_request, 1);
signals-unix.c:    pthread_kill(ptls2->system_id, SIGUSR2);
signals-unix.c:    assert(jl_atomic_load_acquire(&ptls2->signal_request) == 0);
signals-unix.c:    jl_atomic_store_release(&ptls2->signal_request, sig == -1 ? 3 : 1);
signals-unix.c:    assert(jl_atomic_load_acquire(&ptls2->signal_request) == 0);
signals-unix.c:    jl_atomic_store_release(&ptls2->signal_request, 2);
signals-unix.c:    pthread_kill(ptls2->system_id, SIGUSR2);
signals-unix.c:        jl_critical_error(thread0_exit_state - 128, NULL);
signals-unix.c:        ptls2->bt_size = bt_size; // <= JL_MAX_BT_SIZE
signals-unix.c:        memcpy(ptls2->bt_data, bt_data, ptls2->bt_size * sizeof(bt_data[0]));
signals-unix.c:        jl_thread_resume(0, -1);
signals-unix.c:        jl_atomic_store_release(&ptls2->signal_request, 3);
signals-unix.c:        pthread_kill(ptls2->system_id, SIGUSR2);
signals-unix.c:    jl_ptls_t ptls = ct->ptls;
signals-unix.c:    sig_atomic_t request = jl_atomic_exchange(&ptls->signal_request, 0);
signals-unix.c:        request = jl_atomic_exchange(&ptls->signal_request, 0);
signals-unix.c:        if (force || (!ptls->defer_signal && ptls->io_wait)) {
signals-unix.c:        jl_call_in_ctx(ct->ptls, jl_exit_thread0_cb, sig, ctx);
signals-unix.c:// Linux-style
signals-unix.c:    if (timer_create(CLOCK_REALTIME, &sigprof, &timerprof) == -1)
signals-unix.c:        return -2;
signals-unix.c:    if (timer_settime(timerprof, 0, &itsprof, NULL) == -1)
signals-unix.c:        return -3;
signals-unix.c:// BSD-style timers
signals-unix.c:    if (setitimer(ITIMER_PROF, &timerprof, NULL) == -1)
signals-unix.c:        return -3;
signals-unix.c:    ptls->signal_stack = signal_stack;
signals-unix.c:    ss.ss_size = ssize - 16;
signals-unix.c:    if (*sigqueue == -1)
signals-unix.c:        *sigqueue = -1;
signals-unix.c:    if (sigqueue == -1) {
signals-unix.c:        if (sigqueue != -1) {
signals-unix.c:            if (nevents == -1) {
signals-unix.c:                sigqueue = -1;
signals-unix.c:            sig = -1;
signals-unix.c:        if (sig == -1) {
signals-unix.c:        // sample each thread, round-robin style in reverse order
signals-unix.c:        for (int idx = jl_n_threads; idx-- > 0; ) {
signals-unix.c:            // Stop the threads in the random round-robin order.
signals-unix.c:            // this part must be signal-handler safe
signals-unix.c:                        JL_MAX_BT_SIZE / jl_n_threads - 1,
signals-unix.c:                                bt_size_max - bt_size_cur - 1, signal_context, NULL);
signals-unix.c:                    bt_data_prof[bt_size_cur++].uintptr = ptls->tid + 1;
signals-unix.c:                    bt_data_prof[bt_size_cur++].jlvalue = (jl_value_t*)ptls->current_task;
signals-unix.c:                    bt_data_prof[bt_size_cur++].uintptr = jl_atomic_load_relaxed(&ptls->sleep_check_state) + 1;
signals-unix.c:        // and must be thread-safe, but not necessarily signal-handler safe
cgmemmgr.cpp:#include "llvm-version.h"
cgmemmgr.cpp:                     MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
cgmemmgr.cpp:    if (fd == -1)
cgmemmgr.cpp:static intptr_t anon_hdl = -1;
cgmemmgr.cpp:    int fd = -1;
cgmemmgr.cpp:    fd = syscall(__NR_memfd_create, "julia-codegen", 0);
cgmemmgr.cpp:    char shm_name[] = "julia-codegen-0123456789-0123456789/tmp///";
cgmemmgr.cpp:                 "julia-codegen-%d-%d", (int)pid, rand());
cgmemmgr.cpp:             "/tmp/julia-codegen-%d-XXXXXX", (int)pid);
cgmemmgr.cpp:    return -1;
cgmemmgr.cpp:    if (getrlimit(RLIMIT_FSIZE, &rl) != -1) {
cgmemmgr.cpp:    if (anon_hdl == -1)
cgmemmgr.cpp:        return -1;
cgmemmgr.cpp:        // The return value can be -1 when the glibc syscall function
cgmemmgr.cpp:    if (-1 == sscanf(kernel.release, "%d.%d", &major, &minor))
cgmemmgr.cpp:        return -1;
cgmemmgr.cpp:        return -1;
cgmemmgr.cpp:    if (fd == -1)
cgmemmgr.cpp:        return -1;
cgmemmgr.cpp:    if (fd == -1)
cgmemmgr.cpp:        return -1;
cgmemmgr.cpp:                         MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
cgmemmgr.cpp:        return -1;
cgmemmgr.cpp:        if (ret == -1 && (errno == EAGAIN || errno == EINTR))
cgmemmgr.cpp:        size -= ret;
cgmemmgr.cpp:        size_t aligned_avail = avail & (-align);
cgmemmgr.cpp:        char *p = ptr + total - aligned_avail;
cgmemmgr.cpp:        avail = aligned_avail - size;
cgmemmgr.cpp:            uintptr_t first_free = end - avail;
cgmemmgr.cpp:            unmap_page((void*)first_free, end - first_free);
cgmemmgr.cpp:        size_t min_size = (size_t)-1;
cgmemmgr.cpp:        size_t min_size = (size_t)-1;
cgmemmgr.cpp:        return (char*)rt_ptr + (block.wr_ptr - uintptr_t(block.ptr));
cgmemmgr.cpp:        assert(anon_hdl != -1);
cgmemmgr.cpp:        for (auto &block : this->blocks) {
cgmemmgr.cpp:        for (auto &block : this->completed) {
cgmemmgr.cpp:        assert(get_self_mem_fd() != -1);
cgmemmgr.cpp:        for (auto &block : this->blocks) {
cgmemmgr.cpp:        for (auto &block : this->completed) {
cgmemmgr.cpp:        for (auto &alloc : this->allocations) {
cgmemmgr.cpp:        if (!ro_alloc && get_self_mem_fd() != -1) {
cgmemmgr.cpp:        if (!ro_alloc && init_shared_map() != -1) {
cgmemmgr.cpp:        for (auto &alloc: allocator->allocations) {
cgmemmgr.cpp:        for (auto &alloc: allocator->allocations) {
cgmemmgr.cpp:        return (uint8_t*)exe_alloc->alloc(Size, Alignment);
cgmemmgr.cpp:        return (uint8_t*)ro_alloc->alloc(Size, Alignment);
cgmemmgr.cpp:        ro_alloc->finalize();
cgmemmgr.cpp:        exe_alloc->finalize();
cgmemmgr.cpp:    return ((RTDyldMemoryManagerJL*)memmgr)->lookupWriteAddressFor(rt_addr);
cgmemmgr.cpp:    return ((RTDyldMemoryManagerJL*)mm)->getTotalBytes();
Makefile:include $(JULIAHOME)/deps/llvm-ver.make
Makefile:# -I BUILDDIR comes before -I SRCDIR so that the user can override <options.h> on a per-build-directory basis
Makefile:	-D_GNU_SOURCE -I$(BUILDDIR) -I$(SRCDIR) \
Makefile:	-I$(SRCDIR)/flisp -I$(SRCDIR)/support \
Makefile:	-I$(SRCDIR)/dyncall/dyncall \
Makefile:	-I$(LIBUV_INC) -I$(build_includedir) \
Makefile:	-I$(JULIAHOME)/deps/valgrind
Makefile:FLAGS += -Wall -Wno-strict-aliasing -fno-omit-frame-pointer -fvisibility=hidden -fno-common \
Makefile:		 -Wno-comment -Wpointer-arith -Wundef
Makefile:FLAGS += -Wno-unused-result
Makefile:JCFLAGS += -Wold-style-definition -Wstrict-prototypes -Wc++-compat
Makefile:FLAGS += -Wno-return-type-c-linkage
Makefile:FLAGS += -DJL_BUILD_ARCH='"$(ARCH)"'
Makefile:FLAGS += -DJL_BUILD_UNAME='"NT"'
Makefile:FLAGS += -DJL_BUILD_UNAME='"$(OS)"'
Makefile:FLAGS += -I$(LOCALBASE)/include
Makefile:	threading partr stackwalk gc gc-debug gc-pages gc-stacks method \
Makefile:	jlapi signal-handling safepoint timing subtype \
Makefile:	crc32c APInt-C processor ircode opaque_closure codegen-stubs signame
Makefile:CODEGEN_SRCS := codegen llvm-ptls
Makefile:RUNTIME_CODEGEN_SRCS := jitlayers aotcompile debuginfo disasm llvm-simdloop llvm-muladd \
Makefile:	llvm-final-gc-lowering llvm-pass-helpers llvm-late-gc-lowering \
Makefile:	llvm-lower-handlers llvm-gc-invariant-verifier llvm-propagate-addrspaces \
Makefile:	llvm-multiversioning llvm-alloc-opt cgmemmgr llvm-remove-addrspaces \
Makefile:	llvm-remove-ni llvm-julia-licm llvm-demote-float16 staticjit
Makefile:FLAGS += -I$(shell $(LLVM_CONFIG_HOST) --includedir)
Makefile:CG_LLVMLINK += -lPolly -lPollyISL
Makefile:FLAGS += -I$(shell $(LLVM_CONFIG_HOST) --src-root)/tools/polly/include
Makefile:FLAGS += -I$(shell $(LLVM_CONFIG_HOST) --obj-root)/tools/polly/include
Makefile:FLAGS += -DUSE_POLLY
Makefile:FLAGS += -fopenmp
Makefile:CG_LLVMLINK += -lPollyPPCG -lGPURuntime
Makefile:FLAGS += -DUSE_POLLY_ACC
Makefile:FLAGS += -I$(shell $(LLVM_CONFIG_HOST) --src-root)/tools/polly/tools # Required to find GPURuntime/GPUJIT.h
Makefile:LLVM_LDFLAGS := $(shell $(LLVM_CONFIG_HOST) --ldflags)
Makefile:LLVM_CXXFLAGS := $(shell $(LLVM_CONFIG_HOST) --cxxflags)
Makefile:CG_LLVMLINK += $(LLVM_LDFLAGS) $(shell $(LLVM_CONFIG_HOST) --libs --system-libs)
Makefile:# HACK: llvm-config doesn't correctly point to shared libs on all platforms
Makefile:CG_LLVMLINK += $(LLVM_LDFLAGS) $(shell $(LLVM_CONFIG_HOST) --libs $(CG_LLVM_LIBS) --link-static) $($(LLVM_LDFLAGS) $(shell $(LLVM_CONFIG_HOST) --system-libs 2> /dev/null)
Makefile:CG_LLVMLINK += $(LLVM_LDFLAGS) -lLLVM
Makefile:FLAGS += -DLLVM_SHLIB
Makefile:RT_LLVM_LINK_ARGS := $(shell $(LLVM_CONFIG_HOST) --libs $(RT_LLVM_LIBS) --system-libs --link-static)
Makefile:RT_LLVMLINK += -luuid -lole32
Makefile:CLANG_LDFLAGS += -Wl,-undefined,dynamic_lookup
Makefile:COMMON_LIBPATHS := -L$(build_libdir) -L$(build_shlibdir)
Makefile:RT_DEBUG_LIBS := $(COMMON_LIBPATHS) $(WHOLE_ARCHIVE) $(BUILDDIR)/flisp/libflisp-debug.a $(WHOLE_ARCHIVE) $(BUILDDIR)/support/libsupport-debug.a -ljulia-debug $(RT_LIBS)
Makefile:CG_DEBUG_LIBS := $(COMMON_LIBPATHS) $(WHOLE_ARCHIVE) $(WHOLE_ARCHIVE) $(CG_LIBS) -ljulia-debug -ljulia-internal-debug
Makefile:RT_RELEASE_LIBS := $(COMMON_LIBPATHS) $(WHOLE_ARCHIVE) $(BUILDDIR)/flisp/libflisp.a $(WHOLE_ARCHIVE) $(BUILDDIR)/support/libsupport.a -ljulia $(RT_LIBS)
Makefile:CG_RELEASE_LIBS := $(COMMON_LIBPATHS) $(WHOLE_ARCHIVE) $(WHOLE_ARCHIVE) $(CG_LIBS) -ljulia -ljulia-internal
Makefile:DEBUGFLAGS += $(FLAGS) -DLIBRARY_EXPORTS
Makefile:SHIPFLAGS += $(FLAGS) -DLIBRARY_EXPORTS
Makefile:SHIPFLAGS  += "-DJL_SYSTEM_IMAGE_PATH=\"$(build_private_libdir_rel)/sys.$(SHLIB_EXT)\""
Makefile:DEBUGFLAGS += "-DJL_SYSTEM_IMAGE_PATH=\"$(build_private_libdir_rel)/sys-debug.$(SHLIB_EXT)\""
Makefile:SHIPFLAGS  += "-DJL_LIBJULIA_SONAME=\"libjulia.$(JL_MAJOR_SHLIB_EXT)\""       "-DJL_LIBJULIA_INTERNAL_SONAME=\"libjulia-internal.$(JL_MAJOR_SHLIB_EXT)\""
Makefile:DEBUGFLAGS += "-DJL_LIBJULIA_SONAME=\"libjulia-debug.$(JL_MAJOR_SHLIB_EXT)\"" "-DJL_LIBJULIA_INTERNAL_SONAME=\"libjulia-internal-debug.$(JL_MAJOR_SHLIB_EXT)\""
Makefile:FLISP_EXECUTABLE_debug := $(FLISPDIR)/flisp-debug$(BUILD_EXE)
Makefile:FLISP_EXECUTABLE_debug := $(FLISPDIR)/flisp-debug$(EXE)
Makefile:release debug: %: libjulia-internal-% libjulia-codegen-%
Makefile:	mkdir -p $(BUILDDIR)
Makefile:	@$(call PRINT_DTRACE, $(DTRACE) -h -s $< -o $@)
Makefile:	# Generate `.inc` file that contains a list of `#define` macros to rename functions defined in `libjulia-internal`
Makefile:	# to have a `ijl_` prefix instead of `jl_`, to denote that they are coming from `libjulia-internal`.  This avoids
Makefile:	# potential confusion with debugging tools, when inspecting a process that has both `libjulia` and `libjulia-internal`
Makefile:	grep 'XX(.\+)' $< | sed -E 's/.*XX\((.+)\).*/#define \1 i\1/g' >$@
Makefile:	@$(call PRINT_CC, $(CC) $(JCPPFLAGS) $(JCFLAGS) $(SHIPFLAGS) $(DISABLE_ASSERTIONS) -c $< -o $@)
Makefile:	@$(call PRINT_CC, $(CC) $(JCPPFLAGS) $(JCFLAGS) $(DEBUGFLAGS) -c $< -o $@)
Makefile:$(BUILDDIR)/%.o: $(SRCDIR)/%.cpp $(SRCDIR)/llvm-version.h $(HEADERS) $(LLVM_CONFIG_ABSOLUTE) | $(BUILDDIR)
Makefile:	@$(call PRINT_CC, $(CXX) $(LLVM_CXXFLAGS) $(JCPPFLAGS) $(JCXXFLAGS) $(SHIPFLAGS) $(CXX_DISABLE_ASSERTION) -c $< -o $@)
Makefile:$(BUILDDIR)/%.dbg.obj: $(SRCDIR)/%.cpp $(SRCDIR)/llvm-version.h $(HEADERS) $(LLVM_CONFIG_ABSOLUTE) | $(BUILDDIR)
Makefile:	@$(call PRINT_CC, $(CXX) $(LLVM_CXXFLAGS) $(JCPPFLAGS) $(JCXXFLAGS) $(DEBUGFLAGS) -c $< -o $@)
Makefile:	@$(call PRINT_DTRACE, $(DTRACE) -G -s $< -o $@)
Makefile:	@$(call PRINT_DTRACE, $(DTRACE) -G -s $< -o $@)
Makefile:	@$(call PRINT_CC, $(CC) $(JCFLAGS) $(JCPPFLAGS) $(FLAGS) -O3 $< $(fPIC) -shared -o $@.tmp $(LDFLAGS))
Makefile:	$(OBJCOPY) --only-keep-debug $@.tmp $@.debug
Makefile:	$(OBJCOPY) --strip-debug $@.tmp
Makefile:	$(OBJCOPY) --add-gnu-debuglink=$@.debug $@.tmp
Makefile:	@## clang should have made the dSYM split-debug directory,
Makefile:	@## because we want to test the non-default debug configuration
Makefile:	@#rm -r $@.dSYM && mv $@.tmp.dSYM $@.dSYM
Makefile:	@$(call PRINT_CC, $(CXX) $(LLVM_CXXFLAGS) $(FLAGS) $(CPPFLAGS) $(CXXFLAGS) -O3 $< $(fPIC) -shared -o $@ $(LDFLAGS) $(COMMON_LIBPATHS) $(NO_WHOLE_ARCHIVE) $(CG_LLVMLINK)) -lpthread
Makefile:		julia-parser.scm julia-syntax.scm match.scm utils.scm ast.scm macroexpand.scm mk_julia_flisp_boot.scm) \
Makefile:$(BUILDDIR)/codegen-stubs.o $(BUILDDIR)/codegen-stubs.dbg.obj: $(SRCDIR)/intrinsics.h
Makefile:$(BUILDDIR)/gc-debug.o $(BUILDDIR)/gc-debug.dbg.obj: $(SRCDIR)/gc.h
Makefile:$(BUILDDIR)/gc-pages.o $(BUILDDIR)/gc-pages.dbg.obj: $(SRCDIR)/gc.h
Makefile:$(BUILDDIR)/llvm-alloc-opt.o $(BUILDDIR)/llvm-alloc-opt.dbg.obj: $(SRCDIR)/codegen_shared.h $(SRCDIR)/llvm-pass-helpers.h
Makefile:$(BUILDDIR)/llvm-final-gc-lowering.o $(BUILDDIR)/llvm-final-gc-lowering.dbg.obj: $(SRCDIR)/llvm-pass-helpers.h
Makefile:$(BUILDDIR)/llvm-gc-invariant-verifier.o $(BUILDDIR)/llvm-gc-invariant-verifier.dbg.obj: $(SRCDIR)/codegen_shared.h
Makefile:$(BUILDDIR)/llvm-late-gc-lowering.o $(BUILDDIR)/llvm-late-gc-lowering.dbg.obj: $(SRCDIR)/llvm-pass-helpers.h
Makefile:$(BUILDDIR)/llvm-lower-handlers.o $(BUILDDIR)/llvm-lower-handlers.dbg.obj: $(SRCDIR)/codegen_shared.h
Makefile:$(BUILDDIR)/llvm-multiversioning.o $(BUILDDIR)/llvm-multiversioning.dbg.obj: $(SRCDIR)/codegen_shared.h $(SRCDIR)/processor.h
Makefile:$(BUILDDIR)/llvm-pass-helpers.o $(BUILDDIR)/llvm-pass-helpers.dbg.obj: $(SRCDIR)/llvm-pass-helpers.h $(SRCDIR)/codegen_shared.h
Makefile:$(BUILDDIR)/llvm-ptls.o $(BUILDDIR)/llvm-ptls.dbg.obj: $(SRCDIR)/codegen_shared.h
Makefile:$(BUILDDIR)/signal-handling.o $(BUILDDIR)/signal-handling.dbg.obj: $(addprefix $(SRCDIR)/,signals-*.c)
Makefile:$(addprefix $(BUILDDIR)/,APInt-C.o APInt-C.dbg.obj runtime_intrinsics.o runtime_intrinsics.dbg.obj): $(SRCDIR)/APInt-C.h
Makefile:	$(MAKE) -C $(SRCDIR)/support BUILDDIR='$(abspath $(BUILDDIR)/support)'
Makefile:$(BUILDDIR)/support/libsupport-debug.a: $(addprefix $(SRCDIR)/support/,*.h *.c *.S *.inc) $(SRCDIR)/support/*.c
Makefile:	$(MAKE) -C $(SRCDIR)/support debug BUILDDIR='$(abspath $(BUILDDIR)/support)'
Makefile:	$(MAKE) -C $(BUILDDIR)/flisp $(subst $(abspath $(BUILDDIR)/flisp)/,,$(abspath $(FLISP_EXECUTABLE_release)))
Makefile:$(FLISP_EXECUTABLE_debug): $(BUILDDIR)/flisp/libflisp-debug.a
Makefile:	$(MAKE) -C $(BUILDDIR)/flisp $(subst $(abspath $(BUILDDIR)/flisp)/,,$(abspath $(FLISP_EXECUTABLE_debug)))
Makefile:	$(MAKE) -C $(SRCDIR)/flisp BUILDDIR='$(abspath $(BUILDDIR)/flisp)'
Makefile:$(BUILDDIR)/flisp/libflisp-debug.a: $(addprefix $(SRCDIR)/,flisp/*.h flisp/*.c) $(BUILDDIR)/support/libsupport-debug.a
Makefile:	$(MAKE) -C $(SRCDIR)/flisp debug BUILDDIR='$(abspath $(BUILDDIR)/flisp)'
Makefile:	@echo $(JULIA_VERSION) | awk 'BEGIN {FS="[.,-]"} \
Makefile:CXXLD = $(CXX) -shared
Makefile:CXXLD = $(LD) -dll -export:jl_setjmp -export:jl_longjmp
Makefile:$(build_shlibdir)/libjulia-internal.$(JL_MAJOR_MINOR_SHLIB_EXT): $(SRCDIR)/julia.expmap $(OBJS) $(BUILDDIR)/flisp/libflisp.a $(BUILDDIR)/support/libsupport.a $(LIBUV)
Makefile:	@$(call PRINT_LINK, $(CXXLD) $(call IMPLIB_FLAGS,$@) $(JCXXFLAGS) $(CXXLDFLAGS) $(SHIPFLAGS) $(OBJS) $(RPATH_LIB) -o $@ \
Makefile:		$(SRCDIR)/dyncall/dyncall/libdyncall_s.a $(JLDFLAGS) $(JLIBLDFLAGS) $(RT_RELEASE_LIBS) $(call SONAME_FLAGS,libjulia-internal.$(JL_MAJOR_SHLIB_EXT)))
Makefile:	@$(INSTALL_NAME_CMD)libjulia-internal.$(SHLIB_EXT) $@
Makefile:$(build_shlibdir)/libjulia-internal-debug.$(JL_MAJOR_MINOR_SHLIB_EXT): $(SRCDIR)/julia.expmap $(DOBJS) $(BUILDDIR)/flisp/libflisp-debug.a $(BUILDDIR)/support/libsupport-debug.a $(LIBUV)
Makefile:	@$(call PRINT_LINK, $(CXXLD) $(call IMPLIB_FLAGS,$@) $(JCXXFLAGS) $(CXXLDFLAGS) $(DEBUGFLAGS) $(DOBJS) $(RPATH_LIB) -o $@ \
Makefile:		$(SRCDIR)/dyncall/dyncall/libdyncall_s.a  $(JLDFLAGS) $(JLIBLDFLAGS) $(RT_DEBUG_LIBS) $(call SONAME_FLAGS,libjulia-internal-debug.$(JL_MAJOR_SHLIB_EXT)))
Makefile:	@$(INSTALL_NAME_CMD)libjulia-internal-debug.$(SHLIB_EXT) $@
Makefile:$(build_shlibdir)/libjulia-internal.$(JL_MAJOR_SHLIB_EXT) $(build_shlibdir)/libjulia-internal-debug.$(JL_MAJOR_SHLIB_EXT): $(build_shlibdir)/libjulia-internal%.$(JL_MAJOR_SHLIB_EXT): \
Makefile:		$(build_shlibdir)/libjulia-internal%.$(JL_MAJOR_MINOR_SHLIB_EXT)
Makefile:	@$(call PRINT_LINK, ln -sf $(notdir $<) $@)
Makefile:$(build_shlibdir)/libjulia-internal.$(SHLIB_EXT) $(build_shlibdir)/libjulia-internal-debug.$(SHLIB_EXT): $(build_shlibdir)/libjulia-internal%.$(SHLIB_EXT): \
Makefile:		$(build_shlibdir)/libjulia-internal%.$(JL_MAJOR_MINOR_SHLIB_EXT)
Makefile:	@$(call PRINT_LINK, ln -sf $(notdir $<) $@)
Makefile:libjulia-internal-release: $(build_shlibdir)/libjulia-internal.$(JL_MAJOR_SHLIB_EXT) $(build_shlibdir)/libjulia-internal.$(SHLIB_EXT)
Makefile:libjulia-internal-debug: $(build_shlibdir)/libjulia-internal-debug.$(JL_MAJOR_SHLIB_EXT) $(build_shlibdir)/libjulia-internal-debug.$(SHLIB_EXT)
Makefile:libjulia-internal-release: $(build_shlibdir)/libjulia-internal.$(JL_MAJOR_MINOR_SHLIB_EXT)
Makefile:libjulia-internal-debug: $(build_shlibdir)/libjulia-internal-debug.$(JL_MAJOR_MINOR_SHLIB_EXT)
Makefile:libjulia-internal-debug libjulia-internal-release: $(PUBLIC_HEADER_TARGETS)
Makefile:$(build_shlibdir)/libjulia-codegen.$(JL_MAJOR_MINOR_SHLIB_EXT): $(SRCDIR)/julia.expmap $(CODEGEN_OBJS) $(BUILDDIR)/support/libsupport.a $(build_shlibdir)/libjulia-internal.$(JL_MAJOR_MINOR_SHLIB_EXT)
Makefile:	@$(call PRINT_LINK, $(CXXLD) $(call IMPLIB_FLAGS,$@) $(JCXXFLAGS) $(CXXLDFLAGS) $(SHIPFLAGS) $(CODEGEN_OBJS) $(RPATH_LIB) -o $@ \
Makefile:		$(JLDFLAGS) $(JLIBLDFLAGS) $(CG_RELEASE_LIBS) $(call SONAME_FLAGS,libjulia-codegen.$(JL_MAJOR_SHLIB_EXT)))
Makefile:	@$(INSTALL_NAME_CMD)libjulia-codegen.$(SHLIB_EXT) $@
Makefile:$(build_shlibdir)/libjulia-codegen-debug.$(JL_MAJOR_MINOR_SHLIB_EXT): $(SRCDIR)/julia.expmap $(CODEGEN_DOBJS) $(BUILDDIR)/support/libsupport-debug.a $(build_shlibdir)/libjulia-internal-debug.$(JL_MAJOR_MINOR_SHLIB_EXT)
Makefile:	@$(call PRINT_LINK, $(CXXLD) $(call IMPLIB_FLAGS,$@) $(JCXXFLAGS) $(CXXLDFLAGS) $(DEBUGFLAGS) $(CODEGEN_DOBJS) $(RPATH_LIB) -o $@ \
Makefile:		$(JLDFLAGS) $(JLIBLDFLAGS) $(CG_DEBUG_LIBS) $(call SONAME_FLAGS,libjulia-codegen-debug.$(JL_MAJOR_SHLIB_EXT)))
Makefile:	@$(INSTALL_NAME_CMD)libjulia-codegen-debug.$(SHLIB_EXT) $@
Makefile:$(build_shlibdir)/libjulia-codegen.$(JL_MAJOR_SHLIB_EXT) $(build_shlibdir)/libjulia-codegen-debug.$(JL_MAJOR_SHLIB_EXT): $(build_shlibdir)/libjulia-codegen%.$(JL_MAJOR_SHLIB_EXT): \
Makefile:		$(build_shlibdir)/libjulia-codegen%.$(JL_MAJOR_MINOR_SHLIB_EXT)
Makefile:	@$(call PRINT_LINK, ln -sf $(notdir $<) $@)
Makefile:$(build_shlibdir)/libjulia-codegen.$(SHLIB_EXT) $(build_shlibdir)/libjulia-codegen-debug.$(SHLIB_EXT): $(build_shlibdir)/libjulia-codegen%.$(SHLIB_EXT): \
Makefile:		$(build_shlibdir)/libjulia-codegen%.$(JL_MAJOR_MINOR_SHLIB_EXT)
Makefile:	@$(call PRINT_LINK, ln -sf $(notdir $<) $@)
Makefile:libjulia-codegen-release: $(build_shlibdir)/libjulia-codegen.$(JL_MAJOR_SHLIB_EXT) $(build_shlibdir)/libjulia-codegen.$(SHLIB_EXT)
Makefile:libjulia-codegen-debug: $(build_shlibdir)/libjulia-codegen-debug.$(JL_MAJOR_SHLIB_EXT) $(build_shlibdir)/libjulia-codegen-debug.$(SHLIB_EXT)
Makefile:libjulia-codegen-release: $(build_shlibdir)/libjulia-codegen.$(JL_MAJOR_MINOR_SHLIB_EXT)
Makefile:libjulia-codegen-debug: $(build_shlibdir)/libjulia-codegen-debug.$(JL_MAJOR_MINOR_SHLIB_EXT)
Makefile:libjulia-codegen-debug libjulia-codegen-release: $(PUBLIC_HEADER_TARGETS)
Makefile:	-rm -fr $(build_shlibdir)/libjulia-internal* $(build_shlibdir)/libjulia-codegen* $(build_shlibdir)/libccalltest* $(build_shlibdir)/libllvmcalltest*
Makefile:	-rm -f $(BUILDDIR)/julia_flisp.boot $(BUILDDIR)/julia_flisp.boot.inc
Makefile:	-rm -f $(BUILDDIR)/*.dbg.obj $(BUILDDIR)/*.o $(BUILDDIR)/*.dwo $(BUILDDIR)/*.$(SHLIB_EXT) $(BUILDDIR)/*.a
Makefile:	-rm -f $(BUILDDIR)/julia_version.h
Makefile:clean-flisp:
Makefile:	-$(MAKE) -C $(SRCDIR)/flisp clean BUILDDIR='$(abspath $(BUILDDIR)/flisp)'
Makefile:clean-support:
Makefile:	-$(MAKE) -C $(SRCDIR)/support clean BUILDDIR='$(abspath $(BUILDDIR)/support)'
Makefile:cleanall: clean clean-flisp clean-support clean-analyzegc
Makefile:	@$(call PRINT_CC, $(CXX) -g $(fPIC) -shared -o $@ -DCLANG_PLUGIN -I$(build_includedir) -L$(build_libdir) \
Makefile:#   make -C src install-analysis-deps
Makefile:install-analysis-deps:
Makefile:	$(MAKE) -C $(JULIAHOME)/deps install-llvm install-clang install-llvm-tools install-libuv install-utf8proc install-unwind
Makefile:analyzegc-deps-check: $(BUILDDIR)/julia_version.h $(BUILDDIR)/julia_flisp.boot.inc $(BUILDDIR)/jl_internal_funcs.inc
Makefile:clang-sagc-%: $(SRCDIR)/%.c $(build_shlibdir)/libGCCheckerPlugin.$(SHLIB_EXT) .FORCE | analyzegc-deps-check
Makefile:	@$(call PRINT_ANALYZE, $(build_depsbindir)/clang -D__clang_gcanalyzer__ --analyze -Xanalyzer -analyzer-werror -Xanalyzer -analyzer-output=text --analyzer-no-default-checks \
Makefile:		-Xclang -load -Xclang $(build_shlibdir)/libGCCheckerPlugin.$(SHLIB_EXT) -Xclang -analyzer-checker=core$(COMMA)julia.GCChecker \
Makefile:		$(CLANGSA_FLAGS) $(JCPPFLAGS) $(JCFLAGS) $(DEBUGFLAGS) -fcolor-diagnostics -x c $<)
Makefile:clang-sagc-%: $(SRCDIR)/%.cpp $(build_shlibdir)/libGCCheckerPlugin.$(SHLIB_EXT) .FORCE | analyzegc-deps-check
Makefile:	@$(call PRINT_ANALYZE, $(build_depsbindir)/clang -D__clang_gcanalyzer__ --analyze -Xanalyzer -analyzer-werror -Xanalyzer -analyzer-output=text --analyzer-no-default-checks \
Makefile:		-Xclang -load -Xclang $(build_shlibdir)/libGCCheckerPlugin.$(SHLIB_EXT) -Xclang -analyzer-checker=core$(COMMA)julia.GCChecker \
Makefile:		$(CLANGSA_FLAGS) $(CLANGSA_CXXFLAGS) $(LLVM_CXXFLAGS) $(JCPPFLAGS) $(JCXXFLAGS) $(DEBUGFLAGS) -fcolor-diagnostics -x c++ $<)
Makefile:SA_EXCEPTIONS-jloptions.c                   := -Xanalyzer -analyzer-disable-checker=core.NonNullParamChecker,unix.cstring.NullArg
Makefile: # clang doesn't understand that e->vars has the same value in save_env (NULL) and restore_env (assumed non-NULL)
Makefile:SA_EXCEPTIONS-subtype.c                     := -Xanalyzer -analyzer-disable-checker=core.uninitialized.Assign,core.UndefinedBinaryOperatorResult
Makefile:clang-sa-%: $(SRCDIR)/%.c $(build_shlibdir)/libImplicitAtomicsPlugin.$(SHLIB_EXT) .FORCE | analyzegc-deps-check
Makefile:	@$(call PRINT_ANALYZE, $(build_depsbindir)/clang --analyze -Xanalyzer -analyzer-werror -Xanalyzer -analyzer-output=text \
Makefile:		$(if $(findstring $(notdir $<),$(SKIP_IMPLICIT_ATOMICS)),,-Xclang -load -Xclang $(build_shlibdir)/libImplicitAtomicsPlugin.$(SHLIB_EXT) -Xclang -analyzer-checker=julia.ImplicitAtomics) \
Makefile:		-Xanalyzer -analyzer-disable-checker=deadcode.DeadStores \
Makefile:		 --analyzer-no-default-checks  \
Makefile:		$(SA_EXCEPTIONS-$(notdir $<)) \
Makefile:		$(CLANGSA_FLAGS) $(JCPPFLAGS) $(JCFLAGS) $(DEBUGFLAGS) -fcolor-diagnostics -Werror -x c $<)
Makefile:clang-sa-%: $(SRCDIR)/%.cpp $(build_shlibdir)/libImplicitAtomicsPlugin.$(SHLIB_EXT) .FORCE | analyzegc-deps-check
Makefile:	@$(call PRINT_ANALYZE, $(build_depsbindir)/clang --analyze -Xanalyzer -analyzer-werror -Xanalyzer -analyzer-output=text \
Makefile:		$(if $(findstring $(notdir $<),$(SKIP_IMPLICIT_ATOMICS)),,-Xclang -load -Xclang $(build_shlibdir)/libImplicitAtomicsPlugin.$(SHLIB_EXT) -Xclang -analyzer-checker=julia.ImplicitAtomics) \
Makefile:		-Xanalyzer -analyzer-disable-checker=deadcode.DeadStores \
Makefile:		 --analyzer-no-default-checks  \
Makefile:		$(SA_EXCEPTIONS-$(notdir $<)) \
Makefile:		$(CLANGSA_FLAGS) $(CLANGSA_CXXFLAGS) $(LLVM_CXXFLAGS) $(JCPPFLAGS) $(JCXXFLAGS) $(DEBUGFLAGS) -fcolor-diagnostics -Werror -x c++ $<)
Makefile:clang-tidy-%: $(SRCDIR)/%.c $(build_shlibdir)/libImplicitAtomics2Plugin.$(SHLIB_EXT) .FORCE | analyzegc-deps-check
Makefile:	@$(call PRINT_ANALYZE, $(build_depsbindir)/clang-tidy $< -header-filter='.*' --quiet \
Makefile:		-load $(build_shlibdir)/libImplicitAtomics2Plugin.$(SHLIB_EXT) --checks='-clang-analyzer-*$(COMMA)-clang-diagnostic-*$(COMMA)concurrency-implicit-atomics' --warnings-as-errors='*' \
Makefile:		-- $(CLANGSA_FLAGS) $(JCPPFLAGS) $(JCFLAGS) $(DEBUGFLAGS) -fcolor-diagnostics -fno-caret-diagnostics -x c)
Makefile:clang-tidy-%: $(SRCDIR)/%.cpp $(build_shlibdir)/libImplicitAtomics2Plugin.$(SHLIB_EXT) .FORCE | analyzegc-deps-check
Makefile:	@$(call PRINT_ANALYZE, $(build_depsbindir)/clang-tidy $< -header-filter='.*' --quiet \
Makefile:		-load $(build_shlibdir)/libImplicitAtomics2Plugin.$(SHLIB_EXT) --checks='-clang-analyzer-*$(COMMA)-clang-diagnostic-*$(COMMA)concurrency-implicit-atomics' --warnings-as-errors='*' \
Makefile:		-- $(CLANGSA_FLAGS) $(CLANGSA_CXXFLAGS) $(LLVM_CXXFLAGS) $(JCPPFLAGS) $(JCXXFLAGS) $(DEBUGFLAGS) -fcolor-diagnostics --system-header-prefix=llvm -Wno-deprecated-declarations -fno-caret-diagnostics -x c++)
Makefile:tidysrc: $(addprefix clang-tidy-,$(filter-out $(basename $(SKIP_IMPLICIT_ATOMICS)), $(SRCS)))
Makefile:analyzesrc: $(addprefix clang-sa-,$(SRCS))
Makefile:analyzegc: analyzesrc $(addprefix clang-sagc-,$(RUNTIME_SRCS))
Makefile:clean-analyzegc:
Makefile:	rm -f $(build_shlibdir)/libGCCheckerPlugin.$(SHLIB_EXT)
Makefile:	rm -f $(build_shlibdir)/libImplicitAtomicsPlugin.$(SHLIB_EXT)
Makefile:.PHONY: default all debug release clean cleanall clean-* libccalltest libllvmcalltest julia_flisp.boot.inc.phony analyzegc analyzesrc .FORCE
builtins.c:  implementations of built-in functions
builtins.c:// egal and object_id ---------------------------------------------------------
builtins.c:// the function a prologue which saves all the callee-save registers and at
builtins.c:                uint8_t asel = ((uint8_t*)ao)[jl_field_size(dt, f) - 1];
builtins.c:                uint8_t bsel = ((uint8_t*)bo)[jl_field_size(dt, f) - 1];
builtins.c:            else if (ft->layout->first_ptr >= 0) {
builtins.c:                jl_value_t *ptra = ((jl_value_t**)ao)[ft->layout->first_ptr];
builtins.c:                jl_value_t *ptrb = ((jl_value_t**)bo)[ft->layout->first_ptr];
builtins.c:            if (!ft->layout->haspadding) {
builtins.c:                if (!bits_equal(ao, bo, ft->size))
builtins.c:        if (dta->name != dtb->name)
builtins.c:            if (pe->var == (jl_tvar_t*)a)
builtins.c:                return pe->val == b;
builtins.c:            pe = pe->prev;
builtins.c:        if (tvar_names && ua->var->name != ub->var->name)
builtins.c:        if (!(egal_types(ua->var->lb, ub->var->lb, env, tvar_names) && egal_types(ua->var->ub, ub->var->ub, env, tvar_names)))
builtins.c:        jl_typeenv_t e = { ua->var, (jl_value_t*)ub->var, env };
builtins.c:        return egal_types(ua->body, ub->body, &e, tvar_names);
builtins.c:        return egal_types(((jl_uniontype_t*)a)->a, ((jl_uniontype_t*)b)->a, env, tvar_names) &&
builtins.c:            egal_types(((jl_uniontype_t*)a)->b, ((jl_uniontype_t*)b)->b, env, tvar_names);
builtins.c:        jl_value_t *vmaT = vma->T ? vma->T : (jl_value_t*)jl_any_type;
builtins.c:        jl_value_t *vmbT = vmb->T ? vmb->T : (jl_value_t*)jl_any_type;
builtins.c:        if (vma->N && vmb->N)
builtins.c:            return egal_types(vma->N, vmb->N, env, tvar_names);
builtins.c:        return !vma->N && !vmb->N;
builtins.c:    assert(!dt->name->mutabl);
builtins.c:    // warning: a,b may NOT have been gc-rooted by the caller
builtins.c:    // warning: a,b may NOT have been gc-rooted by the caller
builtins.c:        if (dta->name != dtb->name)
builtins.c:        if (dta->name != jl_tuple_typename && (dta->isconcretetype || dtb->isconcretetype))
builtins.c:        return compare_svec(dta->parameters, dtb->parameters);
builtins.c:    if (nf == 0 || !dt->layout->haspadding)
builtins.c:// object_id ------------------------------------------------------------------
builtins.c:            if (pe->var == (jl_tvar_t*)v)
builtins.c:            pe = pe->prev;
builtins.c:                             type_object_id_(((jl_uniontype_t*)v)->a, env)),
builtins.c:                      type_object_id_(((jl_uniontype_t*)v)->b, env));
builtins.c:        uintptr_t h = u->var->name->hash;
builtins.c:        h = bitmix(h, type_object_id_(u->var->lb, env));
builtins.c:        h = bitmix(h, type_object_id_(u->var->ub, env));
builtins.c:        jl_varidx_t e = { u->var, env };
builtins.c:        return bitmix(h, type_object_id_(u->body, &e));
builtins.c:        if (dtv->isconcretetype)
builtins.c:            return dtv->hash;
builtins.c:        uintptr_t h = ~dtv->name->hash;
builtins.c:        jl_value_t *t = vm->T ? vm->T : (jl_value_t*)jl_any_type;
builtins.c:        jl_value_t *n = vm->N ? vm->N : jl_nothing;
builtins.c:        return ((jl_sym_t*)v)->hash;
builtins.c:    assert(!tv->name->mutabl);
builtins.c:    return immut_id_(tv, v, tv->hash);
builtins.c:    if (nf == 0 || (!dt->layout->haspadding && dt->layout->npointers == 0)) {
builtins.c:        // operate element-wise if there are unused bits inside,
builtins.c:                uint8_t sel = ((uint8_t*)vo)[jl_field_size(dt, f) - 1];
builtins.c:            assert(jl_is_datatype(fieldtype) && !fieldtype->name->abstract && !fieldtype->name->mutabl);
builtins.c:            int32_t first_ptr = fieldtype->layout->first_ptr;
builtins.c:        uintptr_t h = ~dtv->name->hash;
builtins.c:        return bitmix(h, hash_svec(dtv->parameters));
builtins.c:    if (dt->name->mutabl)
builtins.c:    return immut_id_(dt, v, dt->hash);
builtins.c:        return ((jl_sym_t*)v)->hash;
builtins.c:        return ((jl_typename_t*)v)->hash;
builtins.c:        if (dtv->isconcretetype)
builtins.c:            return dtv->hash;
builtins.c:// eq hash table --------------------------------------------------------------
builtins.c:// object model and type primitives -------------------------------------------
builtins.c:        if (dx->layout == NULL) {
builtins.c:            if (dx->name->abstract)
builtins.c:                jl_errorf("Abstract type %s does not have a definite size.", jl_symbol_name(dx->name->name));
builtins.c:                jl_errorf("Argument is an incomplete %s type and does not have a definite size.", jl_symbol_name(dx->name->name));
builtins.c:        if (jl_is_layout_opaque(dx->layout))
builtins.c:            jl_errorf("Type %s does not have a definite size.", jl_symbol_name(dx->name->name));
builtins.c:        return jl_box_long(jl_array_len(x) * ((jl_array_t*)x)->elsize);
builtins.c:    assert(!dt->name->abstract);
builtins.c:// apply ----------------------------------------------------------------------
builtins.c:    precount -= 1;
builtins.c:            precount = (precount > al) ? precount - al : 0;
builtins.c:            precount = (precount > al) ? precount - al : 0;
builtins.c:                    jl_gc_wb(arg_heap, newargs[n - 1]);
builtins.c:            precount = (precount > al) ? precount - al : 0;
builtins.c:            if (aai->flags.ptrarray) {
builtins.c:                        jl_gc_wb(arg_heap, newargs[n - 1]);
builtins.c:            extra -= 1;
builtins.c:        ((void**)roots)[-2] = (void*)JL_GC_ENCODE_PUSHARGS(1);
builtins.c:    return do_apply(args + 1, nargs - 1, args[0]);
builtins.c:// this is like `_apply`, but with quasi-exact checks to make sure it is pure
builtins.c:    int last_in = ct->ptls->in_pure_callback;
builtins.c:        ct->ptls->in_pure_callback = 1;
builtins.c:        size_t last_age = ct->world_age;
builtins.c:        ct->world_age = jl_world_counter;
builtins.c:        ct->world_age = last_age;
builtins.c:        ct->ptls->in_pure_callback = last_in;
builtins.c:        ct->ptls->in_pure_callback = last_in;
builtins.c:    size_t last_age = ct->world_age;
builtins.c:    if (!ct->ptls->in_pure_callback)
builtins.c:        ct->world_age = jl_world_counter;
builtins.c:    ct->world_age = last_age;
builtins.c:    size_t last_age = ct->world_age;
builtins.c:    if (!ct->ptls->in_pure_callback)
builtins.c:        ct->world_age = world;
builtins.c:    jl_value_t *ret = jl_apply(&args[1], nargs - 1);
builtins.c:    ct->world_age = last_age;
builtins.c:// tuples ---------------------------------------------------------------------
builtins.c:    if (tt->instance != NULL)
builtins.c:        return tt->instance;
builtins.c:    jl_value_t *jv = jl_gc_alloc(ct->ptls, jl_datatype_size(tt), tt);
builtins.c:// struct operations ------------------------------------------------------------
builtins.c:        if (!st->name->mutabl)
builtins.c:            jl_errorf("%s: immutable struct of type %s cannot be changed", name, jl_symbol_name(st->name->name));
builtins.c:        idx = jl_unbox_long(arg) - 1;
builtins.c:            jl_atomic_error("getfield: non-atomic field cannot be accessed atomically");
builtins.c:            jl_atomic_error("getfield: atomic field cannot be accessed non-atomically");
builtins.c:        jl_atomic_error(isatomic ? "setfield!: atomic field cannot be written non-atomically"
builtins.c:                                 : "setfield!: non-atomic field cannot be written atomically");
builtins.c:        jl_fence(); // `st->[idx]` will have at least relaxed ordering
builtins.c:        jl_atomic_error(isatomic ? "swapfield!: atomic field cannot be written non-atomically"
builtins.c:                                 : "swapfield!: non-atomic field cannot be written atomically");
builtins.c:        jl_atomic_error(isatomic ? "modifyfield!: atomic field cannot be written non-atomically"
builtins.c:                                 : "modifyfield!: non-atomic field cannot be written atomically");
builtins.c:        jl_atomic_error(isatomic ? "replacefield!: atomic field cannot be written non-atomically"
builtins.c:                                 : "replacefield!: non-atomic field cannot be written atomically");
builtins.c:        jl_atomic_error(isatomic ? "replacefield!: atomic field cannot be accessed non-atomically"
builtins.c:                                 : "replacefield!: non-atomic field cannot be accessed atomically");
builtins.c:        u = get_fieldtype(((jl_unionall_t*)t)->body, f, dothrow);
builtins.c:        u = jl_type_unionall(((jl_unionall_t*)t)->var, u);
builtins.c:        u[0] = get_fieldtype(((jl_uniontype_t*)t)->a, f, 0);
builtins.c:        u[1] = get_fieldtype(((jl_uniontype_t*)t)->b, f, 0);
builtins.c:            get_fieldtype(((jl_uniontype_t*)t)->a, f, 1);
builtins.c:            get_fieldtype(((jl_uniontype_t*)t)->b, f, 1);
builtins.c:        field_index = jl_unbox_long(f) - 1;
builtins.c:        if (field_index == -1)
builtins.c:    if (st->name == jl_namedtuple_typename) {
builtins.c:            tt = ((jl_tvar_t*)tt)->ub;
builtins.c:    if (nf > 0 && field_index >= nf-1 && st->name == jl_tuple_typename) {
builtins.c:        jl_value_t *ft = jl_field_type(st, nf-1);
builtins.c:        idx = jl_unbox_long(args[1]) - 1;
builtins.c:        if ((int)idx == -1) {
builtins.c:        jl_atomic_error("isdefined: non-atomic field cannot be accessed atomically");
builtins.c:        jl_atomic_error("isdefined: atomic field cannot be accessed non-atomically");
builtins.c:// apply_type -----------------------------------------------------------------
builtins.c:            // https://github.com/JuliaLang/julia/commit/85f45974a581ab9af955bac600b90d9ab00f093b#commitcomment-13041922
builtins.c:                if (i != nargs-1)
builtins.c:                    jl_type_error_rt("Tuple", "non-final parameter", (jl_value_t*)jl_type_type, pi);
builtins.c:        return (jl_value_t*)jl_apply_tuple_type_v(&args[1], nargs-1);
builtins.c:        return (jl_value_t*)jl_type_union(&args[1], nargs-1);
builtins.c:        if (!vm->T) {
builtins.c:        else if (!vm->N) {
builtins.c:            return (jl_value_t*)jl_wrap_vararg(vm->T, args[1]);
builtins.c:        return jl_apply_type(args[0], &args[1], nargs-1);
builtins.c:// generic function reflection ------------------------------------------------
builtins.c:    size_t world = jl_current_task->world_age;
builtins.c:    if (!jl_tuple_isa(&args[2], nargs - 2, (jl_datatype_t*)argtypes))
builtins.c:    jl_value_t *res = jl_gf_invoke(argtypes, args[0], &args[2], nargs - 1);
builtins.c:                types[i] = jl_tparam(argtypes, i - 2);
builtins.c:                jl_svecset(types, i, jl_tparam(argtypes, i - 2));
builtins.c:// Expr constructor for internal use ------------------------------------------
builtins.c:    jl_expr_t *ex = (jl_expr_t*)jl_gc_alloc(ct->ptls, sizeof(jl_expr_t),
builtins.c:    ex->head = head;
builtins.c:    ex->args = ar;
builtins.c:    jl_array_t *ar = jl_alloc_vec_any(nargs-1);
builtins.c:    for(size_t i=0; i < nargs-1; i++)
builtins.c:    jl_expr_t *ex = (jl_expr_t*)jl_gc_alloc(ct->ptls, sizeof(jl_expr_t),
builtins.c:    ex->head = (jl_sym_t*)args[0];
builtins.c:    ex->args = ar;
builtins.c:    jl_tvar_t *tv = (jl_tvar_t *)jl_gc_alloc(ct->ptls, sizeof(jl_tvar_t), jl_tvar_type);
builtins.c:    tv->name = name;
builtins.c:    tv->lb = lb;
builtins.c:    tv->ub = ub;
builtins.c:// arrays ---------------------------------------------------------------------
builtins.c:    return jl_box_long((&a->nrows)[dno-1]);
builtins.c:        size_t ii = jl_unbox_long(args[k]) - 1;
builtins.c:        if (k < nidxs - 1 && ii >= d)
builtins.c:    size_t i = array_nd_index(a, &args[2], nargs - 2, "arrayref");
builtins.c:    size_t i = array_nd_index(a, &args[3], nargs - 3, "arrayset");
builtins.c:// type definition ------------------------------------------------------------
builtins.c:    return dt->name->wrapper;
builtins.c:    return dt->name->wrapper;
builtins.c:    return dt->name->wrapper;
builtins.c:        tt->super != NULL ||
builtins.c:        tt->name == ((jl_datatype_t*)super)->name ||
builtins.c:                  jl_symbol_name(tt->name->name));
builtins.c:    tt->super = (jl_datatype_t*)super;
builtins.c:    jl_gc_wb(tt, tt->super);
builtins.c:// syntax-enforced restrictions) is via being passed as a type parameter. Thus
builtins.c:        return references_name(((jl_uniontype_t*)p)->a, name, affects_layout) ||
builtins.c:               references_name(((jl_uniontype_t*)p)->b, name, affects_layout);
builtins.c:        return references_name((jl_value_t*)((jl_unionall_t*)p)->var->lb, name, 0) ||
builtins.c:               references_name((jl_value_t*)((jl_unionall_t*)p)->var->ub, name, 0) ||
builtins.c:               references_name(((jl_unionall_t*)p)->body, name, affects_layout);
builtins.c:        if (affects_layout && dp->name == name)
builtins.c:        affects_layout = ((jl_datatype_t*)jl_unwrap_unionall(dp->name->wrapper))->layout == NULL;
builtins.c:                jl_type_error_rt(jl_symbol_name(dt->name->name),
builtins.c:        if (dt->types != NULL) {
builtins.c:            if (!equiv_field_types((jl_value_t*)dt->types, ft))
builtins.c:                jl_errorf("invalid redefinition of type %s", jl_symbol_name(dt->name->name));
builtins.c:            dt->types = (jl_svec_t*)ft;
builtins.c:            if (!dt->name->mutabl && (nf == 0 || !references_name((jl_value_t*)dt->super, dt->name, 1))) {
builtins.c:                    if (references_name(fld, dt->name, 1)) {
builtins.c:                dt->name->mayinlinealloc = mayinlinealloc;
builtins.c:        dt->name->partial = NULL;
builtins.c:          dta->name->name == dtb->name->name &&
builtins.c:          dta->name->abstract == dtb->name->abstract &&
builtins.c:          dta->name->mutabl == dtb->name->mutabl &&
builtins.c:          dta->name->n_uninitialized == dtb->name->n_uninitialized &&
builtins.c:          (jl_svec_len(jl_field_names(dta)) != 0 || dta->size == dtb->size) &&
builtins.c:          (dta->name->atomicfields == NULL
builtins.c:           ? dtb->name->atomicfields == NULL
builtins.c:           : (dtb->name->atomicfields != NULL &&
builtins.c:              memcmp(dta->name->atomicfields, dtb->name->atomicfields, (jl_svec_len(dta->name->names) + 31) / 32 * sizeof(uint32_t)) == 0)) &&
builtins.c:    a = jl_rewrap_unionall((jl_value_t*)dta->super, dta->name->wrapper);
builtins.c:    b = jl_rewrap_unionall((jl_value_t*)dtb->super, dtb->name->wrapper);
builtins.c:        a = jl_apply_type(dtb->name->wrapper, jl_svec_data(dta->parameters), jl_nparams(dta));
builtins.c:    a = dta->name->wrapper;
builtins.c:    b = dtb->name->wrapper;
builtins.c:        if (!jl_types_egal(ua->var->lb, ub->var->lb) || !jl_types_egal(ua->var->ub, ub->var->ub) ||
builtins.c:            ua->var->name != ub->var->name)
builtins.c:        a = jl_instantiate_unionall(ua, (jl_value_t*)ub->var);
builtins.c:        b = ub->body;
builtins.c:// IntrinsicFunctions ---------------------------------------------------------
builtins.c:// init -----------------------------------------------------------------------
builtins.c:    inm->parent = jl_core_module;
builtins.c:    jl_typemap_entry_t *entry = (jl_typemap_entry_t*)jl_atomic_load_relaxed(&jl_gf_mtable(b)->cache);
builtins.c:    jl_code_instance_t *ci = jl_atomic_load_relaxed(&entry->func.linfo->cache);
builtins.c:    return jl_atomic_load_relaxed(&ci->specptr.fptr1);
builtins.c:    return jl_mk_builtin_func(NULL, name, fptr)->instance;
builtins.c:    jl_typename_t *itn = ((jl_datatype_t*)jl_typeof(jl_builtin_invoke))->name;
builtins.c:    jl_value_t *ikws = jl_new_generic_function_with_supertype(itn->name, jl_core_module, jl_builtin_type);
builtins.c:    itn->mt->kwsorter = ikws;
builtins.c:    jl_gc_wb(itn->mt, ikws);
macroexpand.scm:(define splat-token '(__splat__))
macroexpand.scm:(define (bq-expand-arglist lst d)
macroexpand.scm:        (let ((nxt (julia-bq-expand- (car lst) d)))
macroexpand.scm:          (if (and (pair? nxt) (eq? (car nxt) splat-token))
macroexpand.scm:(define (julia-bq-expand- x d)
macroexpand.scm:             (cons splat-token (cdr x))))
macroexpand.scm:           ((inert) `(call (core QuoteNode)      ,@(bq-expand-arglist (cdr x) d)))
macroexpand.scm:           ((line)  `(call (core LineNumberNode) ,@(bq-expand-arglist (cdr x) d)))
macroexpand.scm:           ((quote) `(call (core _expr)          ,@(bq-expand-arglist x (+ d 1))))
macroexpand.scm:           (($)     `(call (core _expr)          ,@(bq-expand-arglist x (- d 1))))
macroexpand.scm:           (else    `(call (core _expr)          ,@(bq-expand-arglist x d)))))))
macroexpand.scm:(define (julia-bq-expand x d)
macroexpand.scm:  (let ((e (julia-bq-expand- x d)))
macroexpand.scm:    (if (and (pair? e) (eq? (car e) splat-token))
macroexpand.scm:(define vars-introduced-by-patterns
macroexpand.scm:  (pattern-set
macroexpand.scm:   (pattern-lambda
macroexpand.scm:    (cons 'varlist (append (safe-llist-positional-args (fix-arglist argl))
macroexpand.scm:                           (typevar-names sparams))))
macroexpand.scm:   (pattern-lambda (function (-$ (call name . argl) (|::| (call name . argl) _t)) body)
macroexpand.scm:                   (cons 'varlist (safe-llist-positional-args (fix-arglist (append (self-argname name) argl)))))
macroexpand.scm:   (pattern-lambda (function (where callspec . wheres) body)
macroexpand.scm:                   (let ((others (pattern-expand1 vars-introduced-by-patterns `(function ,callspec ,body))))
macroexpand.scm:                                            (typevar-names wheres)))))
macroexpand.scm:   (pattern-lambda (function (tuple . args) body)
macroexpand.scm:                   `(-> (tuple ,@args) ,body))
macroexpand.scm:   (pattern-lambda (= (call (curly name . sparams) . argl) body)
macroexpand.scm:   (pattern-lambda (= (-$ (call name . argl) (|::| (call name . argl) _t)) body)
macroexpand.scm:   (pattern-lambda (= (where callspec . wheres) body)
macroexpand.scm:   (pattern-lambda (-> a b)
macroexpand.scm:                     (cons 'varlist (safe-llist-positional-args (fix-arglist a)))))
macroexpand.scm:   (pattern-lambda (where ex . vars)
macroexpand.scm:                   (cons 'varlist (typevar-names vars)))
macroexpand.scm:   (pattern-lambda (= (curly ex . vars) rhs)
macroexpand.scm:                   (cons 'varlist (typevar-names vars)))
macroexpand.scm:   (pattern-lambda (let binds ex)
macroexpand.scm:                   (let loop ((binds (let-binds __))
macroexpand.scm:                           ;; just symbol -> add local
macroexpand.scm:                                 (cons (decl-var (car binds)) vars)))
macroexpand.scm:                             ;; a=b -> add argument
macroexpand.scm:                                   (cons (decl-var (cadar binds)) vars)))
macroexpand.scm:                            ((eventually-call? (cadar binds))
macroexpand.scm:                             (let ((asgn (cadr (julia-expand0 (car binds) 'none 0))))
macroexpand.scm:                                   (append (map decl-var (lhs-vars (cadar binds))) vars)))
macroexpand.scm:   (pattern-lambda (macro (call name . argl) body)
macroexpand.scm:                   `(-> (tuple ,@argl) ,body))
macroexpand.scm:   (pattern-lambda (try tryb var catchb finalb)
macroexpand.scm:   (pattern-lambda (try tryb var catchb)
macroexpand.scm:   (pattern-lambda (struct mut spec body)
macroexpand.scm:                   (let ((tn (typedef-expr-name spec))
macroexpand.scm:                         (tv (typedef-expr-tvars spec)))
macroexpand.scm:                            (typevar-names tv))))
macroexpand.scm:   (pattern-lambda (abstract spec)
macroexpand.scm:                   (let ((tn (typedef-expr-name spec))
macroexpand.scm:                         (tv (typedef-expr-tvars spec)))
macroexpand.scm:                            (typevar-names tv))))
macroexpand.scm:   (pattern-lambda (primitive spec nb)
macroexpand.scm:                   (let ((tn (typedef-expr-name spec))
macroexpand.scm:                         (tv (typedef-expr-tvars spec)))
macroexpand.scm:                            (typevar-names tv))))
macroexpand.scm:   )) ; vars-introduced-by-patterns
macroexpand.scm:(define keywords-introduced-by-patterns
macroexpand.scm:  (pattern-set
macroexpand.scm:   (pattern-lambda (function (call (curly name . sparams) . argl) body)
macroexpand.scm:                   (cons 'varlist (safe-llist-keyword-args (fix-arglist argl))))
macroexpand.scm:   (pattern-lambda (function (-$ (call name . argl) (|::| (call name . argl) _t)) body)
macroexpand.scm:                   (cons 'varlist (safe-llist-keyword-args (fix-arglist argl))))
macroexpand.scm:   (pattern-lambda (function (where callspec . wheres) body)
macroexpand.scm:   (pattern-lambda (= (call (curly name . sparams) . argl) body)
macroexpand.scm:   (pattern-lambda (= (-$ (call name . argl) (|::| (call name . argl) _t)) body)
macroexpand.scm:   (pattern-lambda (= (where callspec . wheres) body)
macroexpand.scm:(define (pair-with-gensyms v)
macroexpand.scm:             (cons s (named-gensy s))))
macroexpand.scm:(define (typedef-expr-name e)
macroexpand.scm:        ((or (eq? (car e) 'curly) (eq? (car e) '<:)) (typedef-expr-name (cadr e)))
macroexpand.scm:(define (typedef-expr-tvars e)
macroexpand.scm:        ((eq? (car e) '<:) (typedef-expr-tvars (cadr e)))
macroexpand.scm:(define (typevar-expr-name e) (car (analyze-typevar e)))
macroexpand.scm:(define (typevar-names lst)
macroexpand.scm:                           (list (typevar-expr-name v))
macroexpand.scm:(define (try-arg-name v)
macroexpand.scm:           ((|::|) (if (length= v 2) '() (try-arg-name (cadr v))))
macroexpand.scm:           ((... kw =) (try-arg-name (cadr v)))
macroexpand.scm:           ((hygienic-scope) (try-arg-name (cadr v)))
macroexpand.scm:           ((meta)  ;; allow certain per-argument annotations
macroexpand.scm:            (if (nospecialize-meta? v #t)
macroexpand.scm:                (try-arg-name (caddr v))
macroexpand.scm:(define (safe-arg-names lst (escaped #f))
macroexpand.scm:                (let ((vv (try-arg-name v)))
macroexpand.scm:(define (safe-llist-positional-args lst (escaped #f))
macroexpand.scm:   (safe-arg-names
macroexpand.scm:(define (safe-llist-keyword-args lst)
macroexpand.scm:     (safe-arg-names kwargs #f)
macroexpand.scm:     (safe-arg-names kwargs #t)
macroexpand.scm:     (safe-llist-positional-args lst #t))))
macroexpand.scm:(define (self-argname name)
macroexpand.scm:;; resolve-expansion-vars-with-new-env, but turn on `inarg` once we get inside
macroexpand.scm:(define (resolve-in-function-lhs e env m parent-scope inarg)
macroexpand.scm:  (define (recur x) (resolve-in-function-lhs x env m parent-scope inarg))
macroexpand.scm:  (define (other x) (resolve-expansion-vars-with-new-env x env m parent-scope inarg))
macroexpand.scm:                             (resolve-expansion-vars-with-new-env x env m parent-scope #t))
macroexpand.scm:                              (resolve-expansion-vars-with-new-env x env m parent-scope #t))
macroexpand.scm:;; given the LHS of e.g. `x::Int -> y`, wrap the signature in `tuple` to normalize
macroexpand.scm:(define (tuple-wrap-arrow-sig e)
macroexpand.scm:        ((eq? (car e) 'where)  `(where ,(tuple-wrap-arrow-arglist (cadr e)) ,@(cddr e)))
macroexpand.scm:        ((eq? (car e) 'escape) `(escape ,(tuple-wrap-arrow-sig (cadr e))))
macroexpand.scm:(define (new-expansion-env-for x env (outermost #f))
macroexpand.scm:  (let ((introduced (pattern-expand1 vars-introduced-by-patterns x)))
macroexpand.scm:        (let ((globals (find-declared-vars-in-expansion x 'global))
macroexpand.scm:           (let ((v (diff (delete-duplicates
macroexpand.scm:                           (append! (find-declared-vars-in-expansion x 'local)
macroexpand.scm:                                    (find-assigned-vars-in-expansion x)
macroexpand.scm:                      (pair-with-gensyms v))
macroexpand.scm:                   (keywords-introduced-by x))
macroexpand.scm:(define (resolve-expansion-vars-with-new-env x env m parent-scope inarg (outermost #f))
macroexpand.scm:  (resolve-expansion-vars-
macroexpand.scm:       (new-expansion-env-for x env outermost))
macroexpand.scm:   m parent-scope inarg))
macroexpand.scm:(define (resolve-expansion-vars- e env m parent-scope inarg)
macroexpand.scm:  (cond ((or (eq? e 'begin) (eq? e 'end) (eq? e 'ccall) (eq? e 'cglobal) (underscore-symbol? e))
macroexpand.scm:           ((escape) (if (null? parent-scope)
macroexpand.scm:              (julia-expand-macroscopes- (cadr e))
macroexpand.scm:              (let* ((scope (car parent-scope))
macroexpand.scm:                     (parent-scope (cdr parent-scope)))
macroexpand.scm:                (resolve-expansion-vars-with-new-env (cadr e) env m parent-scope inarg))))
macroexpand.scm:                                   ,(resolve-expansion-vars-with-new-env (caddr arg) env m parent-scope inarg))))
macroexpand.scm:                              `(global ,(resolve-expansion-vars-with-new-env arg env m parent-scope inarg))))))
macroexpand.scm:            `(struct ,(cadr e) ,(resolve-expansion-vars- (caddr e) env m parent-scope inarg)
macroexpand.scm:                                      ,(resolve-expansion-vars- (caddr x) env m parent-scope inarg)))
macroexpand.scm:                                    (resolve-expansion-vars-with-new-env x env m parent-scope inarg))))
macroexpand.scm:                           (resolve-expansion-vars- x env m parent-scope #f)))
macroexpand.scm:           ((->)
macroexpand.scm:            `(-> ,(resolve-in-function-lhs (tuple-wrap-arrow-sig (cadr e)) env m parent-scope inarg)
macroexpand.scm:                 ,(resolve-expansion-vars-with-new-env (caddr e) env m parent-scope inarg)))
macroexpand.scm:            (if (and (pair? (cadr e)) (function-def? e) (length> e 2))
macroexpand.scm:                `(,(car e) ,(resolve-in-function-lhs (cadr e) env m parent-scope inarg)
macroexpand.scm:                  ,(resolve-expansion-vars-with-new-env (caddr e) env m parent-scope inarg))
macroexpand.scm:                                    (resolve-expansion-vars-with-new-env x env m parent-scope inarg))
macroexpand.scm:              (let* ((type-decl (cadr e)) ;; [argname]::type
macroexpand.scm:                     (argname   (and (length> type-decl 2) (cadr type-decl)))
macroexpand.scm:                     (type      (if argname (caddr type-decl) (cadr type-decl))))
macroexpand.scm:                                      (resolve-expansion-vars- argname env m parent-scope inarg)
macroexpand.scm:                      ,(resolve-expansion-vars- type env m parent-scope inarg))
macroexpand.scm:                     ,(resolve-expansion-vars-with-new-env (caddr e) env m parent-scope inarg))))
macroexpand.scm:                        (resolve-expansion-vars- (cadr e) env m parent-scope inarg)
macroexpand.scm:                   ,(resolve-expansion-vars-with-new-env (caddr e) env m parent-scope inarg)))))
macroexpand.scm:            (let* ((newenv (new-expansion-env-for e env))
macroexpand.scm:                   (body   (resolve-expansion-vars- (caddr e) newenv m parent-scope inarg))
macroexpand.scm:                   (binds  (let-binds e)))
macroexpand.scm:                              (make-assignment
macroexpand.scm:                               (cadr (resolve-expansion-vars- (make-assignment (cadr bind) 0)
macroexpand.scm:                                                              newenv m parent-scope inarg))
macroexpand.scm:                               (resolve-expansion-vars- (caddr bind) env m parent-scope inarg))
macroexpand.scm:           ((hygienic-scope) ; TODO: move this lowering to resolve-scopes, instead of reimplementing it here badly
macroexpand.scm:             (let ((parent-scope (cons (list env m) parent-scope))
macroexpand.scm:              (resolve-expansion-vars-with-new-env body env m parent-scope inarg #t)))
macroexpand.scm:                                 ,(resolve-expansion-vars-with-new-env (caddr x) env m parent-scope inarg))
macroexpand.scm:                             (resolve-expansion-vars-with-new-env x env m parent-scope inarg)))
macroexpand.scm:                         (resolve-expansion-vars-with-new-env x env m parent-scope inarg))
macroexpand.scm:;; decl-var that also identifies f in f()=...
macroexpand.scm:(define (decl-var* e)
macroexpand.scm:        ((eq? (car e) 'call)   (decl-var* (cadr e)))
macroexpand.scm:        ((eq? (car e) '=)      (decl-var* (cadr e)))
macroexpand.scm:        ((eq? (car e) 'curly)  (decl-var* (cadr e)))
macroexpand.scm:        ((eq? (car e) '|::|)   (decl-var* (cadr e)))
macroexpand.scm:        ((eq? (car e) 'where)  (decl-var* (cadr e)))
macroexpand.scm:        (else                  (decl-var e))))
macroexpand.scm:(define (decl-vars* e)
macroexpand.scm:      (apply append (map decl-vars* (cdr e)))
macroexpand.scm:      (list (decl-var* e))))
macroexpand.scm:(define (resume-on-escape lam e nblocks)
macroexpand.scm:            ((eq? (car e) 'hygienic-scope)
macroexpand.scm:             (resume-on-escape lam (cadr e) (+ nblocks 1)))
macroexpand.scm:                 (resume-on-escape lam (cadr e) (- nblocks 1))))
macroexpand.scm:             (foldl (lambda (a l) (append! l (resume-on-escape lam a nblocks)))
macroexpand.scm:(define (find-declared-vars-in-expansion e decl (outer #t))
macroexpand.scm:        ((eq? (car e) 'hygienic-scope)
macroexpand.scm:         (resume-on-escape (lambda (e) (find-declared-vars-in-expansion e decl outer)) (cadr e) 0))
macroexpand.scm:        ((eq? (car e) decl)     (map decl-var* (cdr e)))
macroexpand.scm:        ((and (not outer) (function-def? e)) '())
macroexpand.scm:                               (find-declared-vars-in-expansion x decl #f))
macroexpand.scm:(define (find-assigned-vars-in-expansion e (outer #t))
macroexpand.scm:        ((eq? (car e) 'hygienic-scope)
macroexpand.scm:         (resume-on-escape (lambda (e) (find-assigned-vars-in-expansion e outer)) (cadr e) 0))
macroexpand.scm:        ((and (not outer) (function-def? e))
macroexpand.scm:         (let ((fname (cond ((eq? (car e) '=) (decl-var* (cadr e)))
macroexpand.scm:                                   (else                         (decl-var* (cadr e)))))
macroexpand.scm:        ((and (eq? (car e) '=) (not (function-def? e)))
macroexpand.scm:         (append! (filter symbol? (decl-vars* (cadr e)))
macroexpand.scm:                  (find-assigned-vars-in-expansion (caddr e) #f)))
macroexpand.scm:                               (find-assigned-vars-in-expansion (if (assignment? x)
macroexpand.scm:                               (find-assigned-vars-in-expansion x #f))
macroexpand.scm:(define (keywords-introduced-by e)
macroexpand.scm:  (let ((v (pattern-expand1 keywords-introduced-by-patterns e)))
macroexpand.scm:(define (resolve-expansion-vars e m)
macroexpand.scm:  (resolve-expansion-vars-with-new-env e '() m '() #f #t))
macroexpand.scm:(define (julia-expand-quotes e)
macroexpand.scm:         (julia-expand-quotes (julia-bq-macro (cadr e))))
macroexpand.scm:         (cons (car e) (map julia-expand-quotes (cdr e))))))
macroexpand.scm:(define (julia-expand-macroscopes- e)
macroexpand.scm:        ((eq? (car e) 'hygienic-scope)
macroexpand.scm:         (let ((form (cadr e)) ;; form is the expression returned from expand-macros
macroexpand.scm:           (resolve-expansion-vars form modu)))
macroexpand.scm:         (map julia-expand-macroscopes- e))))
macroexpand.scm:(define (rename-symbolic-labels- e relabels parent-scope)
macroexpand.scm:   ((eq? (car e) 'hygienic-scope)
macroexpand.scm:    (let ((parent-scope (list relabels parent-scope))
macroexpand.scm:      `(hygienic-scope ,(rename-symbolic-labels- (cadr e) (table) parent-scope) ,m)))
macroexpand.scm:   ((and (eq? (car e) 'escape) (not (null? parent-scope)))
macroexpand.scm:    `(escape ,(apply rename-symbolic-labels- (cadr e) parent-scope)))
macroexpand.scm:           (havelabel (if (or (null? parent-scope) (not (symbol? s))) s (get relabels s #f)))
macroexpand.scm:           (newlabel (if havelabel havelabel (named-gensy s))))
macroexpand.scm:          (map (lambda (x) (rename-symbolic-labels- x relabels parent-scope))
macroexpand.scm:(define (rename-symbolic-labels e)
macroexpand.scm:  (rename-symbolic-labels- e (table) '()))
macroexpand.scm:;; TODO: delete this file and fold this operation into resolve-scopes
macroexpand.scm:(define (julia-expand-macroscope e)
macroexpand.scm:  (julia-expand-macroscopes-
macroexpand.scm:   (rename-symbolic-labels
macroexpand.scm:    (julia-expand-quotes e))))
macroexpand.scm:(define (contains-macrocall e)
macroexpand.scm:(define (julia-bq-macro x)
macroexpand.scm:  (julia-bq-expand x 0))
clangsa/ImplicitAtomics.cpp:  // or could check ASTContext::getQualifiedTemplateName()->isDerivedFrom() ?
clangsa/ImplicitAtomics.cpp:  if (!RD || !RD->getDeclContext()->isStdNamespace())
clangsa/ImplicitAtomics.cpp:  if (RD->getDeclName().isIdentifier()) {
clangsa/ImplicitAtomics.cpp:    StringRef Name = RD->getName();
clangsa/ImplicitAtomics.cpp:    return llvm::any_of(Names, [&Name](StringRef GivenName) -> bool {
clangsa/ImplicitAtomics.cpp:  return E && isStdAtomic(E->IgnoreImplicit()->getType()->getAsCXXRecordDecl());
clangsa/ImplicitAtomics.cpp:  return E->getType()->isAtomicType();
clangsa/ImplicitAtomics.cpp:    expr = expr->IgnoreParenCasts();
clangsa/ImplicitAtomics.cpp:      S = UO->getSubExpr();
clangsa/ImplicitAtomics.cpp:      S = isStdAtomic(BO->getLHS()) ? BO->getLHS() :
clangsa/ImplicitAtomics.cpp:             isStdAtomic(BO->getRHS()) ? BO->getRHS() :
clangsa/ImplicitAtomics.cpp:             BO->getLHS();
clangsa/ImplicitAtomics.cpp:  //if (isStdAtomic(CE) != isStdAtomic(CE->getSubExpr())) { // AtomicToNonAtomic or NonAtomicToAtomic CastExpr
clangsa/ImplicitAtomics.cpp:  if (CE->getCastKind() == CK_AtomicToNonAtomic) {
clangsa/ImplicitAtomics.cpp:  if (UOp->getOpcode() == UO_AddrOf)
clangsa/ImplicitAtomics.cpp:  const Expr *Sub = UOp->getSubExpr();
clangsa/ImplicitAtomics.cpp:  const Expr *Lhs = BOp->getLHS();
clangsa/ImplicitAtomics.cpp:  const Expr *Rhs = BOp->getRHS();
clangsa/ImplicitAtomics.cpp:  if (!MC || !isStdAtomicCall(MC->getCXXThisExpr()))
clangsa/ImplicitAtomics.cpp:    OverloadedOperatorKind OOK = OC->getOverloadedOperator();
clangsa/ImplicitAtomics.cpp:  else if (const auto *Convert = dyn_cast<CXXConversionDecl>(MC->getDecl())) {
clangsa/ImplicitAtomics.cpp://    E = expr->IgnoreParenLValueCasts();
clangsa/ImplicitAtomics2.cpp:#include "clang-tidy/ClangTidy.h"
clangsa/ImplicitAtomics2.cpp:#include "clang-tidy/ClangTidyCheck.h"
clangsa/ImplicitAtomics2.cpp:#include "clang-tidy/ClangTidyModule.h"
clangsa/ImplicitAtomics2.cpp:#include "clang-tidy/ClangTidyModuleRegistry.h"
clangsa/ImplicitAtomics2.cpp:  // or could check ASTContext::getQualifiedTemplateName()->isDerivedFrom() ?
clangsa/ImplicitAtomics2.cpp:  if (!RD || !RD->getDeclContext()->isStdNamespace())
clangsa/ImplicitAtomics2.cpp:  if (RD->getDeclName().isIdentifier()) {
clangsa/ImplicitAtomics2.cpp:    StringRef Name = RD->getName();
clangsa/ImplicitAtomics2.cpp:    return llvm::any_of(Names, [&Name](StringRef GivenName) -> bool {
clangsa/ImplicitAtomics2.cpp:  return E && isStdAtomic(E->IgnoreImplicit()->getType()->getAsCXXRecordDecl());
clangsa/ImplicitAtomics2.cpp:  return E->getType()->isAtomicType();
clangsa/ImplicitAtomics2.cpp:    expr = expr->IgnoreParenCasts();
clangsa/ImplicitAtomics2.cpp:      S = UO->getSubExpr();
clangsa/ImplicitAtomics2.cpp:      S = isStdAtomic(BO->getLHS()) ? BO->getLHS() :
clangsa/ImplicitAtomics2.cpp:             isStdAtomic(BO->getRHS()) ? BO->getRHS() :
clangsa/ImplicitAtomics2.cpp:             BO->getLHS();
clangsa/ImplicitAtomics2.cpp:  diag(S->getBeginLoc(), buf.str());
clangsa/ImplicitAtomics2.cpp:  Finder->addMatcher(castExpr(hasCastKind(CK_AtomicToNonAtomic))
clangsa/ImplicitAtomics2.cpp:  Finder->addMatcher(unaryOperator(unless(hasAnyOperatorName("&")))
clangsa/ImplicitAtomics2.cpp:                         .bind("unary-op"),
clangsa/ImplicitAtomics2.cpp:  Finder->addMatcher(binaryOperator()
clangsa/ImplicitAtomics2.cpp:                         .bind("binary-op"),
clangsa/ImplicitAtomics2.cpp:  Finder->addMatcher(cxxOperatorCallExpr()
clangsa/ImplicitAtomics2.cpp:  Finder->addMatcher(cxxMemberCallExpr()
clangsa/ImplicitAtomics2.cpp:  if (const auto *UOp = Result.Nodes.getNodeAs<UnaryOperator>("unary-op")) {
clangsa/ImplicitAtomics2.cpp:    const Expr *Sub = UOp->getSubExpr();
clangsa/ImplicitAtomics2.cpp:  if (const auto *BOp = Result.Nodes.getNodeAs<BinaryOperator>("binary-op")) {
clangsa/ImplicitAtomics2.cpp:    const Expr *Lhs = BOp->getLHS();
clangsa/ImplicitAtomics2.cpp:    const Expr *Rhs = BOp->getRHS();
clangsa/ImplicitAtomics2.cpp:      const auto *CXXThisExpr = OC->getArg(0);
clangsa/ImplicitAtomics2.cpp:        OverloadedOperatorKind OOK = OC->getOperator();
clangsa/ImplicitAtomics2.cpp:      const auto *CXXThisExpr = OC->getImplicitObjectArgument();
clangsa/ImplicitAtomics2.cpp:        if (isa<CXXConversionDecl>(OC->getMethodDecl())) {
clangsa/ImplicitAtomics2.cpp:    CheckFactories.registerCheck<ImplicitAtomicsChecker>("concurrency-implicit-atomics");
clangsa/ImplicitAtomics2.cpp:    X("concurrency-module", "Adds my concurrency checks.");
clangsa/GCChecker.cpp:    return N->getStmtForDiagnostics();
clangsa/GCChecker.cpp:      return ValueState(Allocated, nullptr, -1);
clangsa/GCChecker.cpp:      return ValueState(PotentiallyFreed, nullptr, -1);
clangsa/GCChecker.cpp:      return ValueState(Untracked, nullptr, -1);
clangsa/GCChecker.cpp:      return getRooted(nullptr, -1);
clangsa/GCChecker.cpp:    if (QT->isPointerType() || QT->isArrayType())
clangsa/GCChecker.cpp:          f, clang::QualType(QT->getPointeeOrArrayElementType(), 0));
clangsa/GCChecker.cpp:    const TypedefType *TT = QT->getAs<TypedefType>();
clangsa/GCChecker.cpp:      if (f(TT->getDecl()->getName()))
clangsa/GCChecker.cpp:    const TagDecl *TD = QT->getUnqualifiedDesugaredType()->getAsTagDecl();
clangsa/GCChecker.cpp:    return f(TD->getName());
clangsa/GCChecker.cpp:    if (QT->isPointerType() || QT->isArrayType())
clangsa/GCChecker.cpp:          clang::QualType(QT->getPointeeOrArrayElementType(), 0));
clangsa/GCChecker.cpp:    const TagDecl *TD = QT->getUnqualifiedDesugaredType()->getAsTagDecl();
clangsa/GCChecker.cpp:    const SymbolicRegion *SR = Region->getSymbolicBase();
clangsa/GCChecker.cpp:    SymbolRef Sym = SR->getSymbol();
clangsa/GCChecker.cpp:    const ValueState *OldVState = State->get<GCValueMap>(Sym);
clangsa/GCChecker.cpp:        Region = SRV->getRegion();
clangsa/GCChecker.cpp:        Region = SD->getRegion();
clangsa/GCChecker.cpp:    const VarRegion *VR = Region->getAs<VarRegion>();
clangsa/GCChecker.cpp:    if (VR && VR->getDecl()->hasGlobalStorage()) {
clangsa/GCChecker.cpp:    const SymbolicRegion *SymR = Region->getAs<SymbolicRegion>();
clangsa/GCChecker.cpp:          dyn_cast<SymbolRegionValue>(SymR->getSymbol());
clangsa/GCChecker.cpp:        const SymbolDerived *SD = dyn_cast<SymbolDerived>(SymR->getSymbol());
clangsa/GCChecker.cpp:          Region = SD->getRegion();
clangsa/GCChecker.cpp:      Region = SymRV->getRegion();
clangsa/GCChecker.cpp:    const SubRegion *SR = Region->getAs<SubRegion>();
clangsa/GCChecker.cpp:    Region = SR->getSuperRegion();
clangsa/GCChecker.cpp:  const ExplodedNode *PrevN = N->getFirstPred();
clangsa/GCChecker.cpp:  unsigned NewGCDepth = N->getState()->get<GCDepth>();
clangsa/GCChecker.cpp:  unsigned OldGCDepth = PrevN->getState()->get<GCDepth>();
clangsa/GCChecker.cpp:                               BRC.getSourceManager(), N->getLocationContext());
clangsa/GCChecker.cpp:  unsigned NewGCState = N->getState()->get<GCDisabledAt>();
clangsa/GCChecker.cpp:  unsigned OldGCState = PrevN->getState()->get<GCDisabledAt>();
clangsa/GCChecker.cpp:                               BRC.getSourceManager(), N->getLocationContext());
clangsa/GCChecker.cpp:      N->getState()->getSVal(FromWhere, N->getLocationContext()).getAsRegion();
clangsa/GCChecker.cpp:      N->getState(), Region);
clangsa/GCChecker.cpp:        N->getState(), N->getState()->getSVal(Region).getAsRegion());
clangsa/GCChecker.cpp:                 PathDiagnosticLocation::create(VR->getDecl(),
clangsa/GCChecker.cpp:      const VarDecl *VD = VR->getDecl();
clangsa/GCChecker.cpp:        } else if (!isGCTrackedType(VD->getType())) {
clangsa/GCChecker.cpp:  const ValueState *ValS = N->getState()->get<GCValueMap>(Parent);
clangsa/GCChecker.cpp:  if (ValS->isPotentiallyFreed()) {
clangsa/GCChecker.cpp:  } else if (ValS->isRooted()) {
clangsa/GCChecker.cpp:  if (N->getLocation().getAs<StmtPoint>()) {
clangsa/GCChecker.cpp:    const clang::Stmt *TheS = N->getLocation().castAs<StmtPoint>().getStmt();
clangsa/GCChecker.cpp:      return ExplainNoPropagationFromExpr(ME->getBase(), N, Pos, BRC, BR);
clangsa/GCChecker.cpp:      return ExplainNoPropagationFromExpr(ASE->getLHS(), N, Pos, BRC, BR);
clangsa/GCChecker.cpp:    const clang::FunctionDecl *FD = CE->getDirectCallee();
clangsa/GCChecker.cpp:    for (unsigned i = 0; i < FD->getNumParams(); ++i) {
clangsa/GCChecker.cpp:      if (!declHasAnnotation(FD->getParamDecl(i), "julia_propagates_root"))
clangsa/GCChecker.cpp:      return ExplainNoPropagationFromExpr(CE->getArg(i), N, Pos, BRC, BR);
clangsa/GCChecker.cpp:  const ExplodedNode *PrevN = N->getFirstPred();
clangsa/GCChecker.cpp:  const ValueState *NewValueState = N->getState()->get<GCValueMap>(Sym);
clangsa/GCChecker.cpp:  const ValueState *OldValueState = PrevN->getState()->get<GCValueMap>(Sym);
clangsa/GCChecker.cpp:                                 N->getLocationContext()};
clangsa/GCChecker.cpp:    Pos = PathDiagnosticLocation::createDeclEnd(N->getLocationContext(),
clangsa/GCChecker.cpp:    if (NewValueState->isRooted()) {
clangsa/GCChecker.cpp:      if (NewValueState->FD) {
clangsa/GCChecker.cpp:            !isFDAnnotatedNotSafepoint(NewValueState->FD);
clangsa/GCChecker.cpp:            declHasAnnotation(NewValueState->PVD, "julia_maybe_unrooted");
clangsa/GCChecker.cpp:            PathDiagnosticLocation{NewValueState->PVD, BRC.getSourceManager()};
clangsa/GCChecker.cpp:  if (!OldValueState->isUntracked() && NewValueState->isUntracked()) {
clangsa/GCChecker.cpp:  } else if (NewValueState->isPotentiallyFreed() &&
clangsa/GCChecker.cpp:             OldValueState->isJustAllocated()) {
clangsa/GCChecker.cpp:  } else if (NewValueState->isPotentiallyFreed() &&
clangsa/GCChecker.cpp:             !OldValueState->isPotentiallyFreed()) {
clangsa/GCChecker.cpp:  } else if (NewValueState->isRooted() && OldValueState->isJustAllocated()) {
clangsa/GCChecker.cpp:  } else if (!NewValueState->isRooted() && OldValueState->isRooted()) {
clangsa/GCChecker.cpp:  } else if (NewValueState->RootDepth != OldValueState->RootDepth) {
clangsa/GCChecker.cpp:  Report->addVisitor(make_unique<GCBugVisitor>());
clangsa/GCChecker.cpp:  Report->addVisitor(make_unique<GCValueBugVisitor>(Sym));
clangsa/GCChecker.cpp:  Report->addVisitor(make_unique<GCBugVisitor>());
clangsa/GCChecker.cpp:  Report->addVisitor(make_unique<ConditionBRVisitor>());
clangsa/GCChecker.cpp:    Report->addRange(range);
clangsa/GCChecker.cpp:  unsigned disabledAt = C.getState()->get<GCDisabledAt>();
clangsa/GCChecker.cpp:  return disabledAt == (unsigned)-1;
clangsa/GCChecker.cpp:  unsigned disabledAt = C.getState()->get<SafepointDisabledAt>();
clangsa/GCChecker.cpp:  return disabledAt == (unsigned)-1;
clangsa/GCChecker.cpp:  const auto *Site = cast<StackFrameContext>(LCtx)->getCallSite();
clangsa/GCChecker.cpp:  const auto *FD = dyn_cast<FunctionDecl>(LCtx->getDecl());
clangsa/GCChecker.cpp:  // FD->dump();
clangsa/GCChecker.cpp:  for (const auto P : FD->parameters()) {
clangsa/GCChecker.cpp:    if (!isGCTrackedType(P->getType())) {
clangsa/GCChecker.cpp:    auto Arg = State->getSVal(CE->getArg(idx++), LCtx->getParent());
clangsa/GCChecker.cpp:    const ValueState *ValS = State->get<GCValueMap>(ArgSym);
clangsa/GCChecker.cpp:            Report->addNote(
clangsa/GCChecker.cpp:    auto Param = State->getLValue(P, LCtx);
clangsa/GCChecker.cpp:    SymbolRef ParamSym = State->getSVal(Param).getAsSymbol();
clangsa/GCChecker.cpp:    if (isGloballyRootedType(P->getType())) {
clangsa/GCChecker.cpp:          State->set<GCValueMap>(ParamSym, ValueState::getRooted(nullptr, -1));
clangsa/GCChecker.cpp:    State = State->set<GCValueMap>(ParamSym, *ValS);
clangsa/GCChecker.cpp:  // Consider top-level argument values rooted, unless an annotation says
clangsa/GCChecker.cpp:  const auto *FD = dyn_cast<FunctionDecl>(LCtx->getDecl());
clangsa/GCChecker.cpp:    State = State->set<GCDisabledAt>((unsigned)-1);
clangsa/GCChecker.cpp:    State = State->set<SafepointDisabledAt>((unsigned)-1);
clangsa/GCChecker.cpp:  if (State->get<GCDisabledAt>() == (unsigned)-1) {
clangsa/GCChecker.cpp:      State = State->set<GCDisabledAt>(C.getStackFrame()->getIndex());
clangsa/GCChecker.cpp:  if (State->get<SafepointDisabledAt>() == (unsigned)-1 &&
clangsa/GCChecker.cpp:    State = State->set<SafepointDisabledAt>(C.getStackFrame()->getIndex());
clangsa/GCChecker.cpp:  for (const auto P : FD->parameters()) {
clangsa/GCChecker.cpp:      auto Param = State->getLValue(P, LCtx);
clangsa/GCChecker.cpp:      const MemRegion *Root = State->getSVal(Param).getAsRegion();
clangsa/GCChecker.cpp:      State = State->set<GCRootMap>(Root, RootState::getRoot(-1));
clangsa/GCChecker.cpp:    } else if (isGCTrackedType(P->getType())) {
clangsa/GCChecker.cpp:      auto Param = State->getLValue(P, LCtx);
clangsa/GCChecker.cpp:      SymbolRef AssignedSym = State->getSVal(Param).getAsSymbol();
clangsa/GCChecker.cpp:      State = State->set<GCValueMap>(AssignedSym,
clangsa/GCChecker.cpp:  if (RS && gcEnabledHere(C) && RS->getRetValue() && isGCTracked(RS->getRetValue())) {
clangsa/GCChecker.cpp:    auto ResultVal = C.getSVal(RS->getRetValue());
clangsa/GCChecker.cpp:    const ValueState *ValS = Sym ? State->get<GCValueMap>(Sym) : nullptr;
clangsa/GCChecker.cpp:    if (ValS && ValS->isPotentiallyFreed()) {
clangsa/GCChecker.cpp:      report_value_error(C, Sym, "Return value may have been GCed", RS->getSourceRange());
clangsa/GCChecker.cpp:  if (State->get<GCDisabledAt>() == C.getStackFrame()->getIndex()) {
clangsa/GCChecker.cpp:    State = State->set<GCDisabledAt>((unsigned)-1);
clangsa/GCChecker.cpp:  if (State->get<SafepointDisabledAt>() == C.getStackFrame()->getIndex()) {
clangsa/GCChecker.cpp:    State = State->set<SafepointDisabledAt>((unsigned)-1);
clangsa/GCChecker.cpp:  if (C.getState()->get<GCDepth>() > 0)
clangsa/GCChecker.cpp:    report_error(C, "Non-popped GC frame present at end of function");
clangsa/GCChecker.cpp:  for (const auto *Ann : D->specific_attrs<AnnotateAttr>()) {
clangsa/GCChecker.cpp:    if (Ann->getAnnotation() == which)
clangsa/GCChecker.cpp:    if (isGCTrackedType(E->getType()))
clangsa/GCChecker.cpp:      E = ICE->getSubExpr();
clangsa/GCChecker.cpp:      E = CE->getSubExpr();
clangsa/GCChecker.cpp:    // defined by -isystem per
clangsa/GCChecker.cpp:    // https://clang.llvm.org/docs/UsersManual.html#controlling-diagnostics-in-system-headers
clangsa/GCChecker.cpp:    const DeclContext *DC = Decl ? Decl->getDeclContext() : nullptr;
clangsa/GCChecker.cpp:        if (NDC->getName() == "llvm" || NDC->getName() == "std")
clangsa/GCChecker.cpp:      DC = DC->getParent();
clangsa/GCChecker.cpp:    const FunctionDecl *FD = Decl ? Decl->getAsFunction() : nullptr;
clangsa/GCChecker.cpp:          dyn_cast<CallExpr>(Call.getOriginExpr())->getCallee();
clangsa/GCChecker.cpp:      if (const TypedefType *TDT = dyn_cast<TypedefType>(Callee->getType())) {
clangsa/GCChecker.cpp:            !declHasAnnotation(TDT->getDecl(), "julia_not_safepoint");
clangsa/GCChecker.cpp:        // A pseudo-destructor is an expression that looks like a member
clangsa/GCChecker.cpp:        // access to a destructor of a scalar type. A pseudo-destructor
clangsa/GCChecker.cpp:        // expression has no run-time semantics beyond evaluating the base
clangsa/GCChecker.cpp:      if (FD->getBuiltinID() != 0 || FD->isTrivial())
clangsa/GCChecker.cpp:      else if (FD->getDeclName().isIdentifier() &&
clangsa/GCChecker.cpp:               (FD->getName().startswith("uv_") ||
clangsa/GCChecker.cpp:                FD->getName().startswith("unw_") ||
clangsa/GCChecker.cpp:                FD->getName().startswith("_U")) &&
clangsa/GCChecker.cpp:               FD->getName() != "uv_run")
clangsa/GCChecker.cpp:  const FunctionDecl *FD = D ? D->getAsFunction() : nullptr;
clangsa/GCChecker.cpp:    for (unsigned i = 0; i < FD->getNumParams(); ++i) {
clangsa/GCChecker.cpp:      QualType ParmType = FD->getParamDecl(i)->getType();
clangsa/GCChecker.cpp:      if (declHasAnnotation(FD->getParamDecl(i), "julia_temporarily_roots")) {
clangsa/GCChecker.cpp:        if (ParmType->isPointerType() &&
clangsa/GCChecker.cpp:            ParmType->getPointeeType()->isPointerType() &&
clangsa/GCChecker.cpp:            isGCTrackedType(ParmType->getPointeeType())) {
clangsa/GCChecker.cpp:              State->getSVal(Call.getArgSVal(i).getAs<Loc>().getValue());
clangsa/GCChecker.cpp:  GCValueMapTy AMap = State->get<GCValueMap>();
clangsa/GCChecker.cpp:      State = State->set<GCValueMap>(I.getKey(), ValueState::getFreed());
clangsa/GCChecker.cpp:        return !OldVState || !OldVState->isRooted();
clangsa/GCChecker.cpp:  return State->get<GCValueMap>(Sym);
clangsa/GCChecker.cpp:  const FunctionDecl *FD = Decl ? Decl->getAsFunction() : nullptr;
clangsa/GCChecker.cpp:  for (unsigned i = 0; i < FD->getNumParams(); ++i) {
clangsa/GCChecker.cpp:    if (declHasAnnotation(FD->getParamDecl(i), "julia_rooting_argument")) {
clangsa/GCChecker.cpp:    } else if (declHasAnnotation(FD->getParamDecl(i),
clangsa/GCChecker.cpp:  State = State->set<GCValueMap>(RootedSymbol, *OldVState);
clangsa/GCChecker.cpp:    State = State->BindExpr(Call.getOriginExpr(), C.getLocationContext(), S);
clangsa/GCChecker.cpp:    State = State->set<GCValueMap>(Sym, ValueState::getRooted(nullptr, -1));
clangsa/GCChecker.cpp:    const ValueState *ValS = State->get<GCValueMap>(Sym);
clangsa/GCChecker.cpp:    const FunctionDecl *FD = Decl ? Decl->getAsFunction() : nullptr;
clangsa/GCChecker.cpp:        NewVState = ValueState::getRooted(nullptr, -1);
clangsa/GCChecker.cpp:        // Special case for jl_box_ functions which have value-dependent
clangsa/GCChecker.cpp:            FD->getDeclName().isIdentifier() ? FD->getName() : "";
clangsa/GCChecker.cpp:            const llvm::APSInt &Value = CI->getValue();
clangsa/GCChecker.cpp:              if (-NBOX_C / 2 < Value && Value < (NBOX_C - NBOX_C / 2)) {
clangsa/GCChecker.cpp:              NewVState = ValueState::getRooted(nullptr, -1);
clangsa/GCChecker.cpp:          for (unsigned i = 0; i < FD->getNumParams(); ++i) {
clangsa/GCChecker.cpp:            if (declHasAnnotation(FD->getParamDecl(i),
clangsa/GCChecker.cpp:    State = State->set<GCValueMap>(Sym, NewVState);
clangsa/GCChecker.cpp:  if (!isGloballyRootedType(CE->getTypeAsWritten()))
clangsa/GCChecker.cpp:      C.getState()->set<GCValueMap>(Sym, ValueState::getRooted(nullptr, -1)));
clangsa/GCChecker.cpp:  QualType QT = Result->getType();
clangsa/GCChecker.cpp:  if (!QT->isPointerType() || QT->getPointeeType()->isVoidType())
clangsa/GCChecker.cpp:  auto ValLoc = State->getSVal(Result, C.getLocationContext()).getAs<Loc>();
clangsa/GCChecker.cpp:  SVal Loaded = State->getSVal(*ValLoc);
clangsa/GCChecker.cpp:          nullptr, Result, C.getLocationContext(), Result->getType(),
clangsa/GCChecker.cpp:      State = State->bindLoc(*ValLoc, Loaded, C.getLocationContext());
clangsa/GCChecker.cpp:      // State = State->BindExpr(Result, C.getLocationContext(),
clangsa/GCChecker.cpp:      // State->getSVal(*ValLoc));
clangsa/GCChecker.cpp:    Parent = PE->getSubExpr();
clangsa/GCChecker.cpp:    if (UO->getOpcode() == UO_AddrOf) {
clangsa/GCChecker.cpp:      Parent = UO->getSubExpr();
clangsa/GCChecker.cpp:  if (isGloballyRootedType(Result->getType())) {
clangsa/GCChecker.cpp:    const ValueState *NewValS = State->get<GCValueMap>(NewSym);
clangsa/GCChecker.cpp:    if (NewValS && NewValS->isRooted() && NewValS->RootDepth == -1) {
clangsa/GCChecker.cpp:        State->set<GCValueMap>(NewSym, ValueState::getRooted(nullptr, -1)));
clangsa/GCChecker.cpp:        Parent->getType());
clangsa/GCChecker.cpp:        Result->getType());
clangsa/GCChecker.cpp:    if (!Result->getType()->isPointerType()) {
clangsa/GCChecker.cpp:        Result, C.getLocationContext(), Result->getType(),
clangsa/GCChecker.cpp:    State = State->BindExpr(Result, C.getLocationContext(), ResultVal);
clangsa/GCChecker.cpp:  const ValueState *OldValS = OldSym ? State->get<GCValueMap>(OldSym) : nullptr;
clangsa/GCChecker.cpp:  const ValueState *NewValS = State->get<GCValueMap>(NewSym);
clangsa/GCChecker.cpp:    const VarRegion *VR = Region->getAs<VarRegion>();
clangsa/GCChecker.cpp:    ValueState Updated = ValueState::getRooted(Region, -1);
clangsa/GCChecker.cpp:    if (VR && isa<ParmVarDecl>(VR->getDecl())) {
clangsa/GCChecker.cpp:          dyn_cast<FunctionDecl>(C.getLocationContext()->getDecl());
clangsa/GCChecker.cpp:            ValueState::getForArgument(FD, cast<ParmVarDecl>(VR->getDecl()));
clangsa/GCChecker.cpp:      C.addTransition(State->set<GCValueMap>(NewSym, Updated));
clangsa/GCChecker.cpp:  if (NewValS && NewValS->isRooted()) {
clangsa/GCChecker.cpp:          State->set<GCValueMap>(NewSym, ValueState::getUntracked()));
clangsa/GCChecker.cpp:  if (OldValS->isPotentiallyFreed()) {
clangsa/GCChecker.cpp:    C.addTransition(State->set<GCValueMap>(NewSym, *OldValS));
clangsa/GCChecker.cpp:  const MemRegion *Region = C.getSVal(ASE->getLHS()).getAsRegion();
clangsa/GCChecker.cpp:  if (Region && Region->getAs<ElementRegion>() && isGCTracked(ASE)) {
clangsa/GCChecker.cpp:        State->get<GCRootMap>(Region->getAs<ElementRegion>()->getSuperRegion());
clangsa/GCChecker.cpp:      ValueState ValS = ValueState::getRooted(Region, State->get<GCDepth>());
clangsa/GCChecker.cpp:      const ValueState *ExistingValS = State->get<GCValueMap>(NewSym);
clangsa/GCChecker.cpp:      if (ExistingValS && ExistingValS->isRooted() &&
clangsa/GCChecker.cpp:          ExistingValS->RootDepth < ValS.RootDepth)
clangsa/GCChecker.cpp:      C.addTransition(State->set<GCValueMap>(NewSym, ValS));
clangsa/GCChecker.cpp:  checkDerivingExpr(ASE, ASE->getLHS(), true, C);
clangsa/GCChecker.cpp:    if (const RootState *RS = State->get<GCRootMap>(Region)) {
clangsa/GCChecker.cpp:      ValueState ValS = ValueState::getRooted(Region, RS->RootedAtDepth);
clangsa/GCChecker.cpp:      const ValueState *ExistingValS = State->get<GCValueMap>(NewSym);
clangsa/GCChecker.cpp:      if (ExistingValS && ExistingValS->isRooted() &&
clangsa/GCChecker.cpp:          ExistingValS->RootDepth < ValS.RootDepth)
clangsa/GCChecker.cpp:      C.addTransition(C.getState()->set<GCValueMap>(NewSym, ValS));
clangsa/GCChecker.cpp:  if (!ME->getType()->isPointerType())
clangsa/GCChecker.cpp:  clang::Expr *Base = ME->getBase();
clangsa/GCChecker.cpp:  if (UO->getOpcode() == UO_Deref) {
clangsa/GCChecker.cpp:    checkDerivingExpr(UO, UO->getSubExpr(), true, C);
clangsa/GCChecker.cpp:  GCValueMapTy AMap = State->get<GCValueMap>();
clangsa/GCChecker.cpp:    I.getKey()->dumpToStream(Out);
clangsa/GCChecker.cpp:  const FunctionDecl *FD = Decl ? Decl->getAsFunction() : nullptr;
clangsa/GCChecker.cpp:    if (!FD || !FD->isNoReturn()) {
clangsa/GCChecker.cpp:  if (FD && FD->getDeclName().isIdentifier() &&
clangsa/GCChecker.cpp:      FD->getName() == "JL_GC_PROMISE_ROOTED")
clangsa/GCChecker.cpp:      const MemRegion *R = LCV->getRegion();
clangsa/GCChecker.cpp:        if (const SubRegion *SR = R->getAs<SubRegion>()) {
clangsa/GCChecker.cpp:                  SR->getSuperRegion()->getAs<SymbolicRegion>()) {
clangsa/GCChecker.cpp:            Sym = SSR->getSymbol();
clangsa/GCChecker.cpp:    auto *ValState = State->get<GCValueMap>(Sym);
clangsa/GCChecker.cpp:      range = E->getSourceRange();
clangsa/GCChecker.cpp:    if (ValState->isPotentiallyFreed()) {
clangsa/GCChecker.cpp:    if (ValState->isRooted())
clangsa/GCChecker.cpp:      if (idx < FD->getNumParams()) {
clangsa/GCChecker.cpp:            declHasAnnotation(FD->getParamDecl(idx), "julia_maybe_unrooted");
clangsa/GCChecker.cpp:          "Passing non-rooted value as argument to function that may GC",
clangsa/GCChecker.cpp:  unsigned CurrentDepth = C.getState()->get<GCDepth>();
clangsa/GCChecker.cpp:    CurrentDepth -= 1;
clangsa/GCChecker.cpp:    ProgramStateRef State = C.getState()->set<GCDepth>(CurrentDepth);
clangsa/GCChecker.cpp:    GCRootMapTy AMap = State->get<GCRootMap>();
clangsa/GCChecker.cpp:        State = State->remove<GCRootMap>(I.getKey());
clangsa/GCChecker.cpp:    GCValueMapTy VMap = State->get<GCValueMap>();
clangsa/GCChecker.cpp:              State->set<GCValueMap>(I.getKey(), ValueState::getAllocated());
clangsa/GCChecker.cpp:    unsigned NumArgs = CE->getNumArgs();
clangsa/GCChecker.cpp:      SVal V = C.getSVal(CE->getArg(i));
clangsa/GCChecker.cpp:      const MemRegion *Region = MRV->getRegion();
clangsa/GCChecker.cpp:      State = State->set<GCRootMap>(Region, RootState::getRoot(CurrentDepth));
clangsa/GCChecker.cpp:      SVal Value = State->getSVal(Region);
clangsa/GCChecker.cpp:      const ValueState *ValState = State->get<GCValueMap>(Sym);
clangsa/GCChecker.cpp:      if (ValState->isPotentiallyFreed())
clangsa/GCChecker.cpp:      if (!ValState->isRooted()) {
clangsa/GCChecker.cpp:        State = State->set<GCValueMap>(
clangsa/GCChecker.cpp:    State = State->set<GCDepth>(CurrentDepth);
clangsa/GCChecker.cpp:    SVal ArgArray = C.getSVal(CE->getArg(0));
clangsa/GCChecker.cpp:    const MemRegion *Region = MRV->getRegion()->StripCasts();
clangsa/GCChecker.cpp:        State->set<GCRootMap>(Region, RootState::getRootArray(CurrentDepth));
clangsa/GCChecker.cpp:    // State = State->set<GCValueMap>(ArgArraySym, ValueState::getRooted(Region,
clangsa/GCChecker.cpp:    State = State->set<GCDepth>(CurrentDepth);
clangsa/GCChecker.cpp:    SVal Arg = C.getSVal(CE->getArg(0));
clangsa/GCChecker.cpp:        C.getState()->set<GCValueMap>(Sym, ValueState::getRooted(nullptr, -1)));
clangsa/GCChecker.cpp:    ProgramStateRef State = C.getState()->set<GCDepth>(CurrentDepth);
clangsa/GCChecker.cpp:    SVal ArrayList = C.getSVal(CE->getArg(1));
clangsa/GCChecker.cpp:        CE->getArg(1)->getType()->getPointeeType()->getAsTagDecl());
clangsa/GCChecker.cpp:      for (FieldDecl *X : RD->fields()) {
clangsa/GCChecker.cpp:        if (X->getName() == "items") {
clangsa/GCChecker.cpp:      Loc ItemsLoc = State->getLValue(FD, ArrayList).getAs<Loc>().getValue();
clangsa/GCChecker.cpp:      SVal Items = State->getSVal(ItemsLoc);
clangsa/GCChecker.cpp:            CE, C.getLocationContext(), FD->getType(), C.blockCount());
clangsa/GCChecker.cpp:        State = State->bindLoc(ItemsLoc, Items, C.getLocationContext());
clangsa/GCChecker.cpp:      State = State->set<GCRootMap>(Items.getAsRegion(),
clangsa/GCChecker.cpp:    SymbolRef Sym = C.getSVal(CE->getArg(1)).getAsSymbol();
clangsa/GCChecker.cpp:        State->set<GCValueMap>(Sym, ValueState::getRooted(nullptr, -1)));
clangsa/GCChecker.cpp:    SVal Arg = C.getSVal(CE->getArg(0));
clangsa/GCChecker.cpp:      const llvm::APSInt &Val = CI->getValue();
clangsa/GCChecker.cpp:      cast<SymbolConjured>(Arg.getAsSymbol())->getStmt()->dump();
clangsa/GCChecker.cpp:    bool EnabledNow = State->get<GCDisabledAt>() == (unsigned)-1;
clangsa/GCChecker.cpp:      State = State->set<GCDisabledAt>((unsigned)-2);
clangsa/GCChecker.cpp:      State = State->set<GCDisabledAt>((unsigned)-1);
clangsa/GCChecker.cpp:    SVal Result = C.getSValBuilder().makeTruthVal(EnabledNow, CE->getType());
clangsa/GCChecker.cpp:    C.addTransition(State->BindExpr(CE, C.getLocationContext(), Result));
clangsa/GCChecker.cpp:  const ElementRegion *ER = R->getAs<ElementRegion>();
clangsa/GCChecker.cpp:    R = R->getBaseRegion()->StripCasts();
clangsa/GCChecker.cpp:  const auto *RootState = State->get<GCRootMap>(R);
clangsa/GCChecker.cpp:    if (rootRegionIfGlobal(R->getBaseRegion(), State, C, &ValS)) {
clangsa/GCChecker.cpp:    if (!ValSP || !ValSP->isRooted()) {
clangsa/GCChecker.cpp:    const auto *RValState = State->get<GCValueMap>(Sym);
clangsa/GCChecker.cpp:    if (RValState && RValState->isRooted() &&
clangsa/GCChecker.cpp:        RValState->RootDepth < ValSP->RootDepth)
clangsa/GCChecker.cpp:    C.addTransition(State->set<GCValueMap>(Sym, *ValSP));
clangsa/GCChecker.cpp:  if (shouldBeRootArray && !RootState->isRootArray()) {
clangsa/GCChecker.cpp:  const auto *RValState = State->get<GCValueMap>(Sym);
clangsa/GCChecker.cpp:    if (rootRegionIfGlobal(Sym->getOriginRegion(), State, C)) {
clangsa/GCChecker.cpp:    Sym->dump();
clangsa/GCChecker.cpp:      SC->getStmt()->dump();
clangsa/GCChecker.cpp:  if (RValState->isPotentiallyFreed())
clangsa/GCChecker.cpp:  if (!RValState->isRooted() ||
clangsa/GCChecker.cpp:      RValState->RootDepth > RootState->RootedAtDepth) {
clangsa/GCChecker.cpp:    C.addTransition(State->set<GCValueMap>(
clangsa/GCChecker.cpp:        Sym, ValueState::getRooted(R, RootState->RootedAtDepth)));
clangsa/GCChecker.cpp:  const VarRegion *VR = R->getAs<VarRegion>();
clangsa/GCChecker.cpp:  const VarDecl *VD = VR->getDecl();
clangsa/GCChecker.cpp:  if (!VD->hasGlobalStorage())
clangsa/GCChecker.cpp:  if (!isGCTrackedType(VD->getType()))
clangsa/GCChecker.cpp:      isGloballyRootedType(VD->getType())) {
clangsa/GCChecker.cpp:    State = State->set<GCRootMap>(R, RootState::getRoot(-1));
clangsa/GCChecker.cpp:  SVal TheVal = State->getSVal(R);
clangsa/GCChecker.cpp:  ValueState TheValS(isGlobalRoot ? ValueState::getRooted(R, -1)
clangsa/GCChecker.cpp:    const ValueState *GVState = C.getState()->get<GCValueMap>(Sym);
clangsa/GCChecker.cpp:      State = State->set<GCValueMap>(Sym, TheValS);
clangsa/GCChecker.cpp:  if (IsLoad && (RS = State->get<GCRootMap>(SLoc.getAsRegion()))) {
clangsa/GCChecker.cpp:        State->getSVal(SLoc.getAs<Loc>().getValue()).getAsSymbol();
clangsa/GCChecker.cpp:      const ValueState *ValS = State->get<GCValueMap>(LoadedSym);
clangsa/GCChecker.cpp:      if (!ValS || !ValS->isRooted() || ValS->RootDepth > RS->RootedAtDepth) {
clangsa/GCChecker.cpp:        State = State->set<GCValueMap>(
clangsa/GCChecker.cpp:            ValueState::getRooted(SLoc.getAsRegion(), RS->RootedAtDepth));
clangsa/GCChecker.cpp:  const ValueState *VState = State->get<GCValueMap>(Sym);
clangsa/GCChecker.cpp:  if (VState->isPotentiallyFreed()) {
clangsa/GCChecker.cpp:      "https://docs.julialang.org/en/v1/devdocs/gc-sa/"
precompile.c:        jl_printf(JL_STDERR, "WARNING: --output requested, but no modules defined during run\n");
precompile.c:                ios_write(&f, (const char*)s->buf, (size_t)s->size);
precompile.c:                           (const char*)s->buf, (size_t)s->size);
precompile.c:        env[2 * i] = (jl_value_t*)((jl_unionall_t*)sigbody)->var;
precompile.c:        sigbody = ((jl_unionall_t*)sigbody)->body;
precompile.c:            goto getnext; // signature wouldn't be callable / is invalid -- skip it
precompile.c:            if (jl_is_uniontype(tv->ub)) {
precompile.c:                size_t l = jl_count_union_components(tv->ub);
precompile.c:                    jl_value_t *ty = jl_nth_union_component(tv->ub, j);
precompile.c:                        ty = (jl_value_t*)jl_new_typevar(tv->name, tv->lb, ty);
precompile.c:    size_t i, l = jl_svec_len(sigbody->parameters);
precompile.c:        jl_value_t *ty = jl_svecref(sigbody->parameters, i);
precompile.c:                 ((!jl_is_kind(ty) && ((jl_datatype_t*)ty)->isconcretetype) ||
precompile.c:                  ((jl_datatype_t*)ty)->name == jl_type_typename))
precompile.c:            jl_value_t *ty = jl_svecref(sigbody->parameters, i);
precompile.c:    jl_printf(JL_STDERR, "found %d uncompiled methods for compile-all\n", (int)found_l);
precompile.c:        if (found_i % (1 + found_l / 300) == 0 || found_i == found_l - 1) // show 300 progress steps, to show progress without overwhelming log files
precompile.c:        jl_method_t *m = ml->func.method;
precompile.c:        if (m->source == NULL) // TODO: generic implementations of generated functions
precompile.c:        assert(mi == m->unspecialized); // make sure we didn't get tricked by a generated function, since we can't handle those
precompile.c:        if (ucache->invoke != NULL)
precompile.c:        src = m->source;
precompile.c:        //if (ucache->invoke != NULL)
precompile.c:        _compile_all_union((jl_value_t*)ml->sig);
precompile.c:    // method definition -- compile template field
precompile.c:    jl_method_t *m = ml->func.method;
precompile.c:    if (m->source) {
precompile.c:    jl_typemap_visitor(mt->defs, compile_all_enq__, env);
precompile.c:    jl_code_instance_t *codeinst = mi->cache;
precompile.c:        if (codeinst->invoke != jl_fptr_const_return) {
precompile.c:            if (codeinst->inferred && codeinst->inferred != jl_nothing &&
precompile.c:                jl_ir_flag_inferred((jl_array_t*)codeinst->inferred) &&
precompile.c:                !jl_ir_flag_inlineable((jl_array_t*)codeinst->inferred)) {
precompile.c:            else if (codeinst->invoke != NULL || codeinst->precompile) {
precompile.c:        codeinst = jl_atomic_load_relaxed(&codeinst->next);
precompile.c:    jl_method_t *m = def->func.method;
precompile.c:    if ((m->name == jl_symbol("__init__") || m->ccallable) && jl_is_dispatch_tupletype(m->sig)) {
precompile.c:        // ensure `__init__()` and @ccallables get strongly-hinted, specialized, and compiled
precompile.c:        jl_method_instance_t *mi = jl_specializations_get_linfo(m, m->sig, jl_emptysvec);
precompile.c:        jl_svec_t *specializations = def->func.method->specializations;
precompile.c:    if (m->ccallable)
precompile.c:        jl_array_ptr_1d_push((jl_array_t*)closure, (jl_value_t*)m->ccallable);
precompile.c:    jl_typemap_visitor(mt->defs, precompile_enq_all_specializations__, env);
precompile.c:            if (!jl_isa_compileable_sig((jl_tupletype_t*)mi->specTypes, mi->def.method))
precompile.c:                mi = jl_get_specialization1((jl_tupletype_t*)mi->specTypes, jl_world_counter, &min_world, &max_world, 0);
timing.c:    uint64_t total_time = cycleclock() - t0;
timing.c:        root_time -= jl_timing_data[i];
timing.c:            fprintf(stderr, "%-25s : %5.2f %%   %" PRIu64 "\n", jl_timing_names[i],
timing.c:    jl_ptls_t ptls = jl_current_task->ptls;
timing.c:    jl_timing_block_t *stack = ptls->timing_stack;
timing.c:        stack = stack->prev;
timing.c:    return cur_block->prev;
julia.h:// (assumed to be at least a pointer size). Since C is bad at handling 16-byte
julia.h:    ((type *) ((char *)(ptr) - offsetof(type, member)))
julia.h:// core data types ------------------------------------------------------------
julia.h:        jl_value_t *type; // 16-byte aligned
julia.h:    ((jl_taggedvalue_t*)((char*)(v) - sizeof(jl_taggedvalue_t)))
julia.h:    ((jl_value_t*)(jl_astaggedvalue(v)->header & ~(uintptr_t)15))
julia.h:    jl_atomic_store_relaxed((_Atomic(jl_value_t*)*)&tag->type, (jl_value_t*)t);
julia.h:// Symbols are interned strings (hash-consed) stored as an invasive binary tree.
julia.h:// The string data is nul-terminated and hangs off the end of the struct.
julia.h:// Data is stored at the end of this variable-length struct.
julia.h:      how - allocation style
julia.h:      1 = julia-allocated buffer that needs to be marked
julia.h:      2 = malloc-allocated pointer this array object manages
julia.h:    uint32_t offset;  // for 1-d only. does not need to get big.
julia.h:    return (ndims < 3 ? 0 : ndims-2);
julia.h:// it forms a roughly tree-shaped structure, consisting of nodes of TypeMapLevels
julia.h:    // ssavalue-indexed arrays of properties:
julia.h:        // 3 = <reserved> strict-ieee (strictfp)
julia.h:        // 4 = effect-free (may be deleted if unused)
julia.h:        // 5-6 = <unused>
julia.h:        // 7 = has out-of-band info
julia.h:    // the following are optional transient properties (not preserved by compression--as they typically get stored elsewhere):
julia.h:    // method's type signature. redundant with TypeMapEntry->specTypes
julia.h:    jl_value_t *generator;  // executable code-generating function if available
julia.h:    jl_svec_t *sparam_vals; // static parameter values, indexed by def.method->sparam_syms
julia.h:    jl_value_t *uninferred; // cached uncompressed code, for generated functions, top-level thunks, or the interpreter
julia.h:    jl_array_t *backedges; // list of method-instances which contain a call into this method-instance
julia.h:    uint8_t isspecsig; // if specptr is a specialized function signature for specTypes->rettype
julia.h:// including a cache for hash-consed allocation of DataType objects.
julia.h:// in little-endian, isptr is always the first bit, avoiding the need for a branch in computing isptr
julia.h:    int32_t first_ptr; // index of the first pointer (or -1)
julia.h:    uint16_t fielddesc_type : 2; // 0 -> 8, 1 -> 16, 2 -> 32, 3 -> foreign type
julia.h:    uint8_t isbitstype:1; // relevant query for C-api and type-parameters
julia.h:    uint8_t zeroinit:1; // if one or more fields requires zero-initialization
julia.h:    uint8_t cached_by_hash:1; // stored in hash-based set cache (instead of linear cache)
julia.h:    // not first-class
julia.h:    struct _jl_module_t* owner;  // for individual imported bindings -- TODO: make _Atomic
julia.h:// one Type-to-Value entry
julia.h:    _Atomic(jl_array_t*) name1; // contains non-abstract TypeName, for parents up to (excluding) Any
julia.h:    intptr_t max_args;  // max # of non-vararg arguments in a signature
julia.h:// constants and type objects -------------------------------------------------
julia.h:// gc -------------------------------------------------------------------------
julia.h:// and the arguments to foo are not gc-protected during the call to foo.
julia.h:#define jl_pgcstack (jl_current_task->gcstack)
julia.h:  ((void**)rts_var)[-2] = (void*)JL_GC_ENCODE_PUSHARGS(n);                                              \
julia.h:  ((void**)rts_var)[-1] = jl_pgcstack;                                                                  \
julia.h:  jl_pgcstack = (jl_gcframe_t*)&(((void**)rts_var)[-2])
julia.h:#define JL_GC_POP() (jl_pgcstack = jl_pgcstack->prev)
julia.h:    if (__unlikely(jl_astaggedvalue(parent)->bits.gc == 3 && // parent is old and not in remset
julia.h:                   (jl_astaggedvalue(ptr)->bits.gc & 1) == 0)) // ptr is young
julia.h:    if (__unlikely(jl_astaggedvalue(ptr)->bits.gc == 3)) {
julia.h:    if (__likely(jl_astaggedvalue(parent)->bits.gc != 3))
julia.h:    if (__likely(jl_astaggedvalue(ptr)->bits.gc == 3))
julia.h:    const jl_datatype_layout_t *ly = dt->layout;
julia.h:    if (ly->npointers)
julia.h:// object accessors -----------------------------------------------------------
julia.h:#define jl_svec_len(t)              (((jl_svec_t*)(t))->length)
julia.h:#define jl_svec_set_len_unsafe(t,n) (((jl_svec_t*)(t))->length=(n))
julia.h:#define jl_array_len(a)   (((jl_array_t*)(a))->length)
julia.h:#define jl_array_data(a)  ((void*)((jl_array_t*)(a))->data)
julia.h:#define jl_array_dim(a,i) ((&((jl_array_t*)(a))->nrows)[i])
julia.h:#define jl_array_dim0(a)  (((jl_array_t*)(a))->nrows)
julia.h:#define jl_array_nrows(a) (((jl_array_t*)(a))->nrows)
julia.h:#define jl_array_ndims(a) ((int32_t)(((jl_array_t*)a)->flags.ndims))
julia.h:#define jl_array_ptr_data(a)  ((jl_value_t**)((jl_array_t*)(a))->data)
julia.h:    assert(((jl_array_t*)a)->flags.ptrarray);
julia.h:    assert(((jl_array_t*)a)->flags.ptrarray);
julia.h:        if (((jl_array_t*)a)->flags.how == 3) {
julia.h:#define jl_exprarg(e,n) jl_array_ptr_ref(((jl_expr_t*)(e))->args, n)
julia.h:#define jl_exprargset(e, n, v) jl_array_ptr_set(((jl_expr_t*)(e))->args, n, v)
julia.h:#define jl_expr_nargs(e) jl_array_len(((jl_expr_t*)(e))->args)
julia.h:#define jl_nparams(t)  jl_svec_len(((jl_datatype_t*)(t))->parameters)
julia.h:#define jl_tparam0(t)  jl_svecref(((jl_datatype_t*)(t))->parameters, 0)
julia.h:#define jl_tparam1(t)  jl_svecref(((jl_datatype_t*)(t))->parameters, 1)
julia.h:#define jl_tparam(t,i) jl_svecref(((jl_datatype_t*)(t))->parameters, i)
julia.h:#define jl_gf_mtable(f) (((jl_datatype_t*)jl_typeof(f))->name->mt)
julia.h:#define jl_gf_name(f)   (jl_gf_mtable(f)->name)
julia.h:#define jl_get_fieldtypes(st) ((st)->types ? (st)->types : jl_compute_fieldtypes((st), NULL))
julia.h:    return st->name->names;
julia.h:    assert(st->types);
julia.h:    return jl_svecref(st->types, i);
julia.h:#define jl_datatype_size(t)    (((jl_datatype_t*)t)->size)
julia.h:#define jl_datatype_align(t)   (((jl_datatype_t*)t)->layout->alignment)
julia.h:#define jl_datatype_nbits(t)   ((((jl_datatype_t*)t)->size)*8)
julia.h:#define jl_datatype_nfields(t) (((jl_datatype_t*)(t))->layout->nfields)
julia.h:// inline version with strong type check to detect typos in a `->name` chain
julia.h:    return jl_dt_layout_fields(l) + jl_fielddesc_size(l->fielddesc_type) * l->nfields;
julia.h:        const jl_datatype_layout_t *ly = st->layout;                          \
julia.h:        assert(i >= 0 && (size_t)i < ly->nfields);                            \
julia.h:        if (ly->fielddesc_type == 0) {                                        \
julia.h:        else if (ly->fielddesc_type == 1) {                                   \
julia.h:            assert(ly->fielddesc_type == 2);                                  \
julia.h:    const jl_datatype_layout_t *ly = st->layout;
julia.h:    assert(i >= 0 && (size_t)i < ly->nfields);
julia.h:    return ((const jl_fielddesc8_t*)(jl_dt_layout_fields(ly) + jl_fielddesc_size(ly->fielddesc_type) * i))->isptr;
julia.h:    const jl_datatype_layout_t *ly = st->layout;
julia.h:    assert(i >= 0 && (size_t)i < ly->npointers);
julia.h:    if (ly->fielddesc_type == 0) {
julia.h:    else if (ly->fielddesc_type == 1) {
julia.h:        assert(ly->fielddesc_type == 2);
julia.h:    // if (!st->mutable) return 0; // TODO: is this fast-path helpful?
julia.h:    const uint32_t *atomicfields = st->name->atomicfields;
julia.h:    return l->nfields == 0 && l->npointers > 0;
julia.h:// basic predicates -----------------------------------------------------------
julia.h:#define jl_is_tuple(v)       (((jl_datatype_t*)jl_typeof(v))->name == jl_tuple_typename)
julia.h:#define jl_is_namedtuple(v)  (((jl_datatype_t*)jl_typeof(v))->name == jl_namedtuple_typename)
julia.h:#define jl_is_mutable(t)     (((jl_datatype_t*)t)->name->mutabl)
julia.h:#define jl_is_mutable_datatype(t) (jl_is_datatype(t) && (((jl_datatype_t*)t)->name->mutabl))
julia.h:#define jl_is_immutable(t)   (!((jl_datatype_t*)t)->name->mutabl)
julia.h:#define jl_is_immutable_datatype(t) (jl_is_datatype(t) && (!((jl_datatype_t*)t)->name->mutabl))
julia.h:#define jl_is_llvmpointer(v) (((jl_datatype_t*)jl_typeof(v))->name == jl_llvmpointer_typename)
julia.h:#define jl_array_isbitsunion(a) (!(((jl_array_t*)(a))->flags.ptrarray) && jl_is_uniontype(jl_tparam0(jl_typeof(a))))
julia.h:            ((jl_datatype_t*)(v))->layout &&
julia.h:            !((jl_datatype_t*)(v))->name->abstract &&
julia.h:    return (jl_is_datatype(t) && ((jl_datatype_t*)t)->isbitstype);
julia.h:    return (d->instance != NULL);
julia.h:    return (jl_is_datatype(v) && ((jl_datatype_t*)(v))->name->abstract);
julia.h:            ((jl_datatype_t*)(t))->name == jl_array_typename);
julia.h:            ((jl_datatype_t*)(t))->name == jl_opaque_closure_typename);
julia.h:            ((jl_datatype_t*)(t))->name == ((jl_datatype_t*)jl_pointer_type->body)->name);
julia.h:            ((jl_datatype_t*)(t))->name == jl_llvmpointer_typename);
julia.h:            ((jl_datatype_t*)(t))->name == ((jl_datatype_t*)jl_ref_type->body)->name);
julia.h:            ((jl_datatype_t*)(t))->name == jl_tuple_typename);
julia.h:            ((jl_datatype_t*)(t))->name == jl_namedtuple_typename);
julia.h:            ((jl_datatype_t*)(t))->name == jl_vecelement_typename);
julia.h:            ((jl_datatype_t*)(v))->name == ((jl_datatype_t*)jl_type_type->body)->name);
julia.h:    if (a->flags.ptrarray || a->flags.hasptr)
julia.h:    return jl_is_datatype(elty) && ((jl_datatype_t*)elty)->zeroinit;
julia.h:    if (dt->name->mutabl) {
julia.h:    return jl_is_datatype(v) && ((jl_datatype_t*)v)->isdispatchtuple;
julia.h:    return jl_is_datatype(v) && ((jl_datatype_t*)v)->isconcretetype;
julia.h:JL_DLLEXPORT jl_value_t *jl_arrayref(jl_array_t *a, size_t i);  // 0-indexed
julia.h:JL_DLLEXPORT jl_value_t *jl_ptrarrayref(jl_array_t *a JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;  // 0-indexed
julia.h:JL_DLLEXPORT void jl_arrayset(jl_array_t *a JL_ROOTING_ARGUMENT, jl_value_t *v JL_ROOTED_ARGUMENT JL_MAYBE_UNROOTED, size_t i);  // 0-indexed
julia.h:JL_DLLEXPORT void jl_arrayunset(jl_array_t *a, size_t i);  // 0-indexed
julia.h:JL_DLLEXPORT int jl_array_isassigned(jl_array_t *a, size_t i);  // 0-indexed
julia.h:// calling into julia ---------------------------------------------------------
julia.h:    return jl_apply_generic(args[0], &args[1], nargs - 1);
julia.h:// async signal handling ------------------------------------------------------
julia.h:// tasks and exceptions -------------------------------------------------------
julia.h:    // id of owning thread - does not need to be defined until the task runs
julia.h:// I/O system -----------------------------------------------------------------
julia.h:// julia options -----------------------------------------------------------
julia.h:// Set julia-level ARGS array according to the arguments provided in
julia.h:#define JL_LOGLEVEL_BELOWMIN -1000001
julia.h:#define JL_LOGLEVEL_DEBUG    -1000
julia.h:#define jl_root_task (jl_current_task->ptls->root_task)
julia.h:// codegen interface ----------------------------------------------------------
julia.h:    // controls the emission of debug-info. mirrors the clang options
julia.h:    int debug_info_kind; // Enum for line-table-only, line-directives-only,
bin2hex.scm:(define (read-u8) (io.read *input-stream* 'uint8))
bin2hex.scm:(let loop ((b (read-u8))
bin2hex.scm:  (if (not (eof-object? b))
bin2hex.scm:        (display "0x") (display (number->string b 16))
bin2hex.scm:        (loop (read-u8) (+ 1 i)))))
llvm-pass-helpers.h:// A data structure that can read Julia-specific intrinsics
llvm-pass-helpers.h:// Mainly useful for building Julia-specific LLVM passes.
llvm-pass-helpers.h:        return module->getContext();
llvm-pass-helpers.h:    // Gets the intrinsic or well-known function that conforms to
llvm-pass-helpers.h:    // Gets the intrinsic or well-known function that conforms to
llvm-pass-helpers.h:    // declares the intrinsic or well-known function and adds it
llvm-pass-helpers.h:// A namespace for well-known Julia runtime function descriptions.
llvm-pass-helpers.h:    // A description of a well-known function that can be used to
codegen_shared.h:    v->print(llvm::dbgs(), true);
codegen_shared.h:    v->print(llvm::dbgs(), true);
codegen_shared.h:    f->print(llvm::dbgs(), nullptr, false, true);
codegen_shared.h:    m->print(llvm::dbgs(), nullptr);
codegen_shared.h:    m->print(llvm::dbgs());
codegen_shared.h:    dbg->print(llvm::dbgs());
common_symbols1.inc:jl_symbol("-"),
cgutils.cpp:    inst->setMetadata(llvm::LLVMContext::MD_tbaa, md);
cgutils.cpp:        inst->setMetadata(LLVMContext::MD_invariant_load, MDNode::get(md->getContext(), None));
cgutils.cpp:    if (V->getType() == T_prjlvalue){
cgutils.cpp:    assert(V->getType() == T_pjlvalue);
cgutils.cpp:// Take an arbitrary untracked value and make it gc-tracked
cgutils.cpp:    if (V->getType() == T_pjlvalue)
cgutils.cpp:    assert(V->getType() == T_prjlvalue);
cgutils.cpp:    Type *T = V->getType();
cgutils.cpp:    if (cast<PointerType>(T)->getAddressSpace() == AddressSpace::Derived)
cgutils.cpp:    Type *NewT = PointerType::get(cast<PointerType>(T)->getElementType(), AddressSpace::Derived);
cgutils.cpp:    Type *T = V->getType();
cgutils.cpp:    if (cast<PointerType>(T)->getAddressSpace() != AddressSpace::Tracked)
cgutils.cpp:    Type *NewT = PointerType::get(cast<PointerType>(T)->getElementType(), AddressSpace::Derived);
cgutils.cpp:    assert(V->getType() == T_pjlvalue || V->getType() == T_prjlvalue);
cgutils.cpp:// --- language feature checks ---
cgutils.cpp:#define JL_FEAT_TEST(ctx, feature) ((ctx).params->feature)
cgutils.cpp:// --- string constants ---
cgutils.cpp:    return irbuilder.CreateInBoundsGEP(gv->getValueType(), gv, Args);
cgutils.cpp:// --- MDNode ---
cgutils.cpp:// --- Debug info ---
cgutils.cpp:    if (isboxed || !jl_is_datatype(jt) || !jdt->isconcretetype)
cgutils.cpp:    assert(jdt->layout);
cgutils.cpp:    DIType* &ditype = (ctx ? ctx->ditypes[jdt] : _ditype);
cgutils.cpp:    const char *tname = jl_symbol_name(jdt->name->name);
cgutils.cpp:        ditype = dbuilder->createBasicType(tname, SizeInBits, llvm::dwarf::DW_ATE_unsigned);
cgutils.cpp:    else if (jl_is_structtype(jt) && !jl_is_layout_opaque(jdt->layout)) {
cgutils.cpp:            jl_value_t *el = jl_svecref(jdt->types, i);
cgutils.cpp:        DINodeArray ElemArray = dbuilder->getOrCreateArray(Elements);
cgutils.cpp:        ditype = dbuilder->createStructType(
cgutils.cpp:        ditype = dbuilder->createTypedef(jl_pvalue_dillvmt, tname, NULL, 0, NULL);
cgutils.cpp:    unsigned AS = cast<PointerType>(V->getType())->getAddressSpace();
cgutils.cpp:    if (V->getType() != T)
cgutils.cpp:    Call->setAttributes(F->getAttributes());
cgutils.cpp:        if (PointerType *T = dyn_cast<PointerType>(x.V->getType())) {
cgutils.cpp:            if (T->getAddressSpace() == AddressSpace::Tracked ||
cgutils.cpp:                T->getAddressSpace() == AddressSpace::Derived) {
cgutils.cpp:// --- emitting pointers directly into code ---
cgutils.cpp:        localname = gv->getName();
cgutils.cpp:        if (gv->getParent() != M)
cgutils.cpp:            gv = cast_or_null<GlobalVariable>(M->getNamedValue(localname));
cgutils.cpp:    gv->setMetadata("julia.constgv", MDNode::get(gv->getContext(), None));
cgutils.cpp:    assert(localname == gv->getName());
cgutils.cpp:    assert(!gv->hasInitializer());
cgutils.cpp:        len += strlen(jl_symbol_name(parent->name))+1;
cgutils.cpp:        parent = parent->parent;
cgutils.cpp:    len -= strlen(jl_symbol_name(name)) + 1;
cgutils.cpp:        size_t part = strlen(jl_symbol_name(parent->name)) + 1;
cgutils.cpp:        strcpy(fullname + len - part, jl_symbol_name(parent->name));
cgutils.cpp:        fullname[len - 1] = '.';
cgutils.cpp:        len -= part;
cgutils.cpp:        parent = parent->parent;
cgutils.cpp:        gv->setUnnamedAddr(GlobalValue::UnnamedAddr::Global);
cgutils.cpp:        return julia_pgv(ctx, "+", addr->name->name, addr->name->module, p);
cgutils.cpp:        // functions are prefixed with a -
cgutils.cpp:        return julia_pgv(ctx, "-", m->name, m->module, p);
cgutils.cpp:        // Type-inferred functions are also prefixed with a -
cgutils.cpp:        if (jl_is_method(linfo->def.method))
cgutils.cpp:            return julia_pgv(ctx, "-", linfo->def.method->name, linfo->def.method->module, p);
cgutils.cpp:    A->addAttrs(B);
cgutils.cpp:    if (isa<PointerType>(LI->getType())) {
cgutils.cpp:            LI->setMetadata(LLVMContext::MD_nonnull, MDNode::get(jl_LLVMContext, None));
cgutils.cpp:            LI->setMetadata(can_be_null ? LLVMContext::MD_dereferenceable_or_null : LLVMContext::MD_dereferenceable,
cgutils.cpp:                LI->setMetadata(LLVMContext::MD_align, MDNode::get(jl_LLVMContext, { OP }));
cgutils.cpp:        return i - 10 + 'A';
cgutils.cpp:        return c - 10 + 'A';
cgutils.cpp:    // len is the non-'\0' char number
cgutils.cpp:    if (dt->instance){
cgutils.cpp:    if (dt->layout && nfields == 0){
cgutils.cpp:    assert(dt->types != NULL);
cgutils.cpp:        jl_value_t* _fieldtype = jl_svec_ref(dt->types, i);
cgutils.cpp:        Module* M = ctx.f->getParent();
cgutils.cpp:            os << jl_symbol_name(((jl_typename_t*)p)->name);
cgutils.cpp:            jl_module_to_string(os, dt->name->module);
cgutils.cpp:            jl_sym_to_fully_qualified_sym(os, dt->name->mt->name);
cgutils.cpp:            jl_value_t* meth = (jl_value_t*)(((jl_method_instance_t*)p)->def.method);
cgutils.cpp:                if (((jl_method_t*)meth)->name == jl_symbol("ROOT")){
cgutils.cpp:                // Type-inferred functions are also prefixed with a -
cgutils.cpp:                // if (jl_is_method(linfo->def.method))
cgutils.cpp:                //    return julia_pgv(ctx, "-", linfo->def.method->name, linfo->def.method->module, p);
cgutils.cpp:                // non-const variable is always represented by a globalref, so we don't need to worry about them
cgutils.cpp:                    os << iter->second;
cgutils.cpp:        GlobalVariable* gv = cast_or_null<GlobalVariable>(M->getNamedValue(os.str()));
cgutils.cpp:    Value *pgv = julia_pgv(ctx, "jl_bnd#", p->name, p->owner, p);
cgutils.cpp:        v->getType()->getPointerAddressSpace() != jl_value->getPointerAddressSpace()) {
cgutils.cpp:                PointerType::get(cast<PointerType>(jl_value)->getElementType(),
cgutils.cpp:                                 v->getType()->getPointerAddressSpace());
cgutils.cpp:    if (to != V->getType())
cgutils.cpp:    llvm::Module* M = ctx.f->getParent();
cgutils.cpp:    GlobalVariable* gv = cast_or_null<GlobalVariable>(M->getNamedValue(nameref));
cgutils.cpp:    // binding->value are prefixed with *
cgutils.cpp:        if (b->constp){
cgutils.cpp:            bv = literal_pointer_val_internal(ctx,b->value, 1);
cgutils.cpp:                jl_module_to_string(os, b->owner);
cgutils.cpp:                jl_sym_to_fully_qualified_sym(os, b->name);
cgutils.cpp:                llvm::Module* M = ctx.f->getParent();
cgutils.cpp:                GlobalVariable* gv = cast_or_null<GlobalVariable>(M->getNamedValue(os.str()));
cgutils.cpp:                global_binding_pool[os.str()] = b->value;
cgutils.cpp:                rev_global_binding_pool[b->value] = os.str();
cgutils.cpp:            // we should produce a slot for non-constant value
cgutils.cpp:            jl_module_to_string(os, b->owner);
cgutils.cpp:            jl_sym_to_fully_qualified_sym(os, b->name);
cgutils.cpp:            llvm::Module* M = ctx.f->getParent();
cgutils.cpp:            GlobalVariable* gv = cast_or_null<GlobalVariable>(M->getNamedValue(nameref));
cgutils.cpp:                              ctx.builder.CreateAlignedLoad(T_pjlvalue, julia_pgv(ctx, "*", b->name, b->owner, b), Align(sizeof(void*)))),
cgutils.cpp:// --- mapping between julia and llvm types ---
cgutils.cpp:    unsigned idx = SL->getElementContainingOffset(byte_offset);
cgutils.cpp:    assert(SL->getElementOffset(idx) == byte_offset);
cgutils.cpp:    return jl_is_datatype(typ) && ((jl_datatype_t*)typ)->layout->npointers > 0;
cgutils.cpp:    al &= -al;
cgutils.cpp:    // use this where C-compatible (unboxed) structs are desired
cgutils.cpp:    if (jl_is_structtype(jt) && !(jst->layout && jl_is_layout_opaque(jst->layout))) {
cgutils.cpp:        // don't use pre-filled struct_decl for llvmcall (f16, etc. may be different)
cgutils.cpp:        Type *&struct_decl = (ctx && !llvmcall ? ctx->llvmtypes[jst] : _struct_decl);
cgutils.cpp:                assert(!isptr && fsz == jl_field_size(jst, i) - 1); (void)isptr;
cgutils.cpp:                    while (NumATy--)
cgutils.cpp:                    while (remainder--)
cgutils.cpp:            assert(jst->layout == NULL); // otherwise should have been caught above
cgutils.cpp:#if 0 // stress-test code that tries to assume julia-index == llvm-index
cgutils.cpp:    //  while (remainder--)
cgutils.cpp:            if (allow_va && i == l - 1 && jl_is_vararg(jl_svecref(t, i))) {
cgutils.cpp:        bool allunbox = for_each_uniontype_small(f, ((jl_uniontype_t*)ty)->a, counter);
cgutils.cpp:        allunbox &= for_each_uniontype_small(f, ((jl_uniontype_t*)ty)->b, counter);
cgutils.cpp:            // find the corresponding index in the new union-type
cgutils.cpp:// --- generating various field accessors ---
cgutils.cpp:        auto emit_unboxty = [&] () -> Value* {
cgutils.cpp:            phi->addIncoming(boxTy, boxBB);
cgutils.cpp:            phi->addIncoming(unboxTy, unboxBB);
cgutils.cpp:        Value *size = ConstantInt::get(T_int32, -1);
cgutils.cpp:            sizeof_merge->addIncoming(dyn_size, dynloadBB);
cgutils.cpp:            sizeof_merge->addIncoming(size, currBB);
cgutils.cpp:        CreateConditionalAbort(ctx.builder, ctx.builder.CreateICmpEQ(size, ConstantInt::get(T_int32, -1)));
cgutils.cpp:    Value *Idx2 = ConstantInt::get(T_size, offsetof(jl_typename_t, n_uninitialized) + sizeof(((jl_typename_t*)nullptr)->n_uninitialized));
cgutils.cpp:// --- generating various error checks ---
cgutils.cpp:    ctx.f->getBasicBlockList().push_back(passBB);
cgutils.cpp:        ctx.f->getBasicBlockList().push_back(contBB);
cgutils.cpp:    return ctx.builder.CreateICmpNE(v, Constant::getNullValue(v->getType()));
cgutils.cpp:        if (Cond->isZero())
cgutils.cpp:    PHINode *phi = ctx.builder.CreatePHI(defval->getType(), 2);
cgutils.cpp:    phi->addIncoming(defval, currBB);
cgutils.cpp:    phi->addIncoming(res, passBB);
cgutils.cpp:        return (_can_optimize_isa(((jl_uniontype_t*)type)->a, counter) &&
cgutils.cpp:                _can_optimize_isa(((jl_uniontype_t*)type)->b, counter));
cgutils.cpp:    if (jl_is_datatype(dt) && !dt->name->abstract && jl_subtype(dt->name->wrapper, type))
cgutils.cpp:    return (_can_optimize_isa(type->a, counter) && _can_optimize_isa(type->b, counter));
cgutils.cpp:// a simple case of emit_isa that is obvious not to include a safe-point
cgutils.cpp:        emit_isa_union(ctx, x, ((jl_uniontype_t*)type)->a, bbs);
cgutils.cpp:        emit_isa_union(ctx, x, ((jl_uniontype_t*)type)->b, bbs);
cgutils.cpp:                // optimize more when we know that this is a split union-type where tindex = 0 is invalid
cgutils.cpp:                istype->addIncoming(ConstantInt::get(T_int1, 0), currBB);
cgutils.cpp:                istype->addIncoming(istype_boxed, isaBB);
cgutils.cpp:    if (jl_is_datatype(dt) && !dt->name->abstract && jl_subtype(dt->name->wrapper, type)) {
cgutils.cpp:                    mark_callee_rooted(ctx, literal_pointer_val(ctx, (jl_value_t*)dt->name))),
cgutils.cpp:                res->addIncoming(ConstantInt::get(T_int1, 1), bb);
cgutils.cpp:                res->addIncoming(bbs[i].second, bb);
cgutils.cpp:        ctx.f->getBasicBlockList().push_back(passBB);
cgutils.cpp:    isconcrete = ctx.builder.CreateConstInBoundsGEP1_32(T_int8, emit_bitcast(ctx, decay_derived(ctx, typ), T_pint8), offsetof(jl_datatype_t, hash) + sizeof(((jl_datatype_t*)nullptr)->hash));
cgutils.cpp:    assert(typ->getType() == T_prjlvalue);
cgutils.cpp:                Value *tempSpace = ctx.builder.CreateAlloca(a->getType());
cgutils.cpp:        ctx.f->getBasicBlockList().push_back(passBB);
cgutils.cpp:                num_elements = AT->getNumElements();
cgutils.cpp:                ElementCount EC = VT->getElementCount();
cgutils.cpp:                num_elements = VT->getNumElements();
cgutils.cpp:        for (Type *ElTy : T->subtypes()) {
cgutils.cpp:            if (isa<PointerType>(ElTy) && ElTy->getPointerAddressSpace() == AddressSpace::Tracked) {
cgutils.cpp:    auto path = first_ptr(V->getType());
cgutils.cpp:    if (!isboxed && Order != AtomicOrdering::NotAtomic && !elty->isIntOrPtrTy()) {
cgutils.cpp:        unsigned nb = cast<IntegerType>(elty)->getBitWidth();
cgutils.cpp:    Type *ptrty = PointerType::get(elty, ptr->getType()->getPointerAddressSpace());
cgutils.cpp:    if (ptr->getType() != ptrty)
cgutils.cpp:    //if (elty->isAggregateType() && tbaa == tbaa_immut && !alignment) { // can lazy load on demand, no copy needed
cgutils.cpp:        load->setOrdering(Order);
cgutils.cpp:            load->setMetadata("alias.scope", aliasscope);
cgutils.cpp:            ctx.builder.CreateStore(instr, ctx.builder.CreateBitCast(intcast, instr->getType()->getPointerTo()));
cgutils.cpp:        // NOTE: if we zero-initialize arrays, this optimization should become valid
cgutils.cpp:        //load->setMetadata(LLVMContext::MD_range, MDNode::get(jl_LLVMContext, {
cgutils.cpp:    if (!isboxed && Order != AtomicOrdering::NotAtomic && !elty->isIntOrPtrTy()) {
cgutils.cpp:        unsigned nb = cast<IntegerType>(elty)->getBitWidth();
cgutils.cpp:    Type *ptrty = PointerType::get(elty, ptr->getType()->getPointerAddressSpace());
cgutils.cpp:    if (ptr->getType() != ptrty)
cgutils.cpp:        ptr = ctx.builder.CreateInBoundsGEP(r->getType(), ptr, idx_0based);
cgutils.cpp:                load->setMetadata("noalias", aliasscope);
cgutils.cpp:        store->setOrdering(Order);
cgutils.cpp:            store->setMetadata("noalias", aliasscope);
cgutils.cpp:        store->setAlignment(Align(alignment));
cgutils.cpp:            store->setMetadata("noalias", aliasscope);
cgutils.cpp:                needloop = ((jl_datatype_t*)jltype)->layout->haspadding;
cgutils.cpp:                    load->setOrdering(FailOrder);
cgutils.cpp:                        load->setMetadata("noalias", aliasscope);
cgutils.cpp:                    Succ->addIncoming(ConstantInt::get(T_int1, false), SkipBB);
cgutils.cpp:                    Current = ctx.builder.CreatePHI(instr->getType(), 2);
cgutils.cpp:                    Current->addIncoming(instr, SkipBB);
cgutils.cpp:            Current->setOrdering(Order == AtomicOrdering::NotAtomic ? Order : AtomicOrdering::Monotonic);
cgutils.cpp:                Current->setMetadata("noalias", aliasscope);
cgutils.cpp:            CmpPhi->addIncoming(Compare, From);
cgutils.cpp:                ctx.builder.CreateStore(realCompare, ctx.builder.CreateBitCast(intcast, realCompare->getType()->getPointerTo()));
cgutils.cpp:                load->setMetadata("noalias", aliasscope);
cgutils.cpp:                CmpPhi->addIncoming(load, ctx.builder.GetInsertBlock());
cgutils.cpp:                store->setMetadata("noalias", aliasscope);
cgutils.cpp:            store->setAlignment(Align(alignment));
cgutils.cpp:                store->setMetadata("noalias", aliasscope);
cgutils.cpp:                    ctx.builder.CreateStore(realinstr, ctx.builder.CreateBitCast(intcast, realinstr->getType()->getPointerTo()));
cgutils.cpp:                CmpPhi->addIncoming(instr, ctx.builder.GetInsertBlock());
cgutils.cpp:            Current->addIncoming(instr, ctx.builder.GetInsertBlock());
cgutils.cpp:            Succ->addIncoming(Success, ctx.builder.GetInsertBlock());
cgutils.cpp:            ctx.builder.CreateStore(instr, ctx.builder.CreateBitCast(intcast, instr->getType()->getPointerTo()));
cgutils.cpp:// --- convert boolean value to julia ---
cgutils.cpp:// --- accessing the representations of built-in data types ---
cgutils.cpp:        auto srcty = cast<PointerType>(src->getType());
cgutils.cpp:        auto srcel = srcty->getElementType();
cgutils.cpp:        auto dstty = cast<PointerType>(dst->getType());
cgutils.cpp:        auto dstel = dstty->getElementType();
cgutils.cpp:        if (srcel->isArrayTy() && srcel->getArrayNumElements() == 1) {
cgutils.cpp:            srcel = srcel->getArrayElementType();
cgutils.cpp:            srcty = srcel->getPointerTo();
cgutils.cpp:        if (dstel->isArrayTy() && dstel->getArrayNumElements() == 1) {
cgutils.cpp:            dstel = dstel->getArrayElementType();
cgutils.cpp:            dstty = dstel->getPointerTo();
cgutils.cpp:        if (srcel->isSized() && srcel->isSingleValueType() && DL.getTypeStoreSize(srcel) == sz) {
cgutils.cpp:        else if (dstel->isSized() && dstel->isSingleValueType() &&
cgutils.cpp:        emit_memcpy_llvm(ctx, dst, tbaa_dst, src, tbaa_src, const_sz->getZExtValue(), align, is_volatile);
cgutils.cpp:    bool maybe_null = (unsigned)stt->name->n_uninitialized != 0;
cgutils.cpp:        bool issame = is_tupletype_homogeneous(stt->types);
cgutils.cpp:            jl_value_t *jft = jl_svecref(stt->types, 0);
cgutils.cpp:            if (isa<VectorType>(strct.V->getType())) {
cgutils.cpp:                assert(stt->layout->npointers == 0); // we could, but don't emit this
cgutils.cpp:            else if (isa<ArrayType>(strct.V->getType())) {
cgutils.cpp:                // fall-through to next branch, where we'll handle it
cgutils.cpp:        if (isboxed || (issame && isa<ArrayType>(strct.V->getType()))) {
cgutils.cpp:            assert((cast<ArrayType>(strct.V->getType())->getElementType() == T_prjlvalue) == isboxed);
cgutils.cpp:                        ctx.builder.CreateICmpEQ(idx, ConstantInt::get(idx->getType(), i)),
cgutils.cpp:            jl_value_t *jft = issame ? jl_svecref(stt->types, 0) : (jl_value_t*)jl_any_type;
cgutils.cpp:    bool maybeatomic = stt->name->atomicfields != NULL;
cgutils.cpp:            emit_atomic_error(ctx, "getfield: non-atomic field cannot be accessed atomically");
cgutils.cpp:            fld->setOrdering(AtomicOrdering::Unordered);
cgutils.cpp:        else if (is_tupletype_homogeneous(stt->types)) {
cgutils.cpp:            jl_value_t *jft = jl_svecref(stt->types, 0);
cgutils.cpp:            if (!stt->name->mutabl && !(maybe_null && (jft == (jl_value_t*)jl_bool_type ||
cgutils.cpp:                                                 ((jl_datatype_t*)jft)->layout->npointers))) {
cgutils.cpp:    //tindex0->setMetadata(LLVMContext::MD_range, MDNode::get(jl_LLVMContext, {
cgutils.cpp:        lv->setOperand(0, ConstantInt::get(T_int32, (fsz + al - 1) / al));
cgutils.cpp:        emit_atomic_error(ctx, "getfield: non-atomic field cannot be accessed atomically");
cgutils.cpp:        emit_atomic_error(ctx, "getfield: atomic field cannot be accessed non-atomically");
cgutils.cpp:    bool maybe_null = idx >= nfields - (unsigned)jt->name->n_uninitialized;
cgutils.cpp:            staddr = maybe_bitcast(ctx, staddr, lt->getPointerTo());
cgutils.cpp:            Load->setOrdering(order <= jl_memory_order_notatomic ? AtomicOrdering::Unordered : get_llvm_atomic_order(order));
cgutils.cpp:            assert(!isptr && fsz == jl_field_size(jt, idx) - 1); (void)isptr;
cgutils.cpp:            return emit_unionload(ctx, addr, ptindex, jfty, fsz, al, tbaa, jt->name->mutabl);
cgutils.cpp:        if (!jt->name->mutabl && !(maybe_null && (jfty == (jl_value_t*)jl_bool_type ||
cgutils.cpp:                                            ((jl_datatype_t*)jfty)->layout->npointers))) {
cgutils.cpp:        Type *T = obj->getType();
cgutils.cpp:            int fsz = jl_field_size(jt, idx) - 1;
cgutils.cpp:                IntegerType *ET = cast<IntegerType>(T->getStructElementType(st_idx));
cgutils.cpp:                unsigned align = (ET->getBitWidth() + 7) / 8;
cgutils.cpp:                lv->setOperand(0, ConstantInt::get(T_int32, (fsz + align - 1) / align));
cgutils.cpp:                // emit all of the align-sized words
cgutils.cpp:                if (i < ptindex - st_idx) {
cgutils.cpp:                    for (; i < ptindex - st_idx; i++) {
cgutils.cpp:    if (ctx.nvargs != -1) {
cgutils.cpp:                auto n = cast<ConstantInt>(dim)->getZExtValue() - 1;
cgutils.cpp:    int o = offsetof(jl_array_t, nrows) / sizeof(void*) - 1;
cgutils.cpp:            ctx.builder.CreateAdd(dim, ConstantInt::get(dim->getType(), o)),
cgutils.cpp:    load->setMetadata(LLVMContext::MD_range, rng);
cgutils.cpp:    len->setOrdering(AtomicOrdering::NotAtomic);
cgutils.cpp:    len->setMetadata(LLVMContext::MD_range, rng);
cgutils.cpp:        Value *alen = jl_Module->getOrInsertFunction("jl_array_len_", ft); // TODO: move to codegen init block
cgutils.cpp:    PointerType *PT = cast<PointerType>(addr->getType());
cgutils.cpp:    PointerType *PPT = cast<PointerType>(PT->getElementType());
cgutils.cpp:            PT->getAddressSpace()));
cgutils.cpp:    } else if (AS != PPT->getAddressSpace()) {
cgutils.cpp:                PointerType::get(PPT->getElementType(), AS),
cgutils.cpp:                PT->getAddressSpace()));
cgutils.cpp:    LI->setOrdering(AtomicOrdering::NotAtomic);
cgutils.cpp:    LI->setMetadata(LLVMContext::MD_nonnull, MDNode::get(jl_LLVMContext, None));
cgutils.cpp:    cast<LoadInst>(flags)->setMetadata(LLVMContext::MD_invariant_load, MDNode::get(jl_LLVMContext, None));
cgutils.cpp:    flags = ctx.builder.CreateAnd(flags, 0x1FF); // (1<<9) - 1
cgutils.cpp:    if (nd != -1 && nd != 1) // only Vector can have an offset
cgutils.cpp:// `nd == -1` means the dimension is unknown.
cgutils.cpp:        if (k < nidxs - 1) {
cgutils.cpp:                ctx.f->getBasicBlockList().push_back(okBB);
cgutils.cpp:            ctx.f->getBasicBlockList().push_back(checktrailingdimsBB);
cgutils.cpp:                ctx.f->getBasicBlockList().push_back(dimsokBB);
cgutils.cpp:        ctx.f->getBasicBlockList().push_back(failBB);
cgutils.cpp:        ctx.f->getBasicBlockList().push_back(endBB);
cgutils.cpp:// --- boxing ---
cgutils.cpp:                            unsigned alignment = sizeof(void*)) // min alignment in julia's gc is pointer-aligned
cgutils.cpp:        PointerType::get(v->getType(), 0)), Align(alignment)));
cgutils.cpp:            return cint->isZero() ? jl_false : jl_true;
cgutils.cpp:            const_cast<uint64_t *>(cint->getValue().getRawData()));
cgutils.cpp:            const_cast<uint64_t *>(cfp->getValueAPF().bitcastToAPInt().getRawData()));
cgutils.cpp:        unsigned OpCode = ce->getOpcode();
cgutils.cpp:            return static_constant_instance(ce->getOperand(0), jt);
cgutils.cpp:        nargs = CC->getNumOperands();
cgutils.cpp:        nargs = CAZ->getElementCount().getFixedValue();
cgutils.cpp:        nargs = CAZ->getNumElements();
cgutils.cpp:        nargs = CDS->getNumElements();
cgutils.cpp:    assert(nargs > 0 && jst->instance == NULL);
cgutils.cpp:        if (i > 0 && isa<StructType>(constant->getType()))
cgutils.cpp:            llvm_idx = convert_struct_offset(constant->getType(), jl_field_offset(jst, i));
cgutils.cpp:        Constant *fld = constant->getAggregateElement(llvm_idx);
cgutils.cpp:    Call->setAttributes(F->getAttributes());
cgutils.cpp:// some types have special boxing functions with small-value caches
cgutils.cpp:    if (ctx.linfo && jl_is_method(ctx.linfo->def.method) && !vinfo.ispointer()) { // don't bother codegen pre-boxing for toplevel
cgutils.cpp:        assert(v->getType() == ctx.emission_context.llvmtypes[jl_ssavalue_type]);
cgutils.cpp:    else if (!jb->name->abstract && jl_datatype_nbits(jb) == 0) {
cgutils.cpp:        assert(jb->instance != NULL);
cgutils.cpp:        return track_pjlvalue(ctx, literal_pointer_val(ctx, jb->instance));
cgutils.cpp:    Value *isnull = ctx.builder.CreateICmpEQ(v, Constant::getNullValue(v->getType()));
cgutils.cpp:    PHINode *ti = ctx.builder.CreatePHI(typof->getType(), 2);
cgutils.cpp:    ti->addIncoming(Constant::getNullValue(typof->getType()), entry);
cgutils.cpp:    ti->addIncoming(typof, nonnull);
cgutils.cpp:        Type *AT = ArrayType::get(IntegerType::get(jl_LLVMContext, 8 * min_align), (nbytes + min_align - 1) / min_align);
cgutils.cpp:            lv->setAlignment(Align(align));
cgutils.cpp:                switchInst->addCase(ConstantInt::get(T_int8, idx), tempBB);
cgutils.cpp:                    box = track_pjlvalue(ctx, literal_pointer_val(ctx, jt->instance));
cgutils.cpp:                box_merge->addIncoming(box, tempBB);
cgutils.cpp:        box_merge->addIncoming(V_rnull, defaultBB);
cgutils.cpp:                ctx.f->getParent(),
cgutils.cpp:        box_merge->addIncoming(vinfo.Vboxed, defaultBB);
cgutils.cpp:    llvm::Module* M = ctx.f->getParent();
cgutils.cpp:    GlobalVariable* gv = cast_or_null<GlobalVariable>(M->getNamedValue(nameref));
cgutils.cpp:// dynamically-typed value is required (e.g. argument to unknown function).
cgutils.cpp:        assert(vinfo.V->getType() == T_prjlvalue);
cgutils.cpp:        ctx.builder.CreateAlignedStore(UndefValue::get(ai->getAllocatedType()), ai, ai->getAlign());
cgutils.cpp:                    //   select copy dest -> dest to simulate an undef value / conditional copy
cgutils.cpp:                    switchInst->addCase(ConstantInt::get(T_int8, idx), tempBB);
cgutils.cpp:                                Intrinsic::getDeclaration(ctx.f->getParent(), Intrinsic::trap);
cgutils.cpp:                    ctx.f->getParent(),
cgutils.cpp:            copy_bytes = ctx.builder.CreateSelect(skip, ConstantInt::get(copy_bytes->getType(), 0), copy_bytes);
cgutils.cpp:        emit_memcpy(ctx, dest, tbaa_dst, src, copy_bytes, /*TODO: min-align*/1, isVolatile);
cgutils.cpp:    ctx.f->getBasicBlockList().push_back(passBB);
cgutils.cpp:    call->setAttributes(F->getAttributes());
cgutils.cpp:    call->setAttributes(F->getAttributes());
cgutils.cpp:    if (!typ->layout || typ->layout->npointers == 0)
cgutils.cpp:    size_t nf = jl_svec_len(typ->types);
cgutils.cpp:        jl_value_t *_fld = jl_svecref(typ->types, i);
cgutils.cpp:            // pointer field, check if field is perm-alloc
cgutils.cpp:    if (jltype && jl_is_datatype(jltype) && ((jl_datatype_t*)jltype)->layout)
cgutils.cpp:    auto ptrs = ExtractTrackedValues(agg, agg->getType(), false, ctx.builder, perm_offsets);
cgutils.cpp:    if (!sty->name->mutabl && checked) {
cgutils.cpp:            + std::string(jl_symbol_name(sty->name->name))
cgutils.cpp:    jl_value_t *jfty = jl_svecref(sty->types, idx0);
cgutils.cpp:        assert(!isptr && fsz == jl_field_size(sty, idx0) - 1); (void)isptr;
cgutils.cpp:        bool maybe_null = idx0 >= nfields - (unsigned)sty->name->n_uninitialized;
cgutils.cpp:    if (nf > 0 || sty->name->mutabl) {
cgutils.cpp:            if (lt->isVectorTy() || jl_is_vecelement_type(ty)) { // maybe also check the size ?
cgutils.cpp:                jl_value_t *jtype = jl_svecref(sty->types, i);
cgutils.cpp:                                ->setOrdering(AtomicOrdering::Unordered);
cgutils.cpp:                    assert(!isptr && fsz == jl_field_size(sty, i) - 1); (void)isptr;
cgutils.cpp:                        // would need to emit the union-move into temporary memory,
cgutils.cpp:                            assert(lt->getStructElementType(llvm_idx) == ET);
cgutils.cpp:                            lv->setOperand(0, ConstantInt::get(T_int32, (fsz + al - 1) / al));
cgutils.cpp:                            // emit all of the align-sized words
cgutils.cpp:                            if (i < ptindex - llvm_idx) {
cgutils.cpp:                                for (; i < ptindex - llvm_idx; i++) {
cgutils.cpp:                    else if (lt->isVectorTy())
cgutils.cpp:                    else if (lt->isAggregateType())
cgutils.cpp:                    int fsz = jl_field_size(sty, i) - 1;
cgutils.cpp:                return mark_julia_const(sty->instance);
cgutils.cpp:                                ConstantInt::get(T_size, jl_field_offset(sty, i) + jl_field_size(sty, i) - 1)),
cgutils.cpp:        // TODO: verify that nargs <= nf (currently handled by front-end)
cgutils.cpp:            emit_typecheck(ctx, rhs, jl_svecref(sty->types, i), "new");
cgutils.cpp:           (a->track_allocations == b->track_allocations) &&
cgutils.cpp:           (a->code_coverage == b->code_coverage) &&
cgutils.cpp:           (a->prefer_specsig == b->prefer_specsig) &&
cgutils.cpp:           (a->gnu_pubnames == b->gnu_pubnames) &&
cgutils.cpp:           (a->debug_info_kind == b->debug_info_kind) &&
cgutils.cpp:           (a->lookup == b->lookup) &&
cgutils.cpp:           (a->generic_context == b->generic_context);
gc-pages.c:                            MAP_NORESERVE | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
gc-pages.c:        // round data pointer up to the nearest gc_page_data-aligned
gc-pages.c:        mem = (char*)gc_page_data(mem + GC_PAGE_SZ - 1);
gc-pages.c:            if ((info.pagetable1->freemap0[info.pagetable1_i32] & msk) == 0)
gc-pages.c:                info.pagetable1->freemap0[info.pagetable1_i32] |= msk; // has free
gc-pages.c:            info.pagetable0 = *(ppagetable0 = &info.pagetable1->meta0[i]);
gc-pages.c:            info.pagetable0->freemap[info.pagetable0_i32] |= msk; // is free
gc-pages.c:            pmeta = &info.pagetable0->meta[i];
gc-pages.c:               GC_PAGE_SZ * pg_cnt - LLT_ALIGN(GC_PAGE_SZ * pg, jl_page_size));
gc-pages.c:    // scan over memory_map page-table for existing allocated but unused pages
gc-pages.c:            // repeat over page-table level 1
gc-pages.c:            for (info.pagetable1_i32 = info.pagetable1->lb; info.pagetable1_i32 < REGION1_PG_COUNT / 32; info.pagetable1_i32++) {
gc-pages.c:                uint32_t freemap0 = info.pagetable1->freemap0[info.pagetable1_i32];
gc-pages.c:                    info.pagetable0 = info.pagetable1->meta0[info.pagetable1_i + info.pagetable1_i32 * 32];
gc-pages.c:                    // repeat over page-table level 0
gc-pages.c:                    for (info.pagetable0_i32 = info.pagetable0->lb; info.pagetable0_i32 < REGION0_PG_COUNT / 32; info.pagetable0_i32++) {
gc-pages.c:                        uint32_t freemap = info.pagetable0->freemap[info.pagetable0_i32];
gc-pages.c:                            info.meta = info.pagetable0->meta[info.pagetable0_i + info.pagetable0_i32 * 32];
gc-pages.c:                            assert(info.meta->data);
gc-pages.c:                            if (info.pagetable1->lb < info.pagetable1_i32)
gc-pages.c:                                info.pagetable1->lb = info.pagetable1_i32;
gc-pages.c:                            if (info.pagetable0->lb < info.pagetable0_i32)
gc-pages.c:                                info.pagetable0->lb = info.pagetable0_i32;
gc-pages.c:                    info.pagetable1->freemap0[info.pagetable1_i32] &= ~(uint32_t)(1u << info.pagetable1_i); // record that this was full
gc-pages.c:        info = page_metadata_ext(meta->data);
gc-pages.c:        if (info.pagetable1->lb > info.pagetable1_i32)
gc-pages.c:            info.pagetable1->lb = info.pagetable1_i32;
gc-pages.c:        if (info.pagetable0->lb > info.pagetable0_i32)
gc-pages.c:            info.pagetable0->lb = info.pagetable0_i32;
gc-pages.c:    // in-use pages are now ending at min of ub and pagetable_i32
gc-pages.c:    if (info.pagetable1->ub < info.pagetable1_i32)
gc-pages.c:        info.pagetable1->ub = info.pagetable1_i32;
gc-pages.c:    if (info.pagetable0->ub < info.pagetable0_i32)
gc-pages.c:        info.pagetable0->ub = info.pagetable0_i32;
gc-pages.c:    // mark this entry as in-use and not free
gc-pages.c:    info.pagetable0->freemap[info.pagetable0_i32] &= ~(uint32_t)(1u << info.pagetable0_i);
gc-pages.c:    info.pagetable0->allocmap[info.pagetable0_i32] |= (uint32_t)(1u << info.pagetable0_i);
gc-pages.c:    info.pagetable1->allocmap0[info.pagetable1_i32] |= (uint32_t)(1u << info.pagetable1_i);
gc-pages.c:    VirtualAlloc(info.meta->data, GC_PAGE_SZ, MEM_COMMIT, PAGE_READWRITE);
gc-pages.c:    assert(!(info.pagetable0->freemap[info.pagetable0_i32] & msk));
gc-pages.c:    assert(info.pagetable0->allocmap[info.pagetable0_i32] & msk);
gc-pages.c:    info.pagetable0->allocmap[info.pagetable0_i32] &= ~msk;
gc-pages.c:    info.pagetable0->freemap[info.pagetable0_i32] |= msk;
gc-pages.c:    assert(info.pagetable1->allocmap0[info.pagetable1_i32] & msk);
gc-pages.c:    if ((info.pagetable1->freemap0[info.pagetable1_i32] & msk) == 0)
gc-pages.c:        info.pagetable1->freemap0[info.pagetable1_i32] |= msk;
gc-pages.c:    free(info.meta->ages);
gc-pages.c:    info.meta->ages = NULL;
gc-pages.c:        void *otherp = (void*)((uintptr_t)p & ~(jl_page_size - 1)); // round down to the nearest physical page
gc-pages.c:        while (n_pages--) {
gc-pages.c:            if (info.pagetable0->allocmap[info.pagetable0_i32] & msk)
gc-pages.c:    if (info.pagetable1->lb > info.pagetable1_i32)
gc-pages.c:        info.pagetable1->lb = info.pagetable1_i32;
gc-pages.c:    if (info.pagetable0->lb > info.pagetable0_i32)
gc-pages.c:        info.pagetable0->lb = info.pagetable0_i32;
gc-pages.c:    current_pg_count--;
llvm-lower-handlers.cpp:#include "llvm-version.h"
llvm-lower-handlers.cpp:#include <llvm-c/Core.h>
llvm-lower-handlers.cpp:#include <llvm-c/Types.h>
llvm-lower-handlers.cpp: *  - All EH frames are completely nested.
llvm-lower-handlers.cpp: *  - The exception nestedness of a BB is not dynamic. I.e. we don't allow
llvm-lower-handlers.cpp: * handler structures to tell LLVM that it is free to re-use the stack slot
llvm-lower-handlers.cpp:            ->addFnAttr(Attribute::ReturnsTwice);
llvm-lower-handlers.cpp:                Depth = it->second;
llvm-lower-handlers.cpp:            Function *Callee = CI->getCalledFunction();
llvm-lower-handlers.cpp:                Depth -= cast<ConstantInt>(CI->getArgOperand(0))->getLimitedValue();
llvm-lower-handlers.cpp:        sj->setCanReturnTwice();
llvm-lower-handlers.cpp:        if (auto dbg = enter->getMetadata(LLVMContext::MD_dbg)) {
llvm-lower-handlers.cpp:            new_enter->setMetadata(LLVMContext::MD_dbg, dbg);
llvm-lower-handlers.cpp:            sj->setMetadata(LLVMContext::MD_dbg, dbg);
llvm-lower-handlers.cpp:        enter->replaceAllUsesWith(sj);
llvm-lower-handlers.cpp:        enter->eraseFromParent();
llvm-lower-handlers.cpp:        int StartDepth = it.second - 1;
llvm-lower-handlers.cpp:        int npops = cast<ConstantInt>(it.first->getArgOperand(0))->getLimitedValue();
llvm-lower-handlers.cpp:            assert(StartDepth-i >= 0);
llvm-lower-handlers.cpp:                buffs[StartDepth-i]
llvm-lower-handlers.cpp:            LifetimeEnd->insertAfter(it.first);
llvm-lower-handlers.cpp:    unwrap(PM)->add(createLowerExcHandlersPass());
jltypes.c:// compute empirical max-probe for a given size
jltypes.c:#define h2index(hv, sz) (size_t)((hv) & ((sz)-1))
jltypes.c:// --- type properties and predicates ---
jltypes.c:        if (env->var == v)
jltypes.c:        env = env->prev;
jltypes.c:        return layout_uses_free_typevars(((jl_uniontype_t*)v)->a, env) ||
jltypes.c:               layout_uses_free_typevars(((jl_uniontype_t*)v)->b, env);
jltypes.c:        if (vm->T) {
jltypes.c:            if (layout_uses_free_typevars(vm->T, env))
jltypes.c:            if (vm->N && layout_uses_free_typevars(vm->N, env))
jltypes.c:        jl_typeenv_t newenv = { ua->var, NULL, env };
jltypes.c:        return layout_uses_free_typevars(ua->body, &newenv);
jltypes.c:        if (dt->layout || dt->isconcretetype || !dt->name->mayinlinealloc)
jltypes.c:                // This might be inline-alloc, but we don't know the layout
jltypes.c:        return has_free_typevars(((jl_uniontype_t*)v)->a, env) ||
jltypes.c:            has_free_typevars(((jl_uniontype_t*)v)->b, env);
jltypes.c:        if (vm->T) {
jltypes.c:            if (has_free_typevars(vm->T, env))
jltypes.c:            return vm->N && has_free_typevars(vm->N, env);
jltypes.c:        jl_typeenv_t newenv = { ua->var, NULL, env };
jltypes.c:        return has_free_typevars(ua->var->lb, env) || has_free_typevars(ua->var->ub, env) ||
jltypes.c:            has_free_typevars(ua->body, &newenv);
jltypes.c:        int expect = ((jl_datatype_t*)v)->hasfreetypevars;
jltypes.c:        find_free_typevars(((jl_uniontype_t*)v)->a, env, out);
jltypes.c:        find_free_typevars(((jl_uniontype_t*)v)->b, env, out);
jltypes.c:        if (vm->T) {
jltypes.c:            find_free_typevars(vm->T, env, out);
jltypes.c:            if (vm->N) {
jltypes.c:                find_free_typevars(vm->N, env, out);
jltypes.c:        jl_typeenv_t newenv = { ua->var, NULL, env };
jltypes.c:        find_free_typevars(ua->var->lb, env, out);
jltypes.c:        find_free_typevars(ua->var->ub, env, out);
jltypes.c:        find_free_typevars(ua->body, &newenv, out);
jltypes.c:        if (!((jl_datatype_t*)v)->hasfreetypevars)
jltypes.c:        return jl_has_bound_typevars(((jl_uniontype_t*)v)->a, env) ||
jltypes.c:            jl_has_bound_typevars(((jl_uniontype_t*)v)->b, env);
jltypes.c:        return vm->T && (jl_has_bound_typevars(vm->T, env) ||
jltypes.c:            (vm->N && jl_has_bound_typevars(vm->N, env)));
jltypes.c:        if (jl_has_bound_typevars(ua->var->lb, env) || jl_has_bound_typevars(ua->var->ub, env))
jltypes.c:            if (te->var == ua->var)
jltypes.c:            te = te->prev;
jltypes.c:        if (te) te->var = NULL;  // temporarily remove this var from env
jltypes.c:        int ans = jl_has_bound_typevars(ua->body, env);
jltypes.c:        if (te) te->var = ua->var;
jltypes.c:        if (!((jl_datatype_t*)v)->hasfreetypevars)
jltypes.c:    jl_typeenv_t env = { ua->var, NULL, prev };
jltypes.c:    if (jl_is_unionall(ua->body))
jltypes.c:        return _jl_has_typevar_from_ua(t, (jl_unionall_t*)ua->body, &env);
jltypes.c:    if (dt->layout || dt->isconcretetype)
jltypes.c:    if (dt->name->abstract)
jltypes.c:            // This might be inline-alloc, but we don't know the layout
jltypes.c:// --- type union ---
jltypes.c:            c += count_union_components(&u->a, 1);
jltypes.c:            c += count_union_components(&u->b, 1);
jltypes.c:    return jl_count_union_components(u->a) + jl_count_union_components(u->b);
jltypes.c:        (*pi)--;
jltypes.c:    jl_value_t *a = nth_union_component(u->a, pi);
jltypes.c:    return nth_union_component(u->b, pi);
jltypes.c:        if (jl_find_union_component(((jl_uniontype_t*)haystack)->a, needle, nth))
jltypes.c:        if (jl_find_union_component(((jl_uniontype_t*)haystack)->b, needle, nth))
jltypes.c:            flatten_type_union(&u->a, 1, out, idx);
jltypes.c:            flatten_type_union(&u->b, 1, out, idx);
jltypes.c:    if (((jl_datatype_t*)t)->name->module == NULL)
jltypes.c:    return jl_symbol_name(((jl_datatype_t*)t)->name->module->name);
jltypes.c:    return a < b ? -1 : a > b;
jltypes.c:        return -1;
jltypes.c:        return -1;
jltypes.c:            return -1;
jltypes.c:            return -1;
jltypes.c:            return -1;
jltypes.c:    for (k = (int)nt-1; k >= 0; --k) {
jltypes.c:// unionall types -------------------------------------------------------------
jltypes.c:        int T_has_tv = vm->T && jl_has_typevar(vm->T, v);
jltypes.c:        int N_has_tv = vm->N && jl_has_typevar(vm->N, v);
jltypes.c:            jl_value_t *wrapped = jl_type_unionall(v, vm->T);
jltypes.c:            wrapped = (jl_value_t*)jl_wrap_vararg(wrapped, vm->N);
jltypes.c:            assert(vm->N == (jl_value_t*)v);
jltypes.c:            return (jl_value_t*)jl_wrap_vararg(vm->T, NULL);
jltypes.c:        return v->ub;
jltypes.c:    //if (v->lb == v->ub)  // TODO maybe
jltypes.c:    //    return jl_substitute_var(body, v, v->ub);
jltypes.c:// --- type instantiation and cache ---
jltypes.c:    if (tt->name == jl_type_typename) {
jltypes.c:        jl_value_t *tj = jl_svecref(tt->parameters, j);
jltypes.c:    if (leaf && tt->name == jl_type_typename) {
jltypes.c:        jl_value_t *kj = j == 0 ? key1 : key[j - 1];
jltypes.c:        jl_value_t *tj = jl_svecref(tt->parameters, j);
jltypes.c:        if ((jl_value_t*)val != jl_nothing && val->hash == hv && typekey_eq(val, key, n))
jltypes.c:        index = (index + 1) & (sz - 1);
jltypes.c:        if ((jl_value_t*)val != jl_nothing && val->hash == hv && typekeyvalue_eq(val, key1, key, n, leaf))
jltypes.c:        index = (index + 1) & (sz - 1);
jltypes.c:        return -1;
jltypes.c:        return -1;
jltypes.c:        jl_svec_t *cache = jl_atomic_load_relaxed(&tn->cache);
jltypes.c:        jl_svec_t *linearcache = jl_atomic_load_relaxed(&tn->linearcache);
jltypes.c:        jl_svec_t *cache = jl_atomic_load_relaxed(&tn->cache);
jltypes.c:        jl_svec_t *linearcache = jl_atomic_load_relaxed(&tn->linearcache);
jltypes.c:        index = (index + 1) & (sz - 1);
jltypes.c:    jl_svec_t *a = jl_atomic_load_relaxed(&val->name->cache);
jltypes.c:        jl_atomic_store_release(&val->name->cache, a);
jltypes.c:        jl_gc_wb(val->name, a);
jltypes.c:                uint_t hv = ((jl_datatype_t*)val)->hash;
jltypes.c:    jl_svec_t *cache = jl_atomic_load_relaxed(&type->name->linearcache);
jltypes.c:    if (n == 0 || jl_svecref(cache, n - 1) != NULL) {
jltypes.c:        jl_atomic_store_release(&type->name->linearcache, nc);
jltypes.c:        jl_gc_wb(type->name, nc);
jltypes.c:    jl_svecset(cache, insert_at, (jl_value_t*)type); // todo: make this an atomic-store
jltypes.c:    jl_value_t **key = jl_svec_data(type->parameters);
jltypes.c:    int n = jl_svec_len(type->parameters);
jltypes.c:    unsigned hv = typekey_hash(type->name, key, n, 0);
jltypes.c:        assert(hv == type->hash);
jltypes.c:        ssize_t idx = lookup_type_idx_linear(jl_atomic_load_relaxed(&type->name->linearcache), key, n);
jltypes.c:    jl_value_t **key = jl_svec_data(type->parameters);
jltypes.c:    int n = jl_svec_len(type->parameters);
jltypes.c:    return (jl_datatype_t*)lookup_type(type->name, key, n);
jltypes.c:    return dt1->cached_by_hash == dt2->cached_by_hash;
jltypes.c:        //lb = ((jl_tvar_t*)t)->lb;
jltypes.c:        //ub = ((jl_tvar_t*)t)->ub;
jltypes.c:    jl_typeenv_t e = { ua->var, iparams[c], env };
jltypes.c:    return inst_datatype_env(ua->body, p, iparams, ntp, stack, &e, c + 1);
jltypes.c:            ((jl_datatype_t*)u)->name->wrapper == tc) {
jltypes.c:        tc0 = ((jl_unionall_t*)tc0)->body;
jltypes.c:        if (!jl_has_free_typevars(ua->var->lb) && !jl_has_free_typevars(ua->var->ub) &&
jltypes.c:            !within_typevar(pi, ua->var->lb, ua->var->ub)) {
jltypes.c:                jl_value_t *temp = inner->name->wrapper;
jltypes.c:                    temp = ((jl_unionall_t*)temp)->body;
jltypes.c:                jl_type_error_rt(jl_is_datatype(inner) ? jl_symbol_name(inner->name->name) : "Type",
jltypes.c:                                 jl_symbol_name(ua->var->name), (jl_value_t*)ua->var, pi);
jltypes.c:    jl_typeenv_t env = { u->var, p, NULL };
jltypes.c:    return inst_type_w_(u->body, &env, NULL, 1);
jltypes.c:        v = ((jl_unionall_t*)v)->body;
jltypes.c:    t = jl_rewrap_unionall(t, ((jl_unionall_t*)u)->body);
jltypes.c:    t = jl_new_struct(jl_unionall_type, ((jl_unionall_t*)u)->var, t);
jltypes.c:    jl_typename_t *tn = tt->name;
jltypes.c:        JL_GC_PROMISE_ROOTED(stack->tt);
jltypes.c:        if (stack->tt->name == tn &&
jltypes.c:            ntp == jl_svec_len(stack->tt->parameters) &&
jltypes.c:            typekey_eq(stack->tt, iparams, ntp)) {
jltypes.c:            return (jl_value_t*)stack->tt;
jltypes.c:        stack = stack->prev;
jltypes.c:// stable numbering for types--starts with name->hash, then falls back to objectid
jltypes.c:        unsigned hash = dt->hash;
jltypes.c:            hash = typekey_hash(dt->name, jl_svec_data(dt->parameters), jl_svec_len(dt->parameters), *failed);
jltypes.c:        return type_hash(((jl_tvar_t*)uw)->ub, failed);
jltypes.c:        return bitmix(type_hash(vm->T ? vm->T : (jl_value_t*)jl_any_type, failed), vm->N ? type_hash(vm->N, failed) : 0x064eeaab);
jltypes.c:        unsigned hasha = type_hash(((jl_uniontype_t*)uw)->a, failed);
jltypes.c:        unsigned hashb = type_hash(((jl_uniontype_t*)uw)->b, failed);
jltypes.c:        // use a associative mixing function, with well-defined overflow
jltypes.c:        return jl_typeofbottom_type->hash;
jltypes.c:    hash = bitmix(~tn->hash, hash);
jltypes.c:        jl_value_t *kj = j == 0 ? key1 : key[j - 1];
jltypes.c:            hj = ((jl_datatype_t*)jl_typeof(kj))->hash;
jltypes.c:    hash = bitmix(~tn->hash, hash);
jltypes.c:    int istuple = (dt->name == jl_tuple_typename);
jltypes.c:    dt->hasfreetypevars = 0;
jltypes.c:    dt->isconcretetype = !dt->name->abstract;
jltypes.c:    dt->isdispatchtuple = istuple;
jltypes.c:        if (!dt->hasfreetypevars) {
jltypes.c:            dt->hasfreetypevars = jl_has_free_typevars(p);
jltypes.c:            if (dt->hasfreetypevars)
jltypes.c:                dt->isconcretetype = 0;
jltypes.c:        if (istuple && dt->isconcretetype)
jltypes.c:            dt->isconcretetype = (jl_is_datatype(p) && ((jl_datatype_t*)p)->isconcretetype) || p == jl_bottom_type;
jltypes.c:        if (dt->isdispatchtuple) {
jltypes.c:            dt->isdispatchtuple = jl_is_datatype(p) &&
jltypes.c:                ((!jl_is_kind(p) && ((jl_datatype_t*)p)->isconcretetype) ||
jltypes.c:                 (((jl_datatype_t*)p)->name == jl_type_typename && !((jl_datatype_t*)p)->hasfreetypevars));
jltypes.c:        if (istuple && dt->has_concrete_subtype) {
jltypes.c:                p = ((jl_vararg_t*)p)->T;
jltypes.c:                dt->has_concrete_subtype = 0;
jltypes.c:    if (dt->name == jl_type_typename)
jltypes.c:    dt->hash = typekey_hash(dt->name, jl_svec_data(dt->parameters), l, cacheable);
jltypes.c:    dt->cached_by_hash = cacheable ? (typekey_hash(dt->name, jl_svec_data(dt->parameters), l, 0) != 0) : (dt->hash != 0);
jltypes.c:    jl_value_t *wrapper = tn->wrapper;
jltypes.c:        jl_tvar_t *tv = ((jl_unionall_t*)wrapper)->var;
jltypes.c:        bounds[i++] = tv->lb;
jltypes.c:        bounds[i++] = tv->ub;
jltypes.c:        wrapper = ((jl_unionall_t*)wrapper)->body;
jltypes.c:    wrapper = tn->wrapper;
jltypes.c:        jl_tvar_t *tv = ((jl_unionall_t*)wrapper)->var;
jltypes.c:            if (tv->lb != bounds[2*i] || tv->ub != bounds[2*i+1])
jltypes.c:                tv = jl_new_typevar(tv->name, bounds[2*i], bounds[2*i+1]);
jltypes.c:            jl_type_error_rt(jl_symbol_name(tn->name), jl_symbol_name(tv->name), (jl_value_t*)tv, params[i]);
jltypes.c:        wrapper = ((jl_unionall_t*)wrapper)->body;
jltypes.c:        return ((jl_datatype_t*)t)->name->wrapper;
jltypes.c:        jl_value_t *n1 = extract_wrapper(((jl_uniontype_t*)t)->a);
jltypes.c:        return extract_wrapper(((jl_uniontype_t*)t)->b);
jltypes.c:        return extract_wrapper(((jl_tvar_t*)t)->ub);
jltypes.c:            return *cov_count <= 1 || jl_is_concrete_type(var->ub);
jltypes.c:        return _may_substitute_ub(((jl_uniontype_t*)v)->a, var, inside_inv, cov_count) &&
jltypes.c:            _may_substitute_ub(((jl_uniontype_t*)v)->b, var, inside_inv, cov_count);
jltypes.c:        if (ua->var == var)
jltypes.c:        return _may_substitute_ub(ua->var->lb, var, inside_inv, cov_count) &&
jltypes.c:            _may_substitute_ub(ua->var->ub, var, inside_inv, cov_count) &&
jltypes.c:            _may_substitute_ub(ua->body, var, inside_inv, cov_count);
jltypes.c:        if (va->T && !_may_substitute_ub(va->T, var, inside_inv, cov_count))
jltypes.c:        if (*cov_count > old_count && !jl_is_concrete_type(var->ub))
jltypes.c:        if (va->N && !_may_substitute_ub(va->N, var, 1, cov_count))
jltypes.c:        a = normalize_unionalls(u->a);
jltypes.c:        b = normalize_unionalls(u->b);
jltypes.c:        if (a != u->a || b != u->b) {
jltypes.c:        jl_value_t *body = normalize_unionalls(u->body);
jltypes.c:        if (body != u->body) {
jltypes.c:            t = jl_new_struct(jl_unionall_type, u->var, body);
jltypes.c:        if (u->var->lb == u->var->ub || may_substitute_ub(body, u->var)) {
jltypes.c:                t = jl_instantiate_unionall(u, u->var->ub);
jltypes.c:    jl_typename_t *tn = dt->name;
jltypes.c:    if (dt->name != jl_type_typename) {
jltypes.c:    jl_value_t *last = iparams[ntp - 1];
jltypes.c:                p = jl_alloc_svec(ntp - 1 + nt);
jltypes.c:                for (i = 0, l = ntp - 1; i < l; i++)
jltypes.c:                l = ntp - 1 + nt;
jltypes.c:    ndt->name = tn;
jltypes.c:    jl_gc_wb(ndt, ndt->name);
jltypes.c:    ndt->super = NULL;
jltypes.c:    ndt->parameters = p;
jltypes.c:    jl_gc_wb(ndt, ndt->parameters);
jltypes.c:    ndt->types = NULL; // to be filled in below
jltypes.c:        ndt->types = p; // TODO: this may need to filter out certain types
jltypes.c:            ndt->types = ((jl_datatype_t*)values_tt)->parameters;
jltypes.c:            jl_gc_wb(ndt, ndt->types);
jltypes.c:            ndt->types = jl_emptysvec; // XXX: this is essentially always false
jltypes.c:    jl_datatype_t *primarydt = ((jl_datatype_t*)jl_unwrap_unionall(tn->wrapper));
jltypes.c:    ndt->size = 0;
jltypes.c:    if (primarydt->layout)
jltypes.c:        ndt->super = jl_any_type;
jltypes.c:    else if (dt->super) {
jltypes.c:        ndt->super = (jl_datatype_t*)inst_type_w_((jl_value_t*)dt->super, env, stack, 1);
jltypes.c:        jl_gc_wb(ndt, ndt->super);
jltypes.c:    jl_svec_t *ftypes = dt->types;
jltypes.c:        ftypes = primarydt->types;
jltypes.c:    if (ftypes == NULL || dt->super == NULL) {
jltypes.c:        if (tn->partial == NULL) {
jltypes.c:            tn->partial = jl_alloc_vec_any(0);
jltypes.c:            jl_gc_wb(tn, tn->partial);
jltypes.c:        jl_array_ptr_1d_push(tn->partial, (jl_value_t*)ndt);
jltypes.c:        assert(ftypes == jl_emptysvec || !ndt->name->abstract);
jltypes.c:            ndt->types = ftypes;
jltypes.c:            if (dt->types == NULL)
jltypes.c:                ndt->types = jl_compute_fieldtypes(ndt, stack);
jltypes.c:                ndt->types = inst_ftypes(ftypes, env, stack);
jltypes.c:            jl_gc_wb(ndt, ndt->types);
jltypes.c:        if (ndt->layout == NULL && ndt->types != NULL && ndt->isconcretetype)
jltypes.c:            jl_value_t *ai = (i == 0 ? arg1 : args[i - 1]);
jltypes.c:    jl_svec_t *tp = tt->parameters;
jltypes.c:        // a fixed-length tuple
jltypes.c:            if ((jl_value_t*)e->var == ttT)
jltypes.c:                T = e->val;
jltypes.c:            else if ((jl_value_t*)e->var == ttN)
jltypes.c:                N = e->val;
jltypes.c:            e = e->prev;
jltypes.c:            if (e->var == (jl_tvar_t*)t) {
jltypes.c:                jl_value_t *val = e->val;
jltypes.c:            e = e->prev;
jltypes.c:        lb = inst_type_w_(ua->var->lb, env, stack, check);
jltypes.c:        var = inst_type_w_(ua->var->ub, env, stack, check);
jltypes.c:        if (lb != ua->var->lb || var != ua->var->ub) {
jltypes.c:            var = (jl_value_t*)jl_new_typevar(ua->var->name, lb, var);
jltypes.c:            var = (jl_value_t*)ua->var;
jltypes.c:        jl_typeenv_t newenv = { ua->var, var, env };
jltypes.c:        newbody = inst_type_w_(ua->body, &newenv, stack, check);
jltypes.c:        else if (newbody != ua->body || var != (jl_value_t*)ua->var) {
jltypes.c:        jl_value_t *a = inst_type_w_(u->a, env, stack, check);
jltypes.c:        b = inst_type_w_(u->b, env, stack, check);
jltypes.c:        if (a != u->a || b != u->b) {
jltypes.c:        if (v->T) {
jltypes.c:            T = inst_type_w_(v->T, env, stack, check);
jltypes.c:            if (v->N)
jltypes.c:                N = inst_type_w_(v->N, env, stack, check);
jltypes.c:        if (T != v->T || N != v->N) {
jltypes.c:    jl_svec_t *tp = tt->parameters;
jltypes.c:    jl_typename_t *tn = tt->name;
jltypes.c:        return instantiate_with(t, &env[2], n-1, &en );
jltypes.c:    jl_typeenv_t en = { env->var, vals[0], prev };
jltypes.c:    if (jl_is_unionall(env->body))
jltypes.c:        return _jl_instantiate_type_in_env(ty, (jl_unionall_t*)env->body, vals + 1, &en, stack);
jltypes.c:            if (!(N->lb == jl_bottom_type && N->ub == (jl_value_t*)jl_any_type))
jltypes.c:    jl_vararg_t *vm = (jl_vararg_t *)jl_gc_alloc(ct->ptls, sizeof(jl_vararg_t), jl_vararg_type);
jltypes.c:    vm->T = t;
jltypes.c:    vm->N = n;
jltypes.c:    assert(st->name != jl_namedtuple_typename && st->name != jl_tuple_typename);
jltypes.c:    jl_datatype_t *wt = (jl_datatype_t*)jl_unwrap_unionall(st->name->wrapper);
jltypes.c:    size_t i, n = jl_svec_len(wt->parameters);
jltypes.c:    //    return ((st->types = jl_emptysvec));
jltypes.c:    if (wt->types == NULL)
jltypes.c:                  jl_symbol_name(st->name->name));
jltypes.c:        env[i].var = (jl_tvar_t*)jl_svecref(wt->parameters, i);
jltypes.c:        env[i].val = jl_svecref(st->parameters, i);
jltypes.c:        env[i].prev = i == 0 ? NULL : &env[i - 1];
jltypes.c:    st->types = inst_ftypes(wt->types, &env[n - 1], &top);
jltypes.c:    jl_gc_wb(st, st->types);
jltypes.c:    return st->types;
jltypes.c:    size_t i, j, n = jl_svec_len(t->parameters);
jltypes.c:    jl_array_t *partial = t->name->partial;
jltypes.c:        env[i].var = (jl_tvar_t*)jl_svecref(t->parameters, i);
jltypes.c:        env[i].prev = i == 0 ? NULL : &env[i - 1];
jltypes.c:        assert(jl_unwrap_unionall(ndt->name->wrapper) == (jl_value_t*)t);
jltypes.c:            env[i].val = jl_svecref(ndt->parameters, i);
jltypes.c:        ndt->super = (jl_datatype_t*)inst_type_w_((jl_value_t*)t->super, env, &top, 1);
jltypes.c:        jl_gc_wb(ndt, ndt->super);
jltypes.c:    if (t->types != jl_emptysvec) {
jltypes.c:                env[i].val = jl_svecref(ndt->parameters, i);
jltypes.c:            assert(ndt->types == NULL);
jltypes.c:            ndt->types = inst_ftypes(t->types, env, &top);
jltypes.c:            jl_gc_wb(ndt, ndt->types);
jltypes.c:            if (ndt->isconcretetype) { // cacheable
jltypes.c:// initialization -------------------------------------------------------------
jltypes.c:    jl_any_type->super = jl_any_type;
jltypes.c:    jl_nonfunction_mt = jl_any_type->name->mt;
jltypes.c:    jl_any_type->name->mt = NULL;
jltypes.c:    jl_type_typename = ((jl_datatype_t*)jl_type_type)->name;
jltypes.c:    jl_type_type_mt = jl_new_method_table(jl_type_typename->name, core);
jltypes.c:    jl_type_typename->mt = jl_type_type_mt;
jltypes.c:    // NOTE: types are not actually mutable, but we want to ensure they are heap-allocated with stable addresses
jltypes.c:    jl_datatype_type->name = jl_new_typename_in(jl_symbol("DataType"), core, 0, 1);
jltypes.c:    jl_datatype_type->name->wrapper = (jl_value_t*)jl_datatype_type;
jltypes.c:    jl_datatype_type->super = (jl_datatype_t*)jl_type_type;
jltypes.c:    jl_datatype_type->parameters = jl_emptysvec;
jltypes.c:    jl_datatype_type->name->n_uninitialized = 9 - 3;
jltypes.c:    jl_datatype_type->name->names = jl_perm_symsvec(9,
jltypes.c:    jl_datatype_type->types = jl_svec(9,
jltypes.c:    jl_typename_type->name = jl_new_typename_in(jl_symbol("TypeName"), core, 0, 1);
jltypes.c:    jl_typename_type->name->wrapper = (jl_value_t*)jl_typename_type;
jltypes.c:    jl_typename_type->name->mt = jl_nonfunction_mt;
jltypes.c:    jl_typename_type->super = jl_any_type;
jltypes.c:    jl_typename_type->parameters = jl_emptysvec;
jltypes.c:    jl_typename_type->name->n_uninitialized = 12 - 2;
jltypes.c:    jl_typename_type->name->names = jl_perm_symsvec(12, "name", "module",
jltypes.c:    jl_typename_type->types = jl_svec(12, jl_symbol_type, jl_any_type /*jl_module_type*/,
jltypes.c:    jl_methtable_type->name = jl_new_typename_in(jl_symbol("MethodTable"), core, 0, 1);
jltypes.c:    jl_methtable_type->name->wrapper = (jl_value_t*)jl_methtable_type;
jltypes.c:    jl_methtable_type->name->mt = jl_nonfunction_mt;
jltypes.c:    jl_methtable_type->super = jl_any_type;
jltypes.c:    jl_methtable_type->parameters = jl_emptysvec;
jltypes.c:    jl_methtable_type->name->n_uninitialized = 12 - 5;
jltypes.c:    jl_methtable_type->name->names = jl_perm_symsvec(12, "name", "defs",
jltypes.c:    jl_methtable_type->types = jl_svec(12, jl_symbol_type, jl_any_type, jl_any_type,
jltypes.c:    jl_symbol_type->name = jl_new_typename_in(jl_symbol("Symbol"), core, 0, 1);
jltypes.c:    jl_symbol_type->name->wrapper = (jl_value_t*)jl_symbol_type;
jltypes.c:    jl_symbol_type->name->mt = jl_nonfunction_mt;
jltypes.c:    jl_symbol_type->super = jl_any_type;
jltypes.c:    jl_symbol_type->parameters = jl_emptysvec;
jltypes.c:    jl_symbol_type->name->n_uninitialized = 0;
jltypes.c:    jl_symbol_type->name->names = jl_emptysvec;
jltypes.c:    jl_symbol_type->types = jl_emptysvec;
jltypes.c:    jl_symbol_type->size = 0;
jltypes.c:    jl_simplevector_type->name = jl_new_typename_in(jl_symbol("SimpleVector"), core, 0, 1);
jltypes.c:    jl_simplevector_type->name->wrapper = (jl_value_t*)jl_simplevector_type;
jltypes.c:    jl_simplevector_type->name->mt = jl_nonfunction_mt;
jltypes.c:    jl_simplevector_type->super = jl_any_type;
jltypes.c:    jl_simplevector_type->parameters = jl_emptysvec;
jltypes.c:    jl_simplevector_type->name->n_uninitialized = 0;
jltypes.c:    jl_simplevector_type->name->names = jl_emptysvec;
jltypes.c:    jl_simplevector_type->types = jl_emptysvec;
jltypes.c:    jl_astaggedvalue(jl_nothing)->header = ((uintptr_t)jl_nothing_type) | GC_OLD_MARKED;
jltypes.c:    jl_nothing_type->instance = jl_nothing;
jltypes.c:    jl_typeofbottom_type->instance = jl_bottom_type;
jltypes.c:    jl_tuple_typename = jl_anytuple_type->name;
jltypes.c:    jl_tuple_typename->wrapper = (jl_value_t*)jl_anytuple_type; // remove UnionAll wrappers
jltypes.c:    jl_anytuple_type->isconcretetype = 0;
jltypes.c:    jl_anytuple_type->layout = NULL;
jltypes.c:    jl_anytuple_type->size = 0;
jltypes.c:    jl_anytuple_type->cached_by_hash = 0;
jltypes.c:    ((jl_datatype_t*)jl_type_type)->parameters = jl_svec(1, tttvar);
jltypes.c:    ((jl_datatype_t*)jl_type_type)->hasfreetypevars = 1;
jltypes.c:    ((jl_datatype_t*)jl_type_type)->cached_by_hash = 0;
jltypes.c:    jl_type_typename->wrapper = jl_new_struct(jl_unionall_type, tttvar, (jl_value_t*)jl_type_type);
jltypes.c:    jl_type_type = (jl_unionall_t*)jl_type_typename->wrapper;
jltypes.c:    jl_typeofbottom_type->super = jl_wrap_Type(jl_bottom_type);
jltypes.c:    jl_emptytuple_type->instance = jl_emptytuple;
jltypes.c:    // non-primitive definitions follow
jltypes.c:    jl_string_type->instance = NULL;
jltypes.c:    jl_function_type->name->mt = NULL; // subtypes of Function have independent method tables
jltypes.c:    jl_builtin_type->name->mt = NULL;  // so they don't share the Any type table
jltypes.c:                            jl_any_type, tv)->name->wrapper;
jltypes.c:                            tv)->name->wrapper;
jltypes.c:                        tv, jl_emptysvec, jl_emptysvec, jl_emptysvec, 0, 1, 0)->name->wrapper;
jltypes.c:    jl_array_typename = ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_array_type))->name;
jltypes.c:    jl_atomic_store_relaxed(&jl_nonfunction_mt->leafcache, (jl_array_t*)jl_an_empty_vec_any);
jltypes.c:    jl_atomic_store_relaxed(&jl_type_type_mt->leafcache, (jl_array_t*)jl_an_empty_vec_any);
jltypes.c:    jl_module_type->instance = NULL;
jltypes.c:    jl_svecset(jl_code_instance_type->types, 1, jl_code_instance_type);
jltypes.c:    jl_unionall_type->name->mt = jl_uniontype_type->name->mt = jl_datatype_type->name->mt =
jltypes.c:        jl_new_abstracttype((jl_value_t*)jl_symbol("Ref"), core, jl_any_type, tv)->name->wrapper;
jltypes.c:                             sizeof(void*)*8)->name->wrapper;
jltypes.c:    jl_pointer_typename = ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_pointer_type))->name;
jltypes.c:                             sizeof(void*)*8)->name->wrapper;
jltypes.c:    jl_llvmpointer_typename = ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_llvmpointer_type))->name;
jltypes.c:    jl_namedtuple_type = (jl_unionall_t*)ntt->name->wrapper;
jltypes.c:    ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_namedtuple_type))->layout = NULL;
jltypes.c:    jl_namedtuple_typename = ntt->name;
jltypes.c:    jl_svecset(jl_task_type->types, 0, listt);
jltypes.c:    jl_astaggedvalue(jl_current_task)->header = (uintptr_t)jl_task_type | jl_astaggedvalue(jl_current_task)->header;
jltypes.c:        jl_emptysvec, 0, 0, 6)->name->wrapper;
jltypes.c:    jl_opaque_closure_typename = ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_opaque_closure_type))->name;
jltypes.c:    jl_svecset(jl_datatype_type->types, 5, jl_voidpointer_type);
jltypes.c:    jl_svecset(jl_datatype_type->types, 6, jl_int32_type);
jltypes.c:    jl_svecset(jl_datatype_type->types, 7, jl_int32_type);
jltypes.c:    jl_svecset(jl_datatype_type->types, 8, jl_uint8_type);
jltypes.c:    jl_svecset(jl_typename_type->types, 1, jl_module_type);
jltypes.c:    jl_svecset(jl_typename_type->types, 3, jl_voidpointer_type);
jltypes.c:    jl_svecset(jl_typename_type->types, 4, jl_type_type);
jltypes.c:    jl_svecset(jl_typename_type->types, 9, jl_long_type);
jltypes.c:    jl_svecset(jl_typename_type->types, 10, jl_int32_type);
jltypes.c:    jl_svecset(jl_typename_type->types, 11, jl_uint8_type);
jltypes.c:    jl_svecset(jl_methtable_type->types, 4, jl_long_type);
jltypes.c:    jl_svecset(jl_methtable_type->types, 6, jl_module_type);
jltypes.c:    jl_svecset(jl_methtable_type->types, 7, jl_array_any_type);
jltypes.c:    jl_svecset(jl_methtable_type->types, 8, jl_int64_type); // unsigned long
jltypes.c:    jl_svecset(jl_methtable_type->types, 9, jl_int64_type); // uint32_t plus alignment
jltypes.c:    jl_svecset(jl_methtable_type->types, 8, jl_int32_type); // DWORD
jltypes.c:    jl_svecset(jl_methtable_type->types, 9, jl_int32_type); // uint32_t
jltypes.c:    jl_svecset(jl_methtable_type->types, 10, jl_uint8_type);
jltypes.c:    jl_svecset(jl_methtable_type->types, 11, jl_uint8_type);
jltypes.c:    jl_svecset(jl_method_type->types, 12, jl_method_instance_type);
jltypes.c:    jl_svecset(jl_method_instance_type->types, 6, jl_code_instance_type);
jltypes.c:    jl_svecset(jl_code_instance_type->types, 9, jl_voidpointer_type);
jltypes.c:    jl_svecset(jl_code_instance_type->types, 10, jl_voidpointer_type);
jltypes.c:    jl_lineinfonode_type->name->mayinlinealloc = 0; // FIXME: assumed to be a pointer by codegen
jltypes.c:    // It seems like we probably usually end up needing the box for kinds (used in an Any context)--but is that true?
jltypes.c:    jl_uniontype_type->name->mayinlinealloc = 0;
jltypes.c:    jl_unionall_type->name->mayinlinealloc = 0;
jloptions.c:                        -1,   // banner
jloptions.c:                        NULL, // bind-to
jloptions.c:                        NULL, // output-bc
jloptions.c:                        NULL, // output-unopt-bc
jloptions.c:                        NULL, // output-o
jloptions.c:                        NULL, // output-asm
jloptions.c:                        NULL, // output-ji
jloptions.c:                        NULL,    // output-code_coverage
jloptions.c:                        0, // image-codegen
jloptions.c:                        0, // rr-detach
jloptions.c:static const char usage[] = "julia [switches] -- [programfile] [args...]\n";
jloptions.c:    " -v, --version             Display version information\n"
jloptions.c:    " -h, --help                Print this message (--help-hidden for more)\n"
jloptions.c:    " --help-hidden             Uncommon options not shown by `-h`\n\n"
jloptions.c:    " --project[={<dir>|@.}]    Set <dir> as the home project/environment\n"
jloptions.c:    " -J, --sysimage <file>     Start up with the given system image file\n"
jloptions.c:    " -H, --home <dir>          Set location of `julia` executable\n"
jloptions.c:    " --startup-file={yes|no}   Load `~/.julia/config/startup.jl`\n"
jloptions.c:    " --handle-signals={yes|no} Enable or disable Julia's default signal handlers\n"
jloptions.c:    " --sysimage-native-code={yes|no}\n"
jloptions.c:    " --compiled-modules={yes|no}\n"
jloptions.c:    " -e, --eval <expr>         Evaluate <expr>\n"
jloptions.c:    " -E, --print <expr>        Evaluate <expr> and display the result\n"
jloptions.c:    " -L, --load <file>         Load <file> immediately on all processors\n\n"
jloptions.c:    " -t, --threads {N|auto}    Enable N threads; \"auto\" currently sets N to the number of local\n"
jloptions.c:    " -p, --procs {N|auto}      Integer value N launches N additional local worker processes\n"
jloptions.c:    " --machine-file <file>     Run processes on hosts listed in <file>\n\n"
jloptions.c:    " -i                        Interactive mode; REPL runs and isinteractive() is true\n"
jloptions.c:    " -q, --quiet               Quiet startup: no banner, suppress REPL warnings\n"
jloptions.c:    " --banner={yes|no|auto}    Enable or disable startup banner\n"
jloptions.c:    " --color={yes|no|auto}     Enable or disable color text\n"
jloptions.c:    " --history-file={yes|no}   Load or save history\n\n"
jloptions.c:    " --depwarn={yes|no|error}  Enable or disable syntax and method deprecation warnings (\"error\" turns warnings into errors)\n"
jloptions.c:    " --warn-overwrite={yes|no} Enable or disable method overwrite warnings\n"
jloptions.c:    " --warn-scope={yes|no}     Enable or disable warning for ambiguous top-level scope\n\n"
jloptions.c:    " -C, --cpu-target <target> Limit usage of CPU features up to <target>; set to \"help\" to see the available options\n"
jloptions.c:    " -O, --optimize={0,1,2,3}  Set the optimization level (default level is 2 if unspecified or 3 if used without a level)\n"
jloptions.c:    " --min-optlevel={0,1,2,3}  Set a lower bound on the optimization level (default is 0)\n"
jloptions.c:    " -g, -g <level>            Enable / Set the level of debug info generation"
jloptions.c:        " (default level for julia-debug is 2 if unspecified or if used without a level)\n"
jloptions.c:    " --inline={yes|no}         Control whether inlining is permitted, including overriding @inline declarations\n"
jloptions.c:    " --check-bounds={yes|no|auto}\n"
jloptions.c:    " --polly={yes|no}          Enable or disable the polyhedral optimizer Polly (overrides @polly declaration)\n"
jloptions.c:    " --math-mode={ieee,fast}   Disallow or enable unsafe floating point optimizations (overrides @fastmath declaration)\n\n"
jloptions.c:    " --code-coverage={none|user|all}, --code-coverage\n"
jloptions.c:    " --code-coverage=tracefile.info\n"
jloptions.c:// TODO: These TOKENS are defined in `runtime_ccall.cpp`. A more verbose `--help` should include that list here.
jloptions.c:    " --track-allocation={none|user|all}, --track-allocation\n"
jloptions.c:    " --bug-report=KIND         Launch a bug report session. It can be used to start a REPL, run a script, or evaluate\n"
jloptions.c:    "                           --bug-report=help.\n\n"
jloptions.c:    " --compile={yes|no|all|min}Enable or disable JIT compiler, or request exhaustive or minimal compilation\n"
jloptions.c:    " --output-o name           Generate an object file (including system image data)\n"
jloptions.c:    " --output-ji name          Generate a system image data file (.ji)\n"
jloptions.c:    " --output-unopt-bc name    Generate unoptimized LLVM bitcode (.bc)\n"
jloptions.c:    " --output-bc name          Generate LLVM bitcode (.bc)\n"
jloptions.c:    " --output-asm name         Generate an assembly file (.s)\n"
jloptions.c:    " --output-incremental=no   Generate an incremental output file (rather than complete)\n"
jloptions.c:    " --trace-compile={stderr,name}\n"
jloptions.c:    " --image-codegen           Force generate code in imaging mode\n"
jloptions.c:        { "help-hidden",     no_argument,       0, opt_help_hidden },
jloptions.c:        { "bug-report",      required_argument, 0, opt_bug_report },
jloptions.c:        { "sysimage-native-code", required_argument, 0, opt_sysimage_native_code },
jloptions.c:        { "compiled-modules",    required_argument, 0, opt_compiled_modules },
jloptions.c:        { "cpu-target",      required_argument, 0, 'C' },
jloptions.c:        { "machine-file",    required_argument, 0, opt_machine_file },
jloptions.c:        { "history-file",    required_argument, 0, opt_history_file },
jloptions.c:        { "startup-file",    required_argument, 0, opt_startup_file },
jloptions.c:        { "code-coverage",   optional_argument, 0, opt_code_coverage },
jloptions.c:        { "track-allocation",optional_argument, 0, opt_track_allocation },
jloptions.c:        { "min-optlevel",    optional_argument, 0, opt_optlevel_min },
jloptions.c:        { "check-bounds",    required_argument, 0, opt_check_bounds },
jloptions.c:        { "output-bc",       required_argument, 0, opt_output_bc },
jloptions.c:        { "output-unopt-bc", required_argument, 0, opt_output_unopt_bc },
jloptions.c:        { "output-o",        required_argument, 0, opt_output_o },
jloptions.c:        { "output-asm",      required_argument, 0, opt_output_asm },
jloptions.c:        { "output-ji",       required_argument, 0, opt_output_ji },
jloptions.c:        { "output-incremental",required_argument, 0, opt_incremental },
jloptions.c:        { "warn-overwrite",  required_argument, 0, opt_warn_overwrite },
jloptions.c:        { "warn-scope",      required_argument, 0, opt_warn_scope },
jloptions.c:        { "trace-compile",   required_argument, 0, opt_trace_compile },
jloptions.c:        { "math-mode",       required_argument, 0, opt_math_mode },
jloptions.c:        { "handle-signals",  required_argument, 0, opt_handle_signals },
jloptions.c:        { "bind-to",         required_argument, 0, opt_bind_to },
jloptions.c:        { "image-codegen",   no_argument,       0, opt_image_codegen },
jloptions.c:        { "rr-detach",       no_argument,       0, opt_rr_detach },
jloptions.c:    // getopt handles argument parsing up to -- delineator
jloptions.c:            if (!strcmp(argv[i], "--")) {
jloptions.c:        if (c == -1) break;
jloptions.c:            jl_errorf("--lisp must be specified as the first argument");
jloptions.c:                for (const struct option *o = longopts; o->val; o++) {
jloptions.c:                    if (optopt == o->val) {
jloptions.c:                        if (o->has_arg == optional_argument) {
jloptions.c:                            c = o->val;
jloptions.c:                        else if (o->val <= 0xff && strchr(shortopts, o->val)) {
jloptions.c:                            jl_errorf("option `-%c/--%s` is missing an argument", o->val, o->name);
jloptions.c:                            jl_errorf("option `--%s` is missing an argument", o->name);
jloptions.c:                jl_errorf("unknown option `-%c`", optopt);
jloptions.c:                    jl_errorf("julia: invalid argument to -g (%s)", optarg);
jloptions.c:                jl_options.banner = -1;
jloptions.c:                jl_errorf("julia: invalid argument to --banner={yes|no|auto} (%s)", optarg);
jloptions.c:                jl_errorf("julia: invalid argument to --sysimage-native-code={yes|no} (%s)", optarg);
jloptions.c:                jl_errorf("julia: invalid argument to --compiled-modules={yes|no} (%s)", optarg);
jloptions.c:        case 'C': // cpu-target
jloptions.c:                jl_options.nthreads = -1;
jloptions.c:                    jl_errorf("julia: -t,--threads=<n> must be an integer >= 1");
jloptions.c:                    jl_errorf("julia: -p,--procs=<n> must be an integer >= 1");
jloptions.c:                jl_errorf("julia: invalid argument to --color={yes|no|auto} (%s)", optarg);
jloptions.c:                jl_errorf("julia: invalid argument to --history-file={yes|no} (%s)", optarg);
jloptions.c:                jl_errorf("julia: invalid argument to --startup-file={yes|no} (%s)", optarg);
jloptions.c:                jl_errorf("julia: invalid argument to --compile (%s)", optarg);
jloptions.c:                else if (endof > 5 && !strcmp(optarg + endof - 5, ".info")) {
jloptions.c:                    jl_errorf("julia: invalid argument to --code-coverage (%s)", optarg);
jloptions.c:                    jl_errorf("julia: invalid argument to --track-allocation (%s)", optarg);
jloptions.c:                    jl_errorf("julia: invalid argument to -O (%s)", optarg);
jloptions.c:                    jl_errorf("julia: invalid argument to --min-optlevel (%s)", optarg);
jloptions.c:                jl_errorf("julia: invalid argument to --check-bounds={yes|no|auto} (%s)", optarg);
jloptions.c:                jl_errorf("julia: invalid argument to --output-incremental={yes|no} (%s)", optarg);
jloptions.c:                jl_errorf("julia: invalid argument to --depwarn={yes|no|error} (%s)", optarg);
jloptions.c:                jl_errorf("julia: invalid argument to --warn-overwrite={yes|no} (%s)", optarg);
jloptions.c:                jl_errorf("julia: invalid argument to --warn-scope={yes|no} (%s)", optarg);
jloptions.c:                jl_errorf("julia: invalid argument to --inline (%s)", optarg);
jloptions.c:                jl_errorf("julia: invalid argument to --polly (%s)", optarg);
jloptions.c:                jl_errorf("julia: invalid argument to --math-mode (%s)", optarg);
jloptions.c:                jl_errorf("julia: invalid argument to --handle-signals (%s)", optarg);
jloptions.c:            jl_errorf("julia: unhandled option -- %c\n"
jloptions.c:    *argcp -= proc_args;
julia_atomics.h:#  error Julia can only be built for architectures above Pentium 4. Pass -march=pentium4, or set MARCH=pentium4 and ensure that -march is not passed separately with an older architecture.
julia_atomics.h:// Low-level atomic operations
julia_atomics.h:    jl_memory_order_unspecified = -2,
julia_atomics.h:    jl_memory_order_invalid = -1,
julia_atomics.h:// for the purposes of the GC analyzer, we can turn these into non-atomic
codegen-stubs.c:// used when libjulia-codegen is not available.
codegen-stubs.c:    jl_atomic_store_release(&unspec->invoke, &jl_fptr_interpret_call);
stackwalk.c:int jl_unw_get(void *context) { return -1; }
stackwalk.c:        jl_gcframe_t *prev = pgcstack->prev;
stackwalk.c:        if (pgcstack->nroots & 2) { // tagged frame
stackwalk.c:            uintptr_t frame_fp = ((uintptr_t*)pgcstack)[-1];
stackwalk.c:// `maxsize` is the size of the buffer `bt_data` (and `sp` if non-NULL). It
stackwalk.c:// elements written to bt_data (and sp if non-NULL) are returned in bt_size.
stackwalk.c:        // Workaround 32-bit windows bug missing top frame
stackwalk.c:        skip--;
stackwalk.c:                // separator detection logic (double-NULL).
stackwalk.c:                skip--;
stackwalk.c:            //   https://github.com/llvm/llvm-project/blob/master/libunwind/src/UnwindCursor.hpp
stackwalk.c:            //   https://lists.nongnu.org/archive/html/libunwind-devel/2014-06/msg00025.html
stackwalk.c:            //   which we can get from the return address via `call_ip = return_ip - 1`.
stackwalk.c:                call_ip -= 1; // normal frame
stackwalk.c:                size_t add = jl_capture_interp_frame(bt_entry, (void*)((char*)pgcstack - sizeof(void*)), maxsize - n);
stackwalk.c:                    // If the compiler got inlining-happy, or the user tried to
stackwalk.c:            bt_entry->uintptr = call_ip;
stackwalk.c:        if (n > 0) n -= 1;
stackwalk.c:        jl_array_del_end(ip, jl_array_len(ip) - offset);
stackwalk.c:            jl_array_del_end(sp, jl_array_len(sp) - offset);
stackwalk.c:    memcpy(bt->data, bt_data, bt_size * sizeof(jl_bt_element_t));
stackwalk.c:    // Scan the backtrace buffer for any gc-managed values
stackwalk.c:    jl_excstack_t *s = jl_current_task->excstack;
stackwalk.c:    if (s && s->top) {
stackwalk.c:        bt_data = jl_excstack_bt_data(s, s->top);
stackwalk.c:        bt_size = jl_excstack_bt_size(s, s->top);
stackwalk.c:    if (task != ct && jl_atomic_load_relaxed(&task->_state) == JL_TASK_STATE_RUNNABLE) {
stackwalk.c:    jl_excstack_t *excstack = task->excstack;
stackwalk.c:    size_t itr = excstack ? excstack->top : 0;
stackwalk.c:// XXX: these caches should be per-thread
stackwalk.c:    memset(&cursor->stackframe, 0, sizeof(cursor->stackframe));
stackwalk.c:    cursor->stackframe.AddrPC.Offset = Context->Eip;
stackwalk.c:    cursor->stackframe.AddrStack.Offset = Context->Esp;
stackwalk.c:    cursor->stackframe.AddrFrame.Offset = Context->Ebp;
stackwalk.c:    cursor->stackframe.AddrPC.Mode = AddrModeFlat;
stackwalk.c:    cursor->stackframe.AddrStack.Mode = AddrModeFlat;
stackwalk.c:    cursor->stackframe.AddrFrame.Mode = AddrModeFlat;
stackwalk.c:    cursor->context = *Context;
stackwalk.c:            &cursor->stackframe, &cursor->context, NULL, JuliaFunctionTableAccess64,
stackwalk.c:    *ip = (uintptr_t)cursor->stackframe.AddrPC.Offset;
stackwalk.c:    *sp = (uintptr_t)cursor->stackframe.AddrStack.Offset;
stackwalk.c:        cursor->stackframe.AddrPC.Offset = *(DWORD32*)*sp;      // POP EIP (aka RET)
stackwalk.c:        cursor->stackframe.AddrStack.Offset += sizeof(void*);
stackwalk.c:        return cursor->stackframe.AddrPC.Offset != 0;
stackwalk.c:        &cursor->stackframe, &cursor->context, NULL, JuliaFunctionTableAccess64, JuliaGetModuleBase64, NULL);
stackwalk.c:    *ip = (uintptr_t)cursor->Rip;
stackwalk.c:    *sp = (uintptr_t)cursor->Rsp;
stackwalk.c:        cursor->Rip = *(DWORD64*)*sp;      // POP RIP (aka RET)
stackwalk.c:        cursor->Rsp += sizeof(void*);
stackwalk.c:        return cursor->Rip != 0;
stackwalk.c:    DWORD64 ImageBase = JuliaGetModuleBase64(GetCurrentProcess(), cursor->Rip - !from_signal_handler);
stackwalk.c:        GetCurrentProcess(), cursor->Rip - !from_signal_handler);
stackwalk.c:                cursor->Rip,
stackwalk.c:    return cursor->Rip != 0;
stackwalk.c:    int8_t gc_state = jl_gc_safe_enter(ct->ptls);
stackwalk.c:    jl_gc_safe_leave(ct->ptls, gc_state);
stackwalk.c:    if (line != -1) {
stackwalk.c:            code = ((jl_method_instance_t*)code)->uninferred;
stackwalk.c:            // NB: debuginfoloc is 1-based!
stackwalk.c:            intptr_t debuginfoloc = ((int32_t*)jl_array_data(src->codelocs))[ip];
stackwalk.c:                    jl_array_ptr_ref(src->linetable, debuginfoloc - 1);
stackwalk.c:                jl_value_t *method = locinfo->method;
stackwalk.c:                    method = ((jl_method_instance_t*)method)->def.value;
stackwalk.c:                    method = (jl_value_t*)((jl_method_t*)method)->name;
stackwalk.c:                jl_safe_print_codeloc(func_name, jl_symbol_name(locinfo->file),
stackwalk.c:                                      locinfo->line, locinfo->inlined_at);
stackwalk.c:                debuginfoloc = locinfo->inlined_at;
stackwalk.c:            jl_safe_printf("No code info - unknown interpreter state!\n");
stackwalk.c:        jl_safe_printf("Non-native bt entry with tag and header bits 0x%" PRIxPTR "\n",
stackwalk.c:    jl_ptls_t ptls = ct->ptls;
stackwalk.c:    ptls->bt_size = 0;
stackwalk.c:        ptls->bt_size = rec_backtrace(ptls->bt_data, JL_MAX_BT_SIZE, 0);
stackwalk.c:    if (t->copy_stack || !t->started || t->stkbuf == NULL)
stackwalk.c:    int16_t old = -1;
stackwalk.c:    if (!jl_atomic_cmpswap(&t->tid, &old, ptls->tid) && old != ptls->tid)
stackwalk.c:    _JUMP_BUFFER *mctx = (_JUMP_BUFFER*)&t->ctx.uc_mcontext;
stackwalk.c:    c.Rbx = mctx->Rbx;
stackwalk.c:    c.Rsp = mctx->Rsp;
stackwalk.c:    c.Rbp = mctx->Rbp;
stackwalk.c:    c.Rsi = mctx->Rsi;
stackwalk.c:    c.Rdi = mctx->Rdi;
stackwalk.c:    c.R12 = mctx->R12;
stackwalk.c:    c.R13 = mctx->R13;
stackwalk.c:    c.R14 = mctx->R14;
stackwalk.c:    c.R15 = mctx->R15;
stackwalk.c:    c.Rip = mctx->Rip;
stackwalk.c:    memcpy(&c.Xmm6, &mctx->Xmm6, 10 * sizeof(mctx->Xmm6)); // Xmm6-Xmm15
stackwalk.c:    c.Eip = mctx->Eip;
stackwalk.c:    c.Esp = mctx->Esp;
stackwalk.c:    c.Ebp = mctx->Ebp;
stackwalk.c:    context = &t->ctx;
stackwalk.c:    context = jl_to_bt_context(&t->ctx);
stackwalk.c:        ptls->bt_size = rec_backtrace_ctx(ptls->bt_data, JL_MAX_BT_SIZE, context, t->gcstack);
stackwalk.c:    if (old == -1)
stackwalk.c:        jl_atomic_store_relaxed(&t->tid, old);
stackwalk.c://--------------------------------------------------
stackwalk.c:    if (ct->ptls == NULL)
stackwalk.c:    jl_excstack_t *s = ct->excstack;
stackwalk.c:    size_t i, bt_size = jl_excstack_bt_size(s, s->top);
stackwalk.c:    jl_bt_element_t *bt_data = jl_excstack_bt_data(s, s->top);
stackwalk.c:    jl_ptls_t ptls = ct->ptls;
stackwalk.c:    size_t i, bt_size = ptls->bt_size;
stackwalk.c:    jl_bt_element_t *bt_data = ptls->bt_data;
ircode.c:// --- encoding ---
ircode.c:    jl_array_t *rs = s->method->roots;
ircode.c:    return jl_array_len(rs) - 1;
ircode.c:        write_uint8(s->s, TAG_SHORT_INT32);
ircode.c:        write_uint16(s->s, (uint16_t)x);
ircode.c:        write_uint8(s->s, TAG_INT32);
ircode.c:        write_int32(s->s, x);
ircode.c:        write_uint8(s->s, TAG_NULL);
ircode.c:            write_uint8(s->s, 0);
ircode.c:        write_uint8(s->s, t8);
ircode.c:        write_uint8(s->s, TAG_COMMONSYM);
ircode.c:        write_uint8(s->s, (uint8_t)(size_t)tag);
ircode.c:        write_uint8(s->s, TAG_CORE);
ircode.c:        write_uint8(s->s, TAG_BASE);
ircode.c:    else if (v == (jl_value_t*)s->method->module) {
ircode.c:        write_uint8(s->s, TAG_NEARBYMODULE);
ircode.c:    else if (jl_is_datatype(v) && ((jl_datatype_t*)v)->name == jl_array_typename &&
ircode.c:             !((jl_datatype_t*)v)->hasfreetypevars) {
ircode.c:        write_uint8(s->s, TAG_VECTORTY);
ircode.c:    else if (jl_is_datatype(v) && ((jl_datatype_t*)v)->name == jl_pointer_typename &&
ircode.c:             !((jl_datatype_t*)v)->hasfreetypevars) {
ircode.c:        write_uint8(s->s, TAG_PTRTY);
ircode.c:            write_uint8(s->s, TAG_SVEC);
ircode.c:            write_uint8(s->s, (uint8_t)l);
ircode.c:            write_uint8(s->s, TAG_LONG_SVEC);
ircode.c:            write_int32(s->s, l);
ircode.c:        if (jl_globalref_mod(v) == s->method->module) {
ircode.c:            write_uint8(s->s, TAG_NEARBYGLOBAL);
ircode.c:            write_uint8(s->s, TAG_GLOBALREF);
ircode.c:    else if (jl_is_ssavalue(v) && ((jl_ssavalue_t*)v)->id < 256 && ((jl_ssavalue_t*)v)->id >= 0) {
ircode.c:        write_uint8(s->s, TAG_SSAVALUE);
ircode.c:        write_uint8(s->s, ((jl_ssavalue_t*)v)->id);
ircode.c:    else if (jl_is_ssavalue(v) && ((jl_ssavalue_t*)v)->id <= UINT16_MAX && ((jl_ssavalue_t*)v)->id >= 0) {
ircode.c:        write_uint8(s->s, TAG_LONG_SSAVALUE);
ircode.c:        write_uint16(s->s, ((jl_ssavalue_t*)v)->id);
ircode.c:        write_uint8(s->s, TAG_SLOTNUMBER);
ircode.c:        write_uint16(s->s, jl_slot_number(v));
ircode.c:        size_t l = jl_array_len(e->args);
ircode.c:        if (e->head == jl_call_sym) {
ircode.c:                write_uint8(s->s, TAG_CALL1);
ircode.c:                write_uint8(s->s, TAG_CALL2);
ircode.c:            write_uint8(s->s, TAG_EXPR);
ircode.c:            write_uint8(s->s, (uint8_t)l);
ircode.c:            write_uint8(s->s, TAG_LONG_EXPR);
ircode.c:            write_int32(s->s, l);
ircode.c:        jl_encode_value(s, e->head);
ircode.c:            write_uint8(s->s, TAG_PHINODE);
ircode.c:            write_uint8(s->s, (uint8_t)l);
ircode.c:            write_uint8(s->s, TAG_LONG_PHINODE);
ircode.c:            write_int32(s->s, l);
ircode.c:            write_int32(s->s, jl_array_len(values));
ircode.c:            write_uint8(s->s, TAG_PHICNODE);
ircode.c:            write_uint8(s->s, (uint8_t)l);
ircode.c:            write_uint8(s->s, TAG_LONG_PHICNODE);
ircode.c:            write_int32(s->s, l);
ircode.c:        write_uint8(s->s, TAG_GOTONODE);
ircode.c:        write_uint8(s->s, TAG_GOTOIFNOT);
ircode.c:        write_uint8(s->s, TAG_ARGUMENT);
ircode.c:        write_uint8(s->s, TAG_RETURNNODE);
ircode.c:            write_uint8(s->s, TAG_SHORTER_INT64);
ircode.c:            write_uint16(s->s, (uint16_t)*(int64_t*)data);
ircode.c:            write_uint8(s->s, TAG_SHORT_INT64);
ircode.c:            write_int32(s->s, (int32_t)*(int64_t*)data);
ircode.c:            write_uint8(s->s, TAG_INT64);
ircode.c:            write_int64(s->s, *(int64_t*)data);
ircode.c:        write_uint8(s->s, TAG_UINT8);
ircode.c:        write_int8(s->s, *(int8_t*)jl_data_ptr(v));
ircode.c:        write_uint8(s->s, TAG_LINEINFO);
ircode.c:    else if (((jl_datatype_t*)jl_typeof(v))->instance == v) {
ircode.c:        write_uint8(s->s, TAG_SINGLETON);
ircode.c:        write_uint8(s->s, TAG_STRING);
ircode.c:        write_int32(s->s, jl_string_len(v));
ircode.c:        ios_write(s->s, jl_string_data(v), jl_string_len(v));
ircode.c:        if (ar->flags.ndims == 1 && ar->elsize <= 0x1f) {
ircode.c:            write_uint8(s->s, TAG_ARRAY1D);
ircode.c:            write_uint8(s->s, (ar->flags.ptrarray << 7) | (ar->flags.hasptr << 6) | (isunion << 5) | (ar->elsize & 0x1f));
ircode.c:            write_uint8(s->s, TAG_ARRAY);
ircode.c:            write_uint16(s->s, ar->flags.ndims);
ircode.c:            write_uint16(s->s, (ar->flags.ptrarray << 15) | (ar->flags.hasptr << 14) | (isunion << 13) | (ar->elsize & 0x1fff));
ircode.c:        for (i = 0; i < ar->flags.ndims; i++)
ircode.c:        if (ar->flags.ptrarray) {
ircode.c:        else if (ar->flags.hasptr) {
ircode.c:            uint16_t elsz = ar->elsize;
ircode.c:            size_t j, np = ((jl_datatype_t*)et)->layout->npointers;
ircode.c:                        ios_write(s->s, start, (const char*)fld - start);
ircode.c:                    ios_write(s->s, start, data - start);
ircode.c:            ios_write(s->s, (char*)jl_array_data(ar), l * ar->elsize);
ircode.c:                ios_write(s->s, jl_array_typetagdata(ar), l);
ircode.c:                write_uint8(s->s, TAG_METHODROOT);
ircode.c:                write_uint8(s->s, id);
ircode.c:                write_uint8(s->s, TAG_LONG_METHODROOT);
ircode.c:                write_uint16(s->s, id);
ircode.c:        if (t->size <= 255) {
ircode.c:            write_uint8(s->s, TAG_SHORT_GENERAL);
ircode.c:            write_uint8(s->s, t->size);
ircode.c:            write_uint8(s->s, TAG_GENERAL);
ircode.c:            write_int32(s->s, t->size);
ircode.c:        size_t i, j, np = t->layout->npointers;
ircode.c:        uint32_t nf = t->layout->nfields;
ircode.c:                        ios_write(s->s, last, prevptr - last);
ircode.c:            ios_write(s->s, last, ptr - last);
ircode.c:// --- decoding ---
ircode.c:        len = read_uint8(s->s);
ircode.c:        len = read_int32(s->s);
ircode.c:        elsize = read_uint8(s->s);
ircode.c:        ndims = read_uint16(s->s);
ircode.c:        elsize = read_uint16(s->s);
ircode.c:    if (a->flags.ptrarray) {
ircode.c:        assert(jl_astaggedvalue(a)->bits.gc == GC_CLEAN); // gc is disabled
ircode.c:    else if (a->flags.hasptr) {
ircode.c:        uint16_t elsz = a->elsize;
ircode.c:        size_t j, np = et->layout->npointers;
ircode.c:                    ios_readall(s->s, start, (const char*)fld - start);
ircode.c:                ios_readall(s->s, start, data - start);
ircode.c:        assert(jl_astaggedvalue(a)->bits.gc == GC_CLEAN); // gc is disabled
ircode.c:        size_t tot = jl_array_len(a) * a->elsize + extra;
ircode.c:        ios_readall(s->s, (char*)jl_array_data(a), tot);
ircode.c:        len = read_uint8(s->s);
ircode.c:        len = read_int32(s->s);
ircode.c:    jl_value_t **data = (jl_value_t**)(e->args->data);
ircode.c:        len_e = len_v = read_uint8(s->s);
ircode.c:        len_e = read_int32(s->s);
ircode.c:        len_v = read_int32(s->s);
ircode.c:    int32_t *data_e = (int32_t*)(e->data);
ircode.c:    jl_value_t **data_v = (jl_value_t**)(v->data);
ircode.c:        len = read_uint8(s->s);
ircode.c:        len = read_int32(s->s);
ircode.c:    jl_value_t **data = (jl_value_t**)(v->data);
ircode.c:    int32_t sz = (tag == TAG_SHORT_GENERAL ? read_uint8(s->s) : read_int32(s->s));
ircode.c:    jl_value_t *v = jl_gc_alloc(s->ptls, sz, NULL);
ircode.c:    size_t i, np = dt->layout->npointers;
ircode.c:            ios_readall(s->s, start, (const char*)fld - start);
ircode.c:        ios_readall(s->s, start, data - start);
ircode.c:    assert(!ios_eof(s->s));
ircode.c:    uint8_t tag = read_uint8(s->s);
ircode.c:        tag = read_uint8(s->s);
ircode.c:        return jl_array_ptr_ref(s->method->roots, read_uint8(s->s));
ircode.c:        return jl_array_ptr_ref(s->method->roots, read_uint16(s->s));
ircode.c:        return jl_deser_symbol(read_uint8(s->s));
ircode.c:        v = jl_box_ssavalue(read_uint8(s->s));
ircode.c:        v = jl_box_ssavalue(read_uint16(s->s));
ircode.c:        v = jl_box_slotnumber(read_uint16(s->s));
ircode.c:        v = jl_box_int64((int16_t)read_uint16(s->s));
ircode.c:        v = jl_box_int64(read_int32(s->s));
ircode.c:        v = jl_box_int64((int64_t)read_uint64(s->s));
ircode.c:        v = jl_box_int32((int16_t)read_uint16(s->s));
ircode.c:        v = jl_box_int32(read_int32(s->s));
ircode.c:        return jl_box_uint8(read_uint8(s->s));
ircode.c:        assert(s->method != NULL);
ircode.c:        return jl_module_globalref(s->method->module, (jl_sym_t*)v);
ircode.c:        assert(s->method != NULL);
ircode.c:        return (jl_value_t*)s->method->module;
ircode.c:        return ((jl_datatype_t*)jl_decode_value(s))->instance;
ircode.c:        n = read_int32(s->s);
ircode.c:        ios_readall(s->s, jl_string_data(v), n);
ircode.c:// --- entry points ---
ircode.c:    JL_LOCK(&m->writelock); // protect the roots array (Might GC)
ircode.c:    if (m->roots == NULL) {
ircode.c:        m->roots = jl_alloc_vec_any(0);
ircode.c:        jl_gc_wb(m, m->roots);
ircode.c:        jl_current_task->ptls
ircode.c:    jl_code_info_flags_t flags = code_info_flags(code->pure, code->propagate_inbounds, code->inlineable, code->inferred, code->constprop);
ircode.c:    size_t nslots = jl_array_len(code->slotflags);
ircode.c:    assert(nslots >= m->nargs && nslots < INT32_MAX); // required by generated functions
ircode.c:    ios_write(s.s, (char*)jl_array_data(code->slotflags), nslots);
ircode.c:    if (m->generator)
ircode.c:        jl_encode_value_(&s, (jl_value_t*)jl_compress_argnames(code->slotnames), 1);
ircode.c:    size_t nstmt = jl_array_len(code->code);
ircode.c:    assert(nstmt == jl_array_len(code->codelocs));
ircode.c:    if (jl_array_len(code->linetable) < 256) {
ircode.c:            write_uint8(s.s, ((int32_t*)jl_array_data(code->codelocs))[i]);
ircode.c:    else if (jl_array_len(code->linetable) < 65536) {
ircode.c:            write_uint16(s.s, ((int32_t*)jl_array_data(code->codelocs))[i]);
ircode.c:        ios_write(s.s, (char*)jl_array_data(code->codelocs), nstmt * sizeof(int32_t));
ircode.c:    if (jl_array_len(m->roots) == 0) {
ircode.c:        m->roots = NULL;
ircode.c:    JL_UNLOCK(&m->writelock); // Might GC
ircode.c:    JL_LOCK(&m->writelock); // protect the roots array (Might GC)
ircode.c:    ios_setbuf(&src, (char*)data->data, jl_array_len(data), 0);
ircode.c:        jl_current_task->ptls
ircode.c:    code->constprop = flags.bits.constprop;
ircode.c:    code->inferred = flags.bits.inferred;
ircode.c:    code->inlineable = flags.bits.inlineable;
ircode.c:    code->propagate_inbounds = flags.bits.propagate_inbounds;
ircode.c:    code->pure = flags.bits.pure;
ircode.c:    code->slotflags = jl_alloc_array_1d(jl_array_uint8_type, nslots);
ircode.c:    ios_readall(s.s, (char*)jl_array_data(code->slotflags), nslots);
ircode.c:        slotnames = m->slot_syms;
ircode.c:    code->slotnames = jl_uncompress_argnames(slotnames);
ircode.c:    size_t nstmt = jl_array_len(code->code);
ircode.c:    code->codelocs = (jl_value_t*)jl_alloc_array_1d(jl_array_int32_type, nstmt);
ircode.c:    if (jl_array_len(code->linetable) < 256) {
ircode.c:            ((int32_t*)jl_array_data(code->codelocs))[i] = read_uint8(s.s);
ircode.c:    else if (jl_array_len(code->linetable) < 65536) {
ircode.c:            ((int32_t*)jl_array_data(code->codelocs))[i] = read_uint16(s.s);
ircode.c:        ios_readall(s.s, (char*)jl_array_data(code->codelocs), nstmt * sizeof(int32_t));
ircode.c:    assert(ios_getc(s.s) == -1);
ircode.c:    JL_UNLOCK(&m->writelock); // Might GC
ircode.c:        code->min_world = metadata->min_world;
ircode.c:        code->max_world = metadata->max_world;
ircode.c:        code->rettype = metadata->rettype;
ircode.c:        code->parent = metadata->def;
ircode.c:        return ((jl_code_info_t*)data)->inferred;
ircode.c:    flags.packed = ((uint8_t*)data->data)[0];
ircode.c:        return ((jl_code_info_t*)data)->inlineable;
ircode.c:    flags.packed = ((uint8_t*)data->data)[0];
ircode.c:        return ((jl_code_info_t*)data)->pure;
ircode.c:    flags.packed = ((uint8_t*)data->data)[0];
ircode.c:        size_t namelen = strlen(namestr) + 1; // include nul-byte
ircode.c:        return jl_array_len(func->slotnames);
ircode.c:        int nslots = jl_load_unaligned_i32((char*)data->data + 1);
ircode.c:        return ((uint8_t*)((jl_code_info_t*)data)->slotflags->data)[i];
ircode.c:    return ((uint8_t*)data->data)[1 + sizeof(int32_t) + i];
ircode.c:        remaining -= namelen + 1;
ircode.c:        if (i-- == 0) {
ircode.c:        remaining -= namelen + 1;
ccalltest.c:// Complex-like data types
ccalltest.c:    a.imag -= 2;
ccalltest.c:    a += 1 - (2.0*I);
ccalltest.c:    *a += 1 - (2.0*I);
ccalltest.c:    a += 1 - (2.0*I);
ccalltest.c:    *a += 1 - (2.0*I);
ccalltest.c:    if (verbose) fprintf(stderr,"%" PRIjint " + %" PRIjint " i\n", a->real, a->imag);
ccalltest.c:    a->real += 1;
ccalltest.c:    a->imag -= 2;
ccalltest.c:    if (verbose) fprintf(stderr,"%" PRIjint " + %" PRIjint " i\n", a->real, a->imag);
ccalltest.c:    b->real = a->real;
ccalltest.c:    b->imag = a->imag;
ccalltest.c:    a.y -= b * 2;
ccalltest.c:    a.y -= b * 2;
ccalltest.c:    a.y -= b * 2;
ccalltest.c:    a.y -= b * 2;
ccalltest.c:    a.y.y -= b*2;
ccalltest.c:    a.y -= b*2;
ccalltest.c:    a.y.y -= b*2;
ccalltest.c:    a.y -= b*2;
ccalltest.c:    a.y -= b*2;
ccalltest.c:    a.y -= b*2;
ccalltest.c:    a.a -= b*4;
ccalltest.c:    a.y -= b*2;
ccalltest.c:    a.y -= b*2;
ccalltest.c:    a.y -= b*2;
ccalltest.c:    a.y -= b*2;
ccalltest.c:    a.y -= b*2;
ccalltest.c:    a.a -= b*4;
ccalltest.c:    a.x += b*1 - (b*2.0*I);
ccalltest.c:    a.x += b*1 - (b*2.0*I);
ccalltest.c:    a.y += b*3 - (b*4.0*I);
ccalltest.c:    a.x += b*1 - (b*2.0*I);
ccalltest.c:    a.y -= b*2;
ccalltest.c:    a.y -= b*2;
ccalltest.c:    //Unpack a struct with non-obvious packing requirements
ccalltest.c:    a.y -= b*2;
ccalltest.c:    a.a -= b*4;
ccalltest.c:    a.c -= b*6;
ccalltest.c:    //Unpack a struct with non-obvious packing requirements
ccalltest.c:    a.b -= b*2;
ccalltest.c:    //Unpack a struct with non-obvious packing requirements
ccalltest.c:    a.b -= b*2;
ccalltest.c:    a.y -= 2;
ccalltest.c:    a.z -= 'A';
ccalltest.c:    a.y -= 2;
ccalltest.c:    a.z -= 'A';
ccalltest.c:    if (verbose) fprintf(stderr,"%c-%c\n", a, c); \
ccalltest.c:    set_c_int(-1);
ccalltest.c:    // 64-bit x86 has only level 2 SSE, which does not have a <4 x int32> multiplication,
ccalltest.c:    // so we use floating-point instead, and assume caller knows about the hack.
ccalltest.c:    return v1 * 2 - v2;
ccalltest.c:    struct_aa64_1 x = {(int32_t)v1 / 2 + 1 - v3.v1, v2 * 2 - 1 - v3.v2};
ccalltest.c:    struct_aa64_2 x = {v4 / 2 + 1, v1 * 2 + v2 * 4 - v3};
ccalltest.c:    struct_aa64_3 x = {(int8x8_t)(v1.v1 + vmovn_s16(v2.v1)), (float32x2_t)(v1.v2 - v2.v2)};
abi_llvm.cpp://===-- abi_llvm.cpp - LLVM Target ABI description --------------*- C++ -*-===//
abi_llvm.cpp:// This file is distributed under the BSD-style LDC license:
abi_llvm.cpp:// Copyright (c) 2007-2012 LDC Team.
abi_llvm.cpp://===----------------------------------------------------------------------===//
abi_llvm.cpp:// (until a platform-specific implementation can be developed).
abi_llvm.cpp://===----------------------------------------------------------------------===//
jlapi.c:        jl_current_task->ptls->previous_exception = jl_current_exception();
jlapi.c:    jl_excstack_t *s = jl_current_task->excstack;
jlapi.c:    return s && s->top != 0 ? jl_excstack_exception(s, s->top) : jl_nothing;
jlapi.c:    return jl_current_task->ptls->previous_exception;
jlapi.c:    jl_current_task->ptls->previous_exception = NULL;
jlapi.c:    return jl_symbol_name(((jl_datatype_t*)v)->name->name);
jlapi.c:            argv[i] = args[i - 1];
jlapi.c:        size_t last_age = ct->world_age;
jlapi.c:        ct->world_age = jl_get_world_counter();
jlapi.c:        ct->world_age = last_age;
jlapi.c:        ct->ptls->previous_exception = jl_current_exception();
jlapi.c:        size_t last_age = ct->world_age;
jlapi.c:        ct->world_age = jl_get_world_counter();
jlapi.c:        ct->world_age = last_age;
jlapi.c:        ct->ptls->previous_exception = jl_current_exception();
jlapi.c:        size_t last_age = ct->world_age;
jlapi.c:        ct->world_age = jl_get_world_counter();
jlapi.c:        ct->world_age = last_age;
jlapi.c:        ct->ptls->previous_exception = jl_current_exception();
jlapi.c:        size_t last_age = ct->world_age;
jlapi.c:        ct->world_age = jl_get_world_counter();
jlapi.c:        ct->world_age = last_age;
jlapi.c:        ct->ptls->previous_exception = jl_current_exception();
jlapi.c:        size_t last_age = ct->world_age;
jlapi.c:        ct->world_age = jl_get_world_counter();
jlapi.c:        ct->world_age = last_age;
jlapi.c:        jl_current_task->ptls->previous_exception = jl_current_exception();
jlapi.c:        jl_current_task->ptls->previous_exception = jl_current_exception();
jlapi.c:    if (ct->ptls->defer_signal == 0)
jlapi.c:        jl_error("sigatomic_end called in non-sigatomic region");
jlapi.c:    return jl_gc_unsafe_enter(ct->ptls);
jlapi.c:    jl_gc_unsafe_leave(ct->ptls, state);
jlapi.c:    return jl_gc_safe_enter(ct->ptls);
jlapi.c:    jl_gc_safe_leave(ct->ptls, state);
jlapi.c:    jl_gc_safepoint_(ct->ptls);
jlapi.c:    jl_atomic_fetch_add(&jl_measure_compile_time_enabled, -1);
jlapi.c:            size_t last_age = ct->world_age;
jlapi.c:            ct->world_age = jl_get_world_counter();
jlapi.c:            ct->world_age = last_age;
jlapi.c:        if (strcmp(argv[0], "-")) {
jlapi.c:    // block usage of the 32-bit address space on win64, to catch pointer cast errors
jlapi.c:            first = (char*)(((long long)first + info.dwAllocationGranularity - 1) & ~(info.dwAllocationGranularity - 1));
jlapi.c:            last = (char*)((long long)last & ~(info.dwAllocationGranularity - 1));
jlapi.c:                void *p = VirtualAlloc(first, last - first, MEM_RESERVE, PAGE_NOACCESS); // reserve all memory in between
jlapi.c:                    // so we sometimes end up with unexpected results - this is just ignore those and continue
jlapi.c:    // no-op on Windows, note that the caller must have already converted
jlapi.c:    // from `wchar_t` to `UTF-8` already if we're running on Windows.
jlapi.c:    // No-op on non-windows
jlapi.c:    int lisp_prompt = (argc >= 2 && strcmp((char*)argv[1],"--lisp") == 0);
jlapi.c:        memmove(&argv[1], &argv[2], (argc-2)*sizeof(void*));
jlapi.c:        argc--;
jlapi.c:    // testing for the absence of a memory-model-dependent bug).
jlapi.c:        jl_error("Failed to self-execute");
jlapi.c:        jl_current_task->world_age = jl_get_world_counter();
module.c:  modules and top-level bindings
module.c:    jl_module_t *m = (jl_module_t*)jl_gc_alloc(ct->ptls, sizeof(jl_module_t),
module.c:    m->name = name;
module.c:    m->parent = NULL;
module.c:    m->istopmod = 0;
module.c:    m->uuid = uuid_zero;
module.c:    m->build_id = jl_hrtime() + (++mcounter);
module.c:    if (!m->build_id)
module.c:        m->build_id++; // build id 0 is invalid
module.c:    m->primary_world = 0;
module.c:    m->counter = 1;
module.c:    m->nospecialize = 0;
module.c:    m->optlevel = -1;
module.c:    m->compile = -1;
module.c:    m->infer = -1;
module.c:    JL_MUTEX_INIT(&m->lock);
module.c:    htable_new(&m->bindings, 0);
module.c:    arraylist_new(&m->usings, 0);
module.c:    return jl_atomic_fetch_add(&m->counter, 1);
module.c:    m->parent = jl_main_module; // TODO: this is a lie
module.c:    jl_gc_wb(m, m->parent);
module.c:    // TODO: should we somehow try to gc-root this correctly?
module.c:    self->nospecialize = (on ? -1 : 0);
module.c:    self->optlevel = lvl;
module.c:    int lvl = m->optlevel;
module.c:    while (lvl == -1 && m->parent != m && m != jl_base_module) {
module.c:        m = m->parent;
module.c:        lvl = m->optlevel;
module.c:    self->compile = value;
module.c:    int value = m->compile;
module.c:    while (value == -1 && m->parent != m && m != jl_base_module) {
module.c:        m = m->parent;
module.c:        value = m->compile;
module.c:    self->infer = value;
module.c:    int value = m->infer;
module.c:    while (value == -1 && m->parent != m && m != jl_base_module) {
module.c:        m = m->parent;
module.c:        value = m->infer;
module.c:    self->istopmod = 1;
module.c:    return mod->istopmod;
module.c:    jl_binding_t *b = (jl_binding_t*)jl_gc_alloc_buf(ct->ptls, sizeof(jl_binding_t));
module.c:    b->name = name;
module.c:    b->value = NULL;
module.c:    b->owner = NULL;
module.c:    b->globalref = NULL;
module.c:    b->constp = 0;
module.c:    b->exportp = 0;
module.c:    b->imported = 0;
module.c:    b->deprecated = 0;
module.c:    JL_LOCK(&m->lock);
module.c:    jl_binding_t **bp = (jl_binding_t**)ptrhash_bp(&m->bindings, var);
module.c:        if (b->owner != m) {
module.c:            if (b->owner == NULL) {
module.c:                b->owner = m;
module.c:                JL_UNLOCK(&m->lock);
module.c:                          jl_symbol_name(b->owner->name), jl_symbol_name(var), jl_symbol_name(m->name));
module.c:        b->owner = m;
module.c:    JL_UNLOCK(&m->lock);
module.c:// NOTE: Must hold m->lock while calling these.
module.c:    return (jl_binding_t*)ptrhash_get(&m->bindings, var);
module.c:    return (jl_binding_t**)ptrhash_bp(&m->bindings, var);
module.c:    return b->owner;
module.c:    JL_LOCK(&m->lock);
module.c:        if (b->owner != m) {
module.c:            if (b->owner == NULL) {
module.c:                b->owner = m;
module.c:                JL_UNLOCK(&m->lock);
module.c:                jl_binding_t *b2 = jl_get_binding(b->owner, b->name);
module.c:                if (b2 == NULL || b2->value == NULL)
module.c:                              jl_symbol_name(b->owner->name), jl_symbol_name(b->name));
module.c:                if (!b->imported && !jl_is_type(b2->value)) {
module.c:                              jl_symbol_name(b->owner->name), jl_symbol_name(b->name));
module.c:        b->owner = m;
module.c:    JL_UNLOCK(&m->lock);
module.c:    return (jl_module_t*)m->usings.items[i];
module.c:// called while holding m->lock
module.c:    for(int i=(int)m->usings.len-1; i >= 0; --i) {
module.c:        JL_LOCK(&imp->lock);
module.c:        JL_UNLOCK(&imp->lock);
module.c:        if (tempb != HT_NOTFOUND && tempb->exportp) {
module.c:            if (tempb == NULL || tempb->owner == NULL)
module.c:            if (owner != NULL && tempb->owner != b->owner &&
module.c:                !tempb->deprecated && !b->deprecated &&
module.c:                !(tempb->constp && tempb->value && b->constp && b->value == tempb->value)) {
module.c:                    JL_UNLOCK(&m->lock);
module.c:                              jl_symbol_name(owner->name),
module.c:                              jl_symbol_name(imp->name), jl_symbol_name(var),
module.c:                              jl_symbol_name(m->name));
module.c:                    JL_LOCK(&m->lock);
module.c:            if (owner == NULL || !tempb->deprecated) {
module.c:        if (tmp->m == m && tmp->var == var) {
module.c:        tmp = tmp->prev;
module.c:    JL_LOCK(&m->lock);
module.c:    if (b == HT_NOTFOUND || b->owner == NULL) {
module.c:        JL_UNLOCK(&m->lock);
module.c:            module_import_(m, b->owner, var, var, 0);
module.c:    JL_UNLOCK(&m->lock);
module.c:    if (b->owner != m || b->name != var)
module.c:        return jl_get_binding_(b->owner, b->name, &top);
module.c:    JL_LOCK(&m->lock);
module.c:    jl_binding_t *b = (jl_binding_t*)ptrhash_get(&m->bindings, var);
module.c:    if (b == HT_NOTFOUND || b->owner == NULL)
module.c:    JL_UNLOCK(&m->lock);
module.c:    if (b == NULL || b->owner == NULL)
module.c:    return (jl_value_t*)b->owner;
module.c:    if (b->deprecated)
module.c:    JL_LOCK(&m->lock);
module.c:    jl_binding_t *b = (jl_binding_t*)ptrhash_get(&m->bindings, var);
module.c:        JL_UNLOCK(&m->lock);
module.c:    jl_value_t *globalref = jl_atomic_load_relaxed(&b->globalref);
module.c:        if (jl_atomic_cmpswap_relaxed(&b->globalref, &globalref, newref)) {
module.c:    JL_UNLOCK(&m->lock); // may GC
module.c:    if (a->name == b->name && a->owner == b->owner) return 1;
module.c:    if (a->constp && a->value && b->constp && b->value == a->value) return 1;
module.c:    JL_LOCK(&m->lock);
module.c:    jl_binding_t *b = (jl_binding_t*)ptrhash_get(&m->bindings, s);
module.c:    JL_UNLOCK(&m->lock);
module.c:    return (b != HT_NOTFOUND && b->imported);
module.c:                  jl_symbol_name(from->name), jl_symbol_name(s),
module.c:                  jl_symbol_name(to->name));
module.c:        if (b->deprecated) {
module.c:            if (b->value == jl_nothing) {
module.c:                          jl_symbol_name(from->name), jl_symbol_name(s),
module.c:                          jl_symbol_name(to->name));
module.c:        JL_LOCK(&to->lock);
module.c:        jl_binding_t **bp = (jl_binding_t**)ptrhash_bp(&to->bindings, asname);
module.c:            else if (bto->name != s) {
module.c:                JL_UNLOCK(&to->lock);
module.c:                          jl_symbol_name(from->name), jl_symbol_name(s),
module.c:                          jl_symbol_name(to->name));
module.c:            else if (bto->owner == b->owner) {
module.c:                bto->imported = (explici!=0);
module.c:            else if (bto->owner != to && bto->owner != NULL) {
module.c:                if (bval->constp && bval->value && b->constp && b->value == bval->value) {
module.c:                    bto->imported = (explici!=0);
module.c:                    JL_UNLOCK(&to->lock);
module.c:                    JL_UNLOCK(&to->lock);
module.c:                              jl_symbol_name(from->name), jl_symbol_name(s),
module.c:                              jl_symbol_name(to->name));
module.c:            else if (bto->constp || bto->value) {
module.c:                assert(bto->owner == to);
module.c:                if (bto->constp && bto->value && b->constp && b->value == bto->value) {
module.c:                    JL_UNLOCK(&to->lock);
module.c:                    JL_UNLOCK(&to->lock);
module.c:                              jl_symbol_name(from->name), jl_symbol_name(s),
module.c:                              jl_symbol_name(to->name));
module.c:                bto->owner = b->owner;
module.c:                bto->imported = (explici!=0);
module.c:            nb->owner = b->owner;
module.c:            nb->imported = (explici!=0);
module.c:            nb->deprecated = b->deprecated;
module.c:        JL_UNLOCK(&to->lock);
module.c:    JL_LOCK(&to->lock);
module.c:    for(size_t i=0; i < to->usings.len; i++) {
module.c:        if (from == to->usings.items[i]) {
module.c:            JL_UNLOCK(&to->lock);
module.c:    JL_LOCK(&from->lock);
module.c:    void **table = from->bindings.table;
module.c:    for(size_t i=1; i < from->bindings.size; i+=2) {
module.c:            if (b->exportp && (b->owner==from || b->imported)) {
module.c:                jl_sym_t *var = (jl_sym_t*)table[i-1];
module.c:                jl_binding_t **tobp = (jl_binding_t**)ptrhash_bp(&to->bindings, var);
module.c:                if (*tobp != HT_NOTFOUND && (*tobp)->owner != NULL &&
module.c:                    var != to->name &&
module.c:                              jl_symbol_name(from->name), jl_symbol_name(var),
module.c:                              jl_symbol_name(to->name));
module.c:    JL_UNLOCK(&from->lock);
module.c:    arraylist_push(&to->usings, from);
module.c:    JL_UNLOCK(&to->lock);
module.c:    JL_LOCK(&from->lock);
module.c:    jl_binding_t **bp = (jl_binding_t**)ptrhash_bp(&from->bindings, s);
module.c:        b->owner = NULL;
module.c:    (*bp)->exportp = 1;
module.c:    JL_UNLOCK(&from->lock);
module.c:    return b && (b->value != NULL);
module.c:    JL_LOCK(&m->lock);
module.c:    jl_binding_t *b = (jl_binding_t*)ptrhash_get(&m->bindings, var);
module.c:    JL_UNLOCK(&m->lock);
module.c:    return b != HT_NOTFOUND && (b->exportp || b->owner==m);
module.c:    JL_LOCK(&m->lock);
module.c:    JL_UNLOCK(&m->lock);
module.c:    return b != HT_NOTFOUND && b->exportp;
module.c:    JL_LOCK(&m->lock);
module.c:    JL_UNLOCK(&m->lock);
module.c:    return b != HT_NOTFOUND && b->owner != NULL;
module.c:    JL_LOCK(&m->lock);
module.c:    JL_UNLOCK(&m->lock);
module.c:    if (b->deprecated) jl_binding_deprecation_warning(m, b);
module.c:    return b->value;
module.c:    if (bp->value == NULL) {
module.c:        // if (jl_atomic_cmpswap(&bp->constp, &constp, 1)) {
module.c:        if (constp = bp->constp, bp->constp = 1, constp == 0) {
module.c:            if (jl_atomic_cmpswap(&bp->value, &old, val)) {
module.c:              jl_symbol_name(bp->name));
module.c:    return b && b->constp;
module.c:    if (b) b->deprecated = flag;
module.c:        return b && b->deprecated;
module.c:    size_t name_len = strlen(jl_symbol_name(deprecated_binding->name));
module.c:    memcpy(dep_binding_name + prefix_len, jl_symbol_name(deprecated_binding->name), name_len);
module.c:    if (b->deprecated == 1 && jl_options.depwarn) {
module.c:        if (b->owner) {
module.c:                      jl_symbol_name(b->owner->name), jl_symbol_name(b->name));
module.c:            dep_message_binding = jl_get_dep_message_binding(b->owner, b);
module.c:            jl_printf(JL_STDERR, "%s is deprecated", jl_symbol_name(b->name));
module.c:        if (dep_message_binding && dep_message_binding->value) {
module.c:            if (jl_isa(dep_message_binding->value, (jl_value_t*)jl_string_type)) {
module.c:                jl_uv_puts(JL_STDERR, jl_string_data(dep_message_binding->value),
module.c:                    jl_string_len(dep_message_binding->value));
module.c:                jl_static_show(JL_STDERR, dep_message_binding->value);
module.c:            jl_value_t *v = b->value;
module.c:                    if (mt != NULL && (mt->defs != jl_nothing ||
module.c:                        if (mt->module != jl_core_module) {
module.c:                            jl_static_show(JL_STDERR, (jl_value_t*)mt->module);
module.c:                        jl_printf(JL_STDERR, "%s", jl_symbol_name(mt->name));
module.c:                jl_printf(JL_STDERR, " in module %s\n", jl_symbol_name(m->name));
module.c:            if (b->owner)
module.c:                          jl_symbol_name(b->owner->name),
module.c:                          jl_symbol_name(b->name));
module.c:                jl_errorf("deprecated binding: %s", jl_symbol_name(b->name));
module.c:    if (b->constp) {
module.c:        if (jl_atomic_cmpswap(&b->value, &old, rhs)) {
module.c:                      jl_symbol_name(b->name));
module.c:                       jl_symbol_name(b->name));
module.c:    jl_atomic_store_relaxed(&b->value, rhs);
module.c:    if (b->value != NULL && !b->constp) {
module.c:                  jl_symbol_name(b->name));
module.c:    b->constp = 1;
module.c:    JL_LOCK(&m->lock);
module.c:    for(int i=(int)m->usings.len-1; i >= 0; --i) {
module.c:        jl_module_t *imp = (jl_module_t*)m->usings.items[i];
module.c:        jl_array_ptr_set(a,jl_array_dim0(a)-1, (jl_value_t*)imp);
module.c:    JL_UNLOCK(&m->lock);
module.c:    JL_LOCK(&m->lock);
module.c:    void **table = m->bindings.table;
module.c:    for (i = 1; i < m->bindings.size; i+=2) {
module.c:            int hidden = jl_symbol_name(b->name)[0]=='#';
module.c:            if ((b->exportp ||
module.c:                 (imported && b->imported) ||
module.c:                 (b->owner == m && !b->imported && (all || m == jl_main_module))) &&
module.c:                (all || (!b->deprecated && !hidden))) {
module.c:                jl_array_ptr_set(a, jl_array_dim0(a)-1, (jl_value_t*)b->name);
module.c:    JL_UNLOCK(&m->lock);
module.c:JL_DLLEXPORT jl_sym_t *jl_module_name(jl_module_t *m) { return m->name; }
module.c:JL_DLLEXPORT jl_module_t *jl_module_parent(jl_module_t *m) { return m->parent; }
module.c:JL_DLLEXPORT uint64_t jl_module_build_id(jl_module_t *m) { return m->build_id; }
module.c:JL_DLLEXPORT jl_uuid_t jl_module_uuid(jl_module_t* m) { return m->uuid; }
module.c:// TODO: make this part of the module constructor and read-only?
module.c:JL_DLLEXPORT void jl_set_module_uuid(jl_module_t *m, jl_uuid_t uuid) { m->uuid = uuid; }
module.c:        if (child == NULL || child == child->parent)
module.c:        child = child->parent;
module.c:    JL_LOCK(&m->lock);
module.c:    void **table = m->bindings.table;
module.c:    for (i = 1; i < m->bindings.size; i+=2) {
module.c:            if (b->owner != m && !b->imported)
module.c:    JL_UNLOCK(&m->lock);
julia_gcext.h:// marking, because it can lead to false positives, as non-pointer data
julia_gcext.h:// leaks (especially on 32-bit machines) if used inappropriately and how
julia_gcext.h:// Return a non-null pointer to the start of the stack area if the task
julia_gcext.h:// *tid will be set to -1.
julia_gcext.h:// accordingly. The range for the active part is a best-effort approximation
dyncall/dynload/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./dynload
dyncall/dynload/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/dynload/dynload_syms_mach-o.c: File: dynload/dynload_syms_mach-o.c
dyncall/dynload/dynload_syms_mach-o.c:   Copyright (c) 2007-2015 Olivier Chafik <olivier.chafik@gmail.com>,
dyncall/dynload/dynload_syms_mach-o.c:                 2017-2021 refactored completely for stability, API
dyncall/dynload/dynload_syms_mach-o.c: dynamic symbol resolver for Mach-O
dyncall/dynload/dynload_syms_mach-o.c:#include <mach-o/dyld.h>
dyncall/dynload/dynload_syms_mach-o.c:#include <mach-o/nlist.h>
dyncall/dynload/dynload_syms_mach-o.c:				/* free / refcount-- */
dyncall/dynload/dynload_syms_mach-o.c:	if(pHeader && (pHeader->magic == MACH_HEADER_MAGIC_NR) && (pHeader->filetype == MH_DYLIB)/*@@@ ignore for now, seems to work without it on El Capitan && !(pHeader->flags & MH_SPLIT_SEGS)*/)
dyncall/dynload/dynload_syms_mach-o.c:		for(i = 0, n = pHeader->ncmds; i < n; ++i, cmd = (const struct load_command*)((const char*)cmd + cmd->cmdsize))
dyncall/dynload/dynload_syms_mach-o.c:			if(cmd->cmd == SEGMEND_COMMAND_ID)
dyncall/dynload/dynload_syms_mach-o.c:				/*@@@ unsure why I used this instead of checking __TEXT: if((seg->fileoff == 0) && (seg->filesize != 0))*/
dyncall/dynload/dynload_syms_mach-o.c:				if(strcmp(seg->segname, "__TEXT") == 0)
dyncall/dynload/dynload_syms_mach-o.c:					slide = (uintptr_t)pHeader - seg->vmaddr; /* effective offset of segment from header */
dyncall/dynload/dynload_syms_mach-o.c:				if(strcmp(seg->segname, "__LINKEDIT") == 0) {
dyncall/dynload/dynload_syms_mach-o.c:					pBase = (const char*)(seg->vmaddr - seg->fileoff) + slide;
dyncall/dynload/dynload_syms_mach-o.c:			else if(cmd->cmd == LC_SYMTAB && !pSyms/* only init once - just safety check */)
dyncall/dynload/dynload_syms_mach-o.c:				/* cmd->cmdsize must be size of struct, otherwise something is off; abort */
dyncall/dynload/dynload_syms_mach-o.c:				if(cmd->cmdsize != sizeof(struct symtab_command))
dyncall/dynload/dynload_syms_mach-o.c:				pSyms->symbolCount  = scmd->nsyms;
dyncall/dynload/dynload_syms_mach-o.c:				pSyms->pStringTable = pBase + scmd->stroff;
dyncall/dynload/dynload_syms_mach-o.c:				pSyms->pSymbolTable = (struct NLIST_TYPE*)(pBase + scmd->symoff);
dyncall/dynload/dynload_syms_mach-o.c:				pSyms->symOffset    = symOffset;
dyncall/dynload/dynload_syms_mach-o.c:				pSyms->pLib         = pLib;
dyncall/dynload/dynload_syms_mach-o.c:			else if(cmd->cmd == LC_DYSYMTAB && !dysymtab_cmd/* only init once - just safety check */)
dyncall/dynload/dynload_syms_mach-o.c:				if(cmd->cmdsize != sizeof(struct symtab_command)) {
dyncall/dynload/dynload_syms_mach-o.c:			pSyms->pSymbolTable += dysymtab_cmd->ilocalsym;
dyncall/dynload/dynload_syms_mach-o.c:			pSyms->symbolCount = dysymtab_cmd->nlocalsym;
dyncall/dynload/dynload_syms_mach-o.c:		dlFreeLibrary(pSyms->pLib);
dyncall/dynload/dynload_syms_mach-o.c:	return pSyms ? pSyms->symbolCount : 0;
dyncall/dynload/dynload_syms_mach-o.c:	nl = pSyms->pSymbolTable + index;
dyncall/dynload/dynload_syms_mach-o.c:	t = nl->n_type & N_TYPE;
dyncall/dynload/dynload_syms_mach-o.c:	/* calls as used in dlFindAddress and dlSymsNameFromValue - the "#if 0"-ed code below returns the */
dyncall/dynload/dynload_syms_mach-o.c:	if((t == N_SECT) && (nl->n_type & N_STAB) == 0)
dyncall/dynload/dynload_syms_mach-o.c:		return dlSymsNameFromValue(pSyms, (void*)(nl->n_value + pSyms->symOffset));
dyncall/dynload/dynload_syms_mach-o.c:	/* Mach-O manual: Symbols with an index into the string table of zero */
dyncall/dynload/dynload_syms_mach-o.c:	if(nl->n_un.n_strx == 0)
dyncall/dynload/dynload_syms_mach-o.c:	/*TODO skip more symbols based on nl->n_desc and nl->n_type ? */
dyncall/dynload/dynload_syms_mach-o.c:	/* Return name - handles lookup of indirect names. */
dyncall/dynload/dynload_syms_mach-o.c:	return &pSyms->pStringTable[(t == N_INDR ? nl->n_value : nl->n_un.n_strx)
dyncall/dynload/dynload_syms_mach-o.c:		+ 1 /* Skip '_'-prefix */
dyncall/dynload/Makefile.generic:	rm -f ${OBJS} ${LIB}
dyncall/dynload/Makefile.generic:	mkdir -p ${PREFIX}/lib
dyncall/dynload/Makefile.generic:	mkdir -p ${PREFIX}/include
dyncall/dynload/dynload_syms.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dynload/dynload_syms.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dynload/dynload_syms.c:#include "dynload_syms_mach-o.c"
dyncall/dynload/README.txt:dynload / abstraction to run-time shared library services:
dyncall/dynload/README.txt:- loading/unloading into the current process
dyncall/dynload/README.txt:- symbol lookup
dyncall/dynload/README.txt:- enumerating symbol tables
dyncall/dynload/README.txt:- elf: support for DT_GNU_HASH
dyncall/dynload/README.txt:- a.out format
dyncall/dynload/README.txt:- support for different kind of symbols
dyncall/dynload/README.txt:Variants: Two core classes are defined Elf 32- and 64-bit. 
dyncall/dynload/README.txt:Only one model is compiled in the library (the current run-time format).
dyncall/dynload/README.txt: - elf32 has 21 sections
dyncall/dynload/README.txt: - elf64 has (21 + 2) sections
dyncall/dynload/README.txt: -       elf64 has  ".rela.*" 
dyncall/dynload/README.txt: - both have a ".gnu.hash" section
dyncall/dynload/README.txt:[5] http://refspecs.freestandards.org/LSB_3.2.0/LSB-Core-generic/LSB-Core-generic/symversion.html
dyncall/dynload/README.txt:[7] System V ABI Application Binary Interface - Draft 17 - December 2003 (SCO) : 
dyncall/dynload/dynload_unix.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dynload/dynload_unix.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dynload/dynload_unix.c:  dynload module for .so (unix) and .dylib (mach-o darwin/OS X) files
dyncall/dynload/dynload_unix.c:  /* Check for NULL for cross-platform consistency. *BSD seems to do that in
dyncall/dynload/dynload_unix.c:  object, dlclose() returns a non-zero value", which unfortunately sounds
dyncall/dynload/dynload_unix.c:/* for dlopen-based dlGetLibraryPath impls below, prefer RTLD_NOLOAD that
dyncall/dynload/dynload_unix.c:  int l = -1;
dyncall/dynload/dynload_unix.c:    l = dl_strlen_strcpy(sOut, p->l_name, bufSize);
dyncall/dynload/dynload_unix.c:/* specific implementation needed on Darwin -----> */
dyncall/dynload/dynload_unix.c:#include <mach-o/dyld.h>
dyncall/dynload/dynload_unix.c:  int l = -1;
dyncall/dynload/dynload_unix.c:    /* Darwin's code doesn't come with (non-standard) dlinfo(), so use dyld(1)
dyncall/dynload/dynload_unix.c:     * so "double-load" temporarily all already loaded images (just increases
dyncall/dynload/dynload_unix.c:      const char* libPath = _dyld_get_image_name(--i);
dyncall/dynload/dynload_unix.c:        /* be stored - should be safe b/c address needs alignment, anyways) */
dyncall/dynload/dynload_unix.c:/* - OpenBSD >= 3.7 has dl_iterate_phdr(), as well as glibc >= 2.2.4
dyncall/dynload/dynload_unix.c:   - also some libc impls (like musl) provide dlinfo(), but not RTLD_SELF (see above), however they might come
dyncall/dynload/dynload_unix.c:   - skip and use dladdr()-based guessing (see below) if explicitly requested, e.g. by ./configure
dyncall/dynload/dynload_unix.c:   - Haiku/BeOS does have the headers but no implementation of dl_iterate_phdr() (at least as of 2021) */
dyncall/dynload/dynload_unix.c:  int l = -1;
dyncall/dynload/dynload_unix.c:  if(d->pLib != NULL) {
dyncall/dynload/dynload_unix.c:    /* unable to relate info->dlpi_addr directly to our dlopen handle, let's
dyncall/dynload/dynload_unix.c:     * do what we do on macOS above, re-dlopen the already loaded lib (just
dyncall/dynload/dynload_unix.c:    lib = dlopen(info->dlpi_name, RTLD_LIGHTEST);
dyncall/dynload/dynload_unix.c:  /* compare handles and get name if found; if d->pLib == NULL this will
dyncall/dynload/dynload_unix.c:  if(lib == (void*)d->pLib) {
dyncall/dynload/dynload_unix.c:    l = dl_strlen_strcpy(d->sOut, info->dlpi_name, d->bufSize);
dyncall/dynload/dynload_unix.c:    if(l == 0 && d->pLib == NULL) {
dyncall/dynload/dynload_unix.c:      void* vladdr = (void*)info->dlpi_addr;
dyncall/dynload/dynload_unix.c:      for(; i < info->dlpi_phnum; ++i) {
dyncall/dynload/dynload_unix.c:        if(info->dlpi_phdr[i].p_type == PT_LOAD) {
dyncall/dynload/dynload_unix.c:          vladdr = (void*)(info->dlpi_addr + info->dlpi_phdr[i].p_vaddr);
dyncall/dynload/dynload_unix.c:        l = dl_strlen_strcpy(d->sOut, di.dli_fname, d->bufSize);
dyncall/dynload/dynload_unix.c:#warning "Using non-optimal code for dlGetLibraryPath() b/c of platform limitations."
dyncall/dynload/dynload_unix.c:/* if nothing else is available, fall back to guessing using dladdr() - this */
dyncall/dynload/dynload_unix.c:  int l = -1;
dyncall/dynload/dynload_syms_pe.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dynload/dynload_syms_pe.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dynload/dynload_syms_pe.c:  pNTHeader       = (IMAGE_NT_HEADERS*)(base + pDOSHeader->e_lfanew);
dyncall/dynload/dynload_syms_pe.c:  pExportsDataDir = &pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
dyncall/dynload/dynload_syms_pe.c:  pExports        = (IMAGE_EXPORT_DIRECTORY*)(base + pExportsDataDir->VirtualAddress);
dyncall/dynload/dynload_syms_pe.c:  pSyms->pBase  = base;
dyncall/dynload/dynload_syms_pe.c:  pSyms->pNames = (DWORD*)(base + pExports->AddressOfNames);
dyncall/dynload/dynload_syms_pe.c:  pSyms->pFuncs = (DWORD*)(base + pExports->AddressOfFunctions);
dyncall/dynload/dynload_syms_pe.c:  pSyms->pOrds  = (unsigned short*)(base + pExports->AddressOfNameOrdinals);
dyncall/dynload/dynload_syms_pe.c:  pSyms->count  = (size_t)pExports->NumberOfNames;
dyncall/dynload/dynload_syms_pe.c:  pSyms->pLib   = pLib;
dyncall/dynload/dynload_syms_pe.c:    dlFreeLibrary(pSyms->pLib);
dyncall/dynload/dynload_syms_pe.c:  return (int)pSyms->count;
dyncall/dynload/dynload_syms_pe.c:  return pSyms->pBase + pSyms->pNames[index];
dyncall/dynload/dynload_syms_pe.c:    if((void*)(pSyms->pBase + pSyms->pFuncs[pSyms->pOrds[i]]) == value)
dyncall/dynload/dynload_syms_elf.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dynload/dynload_syms_elf.c:                           Tassilo Philipp <tphilipp@potion-studios.com>,
dyncall/dynload/dynload_syms_elf.c:/* run-time configuration 64/32 */
dyncall/dynload/dynload_syms_elf.c:  if(stat(libPath, &st) == -1)
dyncall/dynload/dynload_syms_elf.c:  if(i == -1)
dyncall/dynload/dynload_syms_elf.c:  pSyms->file = i;
dyncall/dynload/dynload_syms_elf.c:  pSyms->fileSize = st.st_size;
dyncall/dynload/dynload_syms_elf.c:  pSyms->pElf_Ehdr = (Elf_Ehdr*) mmap((void*) NULL, pSyms->fileSize, PROT_READ, MAP_SHARED, pSyms->file, 0);
dyncall/dynload/dynload_syms_elf.c:  assert(pSyms->pElf_Ehdr->e_ident[EI_CLASS] == ELFCLASS32);
dyncall/dynload/dynload_syms_elf.c:  assert(pSyms->pElf_Ehdr->e_ident[EI_CLASS] == ELFCLASS64);
dyncall/dynload/dynload_syms_elf.c:  assert(pSyms->pElf_Ehdr->e_phoff > 0);
dyncall/dynload/dynload_syms_elf.c:  assert(pSyms->pElf_Ehdr->e_shoff > 0);
dyncall/dynload/dynload_syms_elf.c:  pMem = (unsigned char*)pSyms->pElf_Ehdr;
dyncall/dynload/dynload_syms_elf.c:  pS = (Elf_Shdr*) ( pMem + pSyms->pElf_Ehdr->e_shoff );
dyncall/dynload/dynload_syms_elf.c:  for (i = 1; i < pSyms->pElf_Ehdr->e_shnum; i++) 
dyncall/dynload/dynload_syms_elf.c:    void* pSectionContent = ((char*)pMem) + pSection->sh_offset;
dyncall/dynload/dynload_syms_elf.c:    switch (pSection->sh_type)
dyncall/dynload/dynload_syms_elf.c:        if (!pSyms->pSymTab) {
dyncall/dynload/dynload_syms_elf.c:          pSyms->pSymTab  = (Elf_Sym*)pSectionContent;
dyncall/dynload/dynload_syms_elf.c:          pSyms->nSymbols = pSection->sh_size / pSection->sh_entsize;
dyncall/dynload/dynload_syms_elf.c:        /* Do not trust pSyms->pElf_Ehdr->e_shstrndx! */
dyncall/dynload/dynload_syms_elf.c:        if (!pSyms->pStrTab) {
dyncall/dynload/dynload_syms_elf.c:          pSyms->pStrTab  = (const char*)pSectionContent;
dyncall/dynload/dynload_syms_elf.c:          pSyms->strTabSize = pSection->sh_size;
dyncall/dynload/dynload_syms_elf.c:    if (pSyms->pSymTab && pSyms->pStrTab)
dyncall/dynload/dynload_syms_elf.c:    munmap((void*) pSyms->pElf_Ehdr, pSyms->fileSize);
dyncall/dynload/dynload_syms_elf.c:    close(pSyms->file);
dyncall/dynload/dynload_syms_elf.c:  return pSyms ? pSyms->nSymbols : 0;
dyncall/dynload/dynload_syms_elf.c:  if(!pSyms || !pSyms->pSymTab || index < 0 || index >= pSyms->nSymbols)
dyncall/dynload/dynload_syms_elf.c:  str_index = pSyms->pSymTab[index].st_name;
dyncall/dynload/dynload_syms_elf.c:  if (str_index < 0 || str_index >= pSyms->strTabSize)
dyncall/dynload/dynload_syms_elf.c:  return &pSyms->pStrTab[str_index];
dyncall/dynload/dynload.c: Description: Auto-include delegate to windows/posix-based dynamic linker.
dyncall/dynload/dynload.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dynload/dynload.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dynload/dynload.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dynload/dynload.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dynload/dynload.h:/* symbol table enumeration - only for symbol lookup, not resolve */
dyncall/dynload/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dynload/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dynload/Nmakefile:#	$(AR) -rc $(ARFLAGS) "$@" $(OBJS)
dyncall/dynload/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/dynload/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object dynload/CMakeFiles/dynload_s.dir/dynload.c.o"
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dynload && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT dynload/CMakeFiles/dynload_s.dir/dynload.c.o -MF CMakeFiles/dynload_s.dir/dynload.c.o.d -o CMakeFiles/dynload_s.dir/dynload.c.o -c /home/chenningcong/Desktop/dyncall-1.2/dynload/dynload.c
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dynload_s.dir/dynload.c.i"
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dynload && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/dynload/dynload.c > CMakeFiles/dynload_s.dir/dynload.c.i
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dynload_s.dir/dynload.c.s"
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dynload && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/dynload/dynload.c -o CMakeFiles/dynload_s.dir/dynload.c.s
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Building C object dynload/CMakeFiles/dynload_s.dir/dynload_syms.c.o"
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dynload && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT dynload/CMakeFiles/dynload_s.dir/dynload_syms.c.o -MF CMakeFiles/dynload_s.dir/dynload_syms.c.o.d -o CMakeFiles/dynload_s.dir/dynload_syms.c.o -c /home/chenningcong/Desktop/dyncall-1.2/dynload/dynload_syms.c
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dynload_s.dir/dynload_syms.c.i"
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dynload && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/dynload/dynload_syms.c > CMakeFiles/dynload_s.dir/dynload_syms.c.i
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dynload_s.dir/dynload_syms.c.s"
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dynload && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/dynload/dynload_syms.c -o CMakeFiles/dynload_s.dir/dynload_syms.c.s
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Linking C static library libdynload_s.a"
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dynload && $(CMAKE_COMMAND) -P CMakeFiles/dynload_s.dir/cmake_clean_target.cmake
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dynload && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/dynload_s.dir/link.txt --verbose=$(VERBOSE)
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dynload && $(CMAKE_COMMAND) -P CMakeFiles/dynload_s.dir/cmake_clean.cmake
dyncall/dynload/CMakeFiles/dynload_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/dynload /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/dynload /home/chenningcong/Desktop/dyncall-1.2/dynload/CMakeFiles/dynload_s.dir/DependInfo.cmake --color=$(COLOR)
dyncall/dynload/CMakeFiles/dynload_s.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/dynload/CMakeFiles/dynload_s.dir/flags.make:C_FLAGS =   -fPIC
dyncall/dynload/CMakeFiles/dynload_s.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dynload/dynload.c" "dynload/CMakeFiles/dynload_s.dir/dynload.c.o" "gcc" "dynload/CMakeFiles/dynload_s.dir/dynload.c.o.d"
dyncall/dynload/CMakeFiles/dynload_s.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dynload/dynload_syms.c" "dynload/CMakeFiles/dynload_s.dir/dynload_syms.c.o" "gcc" "dynload/CMakeFiles/dynload_s.dir/dynload_syms.c.o.d"
dyncall/dynload/Makefile.embedded:MAKE_CMD  = ${MAKE} -f Makefile.embedded
dyncall/dynload/Makefile.embedded:	rm -f ${OBJS} ${TARGET}
dyncall/dynload/Makefile.embedded:	mkdir -p ${DESTDIR}${PREFIX}/include
dyncall/dynload/Makefile.embedded:	mkdir -p ${DESTDIR}${PREFIX}/lib
dyncall/dynload/Makefile.embedded:osx-universal:
dyncall/dynload/Makefile.embedded:	CFLAGS="${CFLAGS} -arch i386 -arch x86_64 -arch ppc" ASFLAGS="${ASFLAGS} -arch i386 -arch x86_64 -arch ppc" AR="libtool" ARFLAGS="-static -o" ${MAKE_CMD} all
dyncall/dynload/Makefile.embedded:sun-64bit:
dyncall/dynload/Makefile.embedded:	CFLAGS="${CFLAGS} -m64" ASFLAGS="${ASFLAGS} -m64" ${MAKE_CMD} all
dyncall/dynload/Makefile.embedded:sun-gcc:
dyncall/dynload/Makefile.embedded:	CC=gcc CFLAGS="${CFLAGS} -fPIC" ${MAKE_CMD} all
dyncall/dynload/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/dynload
dyncall/dynload/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/dynload/cmake_install.cmake:  file(INSTALL DESTINATION "${CMAKE_INSTALL_PREFIX}/lib" TYPE STATIC_LIBRARY FILES "/home/chenningcong/Desktop/dyncall-1.2/dynload/libdynload_s.a")
dyncall/dynload/cmake_install.cmake:  file(INSTALL DESTINATION "${CMAKE_INSTALL_PREFIX}/include" TYPE FILE FILES "/home/chenningcong/Desktop/dyncall-1.2/dynload/dynload.h")
dyncall/dynload/dynload_alloc.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dynload/dynload_alloc.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dynload/dynload_windows.c:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dynload/dynload_windows.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dynload/dynload_windows.c:    /* convert from UTF-8 to wide chars, so count required size */
dyncall/dynload/dynload_windows.c:    int r = MultiByteToWideChar(CP_UTF8, 0, libPath, -1, NULL, 0);
dyncall/dynload/dynload_windows.c:    if(MultiByteToWideChar(CP_UTF8, 0, libPath, -1, ws, r) == r) {
dyncall/dynload/dynload_windows.c:        ws[r-1] = '.';
dyncall/dynload/dynload_windows.c:  /* get the path name as wide chars, then convert to UTF-8; we need   */
dyncall/dynload/dynload_windows.c:    r = WideCharToMultiByte(CP_UTF8, 0, ws, -1, NULL, 0, NULL, NULL);
dyncall/dynload/dynload_windows.c:      r = WideCharToMultiByte(CP_UTF8, 0, ws, -1, sOut, bufSize, NULL, NULL);
dyncall/dynload/CMakeLists.txt:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>
dyncall/dynload/dynload.3:.\" Copyright (c) 2007-2020 Daniel Adler <dadler AT uni-goettingen DOT de>,
dyncall/dynload/dynload.3:.\"                         Tassilo Philipp <tphilipp AT potion-studios DOT com>
dyncall/dynload/dynload.3:argument is expected to be UTF-8 encoded. Returns a null pointer on error.
dyncall/dynload/dynload.3:(in bytes), to hold the output string (UTF-8 encoded). The return value is the size of the buffer (in bytes) needed to hold the null-terminated string, or 0 if it can't be looked up. If
dyncall/dynload/dynload.3:>= return value >= 1, a null-terminted string with the path to the library should be in
dyncall/dynload/dynload.3:returns the path to the executable (not guaranteed to be absolute - if it isn't it's relative to the working directory the process was started in, not the current one).
dyncall/dynload/dynload.3:to be used with the other dlSyms* functions. Note that contrary to loading and linking libraries, no (OS-specific) rules for searching libraries in library paths, etc. apply. The handle must be freed with
dyncall/dynload/dynload.3:does handle loading dylibs on macos >= 11.0.1 that aren't on the file system but are provided through the OS' "built-in dynamic linker cache of all system-provided libraries" (to load, use same "path" as one would with dlopen(3)).
dyncall/dynload/dynload.3:is not thread-safe on Darwin (macOS, iOS, ...) and OpenBSD.
dyncall/dynload/dynload.3:is not thread-safe on Darwin.
dyncall/dynload/dynload.3:.An "Daniel Adler" Aq dadler@uni-goettingen.de
dyncall/dynload/dynload.3:.An "Tassilo Philipp" Aq tphilipp@potion-studios.com
dyncall/BUGS:- add support for SELinux
dyncall/BUGS:- dyncall sparc v7/v8: -xO3 on SunPro segfaults in tests.
dyncall/BUGS:- dyncall sparc64 port: works fine on Debian 6, but has issues on OpenBSD and Solaris regarding passing of float and double values.
dyncall/BUGS:- this BUGS file should be merged with ToDo or vice-versa
dyncall/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/.
dyncall/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/sign/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/sign
dyncall/test/sign/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/sign/Makefile.generic:CFLAGS += -I${SRCTOP}/dyncall
dyncall/test/sign/Makefile.generic:LDLIBS += -L${BLDTOP}/dyncall -ldyncall_s 
dyncall/test/sign/Makefile.generic:CFLAGS += -O3
dyncall/test/sign/Makefile.generic:	${CC} ${CFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP} 
dyncall/test/sign/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/sign/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/sign/sign.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/sign/sign.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/sign/sign.c:// This test program indicates failure on powerpc 32-bit with
dyncall/test/sign/sign.c:// compiler optimizations enabled (e.g. '-O2' compilation flags).
dyncall/test/sharedlib/Makefile:# Allow only one "make -f Makefile2" at a time, but pass parallelism.
dyncall/test/sharedlib/Makefile:# Disable VCS-based implicit rules.
dyncall/test/sharedlib/Makefile:# Disable VCS-based implicit rules.
dyncall/test/sharedlib/Makefile:# Disable VCS-based implicit rules.
dyncall/test/sharedlib/Makefile:# Disable VCS-based implicit rules.
dyncall/test/sharedlib/Makefile:# Disable VCS-based implicit rules.
dyncall/test/sharedlib/Makefile:# Command-line flag to silence nested $(MAKE).
dyncall/test/sharedlib/Makefile:$(VERBOSE)MAKESILENT = -s
dyncall/test/sharedlib/Makefile:RM = /usr/bin/cmake -E rm -f
dyncall/test/sharedlib/Makefile:# The top-level source directory on which CMake was run.
dyncall/test/sharedlib/Makefile:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/sharedlib/Makefile:# The top-level build directory on which CMake was run.
dyncall/test/sharedlib/Makefile:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/sharedlib/Makefile:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Installing the project stripped..."
dyncall/test/sharedlib/Makefile:	/usr/bin/cmake -DCMAKE_INSTALL_DO_STRIP=1 -P cmake_install.cmake
dyncall/test/sharedlib/Makefile:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Installing the project stripped..."
dyncall/test/sharedlib/Makefile:	/usr/bin/cmake -DCMAKE_INSTALL_DO_STRIP=1 -P cmake_install.cmake
dyncall/test/sharedlib/Makefile:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Installing only the local directory..."
dyncall/test/sharedlib/Makefile:	/usr/bin/cmake -DCMAKE_INSTALL_LOCAL_ONLY=1 -P cmake_install.cmake
dyncall/test/sharedlib/Makefile:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Installing only the local directory..."
dyncall/test/sharedlib/Makefile:	/usr/bin/cmake -DCMAKE_INSTALL_LOCAL_ONLY=1 -P cmake_install.cmake
dyncall/test/sharedlib/Makefile:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running CMake cache editor..."
dyncall/test/sharedlib/Makefile:	/usr/bin/ccmake -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR)
dyncall/test/sharedlib/Makefile:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Run CPack packaging tool for source..."
dyncall/test/sharedlib/Makefile:	cd /home/chenningcong/Desktop/dyncall-1.2 && /usr/bin/cpack --config ./CPackSourceConfig.cmake /home/chenningcong/Desktop/dyncall-1.2/CPackSourceConfig.cmake
dyncall/test/sharedlib/Makefile:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Install the project..."
dyncall/test/sharedlib/Makefile:	/usr/bin/cmake -P cmake_install.cmake
dyncall/test/sharedlib/Makefile:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Install the project..."
dyncall/test/sharedlib/Makefile:	/usr/bin/cmake -P cmake_install.cmake
dyncall/test/sharedlib/Makefile:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Available install components are: \"Unspecified\""
dyncall/test/sharedlib/Makefile:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running CMake to regenerate build system..."
dyncall/test/sharedlib/Makefile:	/usr/bin/cmake --regenerate-during-build -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR)
dyncall/test/sharedlib/Makefile:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Run CPack packaging tool..."
dyncall/test/sharedlib/Makefile:	cd /home/chenningcong/Desktop/dyncall-1.2 && /usr/bin/cpack --config ./CPackConfig.cmake
dyncall/test/sharedlib/Makefile:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles /home/chenningcong/Desktop/dyncall-1.2/test/sharedlib//CMakeFiles/progress.marks
dyncall/test/sharedlib/Makefile:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/sharedlib/all
dyncall/test/sharedlib/Makefile:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/test/sharedlib/Makefile:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/sharedlib/clean
dyncall/test/sharedlib/Makefile:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/sharedlib/preinstall
dyncall/test/sharedlib/Makefile:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/sharedlib/preinstall
dyncall/test/sharedlib/Makefile:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 1
dyncall/test/sharedlib/Makefile:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/sharedlib/CMakeFiles/sharedlib.dir/rule
dyncall/test/sharedlib/Makefile:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(MAKE) $(MAKESILENT) -f test/sharedlib/CMakeFiles/sharedlib.dir/build.make test/sharedlib/CMakeFiles/sharedlib.dir/build
dyncall/test/sharedlib/Makefile:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(MAKE) $(MAKESILENT) -f test/sharedlib/CMakeFiles/sharedlib.dir/build.make test/sharedlib/CMakeFiles/sharedlib.dir/sharedlib.c.o
dyncall/test/sharedlib/Makefile:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(MAKE) $(MAKESILENT) -f test/sharedlib/CMakeFiles/sharedlib.dir/build.make test/sharedlib/CMakeFiles/sharedlib.dir/sharedlib.c.i
dyncall/test/sharedlib/Makefile:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(MAKE) $(MAKESILENT) -f test/sharedlib/CMakeFiles/sharedlib.dir/build.make test/sharedlib/CMakeFiles/sharedlib.dir/sharedlib.c.s
dyncall/test/sharedlib/Makefile:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 0
dyncall/test/sharedlib/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/sharedlib/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object test/sharedlib/CMakeFiles/sharedlib.dir/sharedlib.c.o"
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/sharedlib && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/sharedlib/CMakeFiles/sharedlib.dir/sharedlib.c.o -MF CMakeFiles/sharedlib.dir/sharedlib.c.o.d -o CMakeFiles/sharedlib.dir/sharedlib.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/sharedlib.c
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/sharedlib.dir/sharedlib.c.i"
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/sharedlib && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/sharedlib.c > CMakeFiles/sharedlib.dir/sharedlib.c.i
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/sharedlib.dir/sharedlib.c.s"
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/sharedlib && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/sharedlib.c -o CMakeFiles/sharedlib.dir/sharedlib.c.s
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Linking C shared library libsharedlib.so"
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/sharedlib && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/sharedlib.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/sharedlib && $(CMAKE_COMMAND) -P CMakeFiles/sharedlib.dir/cmake_clean.cmake
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/sharedlib /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/sharedlib /home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/CMakeFiles/sharedlib.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/flags.make:C_DEFINES = -Dsharedlib_EXPORTS
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/flags.make:C_FLAGS = -fPIC   -fPIC
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/link.txt:/usr/bin/cc -fPIC -shared -Wl,-soname,libsharedlib.so -o libsharedlib.so CMakeFiles/sharedlib.dir/sharedlib.c.o  ../../dynload/libdynload_s.a 
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/sharedlib.c" "test/sharedlib/CMakeFiles/sharedlib.dir/sharedlib.c.o" "gcc" "test/sharedlib/CMakeFiles/sharedlib.dir/sharedlib.c.o.d"
dyncall/test/sharedlib/CMakeFiles/sharedlib.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dynload/CMakeFiles/dynload_s.dir/DependInfo.cmake"
dyncall/test/sharedlib/Makefile.embedded:MAKE_CMD  = ${MAKE} -f ${MAKEFILE}
dyncall/test/sharedlib/Makefile.embedded:CPPFLAGS += -I../../dynload
dyncall/test/sharedlib/Makefile.embedded:LDFLAGS  += -L../../dynload
dyncall/test/sharedlib/Makefile.embedded:LDLIBS   += -ldynload_s
dyncall/test/sharedlib/Makefile.embedded:	${CC} -shared -o $@ $? ${LDFLAGS} ${LDLIBS}
dyncall/test/sharedlib/Makefile.embedded:	rm -f ${TARGET} ${OBJS}
dyncall/test/sharedlib/Makefile.embedded:sun-gcc:
dyncall/test/sharedlib/Makefile.embedded:	CC=gcc CFLAGS="${CFLAGS} -fPIC" ${MAKE_CMD} all
dyncall/test/sharedlib/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/sharedlib
dyncall/test/sharedlib/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/sharedlib/sharedlib.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/sharedlib/sharedlib.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32std/case.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2_x86win32std/case.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32std/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/suite2_x86win32std
dyncall/test/suite2_x86win32std/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/suite2_x86win32std/main.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2_x86win32std/main.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32std/main.cc:  const DCsigchar* sig = &fi->sig[2];
dyncall/test/suite2_x86win32std/main.cc:  dcCallVoid( pCall, fi->funcptr );
dyncall/test/suite2_x86win32std/main.cc:        case DC_SIGCHAR_BOOL: if ( getArg(pos)->B != valueBool  [pos] ) r = false; break;
dyncall/test/suite2_x86win32std/main.cc:        case DC_SIGCHAR_CHAR: if ( getArg(pos)->c != valueChar  [pos] ) r = false; break;
dyncall/test/suite2_x86win32std/main.cc:        case DC_SIGCHAR_SHORT: if ( getArg(pos)->s != valueShort  [pos] ) r = false; break;
dyncall/test/suite2_x86win32std/main.cc:        case DC_SIGCHAR_INT: if ( getArg(pos)->i != valueInt   [pos] ) r = false; break;
dyncall/test/suite2_x86win32std/main.cc:        case DC_SIGCHAR_LONG: if ( getArg(pos)->l != valueLong [pos] ) r = false; break;
dyncall/test/suite2_x86win32std/main.cc:        case DC_SIGCHAR_LONGLONG: if ( getArg(pos)->L != valueLongLong  [pos] ) r = false; break;
dyncall/test/suite2_x86win32std/main.cc:        case DC_SIGCHAR_FLOAT: if ( getArg(pos)->f != valueFloat [pos] ) r = false; break;
dyncall/test/suite2_x86win32std/main.cc:        case DC_SIGCHAR_DOUBLE: if ( getArg(pos)->d != valueDouble[pos] ) r = false; break;
dyncall/test/suite2_x86win32std/main.cc:        case DC_SIGCHAR_POINTER: if ( getArg(pos)->p != valuePointer   [pos] ) r = false; break;
dyncall/test/suite2_x86win32std/main.cc:  printf("%d-%s:%d\n", x, sig, r);
dyncall/test/suite2_x86win32std/main.cc:  return (success) ? 0 : -1;
dyncall/test/suite2_x86win32std/Makefile.generic:CFLAGS  = -I${TOP}/dyncall
dyncall/test/suite2_x86win32std/Makefile.generic:LDFLAGS = -L${TOP}/dyncall
dyncall/test/suite2_x86win32std/Makefile.generic:LDLIBS  = -ldyncall_s
dyncall/test/suite2_x86win32std/Makefile.generic:RM      ?= rm -f
dyncall/test/suite2_x86win32std/Makefile.generic:INSTALL ?= install -p
dyncall/test/suite2_x86win32std/Makefile.generic:	${LINK} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP} ${TARGET_ARCH}
dyncall/test/suite2_x86win32std/rand.py:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2_x86win32std/rand.py:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32std/rand.py:  x = random.randint( 0, len(apitypes)-1 )
dyncall/test/suite2_x86win32std/rand.py:    x = random.randint( 0, len(argtypes)-1 )
dyncall/test/suite2_x86win32std/case.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite2_x86win32std/case.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32std/mkcase.py:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2_x86win32std/mkcase.py:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32std/mkcase.py:  # args  = len(line)-1
dyncall/test/suite2_x86win32std/config.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite2_x86win32std/config.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32std/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2_x86win32std/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32std/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/suite2_x86win32std/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/suite2_x86win32std/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/suite2_x86win32std/funcinfo.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2_x86win32std/funcinfo.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/suite
dyncall/test/suite/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/suite/Makefile.generic:CFLAGS += -I${SRCTOP}/dyncall
dyncall/test/suite/Makefile.generic:LDLIBS += -L${BLDTOP}/dyncall -ldyncall_s 
dyncall/test/suite/Makefile.generic:	${CC} ${CFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP}
dyncall/test/suite/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/suite/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/suite/README.txt:Copyright (c) 2007-2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite/README.txt:                        Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite/README.txt:  suite         	        - run full range
dyncall/test/suite/README.txt:  suite <id> 			- run test id <id>
dyncall/test/suite/README.txt:  suite <from> <to>		- run test id <from> to id <to> (inclusive).
dyncall/test/suite/README.txt:  the test invokes 'void'-functions that effectively overwrite global 
dyncall/test/suite/README.txt:    sets all arguments into type-specific value vectors at the given position
dyncall/test/suite/mkfile:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite/mkfile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite/case.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite/case.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite/main.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite/main.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite/main.c:    case ID_BOOL:     return ( getArg(pos)->B == valueBool    [pos] ); break;
dyncall/test/suite/main.c:    case ID_INT:      return ( getArg(pos)->i == valueInt     [pos] ); break;
dyncall/test/suite/main.c:    case ID_LONGLONG: return ( getArg(pos)->l == valueLongLong[pos] ); break;
dyncall/test/suite/main.c:    case ID_DOUBLE:   return ( getArg(pos)->d == valueDouble  [pos] ); break;
dyncall/test/suite/main.c:    case ID_POINTER:  return ( getArg(pos)->p == valuePointer [pos] ); break;
dyncall/test/suite/main.c:    case ID_FLOAT:    return ( getArg(pos)->f == valueFloat   [pos] ); break;
dyncall/test/suite/main.c:    int select = (y-1) % NTYPES; 
dyncall/test/suite/main.c:    y = (y-1) / NTYPES;
dyncall/test/suite/main.c:  return (int)(pow((double)x,n)+powerfact(x,n-1));
dyncall/test/suite/main.c:  return (success) ? 0 : -1;
dyncall/test/suite/mkcase.py:# Copyright (c) 2007,2011 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite/mkcase.py:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite/mkcase.py:    return x**n+powerfact(x,n-1)
dyncall/test/suite/mkcase.py:    s     = (y-1) % ntypes
dyncall/test/suite/mkcase.py:    y     = (y-1) / ntypes
dyncall/test/suite/config.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite/config.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite/case.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite/case.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/suite/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/suite/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/suite/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/suite/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/suite/CMakeFiles/suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite/CMakeFiles/suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite/CMakeFiles/suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite/CMakeFiles/suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite/CMakeFiles/suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite/CMakeFiles/suite.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/suite/CMakeFiles/suite.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/suite/CMakeFiles/suite.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/suite/CMakeFiles/suite.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/suite/CMakeFiles/suite.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/suite/CMakeFiles/suite.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/suite/CMakeFiles/suite.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object test/suite/CMakeFiles/suite.dir/main.c.o"
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/suite/CMakeFiles/suite.dir/main.c.o -MF CMakeFiles/suite.dir/main.c.o.d -o CMakeFiles/suite.dir/main.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/suite/main.c
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/suite.dir/main.c.i"
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/suite/main.c > CMakeFiles/suite.dir/main.c.i
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/suite.dir/main.c.s"
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/suite/main.c -o CMakeFiles/suite.dir/main.c.s
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Building C object test/suite/CMakeFiles/suite.dir/case.c.o"
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/suite/CMakeFiles/suite.dir/case.c.o -MF CMakeFiles/suite.dir/case.c.o.d -o CMakeFiles/suite.dir/case.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/suite/case.c
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/suite.dir/case.c.i"
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/suite/case.c > CMakeFiles/suite.dir/case.c.i
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/suite.dir/case.c.s"
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/suite/case.c -o CMakeFiles/suite.dir/case.c.s
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Linking C executable suite"
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/suite.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite && $(CMAKE_COMMAND) -P CMakeFiles/suite.dir/cmake_clean.cmake
dyncall/test/suite/CMakeFiles/suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/suite /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/suite /home/chenningcong/Desktop/dyncall-1.2/test/suite/CMakeFiles/suite.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/suite/CMakeFiles/suite.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/suite/CMakeFiles/suite.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/suite/CMakeFiles/suite.dir/flags.make:C_FLAGS =   -fPIC
dyncall/test/suite/CMakeFiles/suite.dir/link.txt:/usr/bin/cc -rdynamic CMakeFiles/suite.dir/main.c.o CMakeFiles/suite.dir/case.c.o -o suite  ../../dyncall/libdyncall_s.a -lm 
dyncall/test/suite/CMakeFiles/suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/suite/case.c" "test/suite/CMakeFiles/suite.dir/case.c.o" "gcc" "test/suite/CMakeFiles/suite.dir/case.c.o.d"
dyncall/test/suite/CMakeFiles/suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/suite/main.c" "test/suite/CMakeFiles/suite.dir/main.c.o" "gcc" "test/suite/CMakeFiles/suite.dir/main.c.o.d"
dyncall/test/suite/CMakeFiles/suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake"
dyncall/test/suite/Makefile.embedded:CFLAGS  += -I${SRCTOP}/dyncall
dyncall/test/suite/Makefile.embedded:LDFLAGS += -L${BLDTOP}/dyncall
dyncall/test/suite/Makefile.embedded:LDLIBS  += -ldyncall_s 
dyncall/test/suite/Makefile.embedded:	${CC} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP}
dyncall/test/suite/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/suite/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/suite
dyncall/test/suite/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/ellipsis/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/ellipsis
dyncall/test/ellipsis/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/ellipsis/main.cc: Description: call (...) functions via dyncall library, targets are auto-generated
dyncall/test/ellipsis/main.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/ellipsis/main.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/ellipsis/main.cc:    case 0: return ( getArg(pos)->i == valueInt     [pos] ); break;
dyncall/test/ellipsis/main.cc:    case 1: return ( getArg(pos)->l == valueLongLong[pos] ); break;
dyncall/test/ellipsis/main.cc:    case 2: return ( getArg(pos)->d == valueDouble  [pos] ); break;
dyncall/test/ellipsis/main.cc:    case 3: return ( getArg(pos)->p == valuePointer [pos] ); break;
dyncall/test/ellipsis/main.cc:    int select = (y-1) % NTYPES; 
dyncall/test/ellipsis/main.cc:    y = (y-1) / NTYPES;
dyncall/test/ellipsis/main.cc:    int select = (y-1) % NTYPES; 
dyncall/test/ellipsis/main.cc:    y = (y-1) / NTYPES;
dyncall/test/ellipsis/main.cc:  return static_cast<int>( pow((double)x,n)+powerfact(x,n-1) );
dyncall/test/ellipsis/main.cc:  return (success) ? 0 : -1;
dyncall/test/ellipsis/Makefile.generic:CXXFLAGS += -I${SRCTOP}/dyncall
dyncall/test/ellipsis/Makefile.generic:LDLIBS   += -L${BLDTOP}/dyncall -ldyncall_s
dyncall/test/ellipsis/Makefile.generic:	${CXX} ${CXXFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP} 
dyncall/test/ellipsis/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/ellipsis/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/ellipsis/README.txt:Copyright (c) 2007-2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/ellipsis/README.txt:                        Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/ellipsis/README.txt:  ellipsis         	        - run full range
dyncall/test/ellipsis/README.txt:  ellipsis <id> 		- run test id <id>
dyncall/test/ellipsis/README.txt:  ellipsis <from> <to>		- run test id <from> to id <to> (inclusive).
dyncall/test/ellipsis/README.txt:  the test invokes 'void'-ellipsis functions that effectively overwrite global 
dyncall/test/ellipsis/README.txt:    sets all arguments into type-specific value vectors at the given position
dyncall/test/ellipsis/case.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/ellipsis/case.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/ellipsis/mkcase.py:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/ellipsis/mkcase.py:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/ellipsis/mkcase.py:    return x**n+powerfact(x,n-1)
dyncall/test/ellipsis/mkcase.py:    s     = (y-1) % ntypes
dyncall/test/ellipsis/mkcase.py:    y     = (y-1) / ntypes
dyncall/test/ellipsis/config.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/ellipsis/config.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/ellipsis/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/ellipsis/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/ellipsis/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/ellipsis/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/ellipsis/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/ellipsis/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/ellipsis/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building CXX object test/ellipsis/CMakeFiles/ellipsis.dir/main.cc.o"
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT test/ellipsis/CMakeFiles/ellipsis.dir/main.cc.o -MF CMakeFiles/ellipsis.dir/main.cc.o.d -o CMakeFiles/ellipsis.dir/main.cc.o -c /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/main.cc
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/ellipsis.dir/main.cc.i"
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/main.cc > CMakeFiles/ellipsis.dir/main.cc.i
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/ellipsis.dir/main.cc.s"
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/main.cc -o CMakeFiles/ellipsis.dir/main.cc.s
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Building CXX object test/ellipsis/CMakeFiles/ellipsis.dir/ellipsis.cc.o"
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT test/ellipsis/CMakeFiles/ellipsis.dir/ellipsis.cc.o -MF CMakeFiles/ellipsis.dir/ellipsis.cc.o.d -o CMakeFiles/ellipsis.dir/ellipsis.cc.o -c /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/ellipsis.cc
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/ellipsis.dir/ellipsis.cc.i"
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/ellipsis.cc > CMakeFiles/ellipsis.dir/ellipsis.cc.i
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/ellipsis.dir/ellipsis.cc.s"
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/ellipsis.cc -o CMakeFiles/ellipsis.dir/ellipsis.cc.s
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Linking CXX executable ellipsis"
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/ellipsis.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis && $(CMAKE_COMMAND) -P CMakeFiles/ellipsis.dir/cmake_clean.cmake
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/CMakeFiles/ellipsis.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/flags.make:CXX_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/flags.make:CXX_FLAGS =   -fPIC
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/link.txt:/usr/bin/c++ -rdynamic CMakeFiles/ellipsis.dir/main.cc.o CMakeFiles/ellipsis.dir/ellipsis.cc.o -o ellipsis  ../../dyncall/libdyncall_s.a 
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/ellipsis.cc" "test/ellipsis/CMakeFiles/ellipsis.dir/ellipsis.cc.o" "gcc" "test/ellipsis/CMakeFiles/ellipsis.dir/ellipsis.cc.o.d"
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/main.cc" "test/ellipsis/CMakeFiles/ellipsis.dir/main.cc.o" "gcc" "test/ellipsis/CMakeFiles/ellipsis.dir/main.cc.o.d"
dyncall/test/ellipsis/CMakeFiles/ellipsis.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake"
dyncall/test/ellipsis/Makefile.embedded:CFLAGS  += -I${TOP}/dyncall
dyncall/test/ellipsis/Makefile.embedded:LDFLAGS += -L${TOP}/dyncall
dyncall/test/ellipsis/Makefile.embedded:LDLIBS  += -ldyncall_s
dyncall/test/ellipsis/Makefile.embedded:	${CXX} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP} 
dyncall/test/ellipsis/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/ellipsis/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/ellipsis
dyncall/test/ellipsis/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/ellipsis/ellipsis.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/ellipsis/ellipsis.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_floats/case.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_floats/case.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_floats/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/suite_floats
dyncall/test/suite_floats/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/suite_floats/main.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_floats/main.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_floats/main.cc:    case 0: return ( getArg(pos)->d == valueDouble  [pos] ); break;
dyncall/test/suite_floats/main.cc:    case 1: return ( getArg(pos)->f == valueFloat   [pos] ); break;
dyncall/test/suite_floats/main.cc:    int select = (y-1) % NTYPES; 
dyncall/test/suite_floats/main.cc:    y = (y-1) / NTYPES;
dyncall/test/suite_floats/main.cc:  return static_cast<int>( pow((double)x,n)+powerfact(x,n-1) );
dyncall/test/suite_floats/main.cc:  return (success) ? 0 : -1;
dyncall/test/suite_floats/Makefile.generic:CXXFLAGS += -I${SRCTOP}/dyncall
dyncall/test/suite_floats/Makefile.generic:LDLIBS   += -L${BLDTOP}/dyncall -ldyncall_s
dyncall/test/suite_floats/Makefile.generic:	${CXX} ${CXXFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP}
dyncall/test/suite_floats/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/suite_floats/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/suite_floats/README.txt:Copyright (c) 2007-2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_floats/README.txt:                        Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_floats/README.txt:  suite_floats         	        - run full range
dyncall/test/suite_floats/README.txt:  suite_floats <id> 			- run test id <id>
dyncall/test/suite_floats/README.txt:  suite_floats <from> <to>		- run test id <from> to id <to> (inclusive).
dyncall/test/suite_floats/README.txt:  the test invokes 'void'-functions that effectively overwrite global 
dyncall/test/suite_floats/README.txt:    sets all arguments into type-specific value vectors at the given position
dyncall/test/suite_floats/case.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite_floats/case.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_floats/mkcase.py:# Copyright (c) 2007,2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_floats/mkcase.py:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_floats/mkcase.py:    return x**n+powerfact(x,n-1)
dyncall/test/suite_floats/mkcase.py:    s     = (y-1) % ntypes
dyncall/test/suite_floats/mkcase.py:    y     = (y-1) / ntypes
dyncall/test/suite_floats/config.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite_floats/config.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_floats/Nmakefile:# Copyright (c) 2007,2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_floats/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_floats/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/suite_floats/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/suite_floats/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/suite_floats/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/suite_floats/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building CXX object test/suite_floats/CMakeFiles/suite_floats.dir/case.cc.o"
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT test/suite_floats/CMakeFiles/suite_floats.dir/case.cc.o -MF CMakeFiles/suite_floats.dir/case.cc.o.d -o CMakeFiles/suite_floats.dir/case.cc.o -c /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/case.cc
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/suite_floats.dir/case.cc.i"
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/case.cc > CMakeFiles/suite_floats.dir/case.cc.i
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/suite_floats.dir/case.cc.s"
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/case.cc -o CMakeFiles/suite_floats.dir/case.cc.s
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Building CXX object test/suite_floats/CMakeFiles/suite_floats.dir/main.cc.o"
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT test/suite_floats/CMakeFiles/suite_floats.dir/main.cc.o -MF CMakeFiles/suite_floats.dir/main.cc.o.d -o CMakeFiles/suite_floats.dir/main.cc.o -c /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/main.cc
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/suite_floats.dir/main.cc.i"
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/main.cc > CMakeFiles/suite_floats.dir/main.cc.i
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/suite_floats.dir/main.cc.s"
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/main.cc -o CMakeFiles/suite_floats.dir/main.cc.s
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Linking CXX executable suite_floats"
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/suite_floats.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats && $(CMAKE_COMMAND) -P CMakeFiles/suite_floats.dir/cmake_clean.cmake
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/CMakeFiles/suite_floats.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/flags.make:CXX_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/flags.make:CXX_FLAGS =   -fPIC
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/link.txt:/usr/bin/c++ -rdynamic CMakeFiles/suite_floats.dir/case.cc.o CMakeFiles/suite_floats.dir/main.cc.o -o suite_floats  ../../dyncall/libdyncall_s.a 
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/case.cc" "test/suite_floats/CMakeFiles/suite_floats.dir/case.cc.o" "gcc" "test/suite_floats/CMakeFiles/suite_floats.dir/case.cc.o.d"
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/main.cc" "test/suite_floats/CMakeFiles/suite_floats.dir/main.cc.o" "gcc" "test/suite_floats/CMakeFiles/suite_floats.dir/main.cc.o.d"
dyncall/test/suite_floats/CMakeFiles/suite_floats.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake"
dyncall/test/suite_floats/Makefile.embedded:CFLAGS  += -I${TOP}/dyncall
dyncall/test/suite_floats/Makefile.embedded:LDFLAGS += -L${TOP}/dyncall
dyncall/test/suite_floats/Makefile.embedded:LDLIBS  += -ldyncall_s
dyncall/test/suite_floats/Makefile.embedded:	${CXX} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP}
dyncall/test/suite_floats/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/suite_floats/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/suite_floats
dyncall/test/suite_floats/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test
dyncall/test/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/suite_x86win32fast/case.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_x86win32fast/case.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32fast/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/suite_x86win32fast
dyncall/test/suite_x86win32fast/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/suite_x86win32fast/main.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_x86win32fast/main.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32fast/main.cc:    case 0: return ( getArg(pos)->B == valueBool[pos] ); break;
dyncall/test/suite_x86win32fast/main.cc:    case 1: return ( getArg(pos)->i == valueInt[pos] ); break;
dyncall/test/suite_x86win32fast/main.cc:    case 2: return ( getArg(pos)->l == valueLongLong[pos] ); break;
dyncall/test/suite_x86win32fast/main.cc:    case 3: return ( getArg(pos)->d == valueDouble[pos] ); break;
dyncall/test/suite_x86win32fast/main.cc:    case 4: return ( getArg(pos)->p == valuePointer[pos] ); break;
dyncall/test/suite_x86win32fast/main.cc:    case 5: return ( getArg(pos)->f == valueFloat[pos] ); break;
dyncall/test/suite_x86win32fast/main.cc:    int select = (y-1) % NTYPES; 
dyncall/test/suite_x86win32fast/main.cc:    y = (y-1) / NTYPES;
dyncall/test/suite_x86win32fast/main.cc:  return static_cast<int>( pow((double)x,n)+powerfact(x,n-1) );
dyncall/test/suite_x86win32fast/main.cc:  return (success) ? 0 : -1;
dyncall/test/suite_x86win32fast/Makefile.generic:CFLAGS  += -I${SRCTOP}/dyncall
dyncall/test/suite_x86win32fast/Makefile.generic:LDFLAGS += -L${BLDTOP}/dyncall
dyncall/test/suite_x86win32fast/Makefile.generic:LDLIBS  += -ldyncall_s 
dyncall/test/suite_x86win32fast/Makefile.generic:RM      ?= rm -f
dyncall/test/suite_x86win32fast/Makefile.generic:INSTALL ?= install -p
dyncall/test/suite_x86win32fast/Makefile.generic:	${LINK} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP} ${TARGET_ARCH}
dyncall/test/suite_x86win32fast/README.txt:Copyright (c) 2007-2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_x86win32fast/README.txt:                        Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32fast/README.txt:  suite         	        - run full range
dyncall/test/suite_x86win32fast/README.txt:  suite <id> 			- run test id <id>
dyncall/test/suite_x86win32fast/README.txt:  suite <from> <to>		- run test id <from> to id <to> (inclusive).
dyncall/test/suite_x86win32fast/README.txt:  the test invokes 'void'-functions that effectively overwrite global 
dyncall/test/suite_x86win32fast/README.txt:    sets all arguments into type-specific value vectors at the given position
dyncall/test/suite_x86win32fast/case.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite_x86win32fast/case.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32fast/mkcase.py:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_x86win32fast/mkcase.py:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32fast/mkcase.py:    return x**n+powerfact(x,n-1)
dyncall/test/suite_x86win32fast/mkcase.py:    s     = (y-1) % ntypes
dyncall/test/suite_x86win32fast/mkcase.py:    y     = (y-1) / ntypes
dyncall/test/suite_x86win32fast/config.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite_x86win32fast/config.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32fast/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_x86win32fast/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32fast/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/suite_x86win32fast/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/suite_x86win32fast/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/Makefile.generic:.PHONY: all clean run-tests install distclean ${ALL} 
dyncall/test/Makefile.generic:run-tests: all
dyncall/test/Makefile.generic:	${VPATH}/run-build.sh ${ALL} | grep "result:"
dyncall/test/Makefile.generic:all-c:
dyncall/test/Makefile.generic:all-win32:
dyncall/test/Makefile.generic:run-win32:
dyncall/test/Makefile.generic:all-dyncall:
dyncall/test/Makefile.generic:run-dyncall:
dyncall/test/Makefile.generic:all-dynload:
dyncall/test/Makefile.generic:run-dynload:
dyncall/test/Makefile.generic:all-dyncallback:
dyncall/test/Makefile.generic:run-dyncallback:
dyncall/test/Makefile.generic:	LDLIBS="-lm -ldl" ${MAKE} all
dyncall/test/Makefile.generic:	LDLIBS="-lm" ${MAKE} all
dyncall/test/Makefile.generic:	${VPATH}/pack-tests.sh ${PACK}
dyncall/test/Makefile.generic:	rm -rf _work _packed
dyncall/test/mkfile:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/mkfile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/mkfile:# only C-stuff for now...
dyncall/test/hacking-mips/f0.c: File: test/hacking-mips/f0.c
dyncall/test/hacking-mips/f0.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-mips/f0.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-mips/Makefile:	$(CC) $^ -o $@
dyncall/test/hacking-mips/Makefile:	$(CC) -S $< -o $@
dyncall/test/hacking-mips/prolog.c: File: test/hacking-mips/prolog.c
dyncall/test/hacking-mips/prolog.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-mips/prolog.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-mips/f.c: File: test/hacking-mips/f.c
dyncall/test/hacking-mips/f.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-mips/f.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-mips/node.c: File: test/hacking-mips/node.c
dyncall/test/hacking-mips/node.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-mips/node.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-mips/retn.c: File: test/hacking-mips/retn.c
dyncall/test/hacking-mips/retn.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-mips/retn.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-mips/main.c: File: test/hacking-mips/main.c
dyncall/test/hacking-mips/main.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-mips/main.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-mips/dispatch.c: File: test/hacking-mips/dispatch.c
dyncall/test/hacking-mips/dispatch.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-mips/dispatch.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-mips/calls.c: File: test/hacking-mips/calls.c
dyncall/test/hacking-mips/calls.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-mips/calls.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-mips/common.h: File: test/hacking-mips/common.h
dyncall/test/hacking-mips/common.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-mips/common.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-mips/funs.c: File: test/hacking-mips/funs.c
dyncall/test/hacking-mips/funs.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-mips/funs.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-mips/call.c: File: test/hacking-mips/call.c
dyncall/test/hacking-mips/call.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-mips/call.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	movaps	%xmm0, -16(%rbp)
dyncall/test/samples/composite/args.s:	movaps	%xmm0, -32(%rbp)
dyncall/test/samples/composite/args.s:	movaps	-32(%rbp), %xmm0
dyncall/test/samples/composite/args.s:	movaps	-16(%rbp), %xmm1
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	movaps	%xmm0, -16(%rbp)
dyncall/test/samples/composite/args.s:	movaps	%xmm0, -32(%rbp)
dyncall/test/samples/composite/args.s:	movaps	-32(%rbp), %xmm0
dyncall/test/samples/composite/args.s:	movaps	-16(%rbp), %xmm1
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	movaps	%xmm0, -16(%rbp)
dyncall/test/samples/composite/args.s:	movaps	%xmm0, -32(%rbp)
dyncall/test/samples/composite/args.s:	movq	-8(%rbp), %rax
dyncall/test/samples/composite/args.s:	movq	-16(%rbp), %rax
dyncall/test/samples/composite/args.s:	movq	-32(%rbp), %rax
dyncall/test/samples/composite/args.s:	movq	-24(%rbp), %rcx
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	movaps	%xmm0, -16(%rbp)
dyncall/test/samples/composite/args.s:	movaps	%xmm0, -32(%rbp)
dyncall/test/samples/composite/args.s:	movq	-8(%rbp), %rax
dyncall/test/samples/composite/args.s:	movq	-16(%rbp), %rax
dyncall/test/samples/composite/args.s:	movq	-32(%rbp), %rax
dyncall/test/samples/composite/args.s:	movq	-24(%rbp), %rcx
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	movaps	%xmm0, -16(%rbp)
dyncall/test/samples/composite/args.s:	movaps	%xmm0, -32(%rbp)
dyncall/test/samples/composite/args.s:	movq	-8(%rbp), %rax
dyncall/test/samples/composite/args.s:	movq	-16(%rbp), %rax
dyncall/test/samples/composite/args.s:	movq	-32(%rbp), %rax
dyncall/test/samples/composite/args.s:	movq	-24(%rbp), %rcx
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	movaps	%xmm0, -16(%rbp)
dyncall/test/samples/composite/args.s:	movaps	-16(%rbp), %xmm0
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	movaps	%xmm0, -16(%rbp)
dyncall/test/samples/composite/args.s:	movq	-16(%rbp), %rax
dyncall/test/samples/composite/args.s:	movq	-8(%rbp), %rcx
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/args.s:	.cfi_offset %rbp, -16
dyncall/test/samples/composite/makefile:#CC=gcc-mp-4.7 
dyncall/test/samples/composite/makefile:#TARGET_ARCH=-march=corei7-avx 
dyncall/test/samples/composite/makefile:#TARGET_ARCH=-march=corei7-avx -mavx -msse2avx
dyncall/test/samples/composite/makefile:#-mno-vzeroupper
dyncall/test/samples/composite/makefile:CFLAGS=-O3 
dyncall/test/samples/composite/makefile:#-fomit-frame-pointer -fno-exceptions 
dyncall/test/samples/composite/makefile:# -fno-rtti
dyncall/test/samples/composite/makefile:	rm -f ${TARGETS}
dyncall/test/samples/composite/makefile:	${CC} -S $< -o $@ ${CFLAGS} ${TARGET_ARCH} 
dyncall/test/samples/composite/args.asm:	mov	DWORD PTR [rax-20], 1
dyncall/test/samples/composite/args.asm:	mov	DWORD PTR [rax-12], 3
dyncall/test/samples/composite/args.asm:	lea	rcx, QWORD PTR [rax-24]
dyncall/test/samples/composite/args.asm:	movss	DWORD PTR [rax-24], xmm0
dyncall/test/samples/composite/args.asm:	movss	DWORD PTR [rax-16], xmm1
dyncall/test/samples/composite/args.asm:	movaps	xmm0, XMMWORD PTR [rax-24]
dyncall/test/samples/composite/args.asm:	movdqa	XMMWORD PTR [rax-24], xmm0
dyncall/test/samples/composite/args.asm:	mov	DWORD PTR [rax-24], 0
dyncall/test/samples/composite/args.asm:	mov	DWORD PTR [rax-16], 2
dyncall/test/samples/composite/args.asm:	lea	rcx, QWORD PTR [rax-24]
dyncall/test/samples/composite/args.asm:	movss	DWORD PTR [rax-20], xmm0
dyncall/test/samples/composite/args.asm:	movss	DWORD PTR [rax-12], xmm1
dyncall/test/samples/composite/args.asm:	movaps	xmm0, XMMWORD PTR [rax-24]
dyncall/test/samples/composite/args.asm:	movdqa	XMMWORD PTR [rax-24], xmm0
dyncall/test/samples/composite/args.asm:	mov	BYTE PTR [rax-12], 3
dyncall/test/samples/composite/args.asm:	lea	rcx, QWORD PTR [rax-24]
dyncall/test/samples/composite/args.asm:	movss	DWORD PTR [rax-24], xmm0
dyncall/test/samples/composite/args.asm:	movss	DWORD PTR [rax-20], xmm1
dyncall/test/samples/composite/args.asm:	movss	DWORD PTR [rax-16], xmm0
dyncall/test/samples/composite/args.asm:	movaps	xmm1, XMMWORD PTR [rax-24]
dyncall/test/samples/composite/args.asm:	movdqa	XMMWORD PTR [rax-24], xmm1
dyncall/test/samples/composite/args.asm:	mov	BYTE PTR [rax-24], 0
dyncall/test/samples/composite/args.asm:	lea	rcx, QWORD PTR [rax-24]
dyncall/test/samples/composite/args.asm:	movss	DWORD PTR [rax-20], xmm0
dyncall/test/samples/composite/args.asm:	movss	DWORD PTR [rax-16], xmm1
dyncall/test/samples/composite/args.asm:	movss	DWORD PTR [rax-12], xmm0
dyncall/test/samples/composite/args.asm:	movaps	xmm1, XMMWORD PTR [rax-24]
dyncall/test/samples/composite/args.asm:	movdqa	XMMWORD PTR [rax-24], xmm1
dyncall/test/samples/composite/args.c:                  ------------
dyncall/test/samples/composite/args.c:// int/float 4-byte alignment.
dyncall/test/samples/calls/i7.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/samples/calls/i7.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/samples/calls/d40.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/samples/calls/d40.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/samples/calls/d16.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/samples/calls/d16.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/samples/calls/f20.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/samples/calls/f20.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/samples/calls/d20.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/samples/calls/d20.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/samples/calls/id40.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/samples/calls/id40.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/samples/calls/l16.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/samples/calls/l16.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/samples/calls/f16.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/samples/calls/f16.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/samples/calls/many.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/samples/calls/many.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/samples/calls/fd40.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/samples/calls/fd40.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/samples/calls/i3.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/samples/calls/i3.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/samples/calls/f40.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/samples/calls/f40.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32std/case.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_x86win32std/case.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32std/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/suite_x86win32std
dyncall/test/suite_x86win32std/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/suite_x86win32std/main.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_x86win32std/main.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32std/main.cc:    case 0: return ( getArg(pos)->B == valueBool[pos] ); break;
dyncall/test/suite_x86win32std/main.cc:    case 1: return ( getArg(pos)->i == valueInt[pos] ); break;
dyncall/test/suite_x86win32std/main.cc:    case 2: return ( getArg(pos)->L == valueLongLong[pos] ); break;
dyncall/test/suite_x86win32std/main.cc:    case 3: return ( getArg(pos)->d == valueDouble[pos] ); break;
dyncall/test/suite_x86win32std/main.cc:    case 4: return ( getArg(pos)->p == valuePointer[pos] ); break;
dyncall/test/suite_x86win32std/main.cc:    case 5: return ( getArg(pos)->f == valueFloat[pos] ); break;
dyncall/test/suite_x86win32std/main.cc:    int select = (y-1) % NTYPES; 
dyncall/test/suite_x86win32std/main.cc:    y = (y-1) / NTYPES;
dyncall/test/suite_x86win32std/main.cc:  return static_cast<int>( pow((double)x,n)+powerfact(x,n-1) );
dyncall/test/suite_x86win32std/main.cc:  return (success) ? 0 : -1;
dyncall/test/suite_x86win32std/Makefile.generic:CFLAGS  += -I${SRCTOP}/dyncall
dyncall/test/suite_x86win32std/Makefile.generic:LDFLAGS += -L${BLDTOP}/dyncall
dyncall/test/suite_x86win32std/Makefile.generic:LDLIBS  += -ldyncall_s 
dyncall/test/suite_x86win32std/Makefile.generic:RM      ?= rm -f
dyncall/test/suite_x86win32std/Makefile.generic:INSTALL ?= install -p
dyncall/test/suite_x86win32std/Makefile.generic:	${LINK} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP} ${TARGET_ARCH}
dyncall/test/suite_x86win32std/README.txt:Copyright (c) 2007-2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_x86win32std/README.txt:                        Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32std/README.txt:  suite         	        - run full range
dyncall/test/suite_x86win32std/README.txt:  suite <id> 			- run test id <id>
dyncall/test/suite_x86win32std/README.txt:  suite <from> <to>		- run test id <from> to id <to> (inclusive).
dyncall/test/suite_x86win32std/README.txt:  the test invokes 'void'-functions that effectively overwrite global 
dyncall/test/suite_x86win32std/README.txt:    sets all arguments into type-specific value vectors at the given position
dyncall/test/suite_x86win32std/case.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite_x86win32std/case.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32std/mkcase.py:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_x86win32std/mkcase.py:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32std/mkcase.py:    return x**n+powerfact(x,n-1)
dyncall/test/suite_x86win32std/mkcase.py:    s     = (y-1) % ntypes
dyncall/test/suite_x86win32std/mkcase.py:    y     = (y-1) / ntypes
dyncall/test/suite_x86win32std/config.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite_x86win32std/config.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32std/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite_x86win32std/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite_x86win32std/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/suite_x86win32std/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/suite_x86win32std/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/makepkg.sh:mkdir -p pack_out/testpkg
dyncall/test/makepkg.sh:tar -cvzf test-pack.tar.gz -C pack_out testpkg
dyncall/test/suite2/case.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2/case.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/suite2
dyncall/test/suite2/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/suite2/main.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2/main.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2/main.cc:  exit(-1);
dyncall/test/suite2/main.cc:  const DCsigchar* sig = &fi->sig[2];
dyncall/test/suite2/main.cc:  dcCallVoid( pCall, fi->funcptr );
dyncall/test/suite2/main.cc:        case DC_SIGCHAR_BOOL: if ( getArg(pos)->B != valueBool  [pos] ) r = false; break;
dyncall/test/suite2/main.cc:        case DC_SIGCHAR_CHAR: if ( getArg(pos)->c != valueChar  [pos] ) r = false; break;
dyncall/test/suite2/main.cc:        case DC_SIGCHAR_SHORT: if ( getArg(pos)->s != valueShort  [pos] ) r = false; break;
dyncall/test/suite2/main.cc:        case DC_SIGCHAR_INT: if ( getArg(pos)->i != valueInt   [pos] ) r = false; break;
dyncall/test/suite2/main.cc:        case DC_SIGCHAR_LONGLONG: if ( getArg(pos)->L != valueLongLong  [pos] ) r = false; break;
dyncall/test/suite2/main.cc:        case DC_SIGCHAR_FLOAT: if ( getArg(pos)->f != valueFloat [pos] ) r = false; break;
dyncall/test/suite2/main.cc:        case DC_SIGCHAR_DOUBLE: if ( getArg(pos)->d != valueDouble[pos] ) r = false; break;
dyncall/test/suite2/main.cc:        case DC_SIGCHAR_POINTER: if ( getArg(pos)->p != valuePointer   [pos] ) r = false; break;
dyncall/test/suite2/main.cc:  printf("%d-%s:%d\n", x, sig, r);
dyncall/test/suite2/main.cc:  return (success) ? 0 : -1;
dyncall/test/suite2/Makefile.generic:CXXFLAGS += -I${SRCTOP}/dyncall
dyncall/test/suite2/Makefile.generic:LDLIBS   += -L${BLDTOP}/dyncall -ldyncall_s
dyncall/test/suite2/Makefile.generic:	${CXX} ${CXXFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP} 
dyncall/test/suite2/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/suite2/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/suite2/rand.py:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2/rand.py:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2/rand.py:  x = random.randint( 0, len(apitypes)-1 )
dyncall/test/suite2/rand.py:    x = random.randint( 0, len(argtypes)-1 )
dyncall/test/suite2/case.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite2/case.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2/mkcase.py:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2/mkcase.py:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2/mkcase.py:  # args  = len(line)-1
dyncall/test/suite2/config.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite2/config.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/suite2/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/suite2/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/suite2/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/suite2/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building CXX object test/suite2/CMakeFiles/suite2.dir/case.cc.o"
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite2 && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT test/suite2/CMakeFiles/suite2.dir/case.cc.o -MF CMakeFiles/suite2.dir/case.cc.o.d -o CMakeFiles/suite2.dir/case.cc.o -c /home/chenningcong/Desktop/dyncall-1.2/test/suite2/case.cc
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/suite2.dir/case.cc.i"
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite2 && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/suite2/case.cc > CMakeFiles/suite2.dir/case.cc.i
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/suite2.dir/case.cc.s"
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite2 && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/suite2/case.cc -o CMakeFiles/suite2.dir/case.cc.s
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Building CXX object test/suite2/CMakeFiles/suite2.dir/main.cc.o"
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite2 && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT test/suite2/CMakeFiles/suite2.dir/main.cc.o -MF CMakeFiles/suite2.dir/main.cc.o.d -o CMakeFiles/suite2.dir/main.cc.o -c /home/chenningcong/Desktop/dyncall-1.2/test/suite2/main.cc
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/suite2.dir/main.cc.i"
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite2 && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/suite2/main.cc > CMakeFiles/suite2.dir/main.cc.i
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/suite2.dir/main.cc.s"
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite2 && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/suite2/main.cc -o CMakeFiles/suite2.dir/main.cc.s
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Linking CXX executable suite2"
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite2 && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/suite2.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite2 && $(CMAKE_COMMAND) -P CMakeFiles/suite2.dir/cmake_clean.cmake
dyncall/test/suite2/CMakeFiles/suite2.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/suite2 /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/suite2 /home/chenningcong/Desktop/dyncall-1.2/test/suite2/CMakeFiles/suite2.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/suite2/CMakeFiles/suite2.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/suite2/CMakeFiles/suite2.dir/flags.make:CXX_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/suite2/CMakeFiles/suite2.dir/flags.make:CXX_FLAGS =   -fPIC
dyncall/test/suite2/CMakeFiles/suite2.dir/link.txt:/usr/bin/c++ -rdynamic CMakeFiles/suite2.dir/case.cc.o CMakeFiles/suite2.dir/main.cc.o -o suite2  ../../dyncall/libdyncall_s.a 
dyncall/test/suite2/CMakeFiles/suite2.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/suite2/case.cc" "test/suite2/CMakeFiles/suite2.dir/case.cc.o" "gcc" "test/suite2/CMakeFiles/suite2.dir/case.cc.o.d"
dyncall/test/suite2/CMakeFiles/suite2.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/suite2/main.cc" "test/suite2/CMakeFiles/suite2.dir/main.cc.o" "gcc" "test/suite2/CMakeFiles/suite2.dir/main.cc.o.d"
dyncall/test/suite2/CMakeFiles/suite2.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake"
dyncall/test/suite2/funcinfo.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2/funcinfo.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2/Makefile.embedded:CFLAGS  += -I${TOP}/dyncall
dyncall/test/suite2/Makefile.embedded:LDFLAGS += -L${TOP}/dyncall
dyncall/test/suite2/Makefile.embedded:LDLIBS  += -ldyncall_s
dyncall/test/suite2/Makefile.embedded:	${CXX} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP} 
dyncall/test/suite2/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/suite2/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/suite2
dyncall/test/suite2/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/suite2_x86win32fast/case.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2_x86win32fast/case.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32fast/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/suite2_x86win32fast
dyncall/test/suite2_x86win32fast/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/suite2_x86win32fast/main.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2_x86win32fast/main.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32fast/main.cc:  exit(-1);
dyncall/test/suite2_x86win32fast/main.cc:  const DCsigchar* sig = &fi->sig[2];
dyncall/test/suite2_x86win32fast/main.cc:  dcCallVoid( pCall, fi->funcptr );
dyncall/test/suite2_x86win32fast/main.cc:        case DC_SIGCHAR_BOOL: if ( getArg(pos)->B != valueBool  [pos] ) r = false; break;
dyncall/test/suite2_x86win32fast/main.cc:        case DC_SIGCHAR_CHAR: if ( getArg(pos)->c != valueChar  [pos] ) r = false; break;
dyncall/test/suite2_x86win32fast/main.cc:        case DC_SIGCHAR_SHORT: if ( getArg(pos)->s != valueShort  [pos] ) r = false; break;
dyncall/test/suite2_x86win32fast/main.cc:        case DC_SIGCHAR_INT: if ( getArg(pos)->i != valueInt   [pos] ) r = false; break;
dyncall/test/suite2_x86win32fast/main.cc:        case DC_SIGCHAR_LONGLONG: if ( getArg(pos)->L != valueLongLong  [pos] ) r = false; break;
dyncall/test/suite2_x86win32fast/main.cc:        case DC_SIGCHAR_FLOAT: if ( getArg(pos)->f != valueFloat [pos] ) r = false; break;
dyncall/test/suite2_x86win32fast/main.cc:        case DC_SIGCHAR_DOUBLE: if ( getArg(pos)->d != valueDouble[pos] ) r = false; break;
dyncall/test/suite2_x86win32fast/main.cc:        case DC_SIGCHAR_POINTER: if ( getArg(pos)->p != valuePointer   [pos] ) r = false; break;
dyncall/test/suite2_x86win32fast/main.cc:  printf("%d-%s:%d\n", x, sig, r);
dyncall/test/suite2_x86win32fast/main.cc:  return (success) ? 0 : -1;
dyncall/test/suite2_x86win32fast/Makefile.generic:CFLAGS  = -I${TOP}/dyncall
dyncall/test/suite2_x86win32fast/Makefile.generic:LDFLAGS = -L${TOP}/dyncall
dyncall/test/suite2_x86win32fast/Makefile.generic:LDLIBS  = -ldyncall_s
dyncall/test/suite2_x86win32fast/Makefile.generic:RM      ?= rm -f
dyncall/test/suite2_x86win32fast/Makefile.generic:INSTALL ?= install -p
dyncall/test/suite2_x86win32fast/Makefile.generic:	${LINK} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP} ${TARGET_ARCH}
dyncall/test/suite2_x86win32fast/rand.py:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2_x86win32fast/rand.py:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32fast/rand.py:  x = random.randint( 0, len(apitypes)-1 )
dyncall/test/suite2_x86win32fast/rand.py:    x = random.randint( 0, len(argtypes)-1 )
dyncall/test/suite2_x86win32fast/case.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite2_x86win32fast/case.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32fast/mkcase.py:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2_x86win32fast/mkcase.py:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32fast/mkcase.py:  # args  = len(line)-1
dyncall/test/suite2_x86win32fast/config.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite2_x86win32fast/config.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32fast/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2_x86win32fast/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite2_x86win32fast/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/suite2_x86win32fast/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/suite2_x86win32fast/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/suite2_x86win32fast/funcinfo.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite2_x86win32fast/funcinfo.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/gen-masm/call_x64.S: File: test/gen-masm/call_x64.S
dyncall/test/gen-masm/call_x64.S:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/gen-masm/call_x64.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/gen-masm/call_x64.S:// ---------------------------------------------------------------------------
dyncall/test/gen-masm/call_x64.S:	push	rbp			// Pseudo-prolog - preserve rbp. 
dyncall/test/gen-masm/call_x64.S:	movsd	xmm0, qword ptr[rcx   ]	// Copy first 8 floats to xmm0-xmm7 (this makes rcx free to use).
dyncall/test/gen-masm/call_x64.S:	pop	rbp						/* Pseudo-epilog. */
dyncall/test/gen-masm/call_x64.S:// ---------------------------------------------------------------------------
dyncall/test/gen-masm/call_x64.S:	push	rbp			// Pseudo-prolog - preserve rbp.
dyncall/test/gen-masm/call_x64.S:	mov	rcx,  qword ptr[r8   ]	// Copy first four arguments to rcx, rdx, r8, r9 and xmm0-xmm3.
dyncall/test/gen-masm/call_x64.S:	pop	rbp			// Pseudo-epilog.
dyncall/test/gen-masm/call_x86.S: File: test/gen-masm/call_x86.S
dyncall/test/gen-masm/call_x86.S:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/gen-masm/call_x86.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/gen-masm/call_x86.S:// Copyright (c) 2007-2010 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/gen-masm/call_x86.S://                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/gen-masm/call_x86.S:// ----------------------------------------------------------------------------
dyncall/test/gen-masm/call_x86.S://  - epilog restore esp serves callee cleanup 
dyncall/test/gen-masm/call_x86.S:// --- default / cdecl --------------------------------------------------------
dyncall/test/gen-masm/call_x86.S://  - caller clean-up
dyncall/test/gen-masm/call_x86.S:// ---- C++ this calls (microsoft) ------------------------------------------ 
dyncall/test/gen-masm/call_x86.S://   - this pointer is in ECX
dyncall/test/gen-masm/call_x86.S:	sub esp, ecx         // allocate argument-block on stack 
dyncall/test/gen-masm/call_x86.S:// ---- win32 stdcall ---------------------------------------------------------
dyncall/test/gen-masm/call_x86.S:// - callee cleans up stack
dyncall/test/gen-masm/call_x86.S:// ---- win32 fastcall (GNU/Microsoft) ----------------------------------------
dyncall/test/gen-masm/call_x86.S:// - callee cleans up stack
dyncall/test/gen-masm/call_x86.S:// - first two integer (up to 32bits) are passed in ECX and EDX
dyncall/test/gen-masm/call_x86.S:// --- syscall int80 linux ---------------------------------------------------
dyncall/test/gen-masm/call_x86.S://  - all arguments are passed via registers
dyncall/test/gen-masm/call_x86.S:// --- syscall int80 bsd -----------------------------------------------------
dyncall/test/gen-masm/call_x86.S:// - all arguments are passed via stack
dyncall/test/gen-masm/Makefile:	${CPP} -E -P -DGEN_MASM $< -o $@
dyncall/test/gen-masm/gen_masm.sh:../../portasm/gen-masm.sh call_x86
dyncall/test/gen-masm/gen_masm.sh:../../portasm/gen-masm.sh call_x64
dyncall/test/callback_plain/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/callback_plain
dyncall/test/callback_plain/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/callback_plain/Makefile.generic:CFLAGS += -I${SRCTOP}/dyncall
dyncall/test/callback_plain/Makefile.generic:LDLIBS += -L${BLDTOP}/dyncallback -ldyncallback_s
dyncall/test/callback_plain/Makefile.generic:	${CC} ${CFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP}
dyncall/test/callback_plain/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/callback_plain/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/callback_plain/mkfile:# Copyright (c) 2013 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/callback_plain/mkfile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_plain/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/callback_plain/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_plain/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a $(TOP)\dyncallback\libdyncallback_s.a -o "$(@B).elf"
dyncall/test/callback_plain/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/callback_plain/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/callback_plain/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/callback_plain/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object test/callback_plain/CMakeFiles/callback_plain.dir/callback_plain.c.o"
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/callback_plain/CMakeFiles/callback_plain.dir/callback_plain.c.o -MF CMakeFiles/callback_plain.dir/callback_plain.c.o.d -o CMakeFiles/callback_plain.dir/callback_plain.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/callback_plain.c
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/callback_plain.dir/callback_plain.c.i"
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/callback_plain.c > CMakeFiles/callback_plain.dir/callback_plain.c.i
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/callback_plain.dir/callback_plain.c.s"
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/callback_plain.c -o CMakeFiles/callback_plain.dir/callback_plain.c.s
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Linking C executable callback_plain"
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_plain && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/callback_plain.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_plain && $(CMAKE_COMMAND) -P CMakeFiles/callback_plain.dir/cmake_clean.cmake
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/callback_plain /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/callback_plain /home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/CMakeFiles/callback_plain.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/flags.make:C_FLAGS =   -fPIC
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/link.txt:/usr/bin/cc -rdynamic CMakeFiles/callback_plain.dir/callback_plain.c.o -o callback_plain  ../../dyncallback/libdyncallback_s.a 
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/callback_plain.c" "test/callback_plain/CMakeFiles/callback_plain.dir/callback_plain.c.o" "gcc" "test/callback_plain/CMakeFiles/callback_plain.dir/callback_plain.c.o.d"
dyncall/test/callback_plain/CMakeFiles/callback_plain.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/CMakeFiles/dyncallback_s.dir/DependInfo.cmake"
dyncall/test/callback_plain/callback_plain.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_plain/callback_plain.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_plain/callback_plain.c:  result->s = 1234;
dyncall/test/callback_plain/Makefile.embedded:CFLAGS  += -I${SRCTOP}/dyncall
dyncall/test/callback_plain/Makefile.embedded:LDFLAGS += -L${BLDDIR}/dyncallback
dyncall/test/callback_plain/Makefile.embedded:LDLIBS  += -ldyncallback_s
dyncall/test/callback_plain/Makefile.embedded:	${CC} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP} 
dyncall/test/callback_plain/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/callback_plain/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/callback_plain
dyncall/test/callback_plain/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/pack-tests.sh:# pack-script for embedded testing.
dyncall/test/pack-tests.sh:NAME="dyncall-tests-${DATE}"
dyncall/test/pack-tests.sh:mkdir -p _work/${NAME}
dyncall/test/pack-tests.sh:printf "%-20s <- %-20s\n" "$I" "$PWD/$I/$I" >>_work/${NAME}/CONTENTS.txt
dyncall/test/pack-tests.sh:mkdir -p _packed
dyncall/test/pack-tests.sh:tar -cvzf _packed/${NAME}.tar.gz -C _work ${NAME}
dyncall/test/pack-tests.sh:printf "finished: tests are in ${PWD}/_packed/${NAME}.tar.gz, execute run-all.sh\n"
dyncall/test/call_suite/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/call_suite
dyncall/test/call_suite/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/call_suite/Makefile.generic:CFLAGS += -I${SRCTOP}/dyncall
dyncall/test/call_suite/Makefile.generic:LDLIBS += -L${BLDTOP}/dyncall -ldyncall_s 
dyncall/test/call_suite/Makefile.generic:.PHONY: all clean install config config-random
dyncall/test/call_suite/Makefile.generic:	${CC} ${CFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP} 
dyncall/test/call_suite/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/call_suite/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/call_suite/Makefile.generic:	${LUA} mk-cases.lua <design.txt >cases.h
dyncall/test/call_suite/Makefile.generic:config-random: 
dyncall/test/call_suite/Makefile.generic:	${LUA} rand-sig.lua >cases.txt
dyncall/test/call_suite/Makefile.generic:	${LUA} mk-cases.lua <cases.txt >cases.h
dyncall/test/call_suite/mkfile:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/call_suite/mkfile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/call_suite/mkfile:#config: mkconfig.lua rand-sig.lua mk-cases.lua
dyncall/test/call_suite/mkfile:#	lua mk-config.lua >config.h
dyncall/test/call_suite/mkfile:#	lua rand-sig.lua >cases.txt
dyncall/test/call_suite/mkfile:#	lua mk-cases.lua <cases.txt >cases.h 
dyncall/test/call_suite/mk-cases.lua:  maxargs = max(maxargs, #sig-1)
dyncall/test/call_suite/mk-cases.lua:    pos = tostring(i-1)
dyncall/test/call_suite/mk-cases.lua:  io.write(mkfuntab(lineno-1))
dyncall/test/call_suite/mk-cases.lua:-- print(mkcase(1,"vififififi"))
dyncall/test/call_suite/invoke.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/call_suite/invoke.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/call_suite/invoke.c:    case 'v': dcCallVoid(p,t); s=1; /*TODO:check that no return-arg was touched.*/ break;
dyncall/test/call_suite/main.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/call_suite/main.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/call_suite/globals.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/call_suite/globals.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/call_suite/globals.c:    K_c[i] = (char)      (((rand_d()-0.5)*2) * (1<<7));
dyncall/test/call_suite/globals.c:    K_s[i] = (short)     (((rand_d()-0.5)*2) * (1<<(sizeof(short)*8-1)));
dyncall/test/call_suite/globals.c:    K_i[i] = (int)       (((rand_d()-0.5)*2) * (1<<(sizeof(int)*8-2)));
dyncall/test/call_suite/globals.c:    K_j[i] = (long)      (((rand_d()-0.5)*2) * (1L<<(sizeof(long)*8-2)));
dyncall/test/call_suite/globals.c:    K_l[i] = (long long) (((rand_d()-0.5)*2) * (1LL<<(sizeof(long long)*8-2)));
dyncall/test/call_suite/globals.c:    K_p[i] = (void*)     (long) (((rand_d()-0.5)*2) * (1LL<<(sizeof(void*)*8-1)));
dyncall/test/call_suite/globals.c:    K_d[i] = (double)    (((rand_d()-0.5)*2) * 1.7976931348623157E+308/*__DBL_MAX__*/);	/* Plan9 doesn't know the macro. */
dyncall/test/call_suite/config.lua:-- user config for rand-sig.lua:
dyncall/test/call_suite/Nmakefile:# Copyright (c) 2011 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/call_suite/Nmakefile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/call_suite/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/call_suite/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/call_suite/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/call_suite/Nmakefile:$(AUTOS): mk-cases.lua
dyncall/test/call_suite/Nmakefile:	lua mk-cases.lua <cases.txt >cases.h
dyncall/test/call_suite/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/call_suite/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object test/call_suite/CMakeFiles/call_suite.dir/globals.c.o"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/call_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/call_suite/CMakeFiles/call_suite.dir/globals.c.o -MF CMakeFiles/call_suite.dir/globals.c.o.d -o CMakeFiles/call_suite.dir/globals.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/call_suite/globals.c
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/call_suite.dir/globals.c.i"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/call_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/call_suite/globals.c > CMakeFiles/call_suite.dir/globals.c.i
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/call_suite.dir/globals.c.s"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/call_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/call_suite/globals.c -o CMakeFiles/call_suite.dir/globals.c.s
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Building C object test/call_suite/CMakeFiles/call_suite.dir/invoke.c.o"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/call_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/call_suite/CMakeFiles/call_suite.dir/invoke.c.o -MF CMakeFiles/call_suite.dir/invoke.c.o.d -o CMakeFiles/call_suite.dir/invoke.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/call_suite/invoke.c
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/call_suite.dir/invoke.c.i"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/call_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/call_suite/invoke.c > CMakeFiles/call_suite.dir/invoke.c.i
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/call_suite.dir/invoke.c.s"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/call_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/call_suite/invoke.c -o CMakeFiles/call_suite.dir/invoke.c.s
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Building C object test/call_suite/CMakeFiles/call_suite.dir/cases.c.o"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/call_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/call_suite/CMakeFiles/call_suite.dir/cases.c.o -MF CMakeFiles/call_suite.dir/cases.c.o.d -o CMakeFiles/call_suite.dir/cases.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/call_suite/cases.c
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/call_suite.dir/cases.c.i"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/call_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/call_suite/cases.c > CMakeFiles/call_suite.dir/cases.c.i
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/call_suite.dir/cases.c.s"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/call_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/call_suite/cases.c -o CMakeFiles/call_suite.dir/cases.c.s
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_4) "Building C object test/call_suite/CMakeFiles/call_suite.dir/main.c.o"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/call_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/call_suite/CMakeFiles/call_suite.dir/main.c.o -MF CMakeFiles/call_suite.dir/main.c.o.d -o CMakeFiles/call_suite.dir/main.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/call_suite/main.c
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/call_suite.dir/main.c.i"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/call_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/call_suite/main.c > CMakeFiles/call_suite.dir/main.c.i
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/call_suite.dir/main.c.s"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/call_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/call_suite/main.c -o CMakeFiles/call_suite.dir/main.c.s
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_5) "Linking C executable call_suite"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/call_suite && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/call_suite.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/call_suite && $(CMAKE_COMMAND) -P CMakeFiles/call_suite.dir/cmake_clean.cmake
dyncall/test/call_suite/CMakeFiles/call_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/call_suite /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/call_suite /home/chenningcong/Desktop/dyncall-1.2/test/call_suite/CMakeFiles/call_suite.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/call_suite/CMakeFiles/call_suite.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/call_suite/CMakeFiles/call_suite.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/call_suite/CMakeFiles/call_suite.dir/flags.make:C_FLAGS =   -fPIC
dyncall/test/call_suite/CMakeFiles/call_suite.dir/link.txt:/usr/bin/cc -rdynamic CMakeFiles/call_suite.dir/globals.c.o CMakeFiles/call_suite.dir/invoke.c.o CMakeFiles/call_suite.dir/cases.c.o CMakeFiles/call_suite.dir/main.c.o -o call_suite  ../../dyncall/libdyncall_s.a 
dyncall/test/call_suite/CMakeFiles/call_suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/call_suite/cases.c" "test/call_suite/CMakeFiles/call_suite.dir/cases.c.o" "gcc" "test/call_suite/CMakeFiles/call_suite.dir/cases.c.o.d"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/call_suite/globals.c" "test/call_suite/CMakeFiles/call_suite.dir/globals.c.o" "gcc" "test/call_suite/CMakeFiles/call_suite.dir/globals.c.o.d"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/call_suite/invoke.c" "test/call_suite/CMakeFiles/call_suite.dir/invoke.c.o" "gcc" "test/call_suite/CMakeFiles/call_suite.dir/invoke.c.o.d"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/call_suite/main.c" "test/call_suite/CMakeFiles/call_suite.dir/main.c.o" "gcc" "test/call_suite/CMakeFiles/call_suite.dir/main.c.o.d"
dyncall/test/call_suite/CMakeFiles/call_suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake"
dyncall/test/call_suite/globals.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/call_suite/globals.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/call_suite/Makefile.embedded:CPPFLAGS	+= -I${SRCDIR}/dyncall
dyncall/test/call_suite/Makefile.embedded:LDFLAGS		+= -L${BLDDIR}/dyncall
dyncall/test/call_suite/Makefile.embedded:LDLIBS		+= -ldyncall_s
dyncall/test/call_suite/Makefile.embedded:.PHONY: all clean config config-random
dyncall/test/call_suite/Makefile.embedded:	${CC} ${OBJS} ${LDFLAGS} ${LDLIBS} -o $@
dyncall/test/call_suite/Makefile.embedded:	${LUA} mk-cases.lua <design.txt >cases.h
dyncall/test/call_suite/Makefile.embedded:config-random: 
dyncall/test/call_suite/Makefile.embedded:	${LUA} rand-sig.lua >cases.txt
dyncall/test/call_suite/Makefile.embedded:	${LUA} mk-cases.lua <cases.txt >cases.h
dyncall/test/call_suite/Makefile.embedded:	rm -f ${TARGET}
dyncall/test/call_suite/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/call_suite
dyncall/test/call_suite/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/call_suite/cases.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/call_suite/cases.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/plain/test_main.c:   Copyright (c) 2007-2019 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/plain/test_main.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/plain/test_main.c:/* -------------------------------------------------------------------------
dyncall/test/plain/test_main.c: * ------------------------------------------------------------------------- */
dyncall/test/plain/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/plain
dyncall/test/plain/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/plain/Makefile.generic:CFLAGS += -I${SRCTOP}/dyncall
dyncall/test/plain/Makefile.generic:LDLIBS += -L${BLDTOP}/dyncall -ldyncall_s
dyncall/test/plain/Makefile.generic:	${CC} ${CFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP} 
dyncall/test/plain/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/plain/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/plain/mkfile:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/plain/mkfile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/plain/test_structs.c:   Copyright (c) 2010-2015 Olivier Chafik <olivier.chafik@gmail.com>
dyncall/test/plain/test_structs.c:                      2019 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/plain/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/plain/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/plain/Nmakefile:#	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/plain/Nmakefile:#	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/plain/Nmakefile:#	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/plain/CMakeFiles/plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/plain/CMakeFiles/plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/plain/CMakeFiles/plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/plain/CMakeFiles/plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/plain/CMakeFiles/plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/plain/CMakeFiles/plain.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/plain/CMakeFiles/plain.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/plain/CMakeFiles/plain.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/plain/CMakeFiles/plain.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/plain/CMakeFiles/plain.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/plain/CMakeFiles/plain.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/plain/CMakeFiles/plain.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object test/plain/CMakeFiles/plain.dir/test_main.c.o"
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/plain/CMakeFiles/plain.dir/test_main.c.o -MF CMakeFiles/plain.dir/test_main.c.o.d -o CMakeFiles/plain.dir/test_main.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/plain/test_main.c
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/plain.dir/test_main.c.i"
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/plain/test_main.c > CMakeFiles/plain.dir/test_main.c.i
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/plain.dir/test_main.c.s"
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/plain/test_main.c -o CMakeFiles/plain.dir/test_main.c.s
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Building C object test/plain/CMakeFiles/plain.dir/test_structs.c.o"
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/plain/CMakeFiles/plain.dir/test_structs.c.o -MF CMakeFiles/plain.dir/test_structs.c.o.d -o CMakeFiles/plain.dir/test_structs.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/plain/test_structs.c
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/plain.dir/test_structs.c.i"
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/plain/test_structs.c > CMakeFiles/plain.dir/test_structs.c.i
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/plain.dir/test_structs.c.s"
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/plain/test_structs.c -o CMakeFiles/plain.dir/test_structs.c.s
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Linking C executable plain"
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/plain && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/plain.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/plain && $(CMAKE_COMMAND) -P CMakeFiles/plain.dir/cmake_clean.cmake
dyncall/test/plain/CMakeFiles/plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/plain /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/plain /home/chenningcong/Desktop/dyncall-1.2/test/plain/CMakeFiles/plain.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/plain/CMakeFiles/plain.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/plain/CMakeFiles/plain.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/plain/CMakeFiles/plain.dir/flags.make:C_FLAGS =   -fPIC
dyncall/test/plain/CMakeFiles/plain.dir/link.txt:/usr/bin/cc -rdynamic CMakeFiles/plain.dir/test_main.c.o CMakeFiles/plain.dir/test_structs.c.o -o plain  ../../dyncall/libdyncall_s.a 
dyncall/test/plain/CMakeFiles/plain.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/plain/test_main.c" "test/plain/CMakeFiles/plain.dir/test_main.c.o" "gcc" "test/plain/CMakeFiles/plain.dir/test_main.c.o.d"
dyncall/test/plain/CMakeFiles/plain.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/plain/test_structs.c" "test/plain/CMakeFiles/plain.dir/test_structs.c.o" "gcc" "test/plain/CMakeFiles/plain.dir/test_structs.c.o.d"
dyncall/test/plain/CMakeFiles/plain.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake"
dyncall/test/plain/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/plain/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/plain/Makefile.embedded:CFLAGS  += -I${TOP}/dyncall
dyncall/test/plain/Makefile.embedded:LDFLAGS += -L${TOP}/dyncall
dyncall/test/plain/Makefile.embedded:LDLIBS  += -ldyncall_s
dyncall/test/plain/Makefile.embedded:	${CC} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP}
dyncall/test/plain/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/plain/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/plain
dyncall/test/plain/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/Nmakefile:# Copyright (c) 2007-2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/common/platformInit.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/common/platformInit.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/common/platformInit.c:   Copyright (c) 2015-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/common/platformInit.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/common/platformInit.c:  /* Main loop - console style. */
dyncall/test/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/arm-thumb-interwork/README.txt:Run build.sh from top-level build directory.
dyncall/test/arm-thumb-interwork/README.txt:1. dyncall is compiled as default using Makefile-default.config
dyncall/test/arm-thumb-interwork/README.txt:2. tests are compiled with -mthumb using Makefile-thumb.config
dyncall/test/arm-thumb-interwork/Makefile-default.config:# auto-generated by ./configure
dyncall/test/arm-thumb-interwork/Makefile-default.config:CFLAGS=-fPIC 
dyncall/test/arm-thumb-interwork/Makefile-default.config:CXXFLAGS=-fPIC 
dyncall/test/arm-thumb-interwork/Makefile-default.config:LDLIBS=-lm -ldl
dyncall/test/arm-thumb-interwork/Makefile-thumb.config:# auto-generated by ./configure
dyncall/test/arm-thumb-interwork/Makefile-thumb.config:ASFLAGS=-mthumb
dyncall/test/arm-thumb-interwork/Makefile-thumb.config:CFLAGS=-fPIC -mthumb
dyncall/test/arm-thumb-interwork/Makefile-thumb.config:CXXFLAGS=-fPIC -mthumb
dyncall/test/arm-thumb-interwork/Makefile-thumb.config:LDLIBS=-lm -ldl
dyncall/test/arm-thumb-interwork/build.sh:cp buildsys/arm-thumb-interwork/Makefile-default.config Makefile.config
dyncall/test/arm-thumb-interwork/build.sh:cp buildsys/arm-thumb-interwork/Makefile-thumb.config Makefile.config
dyncall/test/thunk/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/thunk
dyncall/test/thunk/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/thunk/Makefile.generic:CFLAGS += -I${SRCTOP}/dyncallback -I${SRCTOP}/dyncall
dyncall/test/thunk/Makefile.generic:LDLIBS += -L${BLDTOP}/dyncallback -ldyncallback_s
dyncall/test/thunk/Makefile.generic:	${CC} ${CFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP} 
dyncall/test/thunk/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/thunk/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/thunk/mkfile:# Copyright (c) 2013 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/thunk/mkfile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/thunk/test_thunk.c:   Copyright (c) 2011-2021 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/thunk/test_thunk.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/thunk/test_thunk.c:     - use sigaction(2) to pass SA_ONSTACK, to handle segfaults on stack (as
dyncall/test/thunk/test_thunk.c:     - not using sigaltstack(2), as no need in our case
dyncall/test/thunk/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/thunk/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/thunk/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a $(TOP)\dyncallback\libdyncallback_s.a -o "$(@B).elf"
dyncall/test/thunk/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/thunk/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/thunk/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/thunk/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object test/thunk/CMakeFiles/test_thunk.dir/test_thunk.c.o"
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/thunk && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/thunk/CMakeFiles/test_thunk.dir/test_thunk.c.o -MF CMakeFiles/test_thunk.dir/test_thunk.c.o.d -o CMakeFiles/test_thunk.dir/test_thunk.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/thunk/test_thunk.c
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/test_thunk.dir/test_thunk.c.i"
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/thunk && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/thunk/test_thunk.c > CMakeFiles/test_thunk.dir/test_thunk.c.i
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/test_thunk.dir/test_thunk.c.s"
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/thunk && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/thunk/test_thunk.c -o CMakeFiles/test_thunk.dir/test_thunk.c.s
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Linking C executable test_thunk"
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/thunk && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/test_thunk.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/thunk && $(CMAKE_COMMAND) -P CMakeFiles/test_thunk.dir/cmake_clean.cmake
dyncall/test/thunk/CMakeFiles/test_thunk.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/thunk /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/thunk /home/chenningcong/Desktop/dyncall-1.2/test/thunk/CMakeFiles/test_thunk.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/thunk/CMakeFiles/test_thunk.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/thunk/CMakeFiles/test_thunk.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/thunk/CMakeFiles/test_thunk.dir/flags.make:C_FLAGS =   -fPIC
dyncall/test/thunk/CMakeFiles/test_thunk.dir/link.txt:/usr/bin/cc -rdynamic CMakeFiles/test_thunk.dir/test_thunk.c.o -o test_thunk  ../../dyncallback/libdyncallback_s.a 
dyncall/test/thunk/CMakeFiles/test_thunk.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/thunk/test_thunk.c" "test/thunk/CMakeFiles/test_thunk.dir/test_thunk.c.o" "gcc" "test/thunk/CMakeFiles/test_thunk.dir/test_thunk.c.o.d"
dyncall/test/thunk/CMakeFiles/test_thunk.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/CMakeFiles/dyncallback_s.dir/DependInfo.cmake"
dyncall/test/thunk/Makefile.embedded:CFLAGS  += -I${SRCTOP}/dyncallback -I${SRCTOP}/dyncall
dyncall/test/thunk/Makefile.embedded:LDFLAGS += -L${BLDTOP}/dyncallback
dyncall/test/thunk/Makefile.embedded:LDLIBS  += -ldyncallback_s
dyncall/test/thunk/Makefile.embedded:	${CC} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP} 
dyncall/test/thunk/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/thunk/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/thunk
dyncall/test/thunk/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/resolve_self/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/resolve_self
dyncall/test/resolve_self/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/resolve_self/Makefile.generic:CFLAGS   += -I${SRCTOP}/dynload
dyncall/test/resolve_self/Makefile.generic:LDFLAGS  += -rdynamic
dyncall/test/resolve_self/Makefile.generic:LDLIBS_D  = -L${BLDTOP}/dynload -ldynload_s 
dyncall/test/resolve_self/Makefile.generic:	${CC} ${CFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS_D} ${LDLIBS} -o ${APP}
dyncall/test/resolve_self/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/resolve_self/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/resolve_self/README.txt:names are in the binary, at first hand (e.g. --export-dynamic).
dyncall/test/resolve_self/main.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/resolve_self/main.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/resolve_self/Nmakefile:# Copyright (c) 2007-2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/resolve_self/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/resolve_self/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/resolve_self/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object test/resolve_self/CMakeFiles/resolve_self.dir/main.c.o"
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/resolve_self && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/resolve_self/CMakeFiles/resolve_self.dir/main.c.o -MF CMakeFiles/resolve_self.dir/main.c.o.d -o CMakeFiles/resolve_self.dir/main.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/main.c
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/resolve_self.dir/main.c.i"
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/resolve_self && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/main.c > CMakeFiles/resolve_self.dir/main.c.i
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/resolve_self.dir/main.c.s"
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/resolve_self && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/main.c -o CMakeFiles/resolve_self.dir/main.c.s
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Linking C executable resolve_self"
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/resolve_self && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/resolve_self.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/resolve_self && $(CMAKE_COMMAND) -P CMakeFiles/resolve_self.dir/cmake_clean.cmake
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/resolve_self /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/resolve_self /home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/CMakeFiles/resolve_self.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/flags.make:C_FLAGS =   -fPIC
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/link.txt:/usr/bin/cc -rdynamic CMakeFiles/resolve_self.dir/main.c.o -o resolve_self  ../../dynload/libdynload_s.a 
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/main.c" "test/resolve_self/CMakeFiles/resolve_self.dir/main.c.o" "gcc" "test/resolve_self/CMakeFiles/resolve_self.dir/main.c.o.d"
dyncall/test/resolve_self/CMakeFiles/resolve_self.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dynload/CMakeFiles/dynload_s.dir/DependInfo.cmake"
dyncall/test/resolve_self/Makefile.embedded:CFLAGS  += -I${TOP}/dynload
dyncall/test/resolve_self/Makefile.embedded:LDFLAGS += -L${TOP}/dynload
dyncall/test/resolve_self/Makefile.embedded:LDLIBS  += -ldynload_s
dyncall/test/resolve_self/Makefile.embedded:	${CC} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP} 
dyncall/test/resolve_self/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/resolve_self/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/resolve_self
dyncall/test/resolve_self/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/Makefile:DIFFSCRIPT=diff-iphoneos.sh 
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/Makefile:DIFFSCRIPT=diff-generic.sh
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/Makefile:	rm -Rf out
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/empty.S: File: test/hacking-arm-thumb-interwork/diff-gcc-defs/empty.S
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/empty.S:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/empty.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/empty.c: File: test/hacking-arm-thumb-interwork/diff-gcc-defs/empty.c
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/empty.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/empty.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/diff-generic.sh:TARGET_ARCH="-arch armv7"
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/diff-generic.sh:mkdir -p out
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/diff-generic.sh:# ARCHS="armv2 armv2a armv3 armv3m armv4 armv4t armv5 armv5t armv5te armv6 armv6j armv6t2 armv6z armv7-a armv7-r ep9312"
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/diff-generic.sh:# armv7 armv7-m iwmmxt
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/diff-generic.sh:gcc ${TARGET_ARCH} -E -dM empty.c | sort >out/c_default
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/diff-generic.sh:gcc ${TARGET_ARCH} -E -dM empty.S | sort >out/a_default
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/diff-generic.sh:rm -f out/diff_c out/diff_a
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/diff-generic.sh:gcc ${TARGET_ARCH} -E -dM -march=${a} empty.c | sort >out/c_${a}
dyncall/test/hacking-arm-thumb-interwork/diff-gcc-defs/diff-generic.sh:gcc ${TARGET_ARCH} -E -dM -march=${a} empty.S | sort >out/a_${a}
dyncall/test/hacking-arm-thumb-interwork/Makefile.darwin:TARGET_ARCH	+= -arch armv6
dyncall/test/hacking-arm-thumb-interwork/Makefile.darwin:TARGET_ARCH	+= -isysroot /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS3.0.sdk
dyncall/test/hacking-arm-thumb-interwork/Makefile.darwin:# TARGET_ARCH	+= -mno-thumb-interwork
dyncall/test/hacking-arm-thumb-interwork/Makefile.darwin:# TARGET_ARCH	+= -mthumb-interwork 
dyncall/test/hacking-arm-thumb-interwork/Makefile.darwin:CFLAGS		+= -mthumb
dyncall/test/hacking-arm-thumb-interwork/Makefile.darwin:# CFLAGS		= -mthumb-interwork
dyncall/test/hacking-arm-thumb-interwork/Makefile.darwin:# CFLAGS_THUMB	= -mthumb $(CFLAGS)
dyncall/test/hacking-arm-thumb-interwork/Makefile.darwin:# CFLAGS		+= -mthumb-interwork
dyncall/test/hacking-arm-thumb-interwork/Makefile.darwin:	$(CC) -c $(CPPFLAGS) $(CFLAGS) $(TARGET_ARCH) -mthumb $< -o $@
dyncall/test/hacking-arm-thumb-interwork/Makefile.darwin:	$(CC) -S $(CPPFLAGS) $(CFLAGS) $(TARGET_ARCH) $< -o $@
dyncall/test/hacking-arm-thumb-interwork/arm.c: File: test/hacking-arm-thumb-interwork/arm.c
dyncall/test/hacking-arm-thumb-interwork/arm.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-arm-thumb-interwork/arm.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-arm-thumb-interwork/README.txt:  armv7:  addresses are odd -mthumb-interwork and -mno-thumb-interwork no effect
dyncall/test/hacking-arm-thumb-interwork/thumb.c: File: test/hacking-arm-thumb-interwork/thumb.c
dyncall/test/hacking-arm-thumb-interwork/thumb.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-arm-thumb-interwork/thumb.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-arm-thumb-interwork/test.c: File: test/hacking-arm-thumb-interwork/test.c
dyncall/test/hacking-arm-thumb-interwork/test.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/hacking-arm-thumb-interwork/test.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/hacking-arm-thumb-interwork/Makefile.linux:TARGET_ARCH	+= -mthumb-interwork
dyncall/test/hacking-arm-thumb-interwork/Makefile.linux:	$(COMPILE.c) $< -mthumb $(OUTPUT_OPTION)
dyncall/test/Makefile.embedded:MAKE_CMD = ${MAKE} -f ${MAKEFILE} 
dyncall/test/Makefile.embedded:all: all-dyncall all-dyncallback all-dynload
dyncall/test/Makefile.embedded:all-dynload:
dyncall/test/Makefile.embedded:all-dyncall:
dyncall/test/Makefile.embedded:all-dyncallback:
dyncall/test/Makefile.embedded:all-c:
dyncall/test/Makefile.embedded:all-win32:
dyncall/test/Makefile.embedded:run-all-win32:
dyncall/test/Makefile.embedded:all-unix:
dyncall/test/Makefile.embedded:	LDLIBS="${LDLIBS} -lm" ${MAKE_CMD} all
dyncall/test/Makefile.embedded:	LDLIBS="${LDLIBS} -lm -ldl" ${MAKE_CMD} all
dyncall/test/Makefile.embedded:	CFLAGS="${CFLAGS} -m64" CXXFLAGS="${CXXFLAGS} -m64" CCFLAGS="${CXXFLAGS} -m64" LDFLAGS="${LDFLAGS} -m64" LDLIBS="${LDLIBS} -lm -ldl" ${MAKE_CMD} all-c
dyncall/test/Makefile.embedded:osx-template:
dyncall/test/Makefile.embedded:osx-universal:
dyncall/test/Makefile.embedded:	OSX_ARCH="-arch i386 -arch x86_64" ${MAKE_CMD} osx-template
dyncall/test/Makefile.embedded:osx-i386:
dyncall/test/Makefile.embedded:	OSX_ARCH="-arch i386" ${MAKE_CMD} osx-template
dyncall/test/Makefile.embedded:	CXX=CC LDLIBS="${LDLIBS} -lm" ${MAKE_CMD} all
dyncall/test/Makefile.embedded:sun-64bit:
dyncall/test/Makefile.embedded:	CXX=CC CFLAGS="${CFLAGS} -m64" CXXFLAGS="${CXXFLAGS} -m64" CCFLAGS="${CXXFLAGS} -m64" LDFLAGS="${LDFLAGS} -m64" LDLIBS="${LDLIBS} -lm" ${MAKE_CMD} all
dyncall/test/Makefile.embedded:sun-gcc:
dyncall/test/Makefile.embedded:	CC=gcc CCC=g++ CXX=g++ LDLIBS="${LDLIBS} -lm" ${MAKE_CMD} all
dyncall/test/Makefile.embedded:sun-gcc-64bit:
dyncall/test/Makefile.embedded:	CC=gcc CCC=g++ CXX=g++ CFLAGS="${CFLAGS} -m64" CXXFLAGS="${CXXFLAGS} -m64" CCFLAGS=-m64 LDFLAGS="${LDFLAGS} -m64" LDLIBS="${LDLIBS} -lm" ${MAKE_CMD} all
dyncall/test/Makefile.embedded:ios-sdkroot:
dyncall/test/Makefile.embedded:  CC="${CC} ${IOS_ARCH} -miphoneos-version-min=${IOS_SDK}"\
dyncall/test/Makefile.embedded:  CXX="${CXX} ${IOS_ARCH} -miphoneos-version-min=${IOS_SDK}"\
dyncall/test/Makefile.embedded:  LD="${LD} ${IOS_ARCH} -miphoneos-version-min=${IOS_SDK}"\
dyncall/test/Makefile.embedded:  ASFLAGS="-isysroot ${IOS_SDKROOT}"\
dyncall/test/Makefile.embedded:  CFLAGS="-isysroot ${IOS_SDKROOT}"\
dyncall/test/Makefile.embedded:  CXXFLAGS="-isysroot ${IOS_SDKROOT}"\
dyncall/test/Makefile.embedded:  LDFLAGS="-Wl,-syslibroot ${IOS_SDKROOT}"\
dyncall/test/Makefile.embedded:	IOS_SDKROOT="`xcode-select -print-path`/Platforms/iPhone${IOS_PLATFORM}.platform/Developer/SDKs/iPhone${IOS_PLATFORM}${IOS_SDK}.sdk" ${MAKE_CMD} ios-sdkroot
dyncall/test/Makefile.embedded:ios-sim:
dyncall/test/Makefile.embedded:ios-os:
dyncall/test/Makefile.embedded:ios61-os:
dyncall/test/Makefile.embedded:	IOS_SDK="6.1" IOS_ARCH="-arch armv7"            ${MAKE_CMD} ios-os
dyncall/test/Makefile.embedded:ios61-os-no-thumb:
dyncall/test/Makefile.embedded:	IOS_SDK="6.1" IOS_ARCH="-arch armv7 -mno-thumb" ${MAKE_CMD} ios-os
dyncall/test/Makefile.embedded:ios61-sim:
dyncall/test/Makefile.embedded:	IOS_SDK="6.1" IOS_ARCH="-arch i386"             ${MAKE_CMD} ios-sim
dyncall/test/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test
dyncall/test/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/suite2/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/suite3/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/call_suite/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/plain/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/suite/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/callf/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/nm/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/thunk/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/cmake_install.cmake")
dyncall/test/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/test/syscall/cmake_install.cmake")
dyncall/test/plain_c++/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/plain_c++
dyncall/test/plain_c++/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/plain_c++/Makefile.generic:CXXFLAGS += -I${SRCTOP}/dyncall
dyncall/test/plain_c++/Makefile.generic:LDLIBS   += -L${BLDTOP}/dyncall -ldyncall_s 
dyncall/test/plain_c++/Makefile.generic:	${CXX} ${CXXFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP}
dyncall/test/plain_c++/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/plain_c++/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/plain_c++/mkfile:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/plain_c++/mkfile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/plain_c++/test_main.cc:   Copyright (c) 2007-2019 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/plain_c++/test_main.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/plain_c++/test_main.cc:/* -------------------------------------------------------------------------
dyncall/test/plain_c++/test_main.cc: * ------------------------------------------------------------------------- */
dyncall/test/plain_c++/test_main.cc:/* -------------------------------------------------------------------------
dyncall/test/plain_c++/test_main.cc: * ------------------------------------------------------------------------- */
dyncall/test/plain_c++/test_main.cc: * the layout of the VTable is non-standard and it is not clear what is the initial real first method index.
dyncall/test/plain_c++/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/plain_c++/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/plain_c++/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/plain_c++/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/plain_c++/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/plain_c++/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/plain_c++/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building CXX object test/plain_c++/CMakeFiles/plain_cxx.dir/test_main.cc.o"
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/plain_c++ && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT test/plain_c++/CMakeFiles/plain_cxx.dir/test_main.cc.o -MF CMakeFiles/plain_cxx.dir/test_main.cc.o.d -o CMakeFiles/plain_cxx.dir/test_main.cc.o -c /home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/test_main.cc
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/plain_cxx.dir/test_main.cc.i"
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/plain_c++ && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/test_main.cc > CMakeFiles/plain_cxx.dir/test_main.cc.i
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/plain_cxx.dir/test_main.cc.s"
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/plain_c++ && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/test_main.cc -o CMakeFiles/plain_cxx.dir/test_main.cc.s
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Linking CXX executable plain_cxx"
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/plain_c++ && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/plain_cxx.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/plain_c++ && $(CMAKE_COMMAND) -P CMakeFiles/plain_cxx.dir/cmake_clean.cmake
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/plain_c++ /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/plain_c++ /home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/CMakeFiles/plain_cxx.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/flags.make:CXX_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/flags.make:CXX_FLAGS =   -fPIC
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/link.txt:/usr/bin/c++ -rdynamic CMakeFiles/plain_cxx.dir/test_main.cc.o -o plain_cxx  ../../dyncall/libdyncall_s.a 
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/test_main.cc" "test/plain_c++/CMakeFiles/plain_cxx.dir/test_main.cc.o" "gcc" "test/plain_c++/CMakeFiles/plain_cxx.dir/test_main.cc.o.d"
dyncall/test/plain_c++/CMakeFiles/plain_cxx.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake"
dyncall/test/plain_c++/Makefile.embedded:CFLAGS  += -I${TOP}/dyncall
dyncall/test/plain_c++/Makefile.embedded:LDFLAGS += -L${TOP}/dyncall
dyncall/test/plain_c++/Makefile.embedded:LDLIBS  += -ldyncall_s 
dyncall/test/plain_c++/Makefile.embedded:	${CXX} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP}
dyncall/test/plain_c++/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/plain_c++/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/plain_c++
dyncall/test/plain_c++/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/callback_suite/make-signatures.lua:local argrange  = maxargs - minargs
dyncall/test/callback_suite/make-signatures.lua:    local nargs = minargs + math.random(argrange+1) - 1 
dyncall/test/callback_suite/do_test.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_suite/do_test.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/do_test.c:    case DC_SIGCHAR_BOOL:      isequal = (a->B == b->B) ? 1 : 0 ; break;
dyncall/test/callback_suite/do_test.c:    case DC_SIGCHAR_CHAR:      isequal = (a->c == b->c) ? 1 : 0 ; break;
dyncall/test/callback_suite/do_test.c:    case DC_SIGCHAR_UCHAR:     isequal = (a->C == b->C) ? 1 : 0 ; break;
dyncall/test/callback_suite/do_test.c:    case DC_SIGCHAR_SHORT:     isequal = (a->s == b->s) ? 1 : 0 ; break;
dyncall/test/callback_suite/do_test.c:    case DC_SIGCHAR_USHORT:    isequal = (a->S == b->S) ? 1 : 0 ; break;
dyncall/test/callback_suite/do_test.c:    case DC_SIGCHAR_INT:       isequal = (a->i == b->i) ? 1 : 0 ; break;
dyncall/test/callback_suite/do_test.c:    case DC_SIGCHAR_UINT:      isequal = (a->I == b->I) ? 1 : 0 ; break;
dyncall/test/callback_suite/do_test.c:    case DC_SIGCHAR_LONG:      isequal = (a->j == b->j) ? 1 : 0 ; break;
dyncall/test/callback_suite/do_test.c:    case DC_SIGCHAR_ULONG:     isequal = (a->J == b->J) ? 1 : 0 ; break;
dyncall/test/callback_suite/do_test.c:    case DC_SIGCHAR_LONGLONG:  isequal = (a->l == b->l) ? 1 : 0 ; break;
dyncall/test/callback_suite/do_test.c:    case DC_SIGCHAR_ULONGLONG: isequal = (a->L == b->L) ? 1 : 0 ; break;
dyncall/test/callback_suite/do_test.c:    case DC_SIGCHAR_FLOAT:     isequal = (a->f == b->f) ? 1 : 0 ; break;
dyncall/test/callback_suite/do_test.c:    case DC_SIGCHAR_DOUBLE:    isequal = (a->d == b->d) ? 1 : 0 ; break;
dyncall/test/callback_suite/do_test.c:    case DC_SIGCHAR_POINTER:   isequal = (a->p == b->p) ? 1 : 0 ; break;
dyncall/test/callback_suite/do_test.c:    if (OptionVerbose) { total = 0; fprintf(stdout, " @-1 "); }
dyncall/test/callback_suite/do_test.c:  index = id - 1;
dyncall/test/callback_suite/invokers.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_suite/invokers.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/invokers.c:/* type short-cuts */
dyncall/test/callback_suite/invokers.c:/* Front-End. */
dyncall/test/callback_suite/env.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_suite/env.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/env.c:  output->L = 0xCAFEBABEDEADC0DELL;
dyncall/test/callback_suite/env.c:    case DC_SIGCHAR_BOOL:     output->B = ( (pos*K.i) % 2) ? DC_TRUE : DC_FALSE ; break;
dyncall/test/callback_suite/env.c:    case DC_SIGCHAR_CHAR:     output->c = pos*K.c; break;
dyncall/test/callback_suite/env.c:    case DC_SIGCHAR_UCHAR:    output->C = pos*K.C; break;
dyncall/test/callback_suite/env.c:    case DC_SIGCHAR_SHORT:    output->s = pos*K.s; break;
dyncall/test/callback_suite/env.c:    case DC_SIGCHAR_USHORT:   output->S = pos*K.S; break;
dyncall/test/callback_suite/env.c:    case DC_SIGCHAR_INT:      output->i = pos*K.i; break;
dyncall/test/callback_suite/env.c:    case DC_SIGCHAR_UINT:     output->I = pos*K.I; break;
dyncall/test/callback_suite/env.c:    case DC_SIGCHAR_LONG:     output->j = pos*K.j; break;
dyncall/test/callback_suite/env.c:    case DC_SIGCHAR_ULONG:    output->J = pos*K.J; break;
dyncall/test/callback_suite/env.c:    case DC_SIGCHAR_LONGLONG: output->l = ( (long long) pos ) * K.l; break;
dyncall/test/callback_suite/env.c:    case DC_SIGCHAR_ULONGLONG:output->L = pos*K.L; break;
dyncall/test/callback_suite/env.c:    case DC_SIGCHAR_FLOAT:    output->f = ( (float) pos ) * K.f; break;
dyncall/test/callback_suite/env.c:    case DC_SIGCHAR_DOUBLE:   output->d = ( (double) pos ) * K.d; break;
dyncall/test/callback_suite/env.c:    case DC_SIGCHAR_POINTER:  output->p = (DCpointer) (unsigned long) (pos* ( (unsigned long) K.p ) ); break;
dyncall/test/callback_suite/env.c:  GetReferenceArg(output, ch, -1);
dyncall/test/callback_suite/env.c:  K.s = -23;
dyncall/test/callback_suite/env.c:  K.j = -12357;
dyncall/test/callback_suite/env.c:  K.l = -1234556687721LL;
dyncall/test/callback_suite/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/callback_suite
dyncall/test/callback_suite/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/callback_suite/handler.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_suite/handler.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/signature_utils.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_suite/signature_utils.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/sigstrings.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_suite/sigstrings.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/sigstrings.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_suite/sigstrings.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/config-random.lua:-- section 'main' --------------------------------------------------------------
dyncall/test/callback_suite/config-random.lua:nsigs     = 800         -- number of test cases
dyncall/test/callback_suite/config-random.lua:mode      = "random"    -- generatore mode: 'random' or 'ordered' type sequences
dyncall/test/callback_suite/config-random.lua:minargs   = 0           -- minimum num. of supported arguments (>= 0)
dyncall/test/callback_suite/config-random.lua:maxargs   = 67          -- maximum num. of supported arguments (>= minargs)
dyncall/test/callback_suite/config-random.lua:-- section 'types' -------------------------------------------------------------
dyncall/test/callback_suite/config-random.lua:argtypes  = "BcCsSiIjJlLpfd"    -- supported argument types
dyncall/test/callback_suite/config-random.lua:rettypes  = argtypes    -- supported return types (currently no void support)
dyncall/test/callback_suite/config-random.lua:-- section 'ordered' -----------------------------------------------------------
dyncall/test/callback_suite/config-random.lua:offset    = 0           -- permutation index offset (default = 0)
dyncall/test/callback_suite/config-random.lua:step      = 1           -- permutation index increment (default = 1)
dyncall/test/callback_suite/config-random.lua:-- section 'random' ------------------------------------------------------------
dyncall/test/callback_suite/config-random.lua:seed      = 40           -- random seed
dyncall/test/callback_suite/config-random.lua:-- section 'calling convention' (useful on Windows for now) --------------------
dyncall/test/callback_suite/config-random.lua:api       = ""          -- calling convention ("__stdcall" or "__fastcall")
dyncall/test/callback_suite/config-random.lua:            -- for gcc use "__attribute__((__stdcall__))" or "__attribute__((__fastcall__))"
dyncall/test/callback_suite/config-random.lua:            -- for ms ?
dyncall/test/callback_suite/config-random.lua:ccprefix  = ""          -- signature prefix ("_s" (stdcall), "_f" (gcc fastcall) or "_F" (microsoft fastcall))
dyncall/test/callback_suite/Makefile.generic:CFLAGS  += -I${SRCTOP}/dyncall -I${SRCTOP}/dyncallback
dyncall/test/callback_suite/Makefile.generic:LDLIBS  += -L${BLDTOP}/dyncall -ldyncall_s -L${BLDTOP}/dyncallback -ldyncallback_s
dyncall/test/callback_suite/Makefile.generic:.PHONY: all clean install config clean-config 
dyncall/test/callback_suite/Makefile.generic:	${CC} ${CFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP}
dyncall/test/callback_suite/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/callback_suite/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/callback_suite/Makefile.generic:config: clean-config ${AUTOS}
dyncall/test/callback_suite/Makefile.generic:config-random:
dyncall/test/callback_suite/Makefile.generic:	echo "-- auto-generated file from template config-random.lua (created by GNUmake)" >config.lua
dyncall/test/callback_suite/Makefile.generic:	cat config-random.lua >>config.lua
dyncall/test/callback_suite/Makefile.generic:config-stress1:
dyncall/test/callback_suite/Makefile.generic:	echo "-- auto-generated file from template config-stress1.lua (created by GNUmake)" >config.lua
dyncall/test/callback_suite/Makefile.generic:	cat config-stress1.lua >>config.lua
dyncall/test/callback_suite/Makefile.generic:clean-config: clean
dyncall/test/callback_suite/Makefile.generic:	rm -f ${AUTOS}
dyncall/test/callback_suite/Makefile.generic:	${LUA} make-signatures.lua >$@
dyncall/test/callback_suite/Makefile.generic:	${LUA} make-invokers.lua <$> >$@
dyncall/test/callback_suite/Makefile.generic:	${LUA} make-cstrings.lua <$> >$@
dyncall/test/callback_suite/Makefile.generic:	${LUA} make-config.lua >$@
dyncall/test/callback_suite/Makefile.generic:	${LUA} make-invoke-macros.lua >$@
dyncall/test/callback_suite/Makefile.generic:	${LUA} make-invoke-table.lua >$@
dyncall/test/callback_suite/README.txt:---------------------
dyncall/test/callback_suite/README.txt:- dyncall
dyncall/test/callback_suite/README.txt:- ANSI C compiler
dyncall/test/callback_suite/README.txt:- lua (tested with 5.1)
dyncall/test/callback_suite/README.txt:The invokers put up an argument vector using a global Value-Matrix which
dyncall/test/callback_suite/README.txt:holds a specific type-specific value pattern as a function of position.
dyncall/test/callback_suite/README.txt:The Value-Matrix
dyncall/test/callback_suite/README.txt:The value-matrix is a data structure consisting of n x m elements of
dyncall/test/callback_suite/README.txt:It is used in the body of the auto-generated callback invokers (C code).
dyncall/test/callback_suite/README.txt:}              ^^^^^^^^^^- calling convention
dyncall/test/callback_suite/README.txt:                          ^^^^^^^^^^^^^- signature
dyncall/test/callback_suite/README.txt:         ^- return type signature
dyncall/test/callback_suite/README.txt:                                                  ^- arg signature char 0 (later expected) value
dyncall/test/callback_suite/README.txt:and are pure without any side-effects (means the function value does only
dyncall/test/callback_suite/README.txt:relay on the input arguments - if called with same arguments it will reveal
dyncall/test/callback_suite/mkfile:# Copyright (c) 2013 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/callback_suite/mkfile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/dyncall_value_set.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_suite/dyncall_value_set.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/invokers.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_suite/invokers.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/main.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_suite/main.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/main.c:    if ( argv[i][0] == '-' ) {
dyncall/test/callback_suite/main.c:  ncases = (to - from) + 1;
dyncall/test/callback_suite/config.lua:-- auto-generated file from template config-random.lua (created by GNUmake)
dyncall/test/callback_suite/config.lua:-- section 'main' --------------------------------------------------------------
dyncall/test/callback_suite/config.lua:nsigs     = 800         -- number of test cases
dyncall/test/callback_suite/config.lua:mode      = "random"    -- generatore mode: 'random' or 'ordered' type sequences
dyncall/test/callback_suite/config.lua:minargs   = 0           -- minimum num. of supported arguments (>= 0)
dyncall/test/callback_suite/config.lua:maxargs   = 67          -- maximum num. of supported arguments (>= minargs)
dyncall/test/callback_suite/config.lua:-- section 'types' -------------------------------------------------------------
dyncall/test/callback_suite/config.lua:argtypes  = "BcCsSiIjJlLpfd"    -- supported argument types
dyncall/test/callback_suite/config.lua:rettypes  = argtypes    -- supported return types (currently no void support)
dyncall/test/callback_suite/config.lua:-- section 'ordered' -----------------------------------------------------------
dyncall/test/callback_suite/config.lua:offset    = 0           -- permutation index offset (default = 0)
dyncall/test/callback_suite/config.lua:step      = 1           -- permutation index increment (default = 1)
dyncall/test/callback_suite/config.lua:-- section 'random' ------------------------------------------------------------
dyncall/test/callback_suite/config.lua:seed      = 40           -- random seed
dyncall/test/callback_suite/config.lua:-- section 'calling convention' (useful on Windows for now) --------------------
dyncall/test/callback_suite/config.lua:api       = ""          -- calling convention ("__stdcall" or "__fastcall")
dyncall/test/callback_suite/config.lua:            -- for gcc use "__attribute__((__stdcall__))" or "__attribute__((__fastcall__))"
dyncall/test/callback_suite/config.lua:            -- for ms ?
dyncall/test/callback_suite/config.lua:ccprefix  = ""          -- signature prefix ("_s" (stdcall), "_f" (gcc fastcall) or "_F" (microsoft fastcall))
dyncall/test/callback_suite/config-stress1.lua:-- section 'main' --------------------------------------------------------------
dyncall/test/callback_suite/config-stress1.lua:mode      = "designed"    -- generator mode: 'random', 'ordered' or 'designed' type sequences
dyncall/test/callback_suite/config-stress1.lua:designfile= "stress1.cfg" -- design file 
dyncall/test/callback_suite/config-stress1.lua:nsigs     = nlines()    -- number of test cases
dyncall/test/callback_suite/config-stress1.lua:minargs   = 0           -- minimum num. of supported arguments (>= 0)
dyncall/test/callback_suite/config-stress1.lua:maxargs   = 20          -- maximum num. of supported arguments (>= minargs)
dyncall/test/callback_suite/config-stress1.lua:-- section 'types' (not used by 'designed') ------------------------------------
dyncall/test/callback_suite/config-stress1.lua:argtypes  = "BcCsSiIjJlLpfd" -- "BcCsSiIjJlLpfd"    -- supported argument types
dyncall/test/callback_suite/config-stress1.lua:rettypes  = argtypes    -- supported return types (currently no void support)
dyncall/test/callback_suite/config-stress1.lua:-- section 'ordered' -----------------------------------------------------------
dyncall/test/callback_suite/config-stress1.lua:offset    = 0           -- permutation index offset (default = 1)
dyncall/test/callback_suite/config-stress1.lua:step      = 1           -- permutation index increment (default = 1)
dyncall/test/callback_suite/config-stress1.lua:-- section 'random' ------------------------------------------------------------
dyncall/test/callback_suite/config-stress1.lua:seed      = 1           -- random seed
dyncall/test/callback_suite/config-stress1.lua:-- section 'calling convention' (useful on Windows for now) --------------------
dyncall/test/callback_suite/config-stress1.lua:api       = ""          -- calling convention ("__stdcall" or "__fastcall")
dyncall/test/callback_suite/config-stress1.lua:            -- for gcc use "__attribute__((__stdcall__))" or "__attribute__((__fastcall__))"
dyncall/test/callback_suite/config-stress1.lua:            -- for ms ?
dyncall/test/callback_suite/config-stress1.lua:ccprefix  = ""          -- signature prefix ("_s" (stdcall), "_f" (gcc fastcall) or "_F" (microsoft fastcall))
dyncall/test/callback_suite/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/callback_suite/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a $(TOP)\dyncallback\libdyncallback_s.a -o "$(@B).elf"
dyncall/test/callback_suite/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/callback_suite/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/callback_suite/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/callback_suite/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object test/callback_suite/CMakeFiles/callback_suite.dir/env.c.o"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/callback_suite/CMakeFiles/callback_suite.dir/env.c.o -MF CMakeFiles/callback_suite.dir/env.c.o.d -o CMakeFiles/callback_suite.dir/env.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/env.c
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/callback_suite.dir/env.c.i"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/env.c > CMakeFiles/callback_suite.dir/env.c.i
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/callback_suite.dir/env.c.s"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/env.c -o CMakeFiles/callback_suite.dir/env.c.s
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Building C object test/callback_suite/CMakeFiles/callback_suite.dir/handler.c.o"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/callback_suite/CMakeFiles/callback_suite.dir/handler.c.o -MF CMakeFiles/callback_suite.dir/handler.c.o.d -o CMakeFiles/callback_suite.dir/handler.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/handler.c
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/callback_suite.dir/handler.c.i"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/handler.c > CMakeFiles/callback_suite.dir/handler.c.i
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/callback_suite.dir/handler.c.s"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/handler.c -o CMakeFiles/callback_suite.dir/handler.c.s
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Building C object test/callback_suite/CMakeFiles/callback_suite.dir/sigstrings.c.o"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/callback_suite/CMakeFiles/callback_suite.dir/sigstrings.c.o -MF CMakeFiles/callback_suite.dir/sigstrings.c.o.d -o CMakeFiles/callback_suite.dir/sigstrings.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/sigstrings.c
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/callback_suite.dir/sigstrings.c.i"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/sigstrings.c > CMakeFiles/callback_suite.dir/sigstrings.c.i
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/callback_suite.dir/sigstrings.c.s"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/sigstrings.c -o CMakeFiles/callback_suite.dir/sigstrings.c.s
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_4) "Building C object test/callback_suite/CMakeFiles/callback_suite.dir/invokers.c.o"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/callback_suite/CMakeFiles/callback_suite.dir/invokers.c.o -MF CMakeFiles/callback_suite.dir/invokers.c.o.d -o CMakeFiles/callback_suite.dir/invokers.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/invokers.c
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/callback_suite.dir/invokers.c.i"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/invokers.c > CMakeFiles/callback_suite.dir/invokers.c.i
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/callback_suite.dir/invokers.c.s"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/invokers.c -o CMakeFiles/callback_suite.dir/invokers.c.s
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_5) "Building C object test/callback_suite/CMakeFiles/callback_suite.dir/do_test.c.o"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/callback_suite/CMakeFiles/callback_suite.dir/do_test.c.o -MF CMakeFiles/callback_suite.dir/do_test.c.o.d -o CMakeFiles/callback_suite.dir/do_test.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/do_test.c
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/callback_suite.dir/do_test.c.i"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/do_test.c > CMakeFiles/callback_suite.dir/do_test.c.i
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/callback_suite.dir/do_test.c.s"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/do_test.c -o CMakeFiles/callback_suite.dir/do_test.c.s
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_6) "Building C object test/callback_suite/CMakeFiles/callback_suite.dir/main.c.o"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/callback_suite/CMakeFiles/callback_suite.dir/main.c.o -MF CMakeFiles/callback_suite.dir/main.c.o.d -o CMakeFiles/callback_suite.dir/main.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/main.c
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/callback_suite.dir/main.c.i"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/main.c > CMakeFiles/callback_suite.dir/main.c.i
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/callback_suite.dir/main.c.s"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/main.c -o CMakeFiles/callback_suite.dir/main.c.s
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_7) "Building C object test/callback_suite/CMakeFiles/callback_suite.dir/print.c.o"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/callback_suite/CMakeFiles/callback_suite.dir/print.c.o -MF CMakeFiles/callback_suite.dir/print.c.o.d -o CMakeFiles/callback_suite.dir/print.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/print.c
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/callback_suite.dir/print.c.i"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/print.c > CMakeFiles/callback_suite.dir/print.c.i
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/callback_suite.dir/print.c.s"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/print.c -o CMakeFiles/callback_suite.dir/print.c.s
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_8) "Building C object test/callback_suite/CMakeFiles/callback_suite.dir/signature_utils.c.o"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/callback_suite/CMakeFiles/callback_suite.dir/signature_utils.c.o -MF CMakeFiles/callback_suite.dir/signature_utils.c.o.d -o CMakeFiles/callback_suite.dir/signature_utils.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/signature_utils.c
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/callback_suite.dir/signature_utils.c.i"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/signature_utils.c > CMakeFiles/callback_suite.dir/signature_utils.c.i
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/callback_suite.dir/signature_utils.c.s"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/signature_utils.c -o CMakeFiles/callback_suite.dir/signature_utils.c.s
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_9) "Linking C executable callback_suite"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/callback_suite.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite && $(CMAKE_COMMAND) -P CMakeFiles/callback_suite.dir/cmake_clean.cmake
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/CMakeFiles/callback_suite.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/flags.make:C_FLAGS =   -fPIC
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/link.txt:/usr/bin/cc -rdynamic CMakeFiles/callback_suite.dir/env.c.o CMakeFiles/callback_suite.dir/handler.c.o CMakeFiles/callback_suite.dir/sigstrings.c.o CMakeFiles/callback_suite.dir/invokers.c.o CMakeFiles/callback_suite.dir/do_test.c.o CMakeFiles/callback_suite.dir/main.c.o CMakeFiles/callback_suite.dir/print.c.o CMakeFiles/callback_suite.dir/signature_utils.c.o -o callback_suite  ../../dyncallback/libdyncallback_s.a 
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/do_test.c" "test/callback_suite/CMakeFiles/callback_suite.dir/do_test.c.o" "gcc" "test/callback_suite/CMakeFiles/callback_suite.dir/do_test.c.o.d"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/env.c" "test/callback_suite/CMakeFiles/callback_suite.dir/env.c.o" "gcc" "test/callback_suite/CMakeFiles/callback_suite.dir/env.c.o.d"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/handler.c" "test/callback_suite/CMakeFiles/callback_suite.dir/handler.c.o" "gcc" "test/callback_suite/CMakeFiles/callback_suite.dir/handler.c.o.d"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/invokers.c" "test/callback_suite/CMakeFiles/callback_suite.dir/invokers.c.o" "gcc" "test/callback_suite/CMakeFiles/callback_suite.dir/invokers.c.o.d"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/main.c" "test/callback_suite/CMakeFiles/callback_suite.dir/main.c.o" "gcc" "test/callback_suite/CMakeFiles/callback_suite.dir/main.c.o.d"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/print.c" "test/callback_suite/CMakeFiles/callback_suite.dir/print.c.o" "gcc" "test/callback_suite/CMakeFiles/callback_suite.dir/print.c.o.d"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/signature_utils.c" "test/callback_suite/CMakeFiles/callback_suite.dir/signature_utils.c.o" "gcc" "test/callback_suite/CMakeFiles/callback_suite.dir/signature_utils.c.o.d"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/sigstrings.c" "test/callback_suite/CMakeFiles/callback_suite.dir/sigstrings.c.o" "gcc" "test/callback_suite/CMakeFiles/callback_suite.dir/sigstrings.c.o.d"
dyncall/test/callback_suite/CMakeFiles/callback_suite.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/CMakeFiles/dyncallback_s.dir/DependInfo.cmake"
dyncall/test/callback_suite/make-invoke-macros.lua:    for j = 0, i-1 do
dyncall/test/callback_suite/print.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_suite/print.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/print.c:%s [ -v ] [ from [to] ]\n\
dyncall/test/callback_suite/print.c:  -v        verbose reports\n\
dyncall/test/callback_suite/print.c:  -h        help on usage\n\
dyncall/test/callback_suite/Makefile.embedded:CFLAGS  += -I${SRCTOP}/dyncall -I${SRCTOP}/dyncallback
dyncall/test/callback_suite/Makefile.embedded:LDFLAGS += -L${BLDTOP}/dyncall -L${BLDTOP}/dyncallback
dyncall/test/callback_suite/Makefile.embedded:LDLIBS  += -ldyncall_s -ldyncallback_s
dyncall/test/callback_suite/Makefile.embedded:	${CC} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP} 
dyncall/test/callback_suite/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/callback_suite/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/callback_suite
dyncall/test/callback_suite/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/callback_suite/signature_utils.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_suite/signature_utils.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/env.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_suite/env.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callback_suite/env.h:/* function of type (position = -1) */
dyncall/test/callback_suite/make-invokers.lua:  local nargs = string.len(signature) - 2
dyncall/test/callback_suite/print.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callback_suite/print.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/dynload_plain/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/dynload_plain
dyncall/test/dynload_plain/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/dynload_plain/Makefile.generic:DEF_C_DYLIB=$(shell ((ldd `which ls` | grep -o '/.*/libc.so[^ ]*' || ls /lib*/libc.so* || ls /usr/lib/libc.so*) | grep -v '\.a$$' | (sort -V -r || sort -t . -n -k 2)) 2>/dev/null | head -1)
dyncall/test/dynload_plain/Makefile.generic:DEF_C_DYLIB!=((ldd `which ls` | grep -o '/.*/libc.so[^ ]*' || ls /lib*/libc.so* || ls /usr/lib/libc.so*) | grep -v '\.a$$' | (sort -V -r || sort -t . -n -k 2)) 2>/dev/null | head -1
dyncall/test/dynload_plain/Makefile.generic:TEST_U8_SO = dynload_plain__test # @@@ unsure if every platform handles , here (ANSI, UTF-8, ...)
dyncall/test/dynload_plain/Makefile.generic:CFLAGS    += -I${SRCTOP}/dynload -DDEF_C_DYLIB=\"${DEF_C_DYLIB}\"
dyncall/test/dynload_plain/Makefile.generic:LDLIBS_D  += -L${BLDTOP}/dynload -ldynload_s
dyncall/test/dynload_plain/Makefile.generic:# Linux: add '-ldl'
dyncall/test/dynload_plain/Makefile.generic:	${CC} ${LDFLAGS} ${OBJS} ${LDLIBS_D} ${LDLIBS} -o ${APP}
dyncall/test/dynload_plain/Makefile.generic:	echo 'int dynload_plain_testfunc() { return 5; }' | ${CC} -`[ \`uname\` = Darwin ] && echo dynamiclib || echo shared` -x c - -o ${TEST_U8_SO}
dyncall/test/dynload_plain/Makefile.generic:	rm -f ${APP} ${OBJS} ${TEST_U8_SO}
dyncall/test/dynload_plain/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/dynload_plain/Nmakefile:# Copyright (c) 2017-2020 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/dynload_plain/Nmakefile:TEST_U8_SO = dynload_plain__test # this non-ASCII character seems to work in Nmakefiles *iff* the utf-8/BOM mark is present
dyncall/test/dynload_plain/Nmakefile:	echo Building helper lib with UTF-8 path $(TEST_U8_SO) ...
dyncall/test/dynload_plain/Nmakefile:#	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)\dynload\libdynload_s.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/dynload_plain/Nmakefile:#	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/dynload_plain/Nmakefile:#	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/dynload_plain/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/dynload_plain/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object test/dynload_plain/CMakeFiles/dynload_plain.dir/dynload_plain.c.o"
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/dynload_plain/CMakeFiles/dynload_plain.dir/dynload_plain.c.o -MF CMakeFiles/dynload_plain.dir/dynload_plain.c.o.d -o CMakeFiles/dynload_plain.dir/dynload_plain.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/dynload_plain.c
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dynload_plain.dir/dynload_plain.c.i"
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/dynload_plain.c > CMakeFiles/dynload_plain.dir/dynload_plain.c.i
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dynload_plain.dir/dynload_plain.c.s"
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/dynload_plain.c -o CMakeFiles/dynload_plain.dir/dynload_plain.c.s
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Linking C executable dynload_plain"
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/dynload_plain.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain && $(CMAKE_COMMAND) -P CMakeFiles/dynload_plain.dir/cmake_clean.cmake
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/CMakeFiles/dynload_plain.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/flags.make:C_FLAGS =  -DDEF_C_DYLIB=\"/usr/lib/libc.so.6\"   -fPIC
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/link.txt:/usr/bin/cc  -DDEF_C_DYLIB=\"/usr/lib/libc.so.6\" -rdynamic CMakeFiles/dynload_plain.dir/dynload_plain.c.o -o dynload_plain  ../../dynload/libdynload_s.a -ldl 
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/dynload_plain.c" "test/dynload_plain/CMakeFiles/dynload_plain.dir/dynload_plain.c.o" "gcc" "test/dynload_plain/CMakeFiles/dynload_plain.dir/dynload_plain.c.o.d"
dyncall/test/dynload_plain/CMakeFiles/dynload_plain.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dynload/CMakeFiles/dynload_s.dir/DependInfo.cmake"
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object test/dynload_plain/CMakeFiles/x.dir/x.c.o"
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/dynload_plain/CMakeFiles/x.dir/x.c.o -MF CMakeFiles/x.dir/x.c.o.d -o CMakeFiles/x.dir/x.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/x.c
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/x.dir/x.c.i"
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/x.c > CMakeFiles/x.dir/x.c.i
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/x.dir/x.c.s"
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/x.c -o CMakeFiles/x.dir/x.c.s
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Linking C shared library dynload_plain__test"
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/x.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain && $(CMAKE_COMMAND) -P CMakeFiles/x.dir/cmake_clean.cmake
dyncall/test/dynload_plain/CMakeFiles/x.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/CMakeFiles/x.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/dynload_plain/CMakeFiles/x.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/dynload_plain/CMakeFiles/x.dir/flags.make:C_DEFINES = -Dx_EXPORTS
dyncall/test/dynload_plain/CMakeFiles/x.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/dynload_plain/CMakeFiles/x.dir/flags.make:C_FLAGS =  -DDEF_C_DYLIB=\"/usr/lib/libc.so.6\" -fPIC   -fPIC
dyncall/test/dynload_plain/CMakeFiles/x.dir/link.txt:/usr/bin/cc -fPIC  -DDEF_C_DYLIB=\"/usr/lib/libc.so.6\" -shared -Wl,-soname,dynload_plain__test -o dynload_plain__test CMakeFiles/x.dir/x.c.o 
dyncall/test/dynload_plain/CMakeFiles/x.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/x.c" "test/dynload_plain/CMakeFiles/x.dir/x.c.o" "gcc" "test/dynload_plain/CMakeFiles/x.dir/x.c.o.d"
dyncall/test/dynload_plain/dynload_plain.c:   Copyright (c) 2017-2018 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/dynload_plain/dynload_plain.c:  /* hacky/lazy list of some clib paths per platform - more/others, like version-suffixed ones */
dyncall/test/dynload_plain/dynload_plain.c:    "/usr/lib/system/libsystem_c.dylib", /* macos - note: not on fs w/ macos >= 11.0.1 */
dyncall/test/dynload_plain/dynload_plain.c:    if(access(clibs[i], F_OK) != -1) {
dyncall/test/dynload_plain/dynload_plain.c:    /* ---------------- */
dyncall/test/dynload_plain/dynload_plain.c:          b = (stat(path, &st0) != -1) && (stat(queriedPath, &st1) != -1);
dyncall/test/dynload_plain/dynload_plain.c:          printf("lib (inode:%d) and looked up lib (inode:%d) are same: %d\n", b?(int)st0.st_ino:-1, b?(int)st1.st_ino:-1, b && (st0.st_ino == st1.st_ino));
dyncall/test/dynload_plain/dynload_plain.c:          printf("-- skipping inode based check (doesn't apply to this platform or we are dealing with macos dylib that isn't on fs) --\n");
dyncall/test/dynload_plain/dynload_plain.c:      /* test UTF-8 path through dummy library that's created by this test's build */
dyncall/test/dynload_plain/dynload_plain.c:        pLib = dlLoadLibrary(pathU8); /* check if we can load a lib with a UTF-8 path */
dyncall/test/dynload_plain/dynload_plain.c:        printf("pLib (loaded w/ UTF-8 path %s with wd being exec's dir) handle: %p\n", pathU8, pLib);
dyncall/test/dynload_plain/dynload_plain.c:          /* get UTF-8 path back */
dyncall/test/dynload_plain/dynload_plain.c:            nu8c = strlen_utf8(queriedPath); /* num of UTF-8 chars is as big as ... */
dyncall/test/dynload_plain/dynload_plain.c:            b = (bs > 0) && (nu8c == bs-2);   /* ... buffer size minus 2 (b/c of one 2-byte UTF-8 char and "\0") */
dyncall/test/dynload_plain/dynload_plain.c:            printf("UTF-8 path of lib looked up via handle: %s\n", queriedPath);
dyncall/test/dynload_plain/dynload_plain.c:            printf("looked up UTF-8 path's needed buffer size (%d) for %d UTF-8 char string computed correctly: %d\n", bs, nu8c, b);
dyncall/test/dynload_plain/dynload_plain.c:            printf("failed to query UTF-8 lib path using lib's handle\n");
dyncall/test/dynload_plain/dynload_plain.c:    /* ------------- */
dyncall/test/dynload_plain/dynload_plain.c:    pSyms = dlSymsInit(path); /* check if we can iterate over symbols - init */
dyncall/test/dynload_plain/dynload_plain.c:      pLib = dlLoadLibrary(path); /* check if we can resolve ptr -> name, */
dyncall/test/dynload_plain/Makefile.embedded:DEF_C_DYLIB=$(shell ((ldd `which ls` | grep -o '/.*/libc.so[^ ]*' || ls /lib*/libc.so* || ls /usr/lib/libc.so*) | grep -v '\.a$$' | (sort -V -r || sort -t . -n -k 2)) 2>/dev/null | head -1)
dyncall/test/dynload_plain/Makefile.embedded:DEF_C_DYLIB!=((ldd `which ls` | grep -o '/.*/libc.so[^ ]*' || ls /lib*/libc.so* || ls /usr/lib/libc.so*) | grep -v '\.a$$' | (sort -V -r || sort -t . -n -k 2)) 2>/dev/null | head -1
dyncall/test/dynload_plain/Makefile.embedded:TEST_U8_SO = dynload_plain__test # @@@ unsure if every platform handles , here (ANSI, UTF-8, ...)
dyncall/test/dynload_plain/Makefile.embedded:CFLAGS  += -I${TOP}/dynload -DDEF_C_DYLIB=\"${DEF_C_DYLIB}\"
dyncall/test/dynload_plain/Makefile.embedded:LDFLAGS += -L${TOP}/dynload
dyncall/test/dynload_plain/Makefile.embedded:LDLIBS  += -ldynload_s
dyncall/test/dynload_plain/Makefile.embedded:# Linux: add '-ldl'
dyncall/test/dynload_plain/Makefile.embedded:	${CC} ${OBJS} ${LDFLAGS} ${LDLIBS} -o $@
dyncall/test/dynload_plain/Makefile.embedded:	echo 'int dynload_plain_testfunc() { return 5; }' | ${CC} -`[ \`uname\` = Darwin ] && echo dynamiclib || echo shared` -x c - -o ${TEST_U8_SO}
dyncall/test/dynload_plain/Makefile.embedded:	rm -f ${APP} ${OBJS} ${TEST_U8_SO}
dyncall/test/dynload_plain/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain
dyncall/test/dynload_plain/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/dynload_plain/CMakeLists.txt:exec_program("((ldd `which ls` | grep -o '/.*/libc.so[^ ]*' || ls /lib*/libc.so* || ls /usr/lib/libc.so*) | grep -v '\\.a\$' | (sort -V -r || sort -t . -n -k 2)) 2>/dev/null | head -1" OUTPUT_VARIABLE DEF_C_DYLIB)
dyncall/test/dynload_plain/CMakeLists.txt:set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DDEF_C_DYLIB=\\\"${DEF_C_DYLIB}\\\"")
dyncall/test/suite3/case.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite3/case.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite3/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/suite3
dyncall/test/suite3/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/suite3/main.cc:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite3/main.cc:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite3/main.cc:    case 0: return ( getArg(pos)->i == valueInt     [pos] ); break;
dyncall/test/suite3/main.cc:    case 1: return ( getArg(pos)->l == valueLongLong[pos] ); break;
dyncall/test/suite3/main.cc:    case 2: return ( getArg(pos)->d == valueDouble  [pos] ); break;
dyncall/test/suite3/main.cc:    case 3: return ( getArg(pos)->f == valueFloat   [pos] ); break;
dyncall/test/suite3/main.cc:    int select = (y-1) % NTYPES; 
dyncall/test/suite3/main.cc:    y = (y-1) / NTYPES;
dyncall/test/suite3/main.cc:  return static_cast<int>( pow((double)x,n)+powerfact(x,n-1) );
dyncall/test/suite3/main.cc:  return (success) ? 0 : -1;
dyncall/test/suite3/Makefile.generic:CPPFLAGS += -I${SRCTOP}/dyncall
dyncall/test/suite3/Makefile.generic:LDLIBS   += -L${BLDTOP}/dyncall -ldyncall_s
dyncall/test/suite3/Makefile.generic:	${CXX} ${CXXFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP}
dyncall/test/suite3/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/suite3/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/suite3/README.txt:Copyright (c) 2007-2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite3/README.txt:                        Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite3/README.txt:  suite         	        - run full range
dyncall/test/suite3/README.txt:  suite <id> 			- run test id <id>
dyncall/test/suite3/README.txt:  suite <from> <to>		- run test id <from> to id <to> (inclusive).
dyncall/test/suite3/README.txt:  the test invokes 'void'-functions that effectively overwrite global 
dyncall/test/suite3/README.txt:    sets all arguments into type-specific value vectors at the given position
dyncall/test/suite3/case.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite3/case.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite3/mkcase.py:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite3/mkcase.py:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite3/mkcase.py:    return x**n+powerfact(x,n-1)
dyncall/test/suite3/mkcase.py:    s     = (y-1) % ntypes
dyncall/test/suite3/mkcase.py:    y     = (y-1) / ntypes
dyncall/test/suite3/config.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/suite3/config.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite3/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/suite3/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/suite3/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/suite3/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/suite3/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/suite3/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/suite3/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building CXX object test/suite3/CMakeFiles/suite3.dir/case.cc.o"
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite3 && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT test/suite3/CMakeFiles/suite3.dir/case.cc.o -MF CMakeFiles/suite3.dir/case.cc.o.d -o CMakeFiles/suite3.dir/case.cc.o -c /home/chenningcong/Desktop/dyncall-1.2/test/suite3/case.cc
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/suite3.dir/case.cc.i"
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite3 && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/suite3/case.cc > CMakeFiles/suite3.dir/case.cc.i
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/suite3.dir/case.cc.s"
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite3 && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/suite3/case.cc -o CMakeFiles/suite3.dir/case.cc.s
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Building CXX object test/suite3/CMakeFiles/suite3.dir/main.cc.o"
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite3 && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT test/suite3/CMakeFiles/suite3.dir/main.cc.o -MF CMakeFiles/suite3.dir/main.cc.o.d -o CMakeFiles/suite3.dir/main.cc.o -c /home/chenningcong/Desktop/dyncall-1.2/test/suite3/main.cc
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/suite3.dir/main.cc.i"
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite3 && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/suite3/main.cc > CMakeFiles/suite3.dir/main.cc.i
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/suite3.dir/main.cc.s"
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite3 && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/suite3/main.cc -o CMakeFiles/suite3.dir/main.cc.s
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Linking CXX executable suite3"
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite3 && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/suite3.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/suite3 && $(CMAKE_COMMAND) -P CMakeFiles/suite3.dir/cmake_clean.cmake
dyncall/test/suite3/CMakeFiles/suite3.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/suite3 /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/suite3 /home/chenningcong/Desktop/dyncall-1.2/test/suite3/CMakeFiles/suite3.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/suite3/CMakeFiles/suite3.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/suite3/CMakeFiles/suite3.dir/flags.make:CXX_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/suite3/CMakeFiles/suite3.dir/flags.make:CXX_FLAGS =   -fPIC
dyncall/test/suite3/CMakeFiles/suite3.dir/link.txt:/usr/bin/c++ -rdynamic CMakeFiles/suite3.dir/case.cc.o CMakeFiles/suite3.dir/main.cc.o -o suite3  ../../dyncall/libdyncall_s.a 
dyncall/test/suite3/CMakeFiles/suite3.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/suite3/case.cc" "test/suite3/CMakeFiles/suite3.dir/case.cc.o" "gcc" "test/suite3/CMakeFiles/suite3.dir/case.cc.o.d"
dyncall/test/suite3/CMakeFiles/suite3.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/suite3/main.cc" "test/suite3/CMakeFiles/suite3.dir/main.cc.o" "gcc" "test/suite3/CMakeFiles/suite3.dir/main.cc.o.d"
dyncall/test/suite3/CMakeFiles/suite3.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake"
dyncall/test/suite3/Makefile.embedded:CFLAGS  += -I${TOP}/dyncall
dyncall/test/suite3/Makefile.embedded:LDFLAGS += -L${TOP}/dyncall
dyncall/test/suite3/Makefile.embedded:LDLIBS  += -ldyncall_s
dyncall/test/suite3/Makefile.embedded:	${CXX} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP}
dyncall/test/suite3/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/suite3/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/suite3
dyncall/test/suite3/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/nm/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/nm
dyncall/test/nm/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/nm/Makefile.generic:CFLAGS   += -I${SRCTOP}/dynload
dyncall/test/nm/Makefile.generic:LDLIBS_D += -L${BLDTOP}/dynload -ldynload_s
dyncall/test/nm/Makefile.generic:# Linux: add '-ldl'
dyncall/test/nm/Makefile.generic:	${CC} ${CFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS_D} ${LDLIBS} -o ${APP}
dyncall/test/nm/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/nm/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/nm/Nmakefile:# Copyright (c) 2007-2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/nm/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/nm/Nmakefile:#	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)\dynload\libdynload_s.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/nm/Nmakefile:#	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/nm/Nmakefile:#	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/nm/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/nm/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/nm/CMakeFiles/nm.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/nm/CMakeFiles/nm.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/nm/CMakeFiles/nm.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/nm/CMakeFiles/nm.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/nm/CMakeFiles/nm.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/nm/CMakeFiles/nm.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/nm/CMakeFiles/nm.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/nm/CMakeFiles/nm.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/nm/CMakeFiles/nm.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/nm/CMakeFiles/nm.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/nm/CMakeFiles/nm.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/nm/CMakeFiles/nm.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/nm/CMakeFiles/nm.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object test/nm/CMakeFiles/nm.dir/nm.c.o"
dyncall/test/nm/CMakeFiles/nm.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/nm && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/nm/CMakeFiles/nm.dir/nm.c.o -MF CMakeFiles/nm.dir/nm.c.o.d -o CMakeFiles/nm.dir/nm.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/nm/nm.c
dyncall/test/nm/CMakeFiles/nm.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/nm.dir/nm.c.i"
dyncall/test/nm/CMakeFiles/nm.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/nm && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/nm/nm.c > CMakeFiles/nm.dir/nm.c.i
dyncall/test/nm/CMakeFiles/nm.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/nm.dir/nm.c.s"
dyncall/test/nm/CMakeFiles/nm.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/nm && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/nm/nm.c -o CMakeFiles/nm.dir/nm.c.s
dyncall/test/nm/CMakeFiles/nm.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Linking C executable nm"
dyncall/test/nm/CMakeFiles/nm.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/nm && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/nm.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/nm/CMakeFiles/nm.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/nm && $(CMAKE_COMMAND) -P CMakeFiles/nm.dir/cmake_clean.cmake
dyncall/test/nm/CMakeFiles/nm.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/nm /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/nm /home/chenningcong/Desktop/dyncall-1.2/test/nm/CMakeFiles/nm.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/nm/CMakeFiles/nm.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/nm/CMakeFiles/nm.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/nm/CMakeFiles/nm.dir/flags.make:C_FLAGS =   -fPIC
dyncall/test/nm/CMakeFiles/nm.dir/link.txt:/usr/bin/cc -rdynamic CMakeFiles/nm.dir/nm.c.o -o nm  ../../dynload/libdynload_s.a -ldl 
dyncall/test/nm/CMakeFiles/nm.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/nm/nm.c" "test/nm/CMakeFiles/nm.dir/nm.c.o" "gcc" "test/nm/CMakeFiles/nm.dir/nm.c.o.d"
dyncall/test/nm/CMakeFiles/nm.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dynload/CMakeFiles/dynload_s.dir/DependInfo.cmake"
dyncall/test/nm/Makefile.embedded:CFLAGS  += -I${TOP}/dynload
dyncall/test/nm/Makefile.embedded:LDFLAGS += -L${TOP}/dynload
dyncall/test/nm/Makefile.embedded:LDLIBS  += -ldynload_s
dyncall/test/nm/Makefile.embedded:# Linux: add '-ldl'
dyncall/test/nm/Makefile.embedded:	${CC} ${OBJS} ${LDFLAGS} ${LDLIBS} -o $@
dyncall/test/nm/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/nm/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/nm
dyncall/test/nm/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/nm/nm.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/nm/nm.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callf/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/callf
dyncall/test/callf/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/callf/Makefile.generic:CFLAGS += -I${SRCTOP}/dyncall
dyncall/test/callf/Makefile.generic:LDLIBS += -L${BLDTOP}/dyncall -ldyncall_s
dyncall/test/callf/Makefile.generic:	${CC} ${CFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP}
dyncall/test/callf/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/callf/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/callf/mkfile:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/callf/mkfile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callf/main.c:   Copyright (c) 2007-2021 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/callf/main.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callf/main.c:  /* testing syscall using calling convention prefix - not available on all platforms */
dyncall/test/callf/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/callf/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/callf/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a -o "$(@B).elf"
dyncall/test/callf/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/callf/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/callf/CMakeFiles/callf.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callf/CMakeFiles/callf.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callf/CMakeFiles/callf.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callf/CMakeFiles/callf.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callf/CMakeFiles/callf.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/callf/CMakeFiles/callf.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/callf/CMakeFiles/callf.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/callf/CMakeFiles/callf.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/callf/CMakeFiles/callf.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/callf/CMakeFiles/callf.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/callf/CMakeFiles/callf.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/callf/CMakeFiles/callf.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/callf/CMakeFiles/callf.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object test/callf/CMakeFiles/callf.dir/main.c.o"
dyncall/test/callf/CMakeFiles/callf.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callf && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/callf/CMakeFiles/callf.dir/main.c.o -MF CMakeFiles/callf.dir/main.c.o.d -o CMakeFiles/callf.dir/main.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/callf/main.c
dyncall/test/callf/CMakeFiles/callf.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/callf.dir/main.c.i"
dyncall/test/callf/CMakeFiles/callf.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callf && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/callf/main.c > CMakeFiles/callf.dir/main.c.i
dyncall/test/callf/CMakeFiles/callf.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/callf.dir/main.c.s"
dyncall/test/callf/CMakeFiles/callf.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callf && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/callf/main.c -o CMakeFiles/callf.dir/main.c.s
dyncall/test/callf/CMakeFiles/callf.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Linking C executable callf"
dyncall/test/callf/CMakeFiles/callf.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callf && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/callf.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/callf/CMakeFiles/callf.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/callf && $(CMAKE_COMMAND) -P CMakeFiles/callf.dir/cmake_clean.cmake
dyncall/test/callf/CMakeFiles/callf.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/callf /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/callf /home/chenningcong/Desktop/dyncall-1.2/test/callf/CMakeFiles/callf.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/callf/CMakeFiles/callf.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/callf/CMakeFiles/callf.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/callf/CMakeFiles/callf.dir/flags.make:C_FLAGS =   -fPIC
dyncall/test/callf/CMakeFiles/callf.dir/link.txt:/usr/bin/cc -rdynamic CMakeFiles/callf.dir/main.c.o -o callf  ../../dyncall/libdyncall_s.a 
dyncall/test/callf/CMakeFiles/callf.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/callf/main.c" "test/callf/CMakeFiles/callf.dir/main.c.o" "gcc" "test/callf/CMakeFiles/callf.dir/main.c.o.d"
dyncall/test/callf/CMakeFiles/callf.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake"
dyncall/test/callf/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/callf/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/callf/Makefile.embedded:CFLAGS  += -I${TOP}/dyncall
dyncall/test/callf/Makefile.embedded:LDFLAGS += -L${TOP}/dyncall
dyncall/test/callf/Makefile.embedded:LDLIBS  += -ldyncall_s
dyncall/test/callf/Makefile.embedded:	${CC} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP} 
dyncall/test/callf/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/callf/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/callf
dyncall/test/callf/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/malloc_wx/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/malloc_wx
dyncall/test/malloc_wx/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/malloc_wx/Makefile.generic:CFLAGS += -I${SRCTOP}/dyncallback -I${SRCTOP}/dyncall
dyncall/test/malloc_wx/Makefile.generic:LDLIBS += -L${BLDTOP}/dyncallback -ldyncallback_s
dyncall/test/malloc_wx/Makefile.generic:	${CC} ${CFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP} 
dyncall/test/malloc_wx/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/malloc_wx/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/malloc_wx/mkfile:# Copyright (c) 2013 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/malloc_wx/mkfile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/malloc_wx/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/test/malloc_wx/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/malloc_wx/Nmakefile:	$(LD) $(LDFLAGS) $(OBJS) $(DEVKITPRO_PATH)\libnds\lib\libnds9.a $(TOP)/dyncall/libdyncall_s.a $(TOP)\dyncallback\libdyncallback_s.a -o "$(@B).elf"
dyncall/test/malloc_wx/Nmakefile:	$(OCP) -O binary "$(@B).elf" "$(@B).arm9"
dyncall/test/malloc_wx/Nmakefile:	ndstool -c "$@" -9 "$(@B).arm9"
dyncall/test/malloc_wx/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/malloc_wx/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object test/malloc_wx/CMakeFiles/malloc_wx.dir/test_wx.c.o"
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/malloc_wx/CMakeFiles/malloc_wx.dir/test_wx.c.o -MF CMakeFiles/malloc_wx.dir/test_wx.c.o.d -o CMakeFiles/malloc_wx.dir/test_wx.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/test_wx.c
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/malloc_wx.dir/test_wx.c.i"
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/test_wx.c > CMakeFiles/malloc_wx.dir/test_wx.c.i
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/malloc_wx.dir/test_wx.c.s"
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/test_wx.c -o CMakeFiles/malloc_wx.dir/test_wx.c.s
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Linking C executable malloc_wx"
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/malloc_wx.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx && $(CMAKE_COMMAND) -P CMakeFiles/malloc_wx.dir/cmake_clean.cmake
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx /home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/CMakeFiles/malloc_wx.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/flags.make:C_FLAGS =   -fPIC
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/link.txt:/usr/bin/cc -rdynamic CMakeFiles/malloc_wx.dir/test_wx.c.o -o malloc_wx  ../../dyncallback/libdyncallback_s.a 
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/test_wx.c" "test/malloc_wx/CMakeFiles/malloc_wx.dir/test_wx.c.o" "gcc" "test/malloc_wx/CMakeFiles/malloc_wx.dir/test_wx.c.o.d"
dyncall/test/malloc_wx/CMakeFiles/malloc_wx.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/CMakeFiles/dyncallback_s.dir/DependInfo.cmake"
dyncall/test/malloc_wx/Makefile.embedded:CFLAGS  += -I${TOP}/dyncallback -I${TOP}/dyncall
dyncall/test/malloc_wx/Makefile.embedded:LDFLAGS += -L${TOP}/dyncallback
dyncall/test/malloc_wx/Makefile.embedded:LDLIBS  += -ldyncallback_s
dyncall/test/malloc_wx/Makefile.embedded:	${CC} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP} 
dyncall/test/malloc_wx/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/malloc_wx/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx
dyncall/test/malloc_wx/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/test/malloc_wx/test_wx.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/malloc_wx/test_wx.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/syscall/syscall.c:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/test/syscall/syscall.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/test/syscall/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./test/syscall
dyncall/test/syscall/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/test/syscall/Makefile.generic:CFLAGS   += -I${SRCTOP}/dyncall
dyncall/test/syscall/Makefile.generic:LDLIBS   += -L${BLDTOP}/dyncall -ldyncall_s
dyncall/test/syscall/Makefile.generic:	${CC} ${CFLAGS} ${LDFLAGS} ${OBJS} ${LDLIBS} -o ${APP} 
dyncall/test/syscall/Makefile.generic:	rm -f ${APP} ${OBJS}
dyncall/test/syscall/Makefile.generic:	mkdir -p ${PREFIX}/test
dyncall/test/syscall/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/syscall/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:# Disable VCS-based implicit rules.
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object test/syscall/CMakeFiles/syscall.dir/syscall.c.o"
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/syscall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT test/syscall/CMakeFiles/syscall.dir/syscall.c.o -MF CMakeFiles/syscall.dir/syscall.c.o.d -o CMakeFiles/syscall.dir/syscall.c.o -c /home/chenningcong/Desktop/dyncall-1.2/test/syscall/syscall.c
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/syscall.dir/syscall.c.i"
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/syscall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/test/syscall/syscall.c > CMakeFiles/syscall.dir/syscall.c.i
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/syscall.dir/syscall.c.s"
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/syscall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/test/syscall/syscall.c -o CMakeFiles/syscall.dir/syscall.c.s
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Linking C executable syscall"
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/syscall && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/syscall.dir/link.txt --verbose=$(VERBOSE)
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/test/syscall && $(CMAKE_COMMAND) -P CMakeFiles/syscall.dir/cmake_clean.cmake
dyncall/test/syscall/CMakeFiles/syscall.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/syscall /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/test/syscall /home/chenningcong/Desktop/dyncall-1.2/test/syscall/CMakeFiles/syscall.dir/DependInfo.cmake --color=$(COLOR)
dyncall/test/syscall/CMakeFiles/syscall.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/test/syscall/CMakeFiles/syscall.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dynload -I/home/chenningcong/Desktop/dyncall-1.2/dyncall -I/home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/test/syscall/CMakeFiles/syscall.dir/flags.make:C_FLAGS =   -fPIC
dyncall/test/syscall/CMakeFiles/syscall.dir/link.txt:/usr/bin/cc -rdynamic CMakeFiles/syscall.dir/syscall.c.o -o syscall  ../../dyncall/libdyncall_s.a 
dyncall/test/syscall/CMakeFiles/syscall.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/test/syscall/syscall.c" "test/syscall/CMakeFiles/syscall.dir/syscall.c.o" "gcc" "test/syscall/CMakeFiles/syscall.dir/syscall.c.o.d"
dyncall/test/syscall/CMakeFiles/syscall.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake"
dyncall/test/syscall/Makefile.embedded:CFLAGS  += -I${SRCTOP}/dyncall
dyncall/test/syscall/Makefile.embedded:LDFLAGS += -L${BLDTOP}/dyncall
dyncall/test/syscall/Makefile.embedded:LDLIBS  += -ldyncall_s
dyncall/test/syscall/Makefile.embedded:	${CC} ${OBJS} ${LDFLAGS} ${LDLIBS} -o ${APP} 
dyncall/test/syscall/Makefile.embedded:	rm -f ${APP} ${OBJS}
dyncall/test/syscall/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/test/syscall
dyncall/test/syscall/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/README:dyncall - A Generic Dynamic FFI package
dyncall/README:dyncall is a low-level toolkit providing a portable abstraction for 
dyncall/README: - 'dyncall' for making function calls,
dyncall/README: - 'dyncallback' or writing generic callback handlers, and
dyncall/README: - 'dynload' for loading code.
dyncall/README:A typical application for the use of dyncall is the back-end of a FFI 
dyncall/README:The binary footprint of the package is approx. 10-20 kb, depending on
dyncall/README:----------------------
dyncall/README: - C compiler such as gcc, clang, sunpro or msvc.
dyncall/README: - Assembler such as gas (gnu/apple), fbe or masm.
dyncall/README: - Build system such as 'shell/make', cmake, nmake (windows) or mk (plan9).
dyncall/README:---------------------------------
dyncall/README: - x86     32/64-bit  (cdecl, fastcall, stdcall, C++ this calls, syscalls, plan9)
dyncall/README: - ARM     AArch32/64 (32: ARM/Thumb mode, v4t-v7, oabi/eabi, soft/hardfloat ABIs; 64: AAPCS64)
dyncall/README: - MIPS    32/64-bit  (o32, n64, eabi, with o32 and n64 for soft- and hardfloat)
dyncall/README: - PowerPC 32/64-bit  (32: Mac OS X, System V; 64: System V little and big endian ELF ABI)
dyncall/README: - Sparc   32/64-bit  (v7/8 and v9)
dyncall/README:----------------------------
dyncall/README: - Android
dyncall/README: - *BSD
dyncall/README: - Haiku
dyncall/README: - iOS
dyncall/README: - Linux
dyncall/README: - Mac OS X
dyncall/README: - Microsoft Windows
dyncall/README: - Minix
dyncall/README: - Nintendo DS Homebrew
dyncall/README: - Plan9 / 9front
dyncall/README: - Playstation Portable Homebrew
dyncall/README: - ReactOS
dyncall/README: - Solaris
dyncall/README:----------------------
dyncall/README:$ make run-tests
dyncall/README:Build 'out-of-source'
dyncall/README:---------------------
dyncall/README:$ <src_dir>/configure --prefix=<install_dir>
dyncall/README:--------------------
dyncall/README:-------------------
dyncall/README:Platform-specific build details
dyncall/README:-------------------------------
dyncall/README:-------------------
dyncall/README:the dyncall manual and platform-specific READMEs under doc/ for more information.
dyncall/CPackConfig.cmake:#  cpack --help-variable-list
dyncall/CPackConfig.cmake:set(CPACK_BUILD_SOURCE_DIRS "/home/chenningcong/Desktop/dyncall-1.2;/home/chenningcong/Desktop/dyncall-1.2")
dyncall/CPackConfig.cmake:set(CPACK_DEFAULT_PACKAGE_DESCRIPTION_FILE "/usr/share/cmake-3.21/Templates/CPack.GenericDescription.txt")
dyncall/CPackConfig.cmake:set(CPACK_INSTALL_CMAKE_PROJECTS "/home/chenningcong/Desktop/dyncall-1.2;DynCall;ALL;/")
dyncall/CPackConfig.cmake:set(CPACK_OUTPUT_CONFIG_FILE "/home/chenningcong/Desktop/dyncall-1.2/CPackConfig.cmake")
dyncall/CPackConfig.cmake:set(CPACK_PACKAGE_DESCRIPTION_FILE "/home/chenningcong/Desktop/dyncall-1.2/README")
dyncall/CPackConfig.cmake:set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "dyncall enables dynamic invocation of machine-level function calls")
dyncall/CPackConfig.cmake:set(CPACK_PACKAGE_FILE_NAME "dyncall-0.1.1-Linux")
dyncall/CPackConfig.cmake:set(CPACK_RESOURCE_FILE_LICENSE "/home/chenningcong/Desktop/dyncall-1.2/LICENSE")
dyncall/CPackConfig.cmake:set(CPACK_RESOURCE_FILE_README "/usr/share/cmake-3.21/Templates/CPack.GenericDescription.txt")
dyncall/CPackConfig.cmake:set(CPACK_RESOURCE_FILE_WELCOME "/usr/share/cmake-3.21/Templates/CPack.GenericWelcome.txt")
dyncall/CPackConfig.cmake:set(CPACK_SOURCE_OUTPUT_CONFIG_FILE "/home/chenningcong/Desktop/dyncall-1.2/CPackSourceConfig.cmake")
dyncall/CPackConfig.cmake:  set(CPACK_PROPERTIES_FILE "/home/chenningcong/Desktop/dyncall-1.2/CPackProperties.cmake")
dyncall/Makefile.config:# auto-generated by ./configure
dyncall/Makefile.config:CFLAGS=-fPIC
dyncall/Makefile.config:LDLIBS=-lm -ldl
dyncall/dyncall/dyncall_call_x86_generic_masm.asm:; auto-generated by gen-masm.sh
dyncall/dyncall/dyncall_call_x86_generic_masm.asm: and ECX,-16
dyncall/dyncall/dyncall_callvm_arm32_arm.c: Description: ARM 32-bit "arm" ABI callvm implementation
dyncall/dyncall/dyncall_callvm_arm32_arm.c:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_arm32_arm.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_arm32_arm.c:** - hybrid return-type call (bool ... pointer)
dyncall/dyncall/dyncall_callvm_arm32_arm.c:** Note the return type of this declaration is intentially of double-word size (despite
dyncall/dyncall/dyncall_callvm_arm32_arm.c:** in the caller (dc_callvm_call_arm32_arm) that reuses - thus overwrites - r0 and r1.
dyncall/dyncall/dyncall_callvm_arm32_arm.c:  dcVecReset(&self->mVecHead);
dyncall/dyncall/dyncall_callvm_arm32_arm.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCint));
dyncall/dyncall/dyncall_callvm_arm32_arm.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_arm32_arm.c:  dcVecSkip(&self->mVecHead, dcVecSize(&self->mVecHead) & 4);
dyncall/dyncall/dyncall_callvm_arm32_arm.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_arm32_arm.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCfloat));
dyncall/dyncall/dyncall_callvm_arm32_arm.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_arm32_arm.c:  dcVecSkip(&self->mVecHead, dcVecSize(&self->mVecHead) & 4);
dyncall/dyncall/dyncall_callvm_arm32_arm.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_arm32_arm.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCpointer));
dyncall/dyncall/dyncall_callvm_arm32_arm.c:  dcCall_arm32_arm(target, dcVecData(&self->mVecHead), dcVecSize(&self->mVecHead));
dyncall/dyncall/dyncall_callvm_arm32_arm.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE; 
dyncall/dyncall/dyncall_callvm_arm32_arm.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_arm32_arm.c:  dcVecInit(&p->mVecHead, size);
dyncall/dyncall/dyncall_callf.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callf.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_ppc64.h:   Copyright (c) 2014-2015 Masanori Mitsugi <mitsugi@linux.vnet.ibm.com>
dyncall/dyncall/dyncall_callvm_ppc64.h:                      2020 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_mips_n32.h:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncall/dyncall_callvm_mips_n32.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_mips_n32.h:  two register-files for integer (promoted to 64-bit) and float (not promoted!)
dyncall/dyncall/dyncall_callvm_mips_n32.h:  the other register-file will be skipped by one.
dyncall/dyncall/dyncall_callvm_mips_n32.h:  float arguments are either loaded from single or double -
dyncall/dyncall/dyncall_callvm_mips_n32.h:  a auto-conversion into double and then loaded as double precision
dyncall/dyncall/dyncall_callvm_mips_n32.h:  interpreted in the call-kernel.
dyncall/dyncall/dyncall_callvm_arm32_arm.h:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_arm32_arm.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_ppc64.c:   Copyright (c) 2014-2015 Masanori Mitsugi <mitsugi@linux.vnet.ibm.com>
dyncall/dyncall/dyncall_callvm_ppc64.c:                      2020 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_ppc64.c:** PowerPC 64-bit calling convention call
dyncall/dyncall/dyncall_callvm_ppc64.c:** - hybrid return-type call (bool ... pointer)
dyncall/dyncall/dyncall_callvm_ppc64.c:/* Support for Power PC 64-bit */
dyncall/dyncall/dyncall_callvm_ppc64.c:  dcVecReset(&self->mVecHead);
dyncall/dyncall/dyncall_callvm_ppc64.c:  self->mIntRegs   = 0;
dyncall/dyncall/dyncall_callvm_ppc64.c:  self->mFloatRegs = 0;
dyncall/dyncall/dyncall_callvm_ppc64.c:/** floating-point **/
dyncall/dyncall/dyncall_callvm_ppc64.c:  if (self->mFloatRegs < 13) {
dyncall/dyncall/dyncall_callvm_ppc64.c:    self->mRegData.mFloatData[self->mFloatRegs++] = d;
dyncall/dyncall/dyncall_callvm_ppc64.c:    if (self->mIntRegs < 8) {
dyncall/dyncall/dyncall_callvm_ppc64.c:      self->mRegData.mIntData[self->mIntRegs++] = *( (DClonglong*) &d );
dyncall/dyncall/dyncall_callvm_ppc64.c:  if (dcVecSize(&self->mVecHead) == 0) {
dyncall/dyncall/dyncall_callvm_ppc64.c:    dcVecSkip(&self->mVecHead,sizeof(DClonglong)*8);
dyncall/dyncall/dyncall_callvm_ppc64.c:  dcVecAppend(&self->mVecHead,(DCpointer) &d,sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_ppc64.c:  if (dcVecSize(&self->mVecHead) == 0)
dyncall/dyncall/dyncall_callvm_ppc64.c:    dcVecSkip(&self->mVecHead,(sizeof(DClonglong))*(self->mIntRegs));
dyncall/dyncall/dyncall_callvm_ppc64.c:  if (self->mFloatRegs < 13) {
dyncall/dyncall/dyncall_callvm_ppc64.c:    self->mRegData.mFloatData[self->mFloatRegs++] = d;
dyncall/dyncall/dyncall_callvm_ppc64.c:    if (self->mIntRegs < 8) {
dyncall/dyncall/dyncall_callvm_ppc64.c:      self->mRegData.mIntData[self->mIntRegs++] = *( (DClonglong*) &d );
dyncall/dyncall/dyncall_callvm_ppc64.c:  dcVecAppend(&self->mVecHead,(DCpointer) &d,sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_ppc64.c:/* Floating-point */
dyncall/dyncall/dyncall_callvm_ppc64.c:  if (self->mFloatRegs < 13) {
dyncall/dyncall/dyncall_callvm_ppc64.c:    self->mRegData.mFloatData[self->mFloatRegs++] = d;
dyncall/dyncall/dyncall_callvm_ppc64.c:    if (self->mIntRegs < 8) {
dyncall/dyncall/dyncall_callvm_ppc64.c:      self->mRegData.mIntData[self->mIntRegs++] = *( (DClonglong*) &d );
dyncall/dyncall/dyncall_callvm_ppc64.c:  if (dcVecSize(&self->mVecHead) == 0) {
dyncall/dyncall/dyncall_callvm_ppc64.c:    dcVecSkip(&self->mVecHead,sizeof(DClonglong)*8);
dyncall/dyncall/dyncall_callvm_ppc64.c:  dcVecAppend(&self->mVecHead,(DCpointer) &sf,sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_ppc64.c:  if (self->mIntRegs < 8) {
dyncall/dyncall/dyncall_callvm_ppc64.c:    self->mRegData.mIntData[self->mIntRegs++] = L;
dyncall/dyncall/dyncall_callvm_ppc64.c:  if (dcVecSize(&self->mVecHead) == 0) {
dyncall/dyncall/dyncall_callvm_ppc64.c:    dcVecSkip(&self->mVecHead,sizeof(DClonglong)*8);
dyncall/dyncall/dyncall_callvm_ppc64.c:  dcVecAppend(&self->mVecHead,&L,sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_ppc64.c:  if (dcVecSize(&self->mVecHead) == 0) 
dyncall/dyncall/dyncall_callvm_ppc64.c:    dcVecSkip(&self->mVecHead,(sizeof(DClonglong))*(self->mIntRegs));
dyncall/dyncall/dyncall_callvm_ppc64.c:  if (self->mIntRegs < 8) 
dyncall/dyncall/dyncall_callvm_ppc64.c:    self->mRegData.mIntData[self->mIntRegs++] = L;
dyncall/dyncall/dyncall_callvm_ppc64.c:  dcVecAppend(&self->mVecHead,&L,sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_ppc64.c:  int size = dcVecSize(&self->mVecHead);
dyncall/dyncall/dyncall_callvm_ppc64.c:	dcVecSkip(&self->mVecHead, 64-size);
dyncall/dyncall/dyncall_callvm_ppc64.c:  dcCall_ppc64( target, &self->mRegData, dcVecSize(&self->mVecHead) , dcVecData(&self->mVecHead));
dyncall/dyncall/dyncall_callvm_ppc64.c:  dcCall_ppc64_syscall( target, &self->mRegData, dcVecSize(&self->mVecHead) , dcVecData(&self->mVecHead));
dyncall/dyncall/dyncall_callvm_ppc64.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE; 
dyncall/dyncall/dyncall_callvm_ppc64.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_ppc64.c:  dcVecInit(&p->mVecHead, size);
dyncall/dyncall/dyncall_callvm_x86.c:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_x86.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_x86.c:** - hybrid return-type call (bool ... pointer)
dyncall/dyncall/dyncall_callvm_x86.c:#if defined(DC__OS_Plan9) /* No support for other cconvs on Plan9 and vice-versa. */
dyncall/dyncall/dyncall_callvm_x86.c:  dcVecReset(&self->mVecHead);
dyncall/dyncall/dyncall_callvm_x86.c:  self->mIntRegs = 0;
dyncall/dyncall/dyncall_callvm_x86.c:/* arg (bool,char,short,long auto-promoted) to int */
dyncall/dyncall/dyncall_callvm_x86.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCint) );
dyncall/dyncall/dyncall_callvm_x86.c:/* arg bool - promoted to int */
dyncall/dyncall/dyncall_callvm_x86.c:/* arg char - promoted to int */
dyncall/dyncall/dyncall_callvm_x86.c:/* arg short - promoted to int */
dyncall/dyncall/dyncall_callvm_x86.c:/* arg long - promoted to int */
dyncall/dyncall/dyncall_callvm_x86.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DClonglong) );
dyncall/dyncall/dyncall_callvm_x86.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCfloat) );
dyncall/dyncall/dyncall_callvm_x86.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCdouble) );
dyncall/dyncall/dyncall_callvm_x86.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCpointer) );
dyncall/dyncall/dyncall_callvm_x86.c:  /* Calls with 32-bit return values have it returned via EAX, so we don't */
dyncall/dyncall/dyncall_callvm_x86.c:  dcCall_x86_plan9(target, dcVecData(&self->mVecHead), dcVecSize(&self->mVecHead));
dyncall/dyncall/dyncall_callvm_x86.c:  dcCall_x86_plan9_ll(target, dcVecData(&self->mVecHead), dcVecSize(&self->mVecHead), &ret );
dyncall/dyncall/dyncall_callvm_x86.c:  dcCall_x86_cdecl( target, dcVecData(&self->mVecHead), dcVecSize(&self->mVecHead) );
dyncall/dyncall/dyncall_callvm_x86.c:/* --- stdcall -------------------------------------------------------------- */
dyncall/dyncall/dyncall_callvm_x86.c:  dcCall_x86_win32_std( target, dcVecData(&self->mVecHead), dcVecSize(&self->mVecHead) );
dyncall/dyncall/dyncall_callvm_x86.c:/* --- fastcall common (ms/gnu) -------------------------------------------- */
dyncall/dyncall/dyncall_callvm_x86.c:  dcCall_x86_win32_fast( target, dcVecData(&self->mVecHead), dcVecSize(&self->mVecHead) );
dyncall/dyncall/dyncall_callvm_x86.c:/* reset - always resize to 8 bytes (stores ECX and EDX) */
dyncall/dyncall/dyncall_callvm_x86.c:  dcVecResize(&self->mVecHead, sizeof(DCint) * 2 );
dyncall/dyncall/dyncall_callvm_x86.c:  self->mIntRegs = 0;
dyncall/dyncall/dyncall_callvm_x86.c:/* --- fastcall ms --------------------------------------------------------- */
dyncall/dyncall/dyncall_callvm_x86.c:/* arg int - probably hold in ECX and EDX */
dyncall/dyncall/dyncall_callvm_x86.c:  if (self->mIntRegs < 2) {
dyncall/dyncall/dyncall_callvm_x86.c:    *( (int*) dcVecAt(&self->mVecHead, sizeof(DCint) * self->mIntRegs ) ) = x;
dyncall/dyncall/dyncall_callvm_x86.c:    ++( self->mIntRegs );
dyncall/dyncall/dyncall_callvm_x86.c:    dcVecAppend(&self->mVecHead, &x, sizeof(DCint) );
dyncall/dyncall/dyncall_callvm_x86.c:/* arg bool - promote to int */
dyncall/dyncall/dyncall_callvm_x86.c:/* arg char - promote to int */
dyncall/dyncall/dyncall_callvm_x86.c:/* arg short - promote to int */
dyncall/dyncall/dyncall_callvm_x86.c:/* arg long - promote to int */
dyncall/dyncall/dyncall_callvm_x86.c:/* arg pointer - promote to int */
dyncall/dyncall/dyncall_callvm_x86.c:/* --- gnu fastcall -------------------------------------------------------- */
dyncall/dyncall/dyncall_callvm_x86.c:/* arg int - probably hold in ECX and EDX */
dyncall/dyncall/dyncall_callvm_x86.c:  if (self->mIntRegs < 2) {
dyncall/dyncall/dyncall_callvm_x86.c:    *( (int*) dcVecAt(&self->mVecHead, sizeof(DCint) * self->mIntRegs ) ) = x;
dyncall/dyncall/dyncall_callvm_x86.c:    ++( self->mIntRegs );
dyncall/dyncall/dyncall_callvm_x86.c:    dcVecAppend(&self->mVecHead, &x, sizeof(DCint) );
dyncall/dyncall/dyncall_callvm_x86.c:/* arg bool - promote to int */
dyncall/dyncall/dyncall_callvm_x86.c:/* arg char - promote to int */
dyncall/dyncall/dyncall_callvm_x86.c:/* arg short - promote to int */
dyncall/dyncall/dyncall_callvm_x86.c:/* arg long - promote to int */
dyncall/dyncall/dyncall_callvm_x86.c:/* arg pointer - promote to int */
dyncall/dyncall/dyncall_callvm_x86.c:/* arg long long - skip registers and push on stack */
dyncall/dyncall/dyncall_callvm_x86.c:  self->mIntRegs = 2;
dyncall/dyncall/dyncall_callvm_x86.c:/* --- this ms ------------------------------------------------------------- */
dyncall/dyncall/dyncall_callvm_x86.c:  dcCall_x86_win32_msthis( target, dcVecData(&self->mVecHead), dcVecSize(&self->mVecHead) );
dyncall/dyncall/dyncall_callvm_x86.c:/* --- syscall ------------------------------------------------------------- */
dyncall/dyncall/dyncall_callvm_x86.c:  dcCall_x86_syscall_int80h_linux( target, dcVecData(&self->mVecHead), dcVecSize(&self->mVecHead) );
dyncall/dyncall/dyncall_callvm_x86.c:  dcCall_x86_syscall_int80h_bsd( target, dcVecData(&self->mVecHead), dcVecSize(&self->mVecHead) );
dyncall/dyncall/dyncall_callvm_x86.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE; return;
dyncall/dyncall/dyncall_callvm_x86.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE;
dyncall/dyncall/dyncall_callvm_x86.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_x86.c:  dcVecInit(&p->mVecHead, size);
dyncall/dyncall/dyncall_call_mips_eabi_gas.s:   Copyright (c) 2007-2011 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_call_mips_eabi_gas.s:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_mips_eabi_gas.s:	2008-01-03
dyncall/dyncall/dyncall_call_mips_eabi_gas.s:	addiu	$sp,$sp,-16
dyncall/dyncall/dyncall_call_mips_eabi_gas.s:	addiu	$6,$6, -4
dyncall/dyncall/dyncall_call_mips_eabi_gas.s:	/* load single-precision floating pointer parameter registers */
dyncall/dyncall/dyncall_callvm_ppc32.c:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_ppc32.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_ppc32.c:** PowerPC 32-bit calling convention call
dyncall/dyncall/dyncall_callvm_ppc32.c:** - hybrid return-type call (bool ... pointer)
dyncall/dyncall/dyncall_callvm_ppc32.c:/* Support for Mac OS X (Darwin) and Systen V ABI for Power PC 32-bit */
dyncall/dyncall/dyncall_callvm_ppc32.c:  dcVecReset(&self->mVecHead);
dyncall/dyncall/dyncall_callvm_ppc32.c:  self->mIntRegs   = 0;
dyncall/dyncall/dyncall_callvm_ppc32.c:  self->mFloatRegs = 0;
dyncall/dyncall/dyncall_callvm_ppc32.c:  if (self->mIntRegs < 8)
dyncall/dyncall/dyncall_callvm_ppc32.c:    self->mRegData.mIntData[self->mIntRegs++] = i;
dyncall/dyncall/dyncall_callvm_ppc32.c:  dcVecAppend(&self->mVecHead,&i,sizeof(DCint));
dyncall/dyncall/dyncall_callvm_ppc32.c:  if (self->mIntRegs < 8)
dyncall/dyncall/dyncall_callvm_ppc32.c:    self->mRegData.mIntData[self->mIntRegs++] = i;
dyncall/dyncall/dyncall_callvm_ppc32.c:    dcVecAppend(&self->mVecHead,&i,sizeof(DCint));
dyncall/dyncall/dyncall_callvm_ppc32.c:/** floating-point **/
dyncall/dyncall/dyncall_callvm_ppc32.c:  if (self->mFloatRegs < 13) {
dyncall/dyncall/dyncall_callvm_ppc32.c:    self->mRegData.mFloatData[self->mFloatRegs++] = d;
dyncall/dyncall/dyncall_callvm_ppc32.c:    if (self->mIntRegs < 8) 
dyncall/dyncall/dyncall_callvm_ppc32.c:      self->mRegData.mIntData[self->mIntRegs++] = ( (DCint*) &d )[0];
dyncall/dyncall/dyncall_callvm_ppc32.c:    if (self->mIntRegs < 8) 
dyncall/dyncall/dyncall_callvm_ppc32.c:      self->mRegData.mIntData[self->mIntRegs++] = ( (DCint*) &d )[1];
dyncall/dyncall/dyncall_callvm_ppc32.c:  dcVecAppend(&self->mVecHead, &d, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_ppc32.c:  if (self->mFloatRegs < 8) {
dyncall/dyncall/dyncall_callvm_ppc32.c:    self->mRegData.mFloatData[self->mFloatRegs++] = d;
dyncall/dyncall/dyncall_callvm_ppc32.c:    if (self->mIntRegs < 8) 
dyncall/dyncall/dyncall_callvm_ppc32.c:      self->mRegData.mIntData[self->mIntRegs++] = ( (DCint*) &d )[0];
dyncall/dyncall/dyncall_callvm_ppc32.c:    if (self->mIntRegs < 8) 
dyncall/dyncall/dyncall_callvm_ppc32.c:      self->mRegData.mIntData[self->mIntRegs++] = ( (DCint*) &d )[1];
dyncall/dyncall/dyncall_callvm_ppc32.c:  dcVecAppend(&self->mVecHead, &d, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_ppc32.c:  if (self->mFloatRegs < 8) 
dyncall/dyncall/dyncall_callvm_ppc32.c:    self->mRegData.mFloatData[self->mFloatRegs++] = d;
dyncall/dyncall/dyncall_callvm_ppc32.c:  dcVecResize(&self->mVecHead , ( dcVecSize(&self->mVecHead) + 7UL ) & -8UL ); 
dyncall/dyncall/dyncall_callvm_ppc32.c:    dcVecAppend(&self->mVecHead,(DCpointer) &d,sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_ppc32.c:/* Floating-point */
dyncall/dyncall/dyncall_callvm_ppc32.c: * - skip one integer register file entry (write in - for ellipsis calls) 
dyncall/dyncall/dyncall_callvm_ppc32.c: * - 
dyncall/dyncall/dyncall_callvm_ppc32.c:  if (self->mFloatRegs < 13) {
dyncall/dyncall/dyncall_callvm_ppc32.c:    self->mRegData.mFloatData[self->mFloatRegs++] = (DCdouble) (f);
dyncall/dyncall/dyncall_callvm_ppc32.c:  /* AND skip one integer register file entry (write in - for ellipsis calls) */
dyncall/dyncall/dyncall_callvm_ppc32.c:  if (self->mIntRegs < 8) 
dyncall/dyncall/dyncall_callvm_ppc32.c:    self->mRegData.mIntData[self->mIntRegs++] = *( (DCint*) &f );
dyncall/dyncall/dyncall_callvm_ppc32.c:  dcVecAppend(&self->mVecHead, &f, sizeof(DCfloat));
dyncall/dyncall/dyncall_callvm_ppc32.c:  if (self->mFloatRegs < 8)
dyncall/dyncall/dyncall_callvm_ppc32.c:    self->mRegData.mFloatData[self->mFloatRegs++] = (DCdouble) (f);
dyncall/dyncall/dyncall_callvm_ppc32.c:    dcVecAppend(&self->mVecHead, &f, sizeof(DCfloat));
dyncall/dyncall/dyncall_callvm_ppc32.c:  if (self->mIntRegs < 7)
dyncall/dyncall/dyncall_callvm_ppc32.c:    if (self->mIntRegs & 1) self->mIntRegs++;
dyncall/dyncall/dyncall_callvm_ppc32.c:    self->mRegData.mIntData[self->mIntRegs++] = p[0];
dyncall/dyncall/dyncall_callvm_ppc32.c:    self->mRegData.mIntData[self->mIntRegs++] = p[1];
dyncall/dyncall/dyncall_callvm_ppc32.c:    self->mIntRegs = 8;
dyncall/dyncall/dyncall_callvm_ppc32.c:    dcVecResize(&self->mVecHead , ( dcVecSize(&self->mVecHead) + 7 ) & (-8UL) );
dyncall/dyncall/dyncall_callvm_ppc32.c:    dcVecAppend(&self->mVecHead,&L,sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_ppc32.c:    &self->mRegData, 
dyncall/dyncall/dyncall_callvm_ppc32.c:    DC_MAX(dcVecSize(&self->mVecHead), 8*4),
dyncall/dyncall/dyncall_callvm_ppc32.c:    dcVecData(&self->mVecHead)
dyncall/dyncall/dyncall_callvm_ppc32.c:  dcCall_ppc32_sysv( target, &self->mRegData, dcVecSize(&self->mVecHead) , dcVecData(&self->mVecHead));
dyncall/dyncall/dyncall_callvm_ppc32.c:  dcCall_ppc32_syscall( target, &self->mRegData, dcVecSize(&self->mVecHead) , dcVecData(&self->mVecHead));
dyncall/dyncall/dyncall_callvm_ppc32.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE; 
dyncall/dyncall/dyncall_callvm_ppc32.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_ppc32.c:  dcVecInit(&p->mVecHead, size);
dyncall/dyncall/dyncall_callvm_arm64_apple.c: Description: ARM 64-bit Apple ABI implementation
dyncall/dyncall/dyncall_callvm_arm64_apple.c:   Copyright (c) 2015-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_arm64_apple.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  p->i = 0;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  p->f = 0;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  dcVecReset(&p->mVecHead);
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  if (p->i < 8) {
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->I[p->i] = x;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->i++;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAlign(&p->mVecHead, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAppend(&p->mVecHead, &x, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  dcVecAlign(&p->mVecHead, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  dcVecAppend(&p->mVecHead, &x, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  dcVecAlign(&p->mVecHead, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  dcVecAppend(&p->mVecHead, &x, sizeof(DCdouble)); 
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  if (p->i < 8) {
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->I[p->i] = (DClonglong) x;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->i++;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAlign(&p->mVecHead, sizeof(DCbool));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAppend(&p->mVecHead, &x, sizeof(DCbool));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  if (p->i < 8) {
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->I[p->i] = (DClonglong) x;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->i++;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAppend(&p->mVecHead, &x, sizeof(DCchar));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  if (p->i < 8) {
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->I[p->i] = (DClonglong) x;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->i++;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAlign(&p->mVecHead, sizeof(DCshort));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAppend(&p->mVecHead, &x, sizeof(DCshort));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  if (p->i < 8) {
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->I[p->i] = (DClonglong) x;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->i++;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAlign(&p->mVecHead, sizeof(DCint));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAppend(&p->mVecHead, &x, sizeof(DCint));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  if (p->i < 8) {
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->I[p->i] = (DClonglong) x;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->i++;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAlign(&p->mVecHead, sizeof(DClong));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAppend(&p->mVecHead, &x, sizeof(DClong));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  if (p->f < 8) {
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->u.S[ p->f << 1 ] = x;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->f++;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAlign(&p->mVecHead, sizeof(DCfloat));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAppend(&p->mVecHead, &x, sizeof(DCfloat));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  if (p->f < 8) {
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->u.D[ p->f ] = x;
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    p->f++; 
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAlign(&p->mVecHead, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:    dcVecAppend(&p->mVecHead, &x, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  ** copy 'size' argument is given in number of 16-byte 'pair' blocks.
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  dcCall_arm64(target, dcVecData(&p->mVecHead), ( dcVecSize(&p->mVecHead) + 15 ) & -16, &p->u.S[0]);
dyncall/dyncall/dyncall_callvm_arm64_apple.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE; 
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_arm64_apple.c:  dcVecInit(&p->mVecHead, size);
dyncall/dyncall/dyncall_callvm_mips_eabi.c:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_mips_eabi.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_mips_eabi.c:  dcVecReset(&self->mVecHead);
dyncall/dyncall/dyncall_callvm_mips_eabi.c:  self->mIntRegs = 0;
dyncall/dyncall/dyncall_callvm_mips_eabi.c:  self->mSingleRegs = 0;
dyncall/dyncall/dyncall_callvm_mips_eabi.c:/* arg int -- fillup integer register file OR push on stack */
dyncall/dyncall/dyncall_callvm_mips_eabi.c:  if (self->mIntRegs < 8)
dyncall/dyncall/dyncall_callvm_mips_eabi.c:    self->mRegData.mIntData[self->mIntRegs++] = i;
dyncall/dyncall/dyncall_callvm_mips_eabi.c:    dcVecAppend(&self->mVecHead, &i, sizeof(DCint));
dyncall/dyncall/dyncall_callvm_mips_eabi.c:  if (self->mIntRegs < 7) {
dyncall/dyncall/dyncall_callvm_mips_eabi.c:    self->mIntRegs += self->mIntRegs & 1;
dyncall/dyncall/dyncall_callvm_mips_eabi.c:    self->mRegData.mIntData[self->mIntRegs++] = p[0];
dyncall/dyncall/dyncall_callvm_mips_eabi.c:    self->mRegData.mIntData[self->mIntRegs++] = p[1];
dyncall/dyncall/dyncall_callvm_mips_eabi.c:    self->mIntRegs = 8;
dyncall/dyncall/dyncall_callvm_mips_eabi.c:    dcVecSkip(&self->mVecHead, dcVecSize(&self->mVecHead) & 4);
dyncall/dyncall/dyncall_callvm_mips_eabi.c:    dcVecAppend(&self->mVecHead, &Lv, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_mips_eabi.c:  if (self->mSingleRegs < 8) {
dyncall/dyncall/dyncall_callvm_mips_eabi.c:    self->mRegData.mSingleData[self->mSingleRegs++] = x;
dyncall/dyncall/dyncall_callvm_mips_eabi.c:    dcVecAppend(&self->mVecHead, &x, sizeof(DCfloat) );
dyncall/dyncall/dyncall_callvm_mips_eabi.c:  dcCall_mips_eabi(target, &self->mRegData, dcVecSize(&self->mVecHead), dcVecData(&self->mVecHead));
dyncall/dyncall/dyncall_callvm_mips_eabi.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE; 
dyncall/dyncall/dyncall_callvm_mips_eabi.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_mips_eabi.c:  dcVecInit(&p->mVecHead, size);
dyncall/dyncall/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./dyncall
dyncall/dyncall/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/dyncall/dyncall_callvm.c: Description: auto-select default callvm (includes other C sources).
dyncall/dyncall/dyncall_callvm.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_macros.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncall/dyncall_macros.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_macros.h:/* __MACOSX__ is not defined in gcc assembler mode (switch: -S) */
dyncall/dyncall/dyncall_macros.h:/* The most popular open source Unix-like OS - Linux. */
dyncall/dyncall/dyncall_macros.h:/* The most powerful open source Unix-like OS - FreeBSD. */
dyncall/dyncall/dyncall_macros.h:/* The most secure open source Unix-like OS - OpenBSD. */
dyncall/dyncall/dyncall_macros.h:/* The most portable open source Unix-like OS - NetBSD. */
dyncall/dyncall/dyncall_macros.h:/* The FreeBSD fork having heavy clusterization in mind - DragonFlyBSD. */
dyncall/dyncall/dyncall_macros.h:/* Sun's Unix-like OS - SunOS / Solaris. */
dyncall/dyncall/dyncall_macros.h:/* The "Linux-like environment for Windows" - Cygwin. */
dyncall/dyncall/dyncall_macros.h:/* The "Minimalist GNU for Windows" - MinGW. */
dyncall/dyncall/dyncall_macros.h:/* The Unix successor - Plan9 from Bell Labs */
dyncall/dyncall/dyncall_macros.h:/* Digital's Unix-like OS - VMS */
dyncall/dyncall/dyncall_macros.h:/* The GNU Compiler Collection - GCC. */
dyncall/dyncall/dyncall_macros.h:/* Misc machine-dependent modes, ABIs, etc.. */
dyncall/dyncall/dyncall_macros.h:#else                                                      /* all others are bi-endian */
dyncall/dyncall/dyncall_macros.h:/* @@@check flags used on following bi-endianness archs:
dyncall/dyncall/dyncall_macros.h:# elif defined(DC__Arch_Sparc64) && !defined(__BYTE_ORDER__) /* Sparc64 default is big-endian, except if explicitly defined */
dyncall/dyncall/dyncall_call_x64_generic_masm.asm:; auto-generated by gen-masm.sh
dyncall/dyncall/dyncall_call_x64_generic_masm.asm: and RDI,-32
dyncall/dyncall/dyncall_call_x64_generic_masm.asm: and RCX,-16
dyncall/dyncall/dyncall.3:.\" Copyright (c) 2007-2020 Daniel Adler <dadler AT uni-goettingen DOT de>, 
dyncall/dyncall/dyncall.3:.\"                         Tassilo Philipp <tphilipp AT potion-studios DOT com>
dyncall/dyncall/dyncall.3:.Nd encapsulation of architecture-, OS- and compiler-specific function call
dyncall/dyncall/dyncall.3:library encapsulates architecture-, OS- and compiler-specific function call
dyncall/dyncall/dyncall.3:change the calling convention used by the CallVM at run-time. Due to the fact
dyncall/dyncall/dyncall.3:library project intends to be a portable and open-source approach to the variety of
dyncall/dyncall/dyncall.3:compiler-specific binary interfaces, platform specific subtleties, and so on...
dyncall/dyncall/dyncall.3:can be used to bind arguments in a printf-style call, using a signature
dyncall/dyncall/dyncall.3:.Bd -literal -offset indent
dyncall/dyncall/dyncall.3:.Bd -literal -offset indent
dyncall/dyncall/dyncall.3:.An "Daniel Adler" Aq dadler@uni-goettingen.de
dyncall/dyncall/dyncall.3:.An "Tassilo Philipp" Aq tphilipp@potion-studios.com
dyncall/dyncall/dyncall_call_x64.S:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncall/dyncall_call_x64.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_x64.S:#include "../portasm/portasm-x64.S"
dyncall/dyncall/dyncall_call_x64.S:/*---------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_x64.S:    RSP+8: is always 16-byte aligned (32-byte align if __m256 is used)
dyncall/dyncall/dyncall_call_x64.S:	PUSH(RBP)			/* Pseudo-prolog - preserve RBP. */
dyncall/dyncall/dyncall_call_x64.S:	MOVSD(QWORD(RCX,0) ,XMM0)	/* Copy first 8 floats to XMM0-XMM7. */
dyncall/dyncall/dyncall_call_x64.S:	ADD(LIT(31),RDI)		/* Align stack to 32-byte. */
dyncall/dyncall/dyncall_call_x64.S:	AND(LIT(-32),RDI)
dyncall/dyncall/dyncall_call_x64.S:	ADD(LIT(8),RDI)			/* Adjust by 8-byte for the return-address. */
dyncall/dyncall/dyncall_call_x64.S:	POP(RBP)			/* Pseudo-epilog. */
dyncall/dyncall/dyncall_call_x64.S:/*---------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_x64.S:	PUSH(RBP)			/* Pseudo-prolog - preserve RBP. */
dyncall/dyncall/dyncall_call_x64.S:	AND(LIT(-16),RCX)
dyncall/dyncall/dyncall_call_x64.S:	MOV(QWORD(R8,0),RCX)		/* Copy first four arguments to RCX, RDX, R9, R8 ( and XMM0-XMM3. ) */
dyncall/dyncall/dyncall_call_x64.S:	POP(RBP)			/* Pseudo-epilog. */
dyncall/dyncall/dyncall_call_x64.S:/*---------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_arm32_arm.S: Description: Call Kernel for ARM 32-bit ARM Architecture
dyncall/dyncall/dyncall_call_arm32_arm.S:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_call_arm32_arm.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_arm32_arm.S:#include "../portasm/portasm-arm.S"
dyncall/dyncall/dyncall_call_arm32_arm.S:   DynCall Call Kernel for ARM 32-bit ARM Architecture
dyncall/dyncall/dyncall_call_arm32_arm.S:   ----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_arm32_arm.S:	mov	r12, r13	/* Stack ptr (r13) -> temporary (r12). */
dyncall/dyncall/dyncall_call_arm32_arm.S:	stmdb	r13!, {r4-r12, r14}	/* Permanent registers and stack pointer (now in r12), etc... -> save area on stack (except counter). */
dyncall/dyncall/dyncall_call_arm32_arm.S:	ldmia	r5!, {r0-r3}	/* Load first 4 arguments for new call into r0-r3. */
dyncall/dyncall/dyncall_call_arm32_arm.S:	mov	r14, r15	/*   Branch return address(r15) -> link register (r14) -- r15 always points to address of current + 2 instructions (= Epilog code). */ 
dyncall/dyncall/dyncall_call_arm32_arm.S:	ldmdb	r11, {r4-r11, r13, r15}	/* Restore permanent registers (ignore temporary (r12), restore stack ptr and program counter).@@@db not needed since we rewrite r13? */
dyncall/dyncall/dyncall_callvm_mips_o32.h:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_mips_o32.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_mips_o32.h:/* Call-kernel register data:
dyncall/dyncall/dyncall_callvm_mips_o32.h:  The call-kernel on hardfloat platforms implements loads two doubles, which
dyncall/dyncall/dyncall_callvm_mips_o32.h:  involves four 32-bit floating pointer registers. It's unused for softfloat
dyncall/dyncall/dyncall_callvm_sparc.h:   Copyright (c) 2011-2020 Daniel Adler <dadler@uni-goettingen.de>
dyncall/dyncall/dyncall_callvm_mips.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_mips.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_arm32_thumb_apple.s:   Copyright (c) 2007-2011 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_call_arm32_thumb_apple.s:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_arm32_thumb_apple.s:	push	{r4-r7, r14}	   	/* Frame ptr, permanent registers, link register -> save area on stack. */
dyncall/dyncall/dyncall_call_arm32_thumb_apple.s:	/* mov		r0, #1	*/	/* Assure that LSB is set to 1 (THUMB call). - Not Required and not useful for interworking calls */
dyncall/dyncall/dyncall_call_arm32_thumb_apple.s:	ldmia	r5!, {r0-r3}		/* Load first 4 arguments for new call into r0-r3. */
dyncall/dyncall/dyncall_call_arm32_thumb_apple.s:	blx		r4		/* Branch and force THUMB-mode return (LR bit 0 set). */
dyncall/dyncall/dyncall_call_arm32_thumb_apple.s:	pop		{r4-r7, r15}	/* Restore permanent registers and program counter. (Force a stay in THUMB in ARMv4, whether ARMv5 can return in ARM or THUMB depending on the bit 0. */
dyncall/dyncall/dyncall_callvm_x86.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_x86.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_utils.h: Description: Type and calling-convention signature character defines
dyncall/dyncall/dyncall_utils.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_utils.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/README-Developer.txt:Build with GCC Tool-Chain:
dyncall/dyncall/README-Developer.txt:  One assembly front-end *.S source file for all supported architectures:
dyncall/dyncall/README-Developer.txt:    gcc -c dyncall_call.S -o dyncall_call.o
dyncall/dyncall/README-Developer.txt:  - works fine with universal binary builds (fat binaries), e.g.:
dyncall/dyncall/README-Developer.txt:    gcc -arch i386 -arch ppc -arch x86_64 -c dyncall_call.S -o dyncall_call.o
dyncall/dyncall/README-Developer.txt:  gas	  - standard GNU assembler
dyncall/dyncall/README-Developer.txt:  apple - apple's assembler (based on GNU but is significantly different in syntax)
dyncall/dyncall/README-Developer.txt:  masm  - Microsoft assembler x86 and x64
dyncall/dyncall/README-Developer.txt:  nasm  - Netwide assembler for x86 and x64
dyncall/dyncall/README-Developer.txt:  - one way to build the kernel: 
dyncall/dyncall/README-Developer.txt:     gcc -c dyncall_call.S -o dyncall_call.o
dyncall/dyncall/README-Developer.txt:  - we can build now universal binaries
dyncall/dyncall/dyncall_call_arm64.S: Description: Call Kernel for ARM 64-bit Architecture (aka ARM64, AArch64)
dyncall/dyncall/dyncall_call_arm64.S:   Copyright (c) 2015-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_call_arm64.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_arm64.S:#include "../portasm/portasm-arm64.S"
dyncall/dyncall/dyncall_call_arm64.S:   DynCall Call Kernel for ARM 64-bit ARM Architecture 
dyncall/dyncall/dyncall_call_arm64.S:   ----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_arm64.S:   This Call Kernel was tested on Debian/qemu-debootstrap arm64 jessie and on win64.
dyncall/dyncall/dyncall_call_arm64.S:// DynCall Back-End arm64 
dyncall/dyncall/dyncall_call_arm64.S:// - 'ARM 64-bit AArch64 PCS' (@dadler: work in progress)
dyncall/dyncall/dyncall_call_arm64.S:// - http://lxr.free-electrons.com/source/arch/arm64/kernel/stacktrace.c
dyncall/dyncall/dyncall_call_arm64.S://   x2: size     (number of 'pair' 16-byte units)
dyncall/dyncall/dyncall_call_arm64.S:	stp  x29, x30, [sp, #-16]!	// allocate frame
dyncall/dyncall/dyncall_call_arm64.S:// load 64-bit floating-point registers
dyncall/dyncall/dyncall_call_arm64.S:	sub  sp, sp, x2		// create call-frame
dyncall/dyncall/dyncall_call_arm64.S:// load 64-bit integer registers ( 8 x 64-bit )
dyncall/dyncall/dyncall_call_arm32_thumb_gas.s:   Copyright (c) 2007-2011 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_call_arm32_thumb_gas.s:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_arm32_thumb_gas.s:	push	{%r4-%r7, %r14}		/* Frame ptr, permanent registers, link register -> save area on stack. */
dyncall/dyncall/dyncall_call_arm32_thumb_gas.s:	ldmia	%r5!, {%r0-%r3}		/* Load first 4 arguments for new call into r0-r3. */
dyncall/dyncall/dyncall_call_arm32_thumb_gas.s:	bx		%r4		/* Branch and force THUMB-mode return (LR bit 0 set). */
dyncall/dyncall/dyncall_call_arm32_thumb_gas.s:	pop		{%r4-%r7, %r15}	/* Restore permanent registers and program counter. (Force a stay in THUMB in ARMv4, whether ARMv5 can return in ARM or THUMB depending on the bit 0. */
dyncall/dyncall/dyncall_call_arm32_arm_armhf.S: Description: Call Kernel for ARM 32-bit ARM Architecture - Hard Float
dyncall/dyncall/dyncall_call_arm32_arm_armhf.S:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncall/dyncall_call_arm32_arm_armhf.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_arm32_arm_armhf.S:#include "../portasm/portasm-arm.S"
dyncall/dyncall/dyncall_call_arm32_arm_armhf.S:   DynCall Call Kernel for ARM 32-bit ARM Architecture Hard-Float
dyncall/dyncall/dyncall_call_arm32_arm_armhf.S:   ----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_arm32_arm_armhf.S:	mov r12 , r13  /* Stack ptr (r13) -> temporary (r12). */
dyncall/dyncall/dyncall_call_arm32_arm_armhf.S:	stmdb r13!, {r4-r5, r11, r12, r14} /* Permanent registers and stack pointer (now in r12), etc... -> save area on stack (except counter). */
dyncall/dyncall/dyncall_call_arm32_arm_armhf.S:	/* Load 16 single-precision registers (= 8 double-precision registers). */
dyncall/dyncall/dyncall_call_arm32_arm_armhf.S:	fldmiad r3, {d0-d7}
dyncall/dyncall/dyncall_call_arm32_arm_armhf.S:	and r13, r13, #-8  /* align 8-byte. */
dyncall/dyncall/dyncall_call_arm32_arm_armhf.S:	ldmia r1, {r0-r3}  /* Load first 4 arguments for new call into r0-r3. */
dyncall/dyncall/dyncall_call_arm32_arm_armhf.S:	mov r14, r15       /* Branch return address(r15) -> link register (r14) -- r15 always points to address of current + 2 instructions (= Epilog code). */ 
dyncall/dyncall/dyncall_call_arm32_arm_armhf.S:	ldmdb r11, {r4-r5, r11, r13, r15} /* Restore permanent registers (ignore temporary (r12), restore stack ptr and program counter).@@@db not needed since we rewrite r13? */
dyncall/dyncall/Makefile.generic:	rm -f ${OBJS} ${LIB}
dyncall/dyncall/Makefile.generic:	mkdir -p ${PREFIX}/lib 
dyncall/dyncall/Makefile.generic:	mkdir -p ${PREFIX}/include
dyncall/dyncall/dyncall_callvm_mips.c: Description: ARM 32-bit "thumb" ABI callvm implementation
dyncall/dyncall/dyncall_callvm_mips.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_mips.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_sparc.c:   Copyright (c) 2011-2020 Daniel Adler <dadler@uni-goettingen.de>
dyncall/dyncall/dyncall_callvm_sparc.c:  dcVecReset(&self->mVecHead);
dyncall/dyncall/dyncall_callvm_sparc.c:/* Load integer 32-bit. */
dyncall/dyncall/dyncall_callvm_sparc.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCint));
dyncall/dyncall/dyncall_callvm_sparc.c:/* handle others Pointer, Long, LongLong, Float and Double as-is. */
dyncall/dyncall/dyncall_callvm_sparc.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCpointer));
dyncall/dyncall/dyncall_callvm_sparc.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DClong));
dyncall/dyncall/dyncall_callvm_sparc.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_sparc.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCfloat));
dyncall/dyncall/dyncall_callvm_sparc.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_sparc.c:  dcCall_sparc(target, dcVecSize(&self->mVecHead), dcVecData(&self->mVecHead));
dyncall/dyncall/dyncall_callvm_sparc.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE; 
dyncall/dyncall/dyncall_callvm_sparc.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_sparc.c:  /* the six output registers %o0-%o5 are always loaded, thus we need to ensure the argument buffer has space for at least 24 bytes. */
dyncall/dyncall/dyncall_callvm_sparc.c:  dcVecInit(&p->mVecHead, size);
dyncall/dyncall/README.txt:5. extension: high-level formatted C API (ellipsis style)
dyncall/dyncall/README.txt:  gcc front-end: dyncall_call.S
dyncall/dyncall/README.txt:2.2 Static-sized Vector
dyncall/dyncall/README.txt:  Top-level: dynall_callvm.c
dyncall/dyncall/README.txt:  Sub-levels: 
dyncall/dyncall/README.txt:  Top-level: dyncall.h
dyncall/dyncall/README.txt:  Sub-level headers: 
dyncall/dyncall/README.txt:5. Extension: High-level C API (ellipsis style)
dyncall/dyncall/README.txt:  Top-level: dyncall_callf.h
dyncall/dyncall/README.txt:  Sub-level headers:
dyncall/dyncall/gen-masm.sh:../portasm/gen-masm.sh dyncall_call_x86 _generic_masm
dyncall/dyncall/gen-masm.sh:../portasm/gen-masm.sh dyncall_call_x64 _generic_masm
dyncall/dyncall/mkfile:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/mkfile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_config.h: Description: Macro configuration file for non-standard C types
dyncall/dyncall/dyncall_config.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_config.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_alloc.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_alloc.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:** - hybrid return-type call (bool ... pointer)
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:** Note the return type of this declaration is intentially of double-word size (despite
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:** (dyncall_callvm_arm32_arm_armhf.c's call()) that reuses- thus overwrites - r0 and r1.
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:  p->i = 0;
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:  p->s = 0;
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:  p->d = 0;
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:  dcVecResize(&p->mVecHead, 16);
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:  if (p->i < 16) {
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    * (DCint*) dcVecAt(&p->mVecHead, p->i) = x;
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    p->i += 4;
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    dcVecAppend(&p->mVecHead, &x, sizeof(DCint));
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:  p->i = (p->i+4) & -8;
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:  if (p->i < 16) {
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    * (DClonglong*) dcVecAt(&p->mVecHead, p->i) = x;
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    p->i += 8;
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    dcVecSkip(&p->mVecHead, dcVecSize(&p->mVecHead) & 4);
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    dcVecAppend(&p->mVecHead, &x, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:  if (p->s < 16) {
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    p->S[p->s++] = x;
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    if (p->d < p->s) {
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:      p->d = (p->s+1) & ~(1U);
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:      p->s = p->d;
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    dcVecAppend(&p->mVecHead, &x, sizeof(DCfloat));
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:  if (p->d < 16) {
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    * (DCdouble*) &p->S[p->d] = x;
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    p->d += 2;
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    if (!(p->s & 1)) {
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:      p->s = p->d;
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    p->s = 16; /* fp registers all full - need to use stack now: stop filling gaps for single precision, also */
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    dcVecSkip(&p->mVecHead, dcVecSize(&p->mVecHead) & 4);
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:    dcVecAppend(&p->mVecHead, &v.b[0], sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:  dcCall_arm32_armhf(target, dcVecData(&p->mVecHead), dcVecSize(&p->mVecHead), &p->S[0]);
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE; 
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.c:  dcVecInit(&p->mVecHead, size);
dyncall/dyncall/dyncall_callvm_arm32_thumb.c: Description: ARM 32-bit "thumb" ABI callvm implementation
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:** - hybrid return-type call (bool ... pointer)
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:** Note the return type of this declaration is intentially of double-word size (despite
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:  dcVecReset(&self->mVecHead);
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCint));
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:  dcVecSkip(&self->mVecHead, dcVecSize(&self->mVecHead) & 4);
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCfloat));
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:  dcVecSkip(&self->mVecHead, dcVecSize(&self->mVecHead) & 4);
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCpointer));
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:  dcCall_arm32_thumb(target, dcVecData(&self->mVecHead), dcVecSize(&self->mVecHead));
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE; 
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_arm32_thumb.c:  dcVecInit(&p->mVecHead, size);
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S: Description: Call Kernel for ARM 32-bit ARM Architecture - Hard Float in Thumb code
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:#include "../portasm/portasm-arm.S"
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:   DynCall Call Kernel for ARM 32-bit ARM Architecture Hard-Float
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:   ----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:	// mov	r12 , r13	 /* Stack ptr (r13) -> temporary (r12). */
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:	// stmdb	r13!, {r4-r5, r11, r12, r14} /* Permanent registers and stack pointer (now in r12), etc... -> save area on stack (except counter). */
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:	push	{r4-r7, r14}
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:	/* Load 16 single-precision registers (= 8 double-precision registers). */
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:	fldmiad	r3, {d0-d7}
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:	// and	r13, #-8	/* align 8-byte. */
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:	ldmia	r5!, {r0-r3}	/* Load first 4 arguments for new call into r0-r3. */
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:	// mov	r14, r15	/*   Branch return address(r15) -> link register (r14) -- r15 always points to address of current + 2 instructions (= Epilog code). */ 
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:	// ldmdb	r11, {r4-r5, r11, r13, r15}	/* Restore permanent registers (ignore temporary (r12), restore stack ptr and program counter).@@@db not needed since we rewrite r13? */
dyncall/dyncall/dyncall_call_arm32_thumb_armhf.S:	pop	{r4-r7, r15}
dyncall/dyncall/dyncall_struct.h:   Copyright (c) 2010-2015 Olivier Chafik <olivier.chafik@centraliens.net>
dyncall/dyncall/dyncall_struct.h:	DCint nextField;                        /* == -1 if struct is closed */
dyncall/dyncall/dyncall_callvm_mips_o32.c:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_mips_o32.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_mips_o32.c:  first two (if any) double/float arguments are mapped via a common structure --
dyncall/dyncall/dyncall_callvm_mips_o32.c:  differs on C and Assembly-side depending on endianness. (therefore
dyncall/dyncall/dyncall_callvm_mips_o32.c:  dcVecReset(&self->mVecHead);
dyncall/dyncall/dyncall_callvm_mips_o32.c:  self->mArgCount = 0;
dyncall/dyncall/dyncall_callvm_mips_o32.c:/* arg int -- fillup integer register file OR push on stack */
dyncall/dyncall/dyncall_callvm_mips_o32.c:  dcVecAppend(&self->mVecHead, &i, sizeof(DCint));
dyncall/dyncall/dyncall_callvm_mips_o32.c:  self->mArgCount++;
dyncall/dyncall/dyncall_callvm_mips_o32.c:  /* 64-bit values need to be aligned on 8 byte boundaries */
dyncall/dyncall/dyncall_callvm_mips_o32.c:  dcVecSkip(&self->mVecHead, dcVecSize(&self->mVecHead) & 4);
dyncall/dyncall/dyncall_callvm_mips_o32.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_mips_o32.c:  self->mArgCount++;
dyncall/dyncall/dyncall_callvm_mips_o32.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCfloat));
dyncall/dyncall/dyncall_callvm_mips_o32.c:  if (self->mArgCount < 2) {
dyncall/dyncall/dyncall_callvm_mips_o32.c:    /* @@@ unsure if we should zero init, here; seems to work as-is */
dyncall/dyncall/dyncall_callvm_mips_o32.c:    self->mRegData.u[self->mArgCount].f[0] = x;
dyncall/dyncall/dyncall_callvm_mips_o32.c:    self->mRegData.u[self->mArgCount].f[1] = x; // floats in regs always right justified
dyncall/dyncall/dyncall_callvm_mips_o32.c:    self->mRegData.u[self->mArgCount].f[1] = x;
dyncall/dyncall/dyncall_callvm_mips_o32.c:	lwc1  $f12,  4($5)    <--- byte offset 4
dyncall/dyncall/dyncall_callvm_mips_o32.c:	lwc1  $f14, 12($5)    <--- byte offset 12 
dyncall/dyncall/dyncall_callvm_mips_o32.c:	lwc1  $f12,  0($5)    <--- byte offset 4
dyncall/dyncall/dyncall_callvm_mips_o32.c:	lwc1  $f14,  8($5)    <--- byte offset 12 
dyncall/dyncall/dyncall_callvm_mips_o32.c:    self->mRegData.floats[self->mArgCount*2] = x;
dyncall/dyncall/dyncall_callvm_mips_o32.c:    self->mRegData.floats[self->mArgCount*2+1] = x;
dyncall/dyncall/dyncall_callvm_mips_o32.c:  self->mArgCount++;
dyncall/dyncall/dyncall_callvm_mips_o32.c:  /* 64-bit values need to be aligned on 8 byte boundaries */
dyncall/dyncall/dyncall_callvm_mips_o32.c:  dcVecSkip(&self->mVecHead, dcVecSize(&self->mVecHead) & 4);
dyncall/dyncall/dyncall_callvm_mips_o32.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_mips_o32.c:  if (self->mArgCount < 2)
dyncall/dyncall/dyncall_callvm_mips_o32.c:    self->mRegData.u[self->mArgCount].d = x;
dyncall/dyncall/dyncall_callvm_mips_o32.c:  self->mArgCount++;
dyncall/dyncall/dyncall_callvm_mips_o32.c:     minimum of 16-bytes (to hold first 4 int regis as spill area ($4-$7)) */
dyncall/dyncall/dyncall_callvm_mips_o32.c:  size_t size = DC_MAX(16, ( ( (unsigned) dcVecSize(&self->mVecHead) ) +7UL ) & (-8UL) );
dyncall/dyncall/dyncall_callvm_mips_o32.c:  dcCall_mips_o32(target, &self->mRegData, size, dcVecData(&self->mVecHead));
dyncall/dyncall/dyncall_callvm_mips_o32.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE; 
dyncall/dyncall/dyncall_callvm_mips_o32.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_mips_o32.c:  dcVecInit(&p->mVecHead, size);
dyncall/dyncall/dyncall_call_mips_o32.S:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_call_mips_o32.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_mips_o32.S:	.mask   0xc0000000,-4
dyncall/dyncall/dyncall_call_mips_o32.S:	addiu   $sp, $sp, -8
dyncall/dyncall/dyncall_call_mips_o32.S:	addiu   $6,  $6, -4
dyncall/dyncall/dyncall_call_mips_o32.S:	/* load two double-precision floating-point argument registers ($f12, $f14) - not for softfloat */
dyncall/dyncall/dyncall_call_mips_o32.S:	/* load first four integer arguments ($4-$7) */
dyncall/dyncall/dyncall_signature.h: Description: Type and calling-convention signature character defines
dyncall/dyncall/dyncall_signature.h:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_signature.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_sparc64.s:   Copyright (c) 2011-2015 Daniel Adler <dadler@uni-goettingen.de>
dyncall/dyncall/dyncall_call_sparc64.s:	and     %o3, -16, %o3
dyncall/dyncall/dyncall_call_sparc64.s:	neg     %o3            /* o3: -stacksize */
dyncall/dyncall/dyncall_call_sparc64.s:	ldd     [%i2+8*0 ], %f0  /* Load double-precision float registers. */
dyncall/dyncall/dyncall_call_sparc64.s:	or      %o0, %g0, %i0   /* pass out retval (mov o0 -> i0) */
dyncall/dyncall/dyncall_call_sparc64.s:- fundamental data types
dyncall/dyncall/dyncall_call_sparc64.s:	- (un)signed int: 8,16,32,64
dyncall/dyncall/dyncall_call_sparc64.s:	- float: 32,64,128
dyncall/dyncall/dyncall_call_sparc64.s:- float: IEEE 754 compilant
dyncall/dyncall/dyncall_call_sparc64.s:	32 32-bit  float registers f0,f1,..,f31
dyncall/dyncall/dyncall_call_sparc64.s:	32 64-bit  float registers f0,f2,..,f62
dyncall/dyncall/dyncall_call_sparc64.s:	16 128-bit float registers f0,f4,..,f60
dyncall/dyncall/dyncall_call_sparc64.s:Then we raise the frame, ending up in o0-o3 is then i0-i3.
dyncall/dyncall/dyncall_call_sparc64.s:- integer %o0..%o5 (caller view).
dyncall/dyncall/dyncall_call_sparc64.s:- floating-point %f0 .. %f31
dyncall/dyncall/dyncall_call_sparc64.s:- continuous memory starting at %sp+BIAS+136 (caller view).
dyncall/dyncall/dyncall_call_sparc64.s:%fp0..%fp31  : floating-point arguments.
dyncall/dyncall/dyncall_call_sparc64.s:%sp  or  %o6 : stack pointer, always 8 (or 16?)-byte aligned.
dyncall/dyncall/dyncall_call_sparc64.s:r0-7    -> globals
dyncall/dyncall/dyncall_call_sparc64.s:r8-15   -> outs
dyncall/dyncall/dyncall_call_sparc64.s:r16-r23 -> locals
dyncall/dyncall/dyncall_call_sparc64.s:r24-r31 -> ins
dyncall/dyncall/dyncall_call_sparc64.s:------------------------------------------------------------------------------
dyncall/dyncall/dyncall_callvm_mips_eabi.h:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_mips_eabi.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_mips_eabi.h:/* Call-kernel register data: 
dyncall/dyncall/dyncall_callvm_mips_eabi.h:   call-kernel loaded into the registers.
dyncall/dyncall/dyncall_call_arm64_masm.asm:; auto-generated by gen-masm.sh
dyncall/dyncall/dyncall_call_arm64_masm.asm: stp x29, x30, [sp, #-16]!
dyncall/dyncall/dyncall_struct.c:   Copyright (c) 2010-2015 Olivier Chafik <olivier.chafik@centraliens.net>
dyncall/dyncall/dyncall_struct.c:	s->pCurrentStruct = s;
dyncall/dyncall/dyncall_struct.c:	s->pLastStruct = NULL;
dyncall/dyncall/dyncall_struct.c:	s->nextField = 0;
dyncall/dyncall/dyncall_struct.c:	s->fieldCount = fieldCount;
dyncall/dyncall/dyncall_struct.c:	s->alignment = alignment;
dyncall/dyncall/dyncall_struct.c:	s->size = 0;
dyncall/dyncall/dyncall_struct.c:	s->pFields = (DCfield*)dcAllocMem(fieldCount * sizeof(DCfield));
dyncall/dyncall/dyncall_struct.c:	assert(s && s->pCurrentStruct);
dyncall/dyncall/dyncall_struct.c:	assert(s->pCurrentStruct->nextField < (DCint)s->pCurrentStruct->fieldCount);
dyncall/dyncall/dyncall_struct.c:	f = s->pCurrentStruct->pFields + (s->pCurrentStruct->nextField++);
dyncall/dyncall/dyncall_struct.c:	f->type = type;
dyncall/dyncall/dyncall_struct.c:	f->alignment = alignment;
dyncall/dyncall/dyncall_struct.c:	f->arrayLength = arrayLength;
dyncall/dyncall/dyncall_struct.c:	f->pSubStruct = NULL;
dyncall/dyncall/dyncall_struct.c:    	case DC_SIGCHAR_BOOL:       f->size = sizeof(DCbool);     break;
dyncall/dyncall/dyncall_struct.c:    	case DC_SIGCHAR_UCHAR:      f->size = sizeof(DCchar);     break;
dyncall/dyncall/dyncall_struct.c:    	case DC_SIGCHAR_USHORT:     f->size = sizeof(DCshort);    break;
dyncall/dyncall/dyncall_struct.c:    	case DC_SIGCHAR_UINT:       f->size = sizeof(DCint);      break;
dyncall/dyncall/dyncall_struct.c:    	case DC_SIGCHAR_ULONG:      f->size = sizeof(DClong);     break;
dyncall/dyncall/dyncall_struct.c:    	case DC_SIGCHAR_ULONGLONG:  f->size = sizeof(DClonglong); break;
dyncall/dyncall/dyncall_struct.c:    	case DC_SIGCHAR_FLOAT:      f->size = sizeof(DCfloat);    break;
dyncall/dyncall/dyncall_struct.c:    	case DC_SIGCHAR_DOUBLE:     f->size = sizeof(DCdouble);   break;
dyncall/dyncall/dyncall_struct.c:		case DC_SIGCHAR_STRING:     f->size = sizeof(DCpointer);  break;
dyncall/dyncall/dyncall_struct.c:	DCfield *f = s->pCurrentStruct->pFields + (s->pCurrentStruct->nextField++);
dyncall/dyncall/dyncall_struct.c:	f->type = DC_SIGCHAR_STRUCT;
dyncall/dyncall/dyncall_struct.c:	f->arrayLength = arrayLength;
dyncall/dyncall/dyncall_struct.c:	f->alignment = alignment;
dyncall/dyncall/dyncall_struct.c:	f->pSubStruct = dcNewStruct(fieldCount, alignment);
dyncall/dyncall/dyncall_struct.c:	f->pSubStruct->pLastStruct = s->pCurrentStruct;
dyncall/dyncall/dyncall_struct.c:	s->pCurrentStruct = f->pSubStruct;
dyncall/dyncall/dyncall_struct.c:		DCsize rest = alignment - mod;
dyncall/dyncall/dyncall_struct.c:	for (i = 0; i < s->fieldCount; i++) {
dyncall/dyncall/dyncall_struct.c:		DCfield *f = s->pFields + i;
dyncall/dyncall/dyncall_struct.c:		if (f->type == DC_SIGCHAR_STRUCT) {
dyncall/dyncall/dyncall_struct.c:			dcComputeStructSize(f->pSubStruct);
dyncall/dyncall/dyncall_struct.c:			f->size = f->pSubStruct->size;
dyncall/dyncall/dyncall_struct.c:			fieldAlignment = f->pSubStruct->alignment;
dyncall/dyncall/dyncall_struct.c:			fieldAlignment = f->size;
dyncall/dyncall/dyncall_struct.c:		if (!f->alignment)
dyncall/dyncall/dyncall_struct.c:			f->alignment = fieldAlignment;
dyncall/dyncall/dyncall_struct.c:		if (f->alignment > s->alignment)
dyncall/dyncall/dyncall_struct.c:			s->alignment = f->alignment;
dyncall/dyncall/dyncall_struct.c:		f->size *= f->arrayLength;
dyncall/dyncall/dyncall_struct.c:		/*printf("FIELD %d, size = %d, alignment = %d\n", (int)i, (int)f->size, (int)f->alignment);@@@*/
dyncall/dyncall/dyncall_struct.c:	for (i = 0; i < s->fieldCount; i++) {
dyncall/dyncall/dyncall_struct.c:		DCfield *f = s->pFields + i;
dyncall/dyncall/dyncall_struct.c:		dcAlign(&s->size, f->alignment);
dyncall/dyncall/dyncall_struct.c:		s->size += f->size;
dyncall/dyncall/dyncall_struct.c:	dcAlign(&s->size, s->alignment);
dyncall/dyncall/dyncall_struct.c:	/*printf("STRUCT size = %d, alignment = %d\n", (int)s->size, (int)s->alignment);@@@*/
dyncall/dyncall/dyncall_struct.c:	assert(s->pCurrentStruct);
dyncall/dyncall/dyncall_struct.c:	assert(s->pCurrentStruct->nextField == s->pCurrentStruct->fieldCount);
dyncall/dyncall/dyncall_struct.c:	if (!s->pCurrentStruct->pLastStruct) {
dyncall/dyncall/dyncall_struct.c:		dcComputeStructSize(s->pCurrentStruct);
dyncall/dyncall/dyncall_struct.c:	s->pCurrentStruct = s->pCurrentStruct->pLastStruct;
dyncall/dyncall/dyncall_struct.c:	for (i = 0; i < s->fieldCount; i++) {
dyncall/dyncall/dyncall_struct.c:		DCfield *f = s->pFields + i;
dyncall/dyncall/dyncall_struct.c:		if (f->type == DC_SIGCHAR_STRUCT)
dyncall/dyncall/dyncall_struct.c:			dcFreeStruct(f->pSubStruct);
dyncall/dyncall/dyncall_struct.c:	free(s->pFields);
dyncall/dyncall/dyncall_struct.c:	assert(!s->pCurrentStruct && "Struct was not closed");
dyncall/dyncall/dyncall_struct.c:	return s->size;
dyncall/dyncall/dyncall_struct.c:	assert(!s->pCurrentStruct && "Struct was not closed");
dyncall/dyncall/dyncall_struct.c:	return s->alignment;
dyncall/dyncall/dyncall_struct.c:	for (i = 0; i < s->fieldCount; i++) {
dyncall/dyncall/dyncall_struct.c:		DCfield *f = s->pFields + i;
dyncall/dyncall/dyncall_struct.c:		DCpointer p = (char*)value + f->offset;
dyncall/dyncall/dyncall_struct.c:		switch(f->type) {
dyncall/dyncall/dyncall_struct.c:		  	dcArgStruct(vm, f->pSubStruct, p);
dyncall/dyncall/dyncall_callvm_arm64.c: Description: ARM 64-bit ABI implementation
dyncall/dyncall/dyncall_callvm_arm64.c:   Copyright (c) 2015-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_arm64.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_arm64.c:  p->i = 0;
dyncall/dyncall/dyncall_callvm_arm64.c:  p->f = 0;
dyncall/dyncall/dyncall_callvm_arm64.c:  dcVecReset(&p->mVecHead);
dyncall/dyncall/dyncall_callvm_arm64.c:  if (p->i < 8) {
dyncall/dyncall/dyncall_callvm_arm64.c:    p->I[p->i] = x;
dyncall/dyncall/dyncall_callvm_arm64.c:    p->i++;
dyncall/dyncall/dyncall_callvm_arm64.c:    dcVecAppend(&p->mVecHead, &x, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_arm64.c:  if (p->f < 8) {
dyncall/dyncall/dyncall_callvm_arm64.c:    p->u.S[ p->f << 1 ] = x;
dyncall/dyncall/dyncall_callvm_arm64.c:    p->f++;
dyncall/dyncall/dyncall_callvm_arm64.c:    dcVecAppend(&p->mVecHead, &x, sizeof(DCfloat));
dyncall/dyncall/dyncall_callvm_arm64.c:    dcVecSkip(&p->mVecHead, 4);  /* align to 8-bytes */
dyncall/dyncall/dyncall_callvm_arm64.c:  if (p->f < 8) {
dyncall/dyncall/dyncall_callvm_arm64.c:    p->u.D[ p->f ] = x;
dyncall/dyncall/dyncall_callvm_arm64.c:    p->f++; 
dyncall/dyncall/dyncall_callvm_arm64.c:    dcVecAppend(&p->mVecHead, &x, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_arm64.c:  ** copy 'size' argument is given in number of 16-byte 'pair' blocks.
dyncall/dyncall/dyncall_callvm_arm64.c:  dcCall_arm64(target, dcVecData(&p->mVecHead), ( dcVecSize(&p->mVecHead) + 15 ) & -16, &p->u.S[0]);
dyncall/dyncall/dyncall_callvm_arm64.c:   the stack are loaded into x0-x7, and any remaining arguments on the stack */
dyncall/dyncall/dyncall_callvm_arm64.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE; 
dyncall/dyncall/dyncall_callvm_arm64.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_arm64.c:  dcVecInit(&p->mVecHead, size);
dyncall/dyncall/dyncall_callvm_sparc64.c:   Copyright (c) 2011-2020 Daniel Adler <dadler@uni-goettingen.de>
dyncall/dyncall/dyncall_callvm_sparc64.c:  dcVecResize(&self->mVecHead, 0);
dyncall/dyncall/dyncall_callvm_sparc64.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_sparc64.c:/* all integers are promoted to 64-bit. */
dyncall/dyncall/dyncall_callvm_sparc64.c:  dcVecAppend(&self->mVecHead, &x, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_sparc64.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE; 
dyncall/dyncall/dyncall_callvm_sparc64.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_sparc64.c:  dcVecInit(&p->mVecHead,size);
dyncall/dyncall/dyncall_callvm_sparc64.c:  dc_callvm_reset_v9(&p->mInterface);
dyncall/dyncall/dyncall_call_mips_n32.S:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_call_mips_n32.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_mips_n32.S:	/* Stack-frame prolog */
dyncall/dyncall/dyncall_call_mips_n32.S:	.mask   0xd0000000,-8
dyncall/dyncall/dyncall_call_mips_n32.S:	   - stack data is 16-byte aligned.
dyncall/dyncall/dyncall_call_mips_n32.S:	   - no extra-storage for arguments passed via registers.
dyncall/dyncall/dyncall_call_mips_n32.S:	daddiu  $6, $6, -8
dyncall/dyncall/dyncall_call_mips_n32.S:	/* load float-or-double floating pointer parameter registers 
dyncall/dyncall/dyncall_call_mips_n32.S:	   a 64-bit bitmask given at byte offset 128 of regdata indicates
dyncall/dyncall/dyncall_call_mips_n32.S:	/* jump-and-link to register $25 */
dyncall/dyncall/dyncall_call_mips_n32.S:	nop /* branch-delay slot - no nop according to gcc assembly */
dyncall/dyncall/dyncall_call_mips_n32.S:	/* Stack-frame epilog */
dyncall/dyncall/dyncall_call_mips_n32.S:	.size   dcCall_mips_n64, .-dcCall_mips_n64
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.h:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_arm32_arm_armhf.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm.h:/* --- callvm virtual function table --------------------------------------- */
dyncall/dyncall/dyncall_call_mips_n64.S:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_call_mips_n64.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_mips_n64.S:	/* Stack-frame prolog */
dyncall/dyncall/dyncall_call_mips_n64.S:	# .mask   0xd0000000,-8
dyncall/dyncall/dyncall_call_mips_n64.S:	   - stack data is 16-byte aligned.
dyncall/dyncall/dyncall_call_mips_n64.S:	   - no extra-storage for arguments passed via registers.
dyncall/dyncall/dyncall_call_mips_n64.S:	daddiu  $6, $6, -8
dyncall/dyncall/dyncall_call_mips_n64.S:	/* load float-or-double floating pointer parameter registers 
dyncall/dyncall/dyncall_call_mips_n64.S:	   a 64-bit bitmask given at byte offset 128 of regdata indicates
dyncall/dyncall/dyncall_call_mips_n64.S:	/* jump-and-link to register $25 */
dyncall/dyncall/dyncall_call_mips_n64.S:	nop /* branch-delay slot - no nop according to gcc assembly */
dyncall/dyncall/dyncall_call_mips_n64.S:	/* Stack-frame epilog */
dyncall/dyncall/dyncall_call_mips_n64.S:	.size   dcCall_mips_n64, .-dcCall_mips_n64
dyncall/dyncall/dyncall.h:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall.h:#define DC_CALL_C_X86_WIN32_THIS_GNU    DC_CALL_C_X86_CDECL /* alias - identical to cdecl (w/ this-ptr as 1st arg) */
dyncall/dyncall/dyncall.h:#define DC_CALL_C_MIPS32_PSPSDK        DC_CALL_C_MIPS32_EABI /* alias - deprecated. */
dyncall/dyncall/dyncall.h:#define DC_ERROR_UNSUPPORTED_MODE   -1
dyncall/dyncall/dyncall_callf.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callf.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_BOOL:       result->B = dcCallBool             (vm,funcptr); break;
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_CHAR:       result->c = dcCallChar             (vm,funcptr); break;
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_UCHAR:      result->C = (DCuchar)dcCallChar    (vm,funcptr); break;
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_SHORT:      result->s = dcCallShort            (vm,funcptr); break;
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_USHORT:     result->S = dcCallShort            (vm,funcptr); break;
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_INT:        result->i = dcCallInt              (vm,funcptr); break;
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_UINT:       result->I = dcCallInt              (vm,funcptr); break;
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_LONG:       result->j = dcCallLong             (vm,funcptr); break;
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_ULONG:      result->J = dcCallLong             (vm,funcptr); break;
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_LONGLONG:   result->l = dcCallLongLong         (vm,funcptr); break;
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_ULONGLONG:  result->L = dcCallLongLong         (vm,funcptr); break;
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_FLOAT:      result->f = dcCallFloat            (vm,funcptr); break;
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_DOUBLE:     result->d = dcCallDouble           (vm,funcptr); break;
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_POINTER:    result->p = dcCallPointer          (vm,funcptr); break;
dyncall/dyncall/dyncall_callf.c:    case DC_SIGCHAR_STRING:     result->Z = (DCstring)dcCallPointer(vm,funcptr); break;
dyncall/dyncall/dyncall_call_sparc.s:   Copyright (c) 2011-2015 Daniel Adler <dadler@uni-goettingen.de>
dyncall/dyncall/dyncall_call_sparc.s:/* --------------------------------------------------------------------------- 
dyncall/dyncall/dyncall_call_sparc.s:call kernel for sparc 32-bit
dyncall/dyncall/dyncall_call_sparc.s:----------------------------
dyncall/dyncall/dyncall_call_sparc.s:tested on linux/debian [gcc54.fsffrance.org - thanx to the farm!] 
dyncall/dyncall/dyncall_call_sparc.s:otherwise, we would have a 'void' return-value layer which results in failure
dyncall/dyncall/dyncall_call_sparc.s:instead of implementing 'dummy'-C return-values, we call directly.
dyncall/dyncall/dyncall_call_sparc.s:in sparc, this is simply a leaf-function layer using %o3.
dyncall/dyncall/dyncall_call_sparc.s:- big endian
dyncall/dyncall/dyncall_call_sparc.s:- integer/pointer: 32 32-bit integers.
dyncall/dyncall/dyncall_call_sparc.s:- float: 8 quad precision, 16 double precision, 32 single precision.
dyncall/dyncall/dyncall_call_sparc.s:- integer/pointer: 32 64-bit integers.
dyncall/dyncall/dyncall_call_sparc.s:- completely different scheme - similar to mips/plan9.
dyncall/dyncall/dyncall_call_sparc.s:- registers are named r0 .. r31
dyncall/dyncall/dyncall_call_sparc.s:Stack Layout 32-Bit Model:
dyncall/dyncall/dyncall_call_sparc.s:- sp+92 seventh argument
dyncall/dyncall/dyncall_call_sparc.s:- sp+68 first argument
dyncall/dyncall/dyncall_call_sparc.s:- sp+64 
dyncall/dyncall/dyncall_call_sparc.s:- 16 registers save area (in/local).
dyncall/dyncall/dyncall_call_sparc.s:Stack Layout 64-Bit Model:
dyncall/dyncall/dyncall_call_sparc.s:%sp or  %o6: stack pointer, always 8 (or 16?)-byte aligned.
dyncall/dyncall/dyncall_call_sparc.s:r0-7    -> globals
dyncall/dyncall/dyncall_call_sparc.s:r8-15   -> outs
dyncall/dyncall/dyncall_call_sparc.s:r16-r23 -> locals
dyncall/dyncall/dyncall_call_sparc.s:r24-r31 -> ins
dyncall/dyncall/dyncall_call_sparc.s:	/* o0-1: callvm,target */
dyncall/dyncall/dyncall_call_sparc.s:	/*o0-2:target,size,data*/
dyncall/dyncall/dyncall_call_sparc.s:	/*o3-5:free to use */
dyncall/dyncall/dyncall_call_sparc.s:	add     %o1, (16+1+6)*REGSIZE+ALIGN-1, %o3
dyncall/dyncall/dyncall_call_sparc.s:	and     %o3,   -ALIGN, %o3
dyncall/dyncall/dyncall_call_sparc.s:	save    %sp, %o3, %sp    /* min stack size (16+1+6)*sizeof(ptr)=92 paddded to 8-byte alignment => min frame size of 96 bytes. */
dyncall/dyncall/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/Nmakefile:	$(AR) -rc $(ARFLAGS) "$@" $(OBJS)
dyncall/dyncall/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/dyncall/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object dyncall/CMakeFiles/dyncall_s.dir/dyncall_call.S.o"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT dyncall/CMakeFiles/dyncall_s.dir/dyncall_call.S.o -MF CMakeFiles/dyncall_s.dir/dyncall_call.S.o.d -o CMakeFiles/dyncall_s.dir/dyncall_call.S.o -c /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_call.S
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dyncall_s.dir/dyncall_call.S.i"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_call.S > CMakeFiles/dyncall_s.dir/dyncall_call.S.i
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dyncall_s.dir/dyncall_call.S.s"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_call.S -o CMakeFiles/dyncall_s.dir/dyncall_call.S.s
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Building C object dyncall/CMakeFiles/dyncall_s.dir/dyncall_vector.c.o"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT dyncall/CMakeFiles/dyncall_s.dir/dyncall_vector.c.o -MF CMakeFiles/dyncall_s.dir/dyncall_vector.c.o.d -o CMakeFiles/dyncall_s.dir/dyncall_vector.c.o -c /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_vector.c
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dyncall_s.dir/dyncall_vector.c.i"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_vector.c > CMakeFiles/dyncall_s.dir/dyncall_vector.c.i
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dyncall_s.dir/dyncall_vector.c.s"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_vector.c -o CMakeFiles/dyncall_s.dir/dyncall_vector.c.s
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Building C object dyncall/CMakeFiles/dyncall_s.dir/dyncall_struct.c.o"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT dyncall/CMakeFiles/dyncall_s.dir/dyncall_struct.c.o -MF CMakeFiles/dyncall_s.dir/dyncall_struct.c.o.d -o CMakeFiles/dyncall_s.dir/dyncall_struct.c.o -c /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_struct.c
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dyncall_s.dir/dyncall_struct.c.i"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_struct.c > CMakeFiles/dyncall_s.dir/dyncall_struct.c.i
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dyncall_s.dir/dyncall_struct.c.s"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_struct.c -o CMakeFiles/dyncall_s.dir/dyncall_struct.c.s
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_4) "Building C object dyncall/CMakeFiles/dyncall_s.dir/dyncall_api.c.o"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT dyncall/CMakeFiles/dyncall_s.dir/dyncall_api.c.o -MF CMakeFiles/dyncall_s.dir/dyncall_api.c.o.d -o CMakeFiles/dyncall_s.dir/dyncall_api.c.o -c /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_api.c
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dyncall_s.dir/dyncall_api.c.i"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_api.c > CMakeFiles/dyncall_s.dir/dyncall_api.c.i
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dyncall_s.dir/dyncall_api.c.s"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_api.c -o CMakeFiles/dyncall_s.dir/dyncall_api.c.s
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_5) "Building C object dyncall/CMakeFiles/dyncall_s.dir/dyncall_callvm.c.o"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT dyncall/CMakeFiles/dyncall_s.dir/dyncall_callvm.c.o -MF CMakeFiles/dyncall_s.dir/dyncall_callvm.c.o.d -o CMakeFiles/dyncall_s.dir/dyncall_callvm.c.o -c /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_callvm.c
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dyncall_s.dir/dyncall_callvm.c.i"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_callvm.c > CMakeFiles/dyncall_s.dir/dyncall_callvm.c.i
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dyncall_s.dir/dyncall_callvm.c.s"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_callvm.c -o CMakeFiles/dyncall_s.dir/dyncall_callvm.c.s
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_6) "Building C object dyncall/CMakeFiles/dyncall_s.dir/dyncall_callvm_base.c.o"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT dyncall/CMakeFiles/dyncall_s.dir/dyncall_callvm_base.c.o -MF CMakeFiles/dyncall_s.dir/dyncall_callvm_base.c.o.d -o CMakeFiles/dyncall_s.dir/dyncall_callvm_base.c.o -c /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_callvm_base.c
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dyncall_s.dir/dyncall_callvm_base.c.i"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_callvm_base.c > CMakeFiles/dyncall_s.dir/dyncall_callvm_base.c.i
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dyncall_s.dir/dyncall_callvm_base.c.s"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_callvm_base.c -o CMakeFiles/dyncall_s.dir/dyncall_callvm_base.c.s
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_7) "Building C object dyncall/CMakeFiles/dyncall_s.dir/dyncall_callf.c.o"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT dyncall/CMakeFiles/dyncall_s.dir/dyncall_callf.c.o -MF CMakeFiles/dyncall_s.dir/dyncall_callf.c.o.d -o CMakeFiles/dyncall_s.dir/dyncall_callf.c.o -c /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_callf.c
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dyncall_s.dir/dyncall_callf.c.i"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_callf.c > CMakeFiles/dyncall_s.dir/dyncall_callf.c.i
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dyncall_s.dir/dyncall_callf.c.s"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_callf.c -o CMakeFiles/dyncall_s.dir/dyncall_callf.c.s
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_8) "Linking C static library libdyncall_s.a"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && $(CMAKE_COMMAND) -P CMakeFiles/dyncall_s.dir/cmake_clean_target.cmake
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/dyncall_s.dir/link.txt --verbose=$(VERBOSE)
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncall && $(CMAKE_COMMAND) -P CMakeFiles/dyncall_s.dir/cmake_clean.cmake
dyncall/dyncall/CMakeFiles/dyncall_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/dyncall /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/dyncall /home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake --color=$(COLOR)
dyncall/dyncall/CMakeFiles/dyncall_s.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/dyncall/CMakeFiles/dyncall_s.dir/flags.make:C_FLAGS =   -fPIC
dyncall/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_api.c" "dyncall/CMakeFiles/dyncall_s.dir/dyncall_api.c.o" "gcc" "dyncall/CMakeFiles/dyncall_s.dir/dyncall_api.c.o.d"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_call.S" "dyncall/CMakeFiles/dyncall_s.dir/dyncall_call.S.o" "gcc" "dyncall/CMakeFiles/dyncall_s.dir/dyncall_call.S.o.d"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_callf.c" "dyncall/CMakeFiles/dyncall_s.dir/dyncall_callf.c.o" "gcc" "dyncall/CMakeFiles/dyncall_s.dir/dyncall_callf.c.o.d"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_callvm.c" "dyncall/CMakeFiles/dyncall_s.dir/dyncall_callvm.c.o" "gcc" "dyncall/CMakeFiles/dyncall_s.dir/dyncall_callvm.c.o.d"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_callvm_base.c" "dyncall/CMakeFiles/dyncall_s.dir/dyncall_callvm_base.c.o" "gcc" "dyncall/CMakeFiles/dyncall_s.dir/dyncall_callvm_base.c.o.d"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_struct.c" "dyncall/CMakeFiles/dyncall_s.dir/dyncall_struct.c.o" "gcc" "dyncall/CMakeFiles/dyncall_s.dir/dyncall_struct.c.o.d"
dyncall/dyncall/CMakeFiles/dyncall_s.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_vector.c" "dyncall/CMakeFiles/dyncall_s.dir/dyncall_vector.c.o" "gcc" "dyncall/CMakeFiles/dyncall_s.dir/dyncall_vector.c.o.d"
dyncall/dyncall/dyncall_types.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_types.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_types.h:  dyncall argument- and return-types
dyncall/dyncall/dyncall_callvm_ppc32.h:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_ppc32.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_x64.c:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_x64.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_x64.c:** - hybrid return-type call (bool ... pointer)
dyncall/dyncall/dyncall_callvm_x64.c:  dcVecReset(&self->mVecHead);
dyncall/dyncall/dyncall_callvm_x64.c:  self->mRegCount.i = self->mRegCount.f = 0;
dyncall/dyncall/dyncall_callvm_x64.c:  if(self->mRegCount.i < numIntRegs)
dyncall/dyncall/dyncall_callvm_x64.c:    self->mRegData.i[self->mRegCount.i++] = x;
dyncall/dyncall/dyncall_callvm_x64.c:    dcVecAppend(&self->mVecHead, &x, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_x64.c:  if(self->mRegCount.f < numFloatRegs)
dyncall/dyncall/dyncall_callvm_x64.c:    *(DCfloat*)&self->mRegData.f[self->mRegCount.f++] = x;
dyncall/dyncall/dyncall_callvm_x64.c:    dcVecAppend(&self->mVecHead, &f.f, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_x64.c:  if(self->mRegCount.f < numFloatRegs)
dyncall/dyncall/dyncall_callvm_x64.c:    self->mRegData.f[self->mRegCount.f++] = x;
dyncall/dyncall/dyncall_callvm_x64.c:    dcVecAppend(&self->mVecHead, &x, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_x64.c:  if(self->mRegCount.i < numIntRegs)
dyncall/dyncall/dyncall_callvm_x64.c:    *(DCpointer*)&self->mRegData.i[self->mRegCount.i++] = x;
dyncall/dyncall/dyncall_callvm_x64.c:    dcVecAppend(&self->mVecHead, &x, sizeof(DCpointer));
dyncall/dyncall/dyncall_callvm_x64.c:  dcVecAppend(&self->mVecHead, x, s->size);
dyncall/dyncall/dyncall_callvm_x64.c:  /*printf("dc_callvm_argStruct_x64 size = %d\n", (int)s->size);@@@*/
dyncall/dyncall/dyncall_callvm_x64.c:  if (s->size <= 64)
dyncall/dyncall/dyncall_callvm_x64.c:  /*	  dcVecAppend(&self->mVecHead, &x, sizeof(DCpointer));@@@*/
dyncall/dyncall/dyncall_callvm_x64.c:    dcVecSize(&self->mVecHead),  /* Size of stack data.                           */
dyncall/dyncall/dyncall_callvm_x64.c:    dcVecData(&self->mVecHead),  /* Pointer to stack arguments.                   */
dyncall/dyncall/dyncall_callvm_x64.c:    self->mRegData.i,            /* Pointer to register arguments (ints on SysV). */
dyncall/dyncall/dyncall_callvm_x64.c:    self->mRegData.f,            /* Pointer to floating point register arguments. */
dyncall/dyncall/dyncall_callvm_x64.c:/* --- syscall ------------------------------------------------------------- */
dyncall/dyncall/dyncall_callvm_x64.c:  /* SysV manual), so we can use self->mRegData.i directly; verify this has space for at least 6 values, though. */
dyncall/dyncall/dyncall_callvm_x64.c:  dcCall_x64_syscall_sysv(self->mRegData.i, target);
dyncall/dyncall/dyncall_callvm_x64.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE; return;
dyncall/dyncall/dyncall_callvm_x64.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE; 
dyncall/dyncall/dyncall_callvm_x64.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_x64.c:  size -= sizeof(DCRegData_x64);
dyncall/dyncall/dyncall_callvm_x64.c:  dcVecInit(&p->mVecHead, size);
dyncall/dyncall/dyncall_callvm_sparc64.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>
dyncall/dyncall/dyncall_vector.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_vector.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_vector.h:#define dcVecInit(p,size)   (p)->mTotal=size;(p)->mSize=0
dyncall/dyncall/dyncall_vector.h:#define dcVecReset(p)       (p)->mSize=0
dyncall/dyncall/dyncall_vector.h:#define dcVecResize(p,size) (p)->mSize=(size)
dyncall/dyncall/dyncall_vector.h:#define dcVecSkip(p,size)   (p)->mSize+=(size)
dyncall/dyncall/dyncall_vector.h:#define dcVecSize(p)        ( (p)->mSize )
dyncall/dyncall/dyncall_vector.h:#define dcVecAlign(p,align) (p)->mSize=( (p)->mSize + align-1 ) & -align
dyncall/dyncall/dyncall_vector.h: #define dcVecAppend(p,s,n) memcpy( dcVecData(p)+p->mSize, s, n );p->mSize+=n
dyncall/dyncall/dyncall_value.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_value.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_value.h:  a value variant union-type that carries all supported dyncall types.
dyncall/dyncall/dyncall_value.h:/* floats on mips are right justified in fp-registers on big endian targets, as they aren't promoted */
dyncall/dyncall/dyncall_callvm_base.c: Description: ARM 32-bit "thumb" ABI callvm implementation
dyncall/dyncall/dyncall_callvm_base.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_base.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_base.c:  pInstance->mVTpointer = pVTable;
dyncall/dyncall/dyncall_callvm_base.c:  pInstance->mError = DC_ERROR_NONE;
dyncall/dyncall/dyncall_call_x86_nasm.asm:; Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_call_x86_nasm.asm:;                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_x86_nasm.asm:; -----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_x86_nasm.asm:; - all arguments are on the stack
dyncall/dyncall/dyncall_call_x86_nasm.asm:; - caller cleans up stack
dyncall/dyncall/dyncall_call_x86_nasm.asm:; -----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_x86_nasm.asm:; -----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_x86_nasm.asm:; - thispointer is in ECX, rest is on the stack
dyncall/dyncall/dyncall_call_x86_nasm.asm:; - callee cleans up stack
dyncall/dyncall/dyncall_call_x86_nasm.asm:; -----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_x86_nasm.asm:	sub  esp, ecx         ; allocate argument-block on stack
dyncall/dyncall/dyncall_call_x86_nasm.asm:; -----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_x86_nasm.asm:; - all arguments are passed by stack
dyncall/dyncall/dyncall_call_x86_nasm.asm:; - callee cleans up stack
dyncall/dyncall/dyncall_call_x86_nasm.asm:; -----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_x86_nasm.asm:	sub  esp, ecx         ; stdcall: allocate 'size'-8 bytes on stack
dyncall/dyncall/dyncall_call_x86_nasm.asm:; -----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_x86_nasm.asm:; - first two integer (up to 32bits) are passed in ECX and EDX
dyncall/dyncall/dyncall_call_x86_nasm.asm:; - others are passed on the stack
dyncall/dyncall/dyncall_call_x86_nasm.asm:; - callee cleans up stack
dyncall/dyncall/dyncall_call_x86_nasm.asm:; -----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_x86_nasm.asm:	sub  esp, ecx         ; fastcall: allocate 'size'-8 bytes on stack
dyncall/dyncall/dyncall_call_x86_nasm.asm:;section .note.GNU-stack noalloc noexec nowrite progbits
dyncall/dyncall/dyncall_callvm_arm32_thumb.h:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_arm32_thumb.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/Makefile.embedded:MAKE_CMD = ${MAKE} -f ${MAKEFILE} 
dyncall/dyncall/Makefile.embedded:	rm -f ${OBJS} ${TARGET}
dyncall/dyncall/Makefile.embedded:	mkdir -p ${DESTDIR}${PREFIX}/include
dyncall/dyncall/Makefile.embedded:	mkdir -p ${DESTDIR}${PREFIX}/lib
dyncall/dyncall/Makefile.embedded:	mkdir -p ${DESTDIR}${PREFIX}/man/man3
dyncall/dyncall/Makefile.embedded:	gzip -c dyncall.3 >${DESTDIR}${PREFIX}/man/man3/dyncall.3.gz
dyncall/dyncall/Makefile.embedded:osx-universal:
dyncall/dyncall/Makefile.embedded:	CFLAGS="${CFLAGS} -arch i386 -arch x86_64 -arch ppc" ASFLAGS="${ASFLAGS} -arch i386 -arch x86_64 -arch ppc" AR="libtool" ARFLAGS="-static -o" ${MAKE_CMD} all
dyncall/dyncall/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/dyncall
dyncall/dyncall/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/dyncall/cmake_install.cmake:  file(INSTALL DESTINATION "${CMAKE_INSTALL_PREFIX}/lib" TYPE STATIC_LIBRARY FILES "/home/chenningcong/Desktop/dyncall-1.2/dyncall/libdyncall_s.a")
dyncall/dyncall/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_macros.h"
dyncall/dyncall/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_config.h"
dyncall/dyncall/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_types.h"
dyncall/dyncall/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall.h"
dyncall/dyncall/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_signature.h"
dyncall/dyncall/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_value.h"
dyncall/dyncall/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncall/dyncall_callf.h"
dyncall/dyncall/dyncall_callvm_mips_n32.c:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncall/dyncall_callvm_mips_n32.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_mips_n32.c:  stack is always 16-byte aligned at entry (call to call-kernel automatically
dyncall/dyncall/dyncall_callvm_mips_n32.c:  integer and float register-file is interleaved either taking one slot up
dyncall/dyncall/dyncall_callvm_mips_n32.c:  dcVecReset(&self->mVecHead);
dyncall/dyncall/dyncall_callvm_mips_n32.c:  self->mRegCount = 0;
dyncall/dyncall/dyncall_callvm_mips_n32.c:  self->mRegData.mUseDouble = 0LL;
dyncall/dyncall/dyncall_callvm_mips_n32.c:   - promote to 64-bit integer.
dyncall/dyncall/dyncall_callvm_mips_n32.c:   - fill up integers and float - left-to-right otherwise go over stack.
dyncall/dyncall/dyncall_callvm_mips_n32.c:/* arg int -- fillup 64-bit integer register file OR push on stack */
dyncall/dyncall/dyncall_callvm_mips_n32.c:  if (self->mRegCount < 8)
dyncall/dyncall/dyncall_callvm_mips_n32.c:    self->mRegData.mIntData[self->mRegCount++] = Lv;
dyncall/dyncall/dyncall_callvm_mips_n32.c:    dcVecAppend(&self->mVecHead, &Lv, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_mips_n32.c:  if (self->mRegCount < 8) {
dyncall/dyncall/dyncall_callvm_mips_n32.c:    self->mRegData.mUseDouble |= 1<<( self->mRegCount );
dyncall/dyncall/dyncall_callvm_mips_n32.c:    self->mRegData.mFloatData[self->mRegCount++].d = x;
dyncall/dyncall/dyncall_callvm_mips_n32.c:    dcVecAppend(&self->mVecHead, &x, sizeof(DCdouble) );
dyncall/dyncall/dyncall_callvm_mips_n32.c:  if (self->mRegCount < 8) {
dyncall/dyncall/dyncall_callvm_mips_n32.c:    /*self->mRegData.mFloatData[self->mRegCount++].d = (DCdouble) x;*/
dyncall/dyncall/dyncall_callvm_mips_n32.c:    self->mRegData.mFloatData[self->mRegCount++].f = x;
dyncall/dyncall/dyncall_callvm_mips_n32.c:    dcVecAppend(&self->mVecHead, &x, sizeof(DCfloat) );
dyncall/dyncall/dyncall_callvm_mips_n32.c:    dcVecSkip(&self->mVecHead, sizeof(DCfloat) );
dyncall/dyncall/dyncall_callvm_mips_n32.c:   - float is promoted to double (due to ANSI C).
dyncall/dyncall/dyncall_callvm_mips_n32.c:   - double is passed via integer register-file (due to MIPS ABI).
dyncall/dyncall/dyncall_callvm_mips_n32.c:  /* at minimum provide 16-bytes
dyncall/dyncall/dyncall_callvm_mips_n32.c:     and are automatically loaded to $4-$7
dyncall/dyncall/dyncall_callvm_mips_n32.c:  size_t size = DC_MAX(16, ( ( (unsigned) dcVecSize(&self->mVecHead) ) +7UL ) & (-8UL) );
dyncall/dyncall/dyncall_callvm_mips_n32.c:  dcCall_mips_n32(target, &self->mRegData, size, dcVecData(&self->mVecHead));
dyncall/dyncall/dyncall_callvm_mips_n32.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE;
dyncall/dyncall/dyncall_callvm_mips_n32.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_mips_n32.c:  dcVecInit(&p->mVecHead, size);
dyncall/dyncall/dyncall_call_ppc32.S: Description: Call Kernel for PowerPC 32-bit Architecture
dyncall/dyncall/dyncall_call_ppc32.S:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_call_ppc32.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_ppc32.S:#include "../portasm/portasm-ppc.S"
dyncall/dyncall/dyncall_call_ppc32.S:   -------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_ppc32.S:  2015-01-15: Added support for system calls.
dyncall/dyncall/dyncall_call_ppc32.S:  2011-04-03: Using portasm.
dyncall/dyncall/dyncall_call_ppc32.S:  2009-01-09: Added Support for System V ABI.
dyncall/dyncall/dyncall_call_ppc32.S:  2007-11-28: Initial Support for Darwin.
dyncall/dyncall/dyncall_call_ppc32.S:/*---------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_ppc32.S:  - Stack frames are always aligned on 16 byte
dyncall/dyncall/dyncall_call_ppc32.S:  - The GPR3 .. GPR10 are loaded
dyncall/dyncall/dyncall_call_ppc32.S:  - The FPR1 .. FPR13 are loaded
dyncall/dyncall/dyncall_call_ppc32.S:  - No support for Vector Parameters so far. 
dyncall/dyncall/dyncall_call_ppc32.S:  - Parameter Area (min. 32 Bytes)
dyncall/dyncall/dyncall_call_ppc32.S:  - Linkage Area (24 Bytes)
dyncall/dyncall/dyncall_call_ppc32.S:	stw  r0,8(r1)		/* store return address in caller link-area */
dyncall/dyncall/dyncall_call_ppc32.S:	/* compute aligned stack-size */
dyncall/dyncall/dyncall_call_ppc32.S:	rlwinm r0,r0,0,0,27	/* r0 = r0 and -15 */
dyncall/dyncall/dyncall_call_ppc32.S:				/* r0 = r0 and -15 */
dyncall/dyncall/dyncall_call_ppc32.S:	neg r2,r0		/* r2 = -stacksize */
dyncall/dyncall/dyncall_call_ppc32.S:	stwux r1,r1,r2		/* r1 = r1 - stacksize */
dyncall/dyncall/dyncall_call_ppc32.S:	addi r7,r1,20		/* r7 = 4 bytes before target stack parameter-block */
dyncall/dyncall/dyncall_call_ppc32.S:/* ----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_ppc32.S:   - Stack frames are always aligned on 16 byte
dyncall/dyncall/dyncall_call_ppc32.S:   - Reserve GPR2 (System register)  
dyncall/dyncall/dyncall_call_ppc32.S:   - The GPR3 .. GPR10 are loaded
dyncall/dyncall/dyncall_call_ppc32.S:   - The FPR1 .. FPR8 are loaded
dyncall/dyncall/dyncall_call_ppc32.S:   - No support for Vector Parameters so far. 
dyncall/dyncall/dyncall_call_ppc32.S:     0:      parent stack frame (back-chain)
dyncall/dyncall/dyncall_call_ppc32.S:    	stack size = ( (8+15) + stacksize ) & -(16)
dyncall/dyncall/dyncall_call_ppc32.S:     0:      parent stack frame (back-chain)
dyncall/dyncall/dyncall_call_ppc32.S:	stw  r0,4(r1)		/* store r0 to link-area */
dyncall/dyncall/dyncall_call_ppc32.S:	/* compute aligned stack-size */
dyncall/dyncall/dyncall_call_ppc32.S:	/* r0 = stacksize + frame parameter(back-chain link, this callee's call return address) */
dyncall/dyncall/dyncall_call_ppc32.S:	rlwinm r0,r0,0,0,27  	/* r0 = r0 and -15 */
dyncall/dyncall/dyncall_call_ppc32.S:	neg r0,r0 		/* r0 = -r0 */
dyncall/dyncall/dyncall_call_ppc32.S:			        /* 4 bytes before target stack parameter-block */
dyncall/dyncall/dyncall_call_ppc32.S:	addi r7,r1,4		/* r7 = r1 + 8 offset - 4 displacement */
dyncall/dyncall/dyncall_call_ppc32.S:	stw  r0,4(r1)		/* store r0 to link-area */
dyncall/dyncall/dyncall_call_ppc32.S:	li   r0, -8
dyncall/dyncall/dyncall_call.S: Description: assembly call kernel, auto-selected by gcc / Plan9 build system
dyncall/dyncall/dyncall_call.S:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_call.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call.S:/* Use .note.GNU-stack to explicitly indicate a non-exec stack, b/c of bad   */
dyncall/dyncall/dyncall_call.S:.section .note.GNU-stack,"",%progbits
dyncall/dyncall/dyncall_vector.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_vector.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_vector.c:  size_t newSize = pHead->mSize + size;
dyncall/dyncall/dyncall_vector.c:  if(newSize <= pHead->mTotal) 
dyncall/dyncall/dyncall_vector.c:    void* dst = (DCchar*)dcVecData(pHead) + pHead->mSize;
dyncall/dyncall/dyncall_vector.c:      /* On sparc 32-bit, this one crashes if ptrs are not aligned, so use above.
dyncall/dyncall/dyncall_vector.c:    pHead->mSize = newSize;
dyncall/dyncall/dyncall_callvm_x64.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_x64.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_x86_8a.s:   Copyright (c) 2007-2011 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncall/dyncall_call_x86_8a.s:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_x86_8a.s:       The only real issue with this approach would be a non-executable
dyncall/dyncall/dyncall_call_x86_8a.s:    SUBL  $16, SP     /* Make some room for our SP-refetch logic */
dyncall/dyncall/dyncall_call_x86_8a.s:       container for 64-bit return values. */
dyncall/dyncall/CMakeLists.txt:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>
dyncall/dyncall/dyncall_callvm_mips_n64.c:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncall/dyncall_callvm_mips_n64.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_mips_n64.c:  stack is always 16-byte aligned at entry (call to call-kernel automatically
dyncall/dyncall/dyncall_callvm_mips_n64.c:  integer and float register-file is interleaved either taking one slot up
dyncall/dyncall/dyncall_callvm_mips_n64.c:  dcVecReset(&self->mVecHead);
dyncall/dyncall/dyncall_callvm_mips_n64.c:  self->mRegCount = 0;
dyncall/dyncall/dyncall_callvm_mips_n64.c:  self->mRegData.mUseDouble = 0LL;
dyncall/dyncall/dyncall_callvm_mips_n64.c:   - promote to 64-bit integer.
dyncall/dyncall/dyncall_callvm_mips_n64.c:   - fill up integers and float - left-to-right otherwise go over stack.
dyncall/dyncall/dyncall_callvm_mips_n64.c:/* arg int -- fillup 64-bit integer register file OR push on stack */
dyncall/dyncall/dyncall_callvm_mips_n64.c:  if (self->mRegCount < 8)
dyncall/dyncall/dyncall_callvm_mips_n64.c:    self->mRegData.mIntData[self->mRegCount++] = x;
dyncall/dyncall/dyncall_callvm_mips_n64.c:    dcVecAppend(&self->mVecHead, &x, sizeof(DClonglong));
dyncall/dyncall/dyncall_callvm_mips_n64.c:  if (self->mRegCount < 8) {
dyncall/dyncall/dyncall_callvm_mips_n64.c:    self->mRegData.mUseDouble |= 1<<( self->mRegCount );
dyncall/dyncall/dyncall_callvm_mips_n64.c:    self->mRegData.mFloatData[self->mRegCount++].d = x;
dyncall/dyncall/dyncall_callvm_mips_n64.c:    dcVecAppend(&self->mVecHead, &x, sizeof(DCdouble));
dyncall/dyncall/dyncall_callvm_mips_n64.c:  if (self->mRegCount < 8) {
dyncall/dyncall/dyncall_callvm_mips_n64.c:    /*self->mRegData.mFloatData[self->mRegCount++].d = (DCdouble) x;*/
dyncall/dyncall/dyncall_callvm_mips_n64.c:    self->mRegData.mFloatData[self->mRegCount++].f = x;
dyncall/dyncall/dyncall_callvm_mips_n64.c:    dcVecAppend(&self->mVecHead, &x, sizeof(DCfloat));
dyncall/dyncall/dyncall_callvm_mips_n64.c:    dcVecSkip(&self->mVecHead, sizeof(DCfloat));
dyncall/dyncall/dyncall_callvm_mips_n64.c:  if (((DCCallVM_mips_n64*)in_self)->mRegCount < 8) {
dyncall/dyncall/dyncall_callvm_mips_n64.c:   - float is promoted to double (due to ANSI C).
dyncall/dyncall/dyncall_callvm_mips_n64.c:   - double is passed via integer register-file (due to MIPS ABI).
dyncall/dyncall/dyncall_callvm_mips_n64.c:  /* at minimum provide 16-bytes
dyncall/dyncall/dyncall_callvm_mips_n64.c:     and are automatically loaded to $4-$7
dyncall/dyncall/dyncall_callvm_mips_n64.c:  size_t size = DC_MAX(16, ( ( (unsigned) dcVecSize(&self->mVecHead) ) +7UL ) & (-8UL) );
dyncall/dyncall/dyncall_callvm_mips_n64.c:  dcCall_mips_n64(target, &self->mRegData, size, dcVecData(&self->mVecHead));
dyncall/dyncall/dyncall_callvm_mips_n64.c:      self->mInterface.mError = DC_ERROR_UNSUPPORTED_MODE;
dyncall/dyncall/dyncall_callvm_mips_n64.c:  dc_callvm_base_init(&self->mInterface, vt);
dyncall/dyncall/dyncall_callvm_mips_n64.c:  dcVecInit(&p->mVecHead, size);
dyncall/dyncall/dyncall_call_ppc64.S: Description: Call Kernel for PowerPC 64-bit Architecture
dyncall/dyncall/dyncall_call_ppc64.S:   Copyright (c) 2014-2015 Masanori Mitsugi <mitsugi@linux.vnet.ibm.com>
dyncall/dyncall/dyncall_call_ppc64.S:#include "../portasm/portasm-ppc64.S"
dyncall/dyncall/dyncall_call_ppc64.S:   -------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_ppc64.S:  2015-07-08: Added support for system calls
dyncall/dyncall/dyncall_call_ppc64.S:  2014-08-07: Initial Support
dyncall/dyncall/dyncall_call_ppc64.S:/* ----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_ppc64.S:   - Stack frames are always aligned on 16 byte
dyncall/dyncall/dyncall_call_ppc64.S:   - Reserve GPR2 (System register)  
dyncall/dyncall/dyncall_call_ppc64.S:   - The GPR3 .. GPR10 are loaded
dyncall/dyncall/dyncall_call_ppc64.S:   - The FPR1 .. FPR8 are loaded
dyncall/dyncall/dyncall_call_ppc64.S:   - No support for Vector Parameters so far. 
dyncall/dyncall/dyncall_call_ppc64.S:   - Parameter Area (min. v1:64 Bytes v2:0 Byte)
dyncall/dyncall/dyncall_call_ppc64.S:   - Frame Header Area (v1:48 Bytes v2:32 Bytes)
dyncall/dyncall/dyncall_call_ppc64.S:     0:      parent stack frame (back-chain)
dyncall/dyncall/dyncall_call_ppc64.S:    	v1: stack size = ( (48+64+8+15) + stacksize ) & -(16)
dyncall/dyncall/dyncall_call_ppc64.S:    	v2: stack size = ( (32+0+8+15) + stacksize ) & -(16)
dyncall/dyncall/dyncall_call_ppc64.S:     0:      parent stack frame (back-chain)
dyncall/dyncall/dyncall_call_ppc64.S:	std  r0,16(r1)          /* store r0 to link-area */
dyncall/dyncall/dyncall_call_ppc64.S:	std  r31,-8(r1)
dyncall/dyncall/dyncall_call_ppc64.S:	/* compute aligned stack-size */
dyncall/dyncall/dyncall_call_ppc64.S:	/* r0 = stacksize + frame parameter(back-chain link, this callee's call return address) */
dyncall/dyncall/dyncall_call_ppc64.S:	rlwinm r0,r0,0,0,27     /* r0 = r0 and -15 */
dyncall/dyncall/dyncall_call_ppc64.S:	neg r0,r0               /* r0 = -r0 */
dyncall/dyncall/dyncall_call_ppc64.S:	addi r7,r1,PARAM_SAVE-8 /* r7 = 8 bytes before target stack parameter-block */
dyncall/dyncall/dyncall_call_ppc64.S:	ld   r31,-8(r1)
dyncall/dyncall/dyncall_call_ppc64.S:	std  r0,16(r1)          /* store r0 to link-area */
dyncall/dyncall/dyncall_call_ppc64.S:	std  r31,-8(r1)
dyncall/dyncall/dyncall_call_ppc64.S:	li   r0, -STACK_MIN
dyncall/dyncall/dyncall_call_ppc64.S:	ld   r31,-8(r1)
dyncall/dyncall/dyncall_api.c:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_api.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->reset(vm); 
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->free(vm); 
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->mode(vm,mode);
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->argBool(vm, x); 
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->argChar(vm, x); 
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->argShort(vm, x); 
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->argInt(vm, x); 
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->argLong(vm, x); 
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->argLongLong(vm, x); 
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->argFloat(vm, x); 
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->argDouble(vm, x); 
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->argPointer(vm, x); 
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->argStruct(vm, s, x); 
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->callVoid(vm, funcptr); 
dyncall/dyncall/dyncall_api.c:  return vm->mVTpointer->callChar(vm, funcptr); 
dyncall/dyncall/dyncall_api.c:  return vm->mVTpointer->callBool(vm, funcptr); 
dyncall/dyncall/dyncall_api.c:  return vm->mVTpointer->callShort(vm, funcptr); 
dyncall/dyncall/dyncall_api.c:  return vm->mVTpointer->callInt(vm, funcptr); 
dyncall/dyncall/dyncall_api.c:  return vm->mVTpointer->callLong(vm, funcptr); 
dyncall/dyncall/dyncall_api.c:  return vm->mVTpointer->callLongLong(vm, funcptr); 
dyncall/dyncall/dyncall_api.c:  return vm->mVTpointer->callFloat(vm, funcptr); 
dyncall/dyncall/dyncall_api.c:  return vm->mVTpointer->callDouble(vm, funcptr); 
dyncall/dyncall/dyncall_api.c:  return vm->mVTpointer->callPointer(vm, funcptr); 
dyncall/dyncall/dyncall_api.c:  vm->mVTpointer->callStruct(vm, funcptr, s, x); 
dyncall/dyncall/dyncall_api.c:  return vm->mError;
dyncall/dyncall/dyncall_callvm_arm64.h:   Copyright (c) 2015-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncall/dyncall_callvm_arm64.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_mips_n64.h:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncall/dyncall_callvm_mips_n64.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_callvm_mips_n64.h:  two register-files for integer (promoted to 64-bit) and float (not promoted!)
dyncall/dyncall/dyncall_callvm_mips_n64.h:  the other register-file will be skipped by one.
dyncall/dyncall/dyncall_callvm_mips_n64.h:  float arguments are either loaded from single or double -
dyncall/dyncall/dyncall_callvm_mips_n64.h:  a auto-conversion into double and then loaded as double precision
dyncall/dyncall/dyncall_callvm_mips_n64.h:  interpreted in the call-kernel.
dyncall/dyncall/dyncall_call_x86.S: Description: All - except Plan9 - x86 abi call kernel implementation
dyncall/dyncall/dyncall_call_x86.S:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncall/dyncall_call_x86.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncall/dyncall_call_x86.S:#include "../portasm/portasm-x86.S"
dyncall/dyncall/dyncall_call_x86.S:   ----------------------------------------------------------------------------
dyncall/dyncall/dyncall_call_x86.S:   Where XXX is one of calling-conventions,
dyncall/dyncall/dyncall_call_x86.S:    - epilog restore ESP serves callee cleanup 
dyncall/dyncall/dyncall_call_x86.S:    - 16 byte alignment (to be compatible with darwin).
dyncall/dyncall/dyncall_call_x86.S:/*--- default / cdecl --------------------------------------------------------
dyncall/dyncall/dyncall_call_x86.S:  - caller clean-up
dyncall/dyncall/dyncall_call_x86.S:	ANDL(LIT(-16),ECX)
dyncall/dyncall/dyncall_call_x86.S:/* ---- C++ this calls (microsoft) ------------------------------------------ 
dyncall/dyncall/dyncall_call_x86.S:  - this pointer is in ECX
dyncall/dyncall/dyncall_call_x86.S:	SUBL(ECX,ESP)         		/* allocate argument-block on stack. */
dyncall/dyncall/dyncall_call_x86.S:/*---- win32 stdcall ---------------------------------------------------------
dyncall/dyncall/dyncall_call_x86.S:  - callee cleans up stack
dyncall/dyncall/dyncall_call_x86.S:/*---- win32 fastcall (GNU/Microsoft) ----------------------------------------
dyncall/dyncall/dyncall_call_x86.S:  - callee cleans up stack
dyncall/dyncall/dyncall_call_x86.S:  - first two integer (up to 32bits) are passed in ECX and EDX
dyncall/dyncall/dyncall_call_x86.S:/*--- syscall int80 linux ---------------------------------------------------
dyncall/dyncall/dyncall_call_x86.S:  - all arguments are passed via registers
dyncall/dyncall/dyncall_call_x86.S:/*--- syscall int80 bsd -----------------------------------------------------
dyncall/dyncall/dyncall_call_x86.S:  - all arguments are passed via stack
dyncall/configure.rc:# Copyright (c) 2007-2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/configure.rc:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/configure.rc:# --- configure settings ------------------------------------------------------
dyncall/configure.rc:# --- output error message ----------------------------------------------------
dyncall/configure.rc:# --- output warning message --------------------------------------------------
dyncall/configure.rc:# --- output info message -----------------------------------------------------
dyncall/configure.rc:# --- print usage -------------------------------------------------------------
dyncall/configure.rc:  echo $PACKAGE' configuration shell-script'
dyncall/configure.rc:  echo '  --help'
dyncall/configure.rc:  echo '   -h                print this page'
dyncall/configure.rc:  #echo '  --target-x86       build for x86 architecture platform'
dyncall/configure.rc:  #echo '  --target-x64       build for x64 architecture platform'
dyncall/configure.rc:  #echo '  --target-ppc32     build for ppc32 architecture platform'
dyncall/configure.rc:  #echo '  --target-arm-arm   build for ARM architecture platform (ARM mode)'
dyncall/configure.rc:  #echo '  --target-arm-thumb build for ARM architecture platform (THUMB mode)'
dyncall/configure.rc:  #echo '  --tool-pcc         use Portable C Compiler'
dyncall/configure.rc:  #echo '  --asm-xa           use Plan9 Assemblers (0a, 1a, 2a, etc.)'
dyncall/configure.rc:  #echo '  --config-release   build release version (default)'
dyncall/configure.rc:  #echo '  --config-debug     build debug version'
dyncall/configure.rc:# --- guess operating system -------------------------------------------------
dyncall/configure.rc:# --- guess architecture -----------------------------------------------------
dyncall/configure.rc:      warning 'unknown architecture '$cputype' - using default (x86)'
dyncall/configure.rc:# --- guess tool chain -------------------------------------------------------
dyncall/configure.rc:# --- guess assembler --------------------------------------------------------
dyncall/configure.rc:# --- process arguments ------------------------------------------------------
dyncall/configure.rc:  while(! ~ $#* 0 && ~ $1 -*) {
dyncall/configure.rc:      case --help -h
dyncall/configure.rc:      #case --target-x86
dyncall/configure.rc:      #case --target-x64
dyncall/configure.rc:      #case --target-ppc32
dyncall/configure.rc:      #case --target-arm-arm
dyncall/configure.rc:      #case --target-arm-thumb
dyncall/configure.rc:      #case --tool-pcc
dyncall/configure.rc:      #case --tool-xa
dyncall/configure.rc:      #case --config-release
dyncall/configure.rc:      #case --config-debug
dyncall/configure.rc:# --- guess variables --------------------------------------------------------
dyncall/configure.rc:# --- set default variables --------------------------------------------------
dyncall/configure.rc:# --- derive variables -------------------------------------------------------
dyncall/configure.rc:# --- write ConfigVars files ------------------------------------------------
dyncall/configure.rc:  echo '#auto-generated by '$PACKAGE'/configure' >$1
dyncall/configure.rc:# --- main -------------------------------------------------------------------
dyncall/AUTHORS:Daniel Adler <dadler@uni-goettingen.de>
dyncall/AUTHORS:Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/AUTHORS:Bernhard Urban-Forster <beurba@microsoft.com>
dyncall/CMakeCache.txt:# For build in directory: /home/chenningcong/Desktop/dyncall-1.2
dyncall/CMakeCache.txt:BIBER_COMPILER:FILEPATH=BIBER_COMPILER-NOTFOUND
dyncall/CMakeCache.txt://A wrapper around 'ar' adding the appropriate '--plugin' option
dyncall/CMakeCache.txt:CMAKE_ASM_COMPILER_AR:FILEPATH=/usr/bin/gcc-ar
dyncall/CMakeCache.txt://A wrapper around 'ranlib' adding the appropriate '--plugin' option
dyncall/CMakeCache.txt:CMAKE_ASM_COMPILER_RANLIB:FILEPATH=/usr/bin/gcc-ranlib
dyncall/CMakeCache.txt:CMAKE_ASM_FLAGS_DEBUG:STRING=-g
dyncall/CMakeCache.txt:CMAKE_ASM_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG
dyncall/CMakeCache.txt:CMAKE_ASM_FLAGS_RELEASE:STRING=-O3 -DNDEBUG
dyncall/CMakeCache.txt:CMAKE_ASM_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG
dyncall/CMakeCache.txt://A wrapper around 'ar' adding the appropriate '--plugin' option
dyncall/CMakeCache.txt:CMAKE_CXX_COMPILER_AR:FILEPATH=/usr/bin/gcc-ar
dyncall/CMakeCache.txt://A wrapper around 'ranlib' adding the appropriate '--plugin' option
dyncall/CMakeCache.txt:CMAKE_CXX_COMPILER_RANLIB:FILEPATH=/usr/bin/gcc-ranlib
dyncall/CMakeCache.txt:CMAKE_CXX_FLAGS_DEBUG:STRING=-g
dyncall/CMakeCache.txt:CMAKE_CXX_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG
dyncall/CMakeCache.txt:CMAKE_CXX_FLAGS_RELEASE:STRING=-O3 -DNDEBUG
dyncall/CMakeCache.txt:CMAKE_CXX_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG
dyncall/CMakeCache.txt://A wrapper around 'ar' adding the appropriate '--plugin' option
dyncall/CMakeCache.txt:CMAKE_C_COMPILER_AR:FILEPATH=/usr/bin/gcc-ar
dyncall/CMakeCache.txt://A wrapper around 'ranlib' adding the appropriate '--plugin' option
dyncall/CMakeCache.txt:CMAKE_C_COMPILER_RANLIB:FILEPATH=/usr/bin/gcc-ranlib
dyncall/CMakeCache.txt:CMAKE_C_FLAGS_DEBUG:STRING=-g
dyncall/CMakeCache.txt:CMAKE_C_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG
dyncall/CMakeCache.txt:CMAKE_C_FLAGS_RELEASE:STRING=-O3 -DNDEBUG
dyncall/CMakeCache.txt:CMAKE_C_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG
dyncall/CMakeCache.txt:CMAKE_DLLTOOL:FILEPATH=CMAKE_DLLTOOL-NOTFOUND
dyncall/CMakeCache.txt:DynCall_BINARY_DIR:STATIC=/home/chenningcong/Desktop/dyncall-1.2
dyncall/CMakeCache.txt:DynCall_SOURCE_DIR:STATIC=/home/chenningcong/Desktop/dyncall-1.2
dyncall/CMakeCache.txt:LATEX2HTML_CONVERTER:FILEPATH=LATEX2HTML_CONVERTER-NOTFOUND
dyncall/CMakeCache.txt:BIBER_COMPILER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:BIBTEX_COMPILER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_ADDR2LINE-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_AR-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_ASM_COMPILER_AR-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_ASM_COMPILER_RANLIB-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_ASM_FLAGS-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_ASM_FLAGS_DEBUG-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_ASM_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_ASM_FLAGS_RELEASE-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_ASM_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_CACHEFILE_DIR:INTERNAL=/home/chenningcong/Desktop/dyncall-1.2
dyncall/CMakeCache.txt:CMAKE_COLOR_MAKEFILE-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_CXX_COMPILER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_CXX_COMPILER_AR-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_CXX_COMPILER_RANLIB-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_CXX_FLAGS-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_CXX_FLAGS_DEBUG-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_CXX_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_CXX_FLAGS_RELEASE-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_CXX_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_C_COMPILER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_C_COMPILER_AR-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_C_COMPILER_RANLIB-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_C_FLAGS-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_C_FLAGS_DEBUG-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_C_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_C_FLAGS_RELEASE-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_C_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_DLLTOOL-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_EXE_LINKER_FLAGS-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_EXE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_EXE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_EXE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_EXPORT_COMPILE_COMMANDS-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_HOME_DIRECTORY:INTERNAL=/home/chenningcong/Desktop/dyncall-1.2
dyncall/CMakeCache.txt:CMAKE_LINKER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_MAKE_PROGRAM-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_MODULE_LINKER_FLAGS-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_MODULE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_MODULE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_NM-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_OBJCOPY-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_OBJDUMP-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_RANLIB-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_READELF-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_ROOT:INTERNAL=/usr/share/cmake-3.21
dyncall/CMakeCache.txt:CMAKE_SHARED_LINKER_FLAGS-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_SHARED_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_SHARED_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_SKIP_INSTALL_RPATH-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_SKIP_RPATH-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_STATIC_LINKER_FLAGS-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_STATIC_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_STATIC_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_STRIP-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CMAKE_VERBOSE_MAKEFILE-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_BINARY_DEB-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_BINARY_FREEBSD-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_BINARY_IFW-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_BINARY_NSIS-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_BINARY_RPM-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_BINARY_STGZ-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_BINARY_TBZ2-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_BINARY_TGZ-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_BINARY_TXZ-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_BINARY_TZ-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_SOURCE_RPM-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_SOURCE_TBZ2-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_SOURCE_TGZ-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_SOURCE_TXZ-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_SOURCE_TZ-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:CPACK_SOURCE_ZIP-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:DVIPDF_CONVERTER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:DVIPS_CONVERTER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:HTLATEX_COMPILER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:LATEX2HTML_CONVERTER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:LATEX_COMPILER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:LUALATEX_COMPILER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:MAKEINDEX_COMPILER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:PDFLATEX_COMPILER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:PDFTOPS_CONVERTER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:PS2PDF_CONVERTER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:XELATEX_COMPILER-ADVANCED:INTERNAL=1
dyncall/CMakeCache.txt:XINDY_COMPILER-ADVANCED:INTERNAL=1
dyncall/Makefile.generic:.PHONY: all clean install tests docs run-tests clean distclean libdyncall libdyncallback libdynload
dyncall/Makefile.generic:install: all install-libdyncall install-libdyncallback install-libdynload
dyncall/Makefile.generic:install-libdyncall: libdyncall
dyncall/Makefile.generic:install-libdyncallback: libdyncallback
dyncall/Makefile.generic:install-libdynload: libdynload
dyncall/Makefile.generic:tests: tests-libdyncall tests-libdyncallback tests-libdynload
dyncall/Makefile.generic:tests-libdyncall: libdyncall
dyncall/Makefile.generic:	cd test && ${MAKE} all-dyncall
dyncall/Makefile.generic:tests-libdyncallback: libdyncallback
dyncall/Makefile.generic:	cd test && ${MAKE} all-dyncallback
dyncall/Makefile.generic:tests-libdynload: libdynload
dyncall/Makefile.generic:	cd test && ${MAKE} all-dynload
dyncall/Makefile.generic:run-tests: all
dyncall/Makefile.generic:	rm -f Makefile.config
dyncall/Makefile.generic:	find . -type f -name "Makefile.generic" | sed s/\.generic$$// | xargs rm
dyncall/Makefile.generic:show-compiler-predefs:
dyncall/Makefile.generic:	${CC} ${CFLAGS} -dM -E - < /dev/null
dyncall/Makefile.generic:show-tool-versions:
dyncall/Makefile.generic:	${CC} -v
dyncall/Makefile.generic:	${LD} -v
dyncall/Makefile.generic:	${MAKE} -v 2>/dev/null || echo ${MAKE} ${MAKE_VERSION}
dyncall/dyncallback/dyncall_args_arm64_apple.c: Description: Callback's Arguments VM - Implementation for Apple's ARM64 / ARMv8 / AAPCS64
dyncall/dyncallback/dyncall_args_arm64_apple.c:   Copyright (c) 2015-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_arm64_apple.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_arm64_apple.c:  /* buffers and stack-pointer: */
dyncall/dyncallback/dyncall_args_arm64_apple.c:  return (uint8_t*) ( ( ( (ptrdiff_t) p ) + v - 1) & (ptrdiff_t) -v );
dyncall/dyncallback/dyncall_args_arm64_apple.c:  if (p->i < 8) {
dyncall/dyncallback/dyncall_args_arm64_apple.c:    return p->I[p->i++];
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp = align(p->sp,sizeof(DClonglong));
dyncall/dyncallback/dyncall_args_arm64_apple.c:    value =  * ( (DClonglong*) p->sp );
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp += sizeof(DClonglong);
dyncall/dyncallback/dyncall_args_arm64_apple.c:  if (p->f < 8) { 
dyncall/dyncallback/dyncall_args_arm64_apple.c:    return p->F[p->f++].d.value;
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp = align(p->sp,sizeof(DCdouble));
dyncall/dyncallback/dyncall_args_arm64_apple.c:    value =  * ( (DCdouble*) p->sp );
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp += sizeof(DCdouble);
dyncall/dyncallback/dyncall_args_arm64_apple.c:  if (p->f < 8) {
dyncall/dyncallback/dyncall_args_arm64_apple.c:    return p->F[p->f++].f.value;
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp = align(p->sp,sizeof(DCfloat));
dyncall/dyncallback/dyncall_args_arm64_apple.c:    value =  * ( (DCfloat*) p->sp );
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp += sizeof(DCfloat);
dyncall/dyncallback/dyncall_args_arm64_apple.c:  if (p->i < 8) {
dyncall/dyncallback/dyncall_args_arm64_apple.c:    return (DClong) p->I[p->i++];
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp = align(p->sp,sizeof(DClong));
dyncall/dyncallback/dyncall_args_arm64_apple.c:    value =  * ( (DClong*) p->sp );
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp += sizeof(DClong);
dyncall/dyncallback/dyncall_args_arm64_apple.c:  if (p->i < 8) {
dyncall/dyncallback/dyncall_args_arm64_apple.c:    return (DCint) p->I[p->i++];
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp = align(p->sp,sizeof(DCint));
dyncall/dyncallback/dyncall_args_arm64_apple.c:    value =  * ( (DCint*) p->sp );
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp += sizeof(DCint);
dyncall/dyncallback/dyncall_args_arm64_apple.c:  if (p->i < 8) {
dyncall/dyncallback/dyncall_args_arm64_apple.c:    return (DCshort) p->I[p->i++];
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp = align(p->sp,sizeof(DCshort));
dyncall/dyncallback/dyncall_args_arm64_apple.c:    value =  * ( (DCshort*) p->sp );
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp += sizeof(DCshort);
dyncall/dyncallback/dyncall_args_arm64_apple.c:  if (p->i < 8) {
dyncall/dyncallback/dyncall_args_arm64_apple.c:    return (DCchar) p->I[p->i++];
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp = align(p->sp,sizeof(DCchar));
dyncall/dyncallback/dyncall_args_arm64_apple.c:    value =  * ( (DCchar*) p->sp );
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp += sizeof(DCchar);
dyncall/dyncallback/dyncall_args_arm64_apple.c:  if (p->i < 8) {
dyncall/dyncallback/dyncall_args_arm64_apple.c:    return (DCbool) p->I[p->i++];
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp = align(p->sp,sizeof(DCbool));
dyncall/dyncallback/dyncall_args_arm64_apple.c:    value =  * ( (DCbool*) p->sp );
dyncall/dyncallback/dyncall_args_arm64_apple.c:    p->sp += sizeof(DCbool);
dyncall/dyncallback/dyncall_callback_arm32_thumb_apple.S: Description: Callback Thunk - Implementation for ARM32 (THUMB mode)
dyncall/dyncallback/dyncall_callback_arm32_thumb_apple.S:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_arm32_thumb_apple.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_arm64.S: Description: Callback Thunk - Implementation for ARM64 / ARMv8 / AAPCS64
dyncall/dyncallback/dyncall_callback_arm64.S:   Copyright (c) 2015-2020 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_arm64.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_arm64.S:#include "../portasm/portasm-arm64.S"
dyncall/dyncallback/dyncall_callback_arm64.S://   ---------|------|------
dyncall/dyncallback/dyncall_callback_arm64.S://   ---------|------|------
dyncall/dyncallback/dyncall_callback_arm64.S:	stp x29, x30, [sp, #-208 ]! 
dyncall/dyncallback/dyncall_thunk_arm64.h: Description: Thunk - Header for ARM64 / ARMv8 / AAPCS64
dyncall/dyncallback/dyncall_thunk_arm64.h:   Copyright (c) 2015-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_arm64.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_arm64.h:{                        /* ----|---- */
dyncall/dyncallback/dyncall_thunk_ppc32.h: Description: Thunk - Header for ppc32 (darwin/sysv)
dyncall/dyncallback/dyncall_thunk_ppc32.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_ppc32.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_mips.c: Description: Thunk - Implementation for MIPS
dyncall/dyncallback/dyncall_thunk_mips.c:   Copyright (c) 2013-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_mips.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_mips.c:  p->data[0] = 0x3c0c; p->data[1] = hi16(p);     /* lui $t4, hi(p) */
dyncall/dyncallback/dyncall_thunk_mips.c:  p->data[2] = 0x3c19; p->data[3] = hi16(entry); /* lui $t9, hi(entry) */
dyncall/dyncallback/dyncall_thunk_mips.c:  p->data[4] = 0x3739; p->data[5] = lo16(entry); /* ori $t9, $t9, lo(entry) */
dyncall/dyncallback/dyncall_thunk_mips.c:  p->jump    = 0x03200008;                       /* jr $t9 */
dyncall/dyncallback/dyncall_thunk_mips.c:  p->bddt[0] = 0x358c; p->bddt[1] = lo16(p);     /* ori $t4, $t4, lo(p) - branch delay slot */
dyncall/dyncallback/dyncall_thunk_mips.c:  p->data[1] = 0x3c0c; p->data[0] = hi16(p);     /* lui $t4, hi(p) */
dyncall/dyncallback/dyncall_thunk_mips.c:  p->data[3] = 0x3c19; p->data[2] = hi16(entry); /* lui $t9, hi(entry) */
dyncall/dyncallback/dyncall_thunk_mips.c:  p->data[5] = 0x3739; p->data[4] = lo16(entry); /* ori $t9, $t9, lo(entry) */
dyncall/dyncallback/dyncall_thunk_mips.c:  p->jump    = 0x03200008;                       /* jr $t9 */
dyncall/dyncallback/dyncall_thunk_mips.c:  p->bddt[1] = 0x358c; p->bddt[0] = lo16(p);     /* ori $t4, $t4, lo(p) - branch delay slot */
dyncall/dyncallback/dyncall_thunk_ppc64.h: Description: Thunk - Header for ppc64
dyncall/dyncallback/dyncall_thunk_ppc64.h:   Copyright (c) 2014-2015 Masanori Mitsugi <mitsugi@linux.vnet.ibm.com>
dyncall/dyncallback/dyncallback.3:.\" Copyright (c) 2007-2014 Daniel Adler <dadler AT uni-goettingen DOT de>, 
dyncall/dyncallback/dyncallback.3:.\"                         Tassilo Philipp <tphilipp AT potion-studios DOT com>
dyncall/dyncallback/dyncallback.3:.Bd -literal -offset indent
dyncall/dyncallback/dyncallback.3:our callback handler - the following handler illustrates how to access the passed-
dyncall/dyncallback/dyncallback.3:.Bd -literal -offset indent
dyncall/dyncallback/dyncallback.3:  result->s = 1244;
dyncall/dyncallback/dyncallback.3:.Bd -literal -offset indent
dyncall/dyncallback/dyncallback.3:.An "Daniel Adler" Aq dadler@uni-goettingen.de
dyncall/dyncallback/dyncallback.3:.An "Tassilo Philipp" Aq tphilipp@potion-studios.com
dyncall/dyncallback/dyncall_callback_arm32_arm_apple.s: Description: Callback Thunk - Implementation for ARM32 (ARM mode) for Apple's as
dyncall/dyncallback/dyncall_callback_arm32_arm_apple.s:   Copyright (c) 2007-2011 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_arm32_arm_apple.s:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_arm32_arm_apple.s:/* Called by thunk - thunk stores pointer to DCCallback in r12 */
dyncall/dyncallback/dyncall_callback_arm32_arm_apple.s:	stmdb	r13, {r4-r11, r13, r14}	/* Permanent registers and stack pointer, etc... -> save area on stack (except counter). */
dyncall/dyncallback/dyncall_callback_arm32_arm_apple.s:	stmdb	r13!, {r0-r4, r11}			/* Spill first 4 args to DCArgs, along with reg_count and (stack) pointer to remaining args. */
dyncall/dyncallback/dyncall_callback_arm32_arm_apple.s:	mov		r14, r15						/* Branch return address(r15) -> link register (r14) -- r15 always points to address of current + 2 instructions (= Epilog code). */ 
dyncall/dyncallback/dyncall_callback_arm32_arm_apple.s:	ldmdb	r11, {r4-r11, r13, r15}	/* Restore permanent registers (restore stack ptr and program counter).@@@db not needed since we rewrite r13? */
dyncall/dyncallback/dyncall_args_x64.c: Description: Callback's Arguments VM - Implementation for x64
dyncall/dyncallback/dyncall_args_x64.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_x64.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_x64.c:  if (args->reg_count.i < numIntRegs)
dyncall/dyncallback/dyncall_args_x64.c:    return &args->reg_data.i[args->reg_count.i++];
dyncall/dyncallback/dyncall_args_x64.c:    return args->stack_ptr++;
dyncall/dyncallback/dyncall_args_x64.c:  if (args->reg_count.f < numFloatRegs)
dyncall/dyncallback/dyncall_args_x64.c:    return &args->reg_data.f[args->reg_count.f++];
dyncall/dyncallback/dyncall_args_x64.c:    return (double*)args->stack_ptr++;
dyncall/dyncallback/dyncall_args_x64.c:// ----------------------------------------------------------------------------
dyncall/dyncallback/dyncall_callback_arm32_thumb_gas.S: Description: Callback Thunk - Implementation for ARM32 (THUMB mode)
dyncall/dyncallback/dyncall_callback_arm32_thumb_gas.S:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_arm32_thumb_gas.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_arm64.c: Description: Callback's Arguments VM - Implementation for ARM64 / ARMv8 / AAPCS64
dyncall/dyncallback/dyncall_args_arm64.c:   Copyright (c) 2015-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_arm64.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_arm64.c:  /* buffers and stack-pointer: */
dyncall/dyncallback/dyncall_args_arm64.c:  if (p->i < 8) {
dyncall/dyncallback/dyncall_args_arm64.c:    return p->I[p->i++];
dyncall/dyncallback/dyncall_args_arm64.c:    return *(p->sp)++;
dyncall/dyncallback/dyncall_args_arm64.c:  return (p->f < 8) ? p->F[p->f++].d.value : * ( (double*) (p->sp++) );
dyncall/dyncallback/dyncall_args_arm64.c:  return (p->f < 8) ? p->F[p->f++].f.value : * ( (float*)  (p->sp++) );
dyncall/dyncallback/dyncall_callback_x64_masm.asm:; auto-generated by gen-masm.sh
dyncall/dyncallback/dyncall_callback_x64_masm.asm:FRAME_DCArgs_sysv = -128
dyncall/dyncallback/dyncall_callback_x64_masm.asm:FRAME_DCValue_sysv = -136
dyncall/dyncallback/dyncall_callback_x64_masm.asm:FRAME_DCArgs_win64 = -80
dyncall/dyncallback/dyncall_callback_x64_masm.asm:FRAME_DCValue_win64 = -80
dyncall/dyncallback/dyncall_thunk_mips64.c: Description: Thunk - Implementation for MIPS64
dyncall/dyncallback/dyncall_thunk_mips64.c:   Copyright (c) 2016-2018 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[ 0] = 0x3c18; p->text.s[ 1] = b_48_63(p);     /* lui $t8, p[48:63] */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[ 2] = 0x3718; p->text.s[ 3] = b_32_47(p);     /* ori $t8, $t8, p[32:47] */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[ 6] = 0x3718; p->text.s[ 7] = b_16_31(p);     /* ori $t8, $t8, p[16:31] */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[10] = 0x3c19; p->text.s[11] = b_48_63(entry); /* lui $t9, entry[48:63] */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[12] = 0x3739; p->text.s[13] = b_32_47(entry); /* ori $t9, $t9, entry[32:47] */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[16] = 0x3739; p->text.s[17] = b_16_31(entry); /* ori $t9, $t9, entry[16:31] */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[20] = 0x3739; p->text.s[21] = b_00_15(entry); /* ori $t9, $t9, entry[0:15] */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[24] = 0x3718; p->text.s[25] = b_00_15(p);     /* ori $t8, $t8, p[0:15] - branch delay slot */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[ 1] = 0x3c18; p->text.s[ 0] = b_48_63(p);     /* lui $t8, p[48:63] */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[ 3] = 0x3718; p->text.s[ 2] = b_32_47(p);     /* ori $t8, $t8, p[32:47] */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[ 7] = 0x3718; p->text.s[ 6] = b_16_31(p);     /* ori $t8, $t8, p[16:31] */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[11] = 0x3c19; p->text.s[10] = b_48_63(entry); /* lui $t9, entry[48:63] */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[13] = 0x3739; p->text.s[12] = b_32_47(entry); /* ori $t9, $t9, entry[32:47] */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[17] = 0x3739; p->text.s[16] = b_16_31(entry); /* ori $t9, $t9, entry[16:31] */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[21] = 0x3739; p->text.s[20] = b_00_15(entry); /* ori $t9, $t9, entry[0:15] */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.s[25] = 0x3718; p->text.s[24] = b_00_15(p);     /* ori $t8, $t8, p[0:15] - branch delay slot */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.i[ 2] = 0x0018c438; /* dsll t8,t8,0x10 */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.i[ 4] = 0x0018c438; /* dsll t8,t8,0x10 */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.i[ 7] = 0x0019cc38; /* dsll t9,t9,0x10 */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.i[ 9] = 0x0019cc38; /* dsll t9,t9,0x10 */
dyncall/dyncallback/dyncall_thunk_mips64.c:  p->text.i[11] = 0x03200008; /* jr $t9 */
dyncall/dyncallback/dyncall_callback_x64.S:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>
dyncall/dyncallback/dyncall_callback_x64.S:#include "../portasm/portasm-x64.S"
dyncall/dyncallback/dyncall_callback_x64.S:SET(FRAME_DCArgs_sysv,-128)
dyncall/dyncallback/dyncall_callback_x64.S:SET(FRAME_DCValue_sysv,-136)
dyncall/dyncallback/dyncall_callback_x64.S:SET(FRAME_DCArgs_win64,-80)
dyncall/dyncallback/dyncall_callback_x64.S:SET(FRAME_DCValue_win64,-80)
dyncall/dyncallback/dyncall_callback_x86_masm.asm:; auto-generated by gen-masm.sh
dyncall/dyncallback/dyncall_callback_x86_masm.asm:frame_CTX = -4
dyncall/dyncallback/dyncall_callback_x86_masm.asm:frame_DCArgs = -24
dyncall/dyncallback/dyncall_callback_x86_masm.asm:frame_DCValue = -32
dyncall/dyncallback/dyncall_callback_x86_masm.asm: and ESP,-16
dyncall/dyncallback/dyncall_args_sparc64.c: Description: Callback's Arguments VM - Implementation for sparc64 - not yet
dyncall/dyncallback/dyncall_args_sparc64.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_sparc64.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_sparc64.c:DCulonglong dcbArgULongLong(DCArgs* p) { return p->arg_ptr[p->i++]; }
dyncall/dyncallback/dyncall_args_sparc64.c:	return (p->i < DCARGS_SPARC64_NUM_DOUBLE_REGS)
dyncall/dyncallback/dyncall_args_sparc64.c:		? p->dreg_data[p->i++]
dyncall/dyncallback/dyncall_args_sparc64.c:		: *(DCdouble*)(p->arg_ptr + p->i++);
dyncall/dyncallback/dyncall_args_sparc64.c:	return (p->i < DCARGS_SPARC64_NUM_DOUBLE_REGS)
dyncall/dyncallback/dyncall_args_sparc64.c:		? *((DCfloat*)(p->dreg_data + p->i++)+1)  /* +1 bc single-prec fp args are */
dyncall/dyncallback/dyncall_args_sparc64.c:		: *((DCfloat*)(p->arg_ptr   + p->i++)+1); /* right aligned in 64bit slot   */
dyncall/dyncallback/dyncall_thunk_sparc32.h: Description: Thunk - Header for sparc32
dyncall/dyncallback/dyncall_thunk_sparc32.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_sparc32.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_sparc32.s: Description: Callback - Implementation for Sparc 32-bit
dyncall/dyncallback/dyncall_callback_sparc32.s:   Copyright (c) 2007-2017 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_sparc32.s:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_sparc32.s:	$i0    -> thunk
dyncall/dyncallback/dyncall_callback_sparc32.s:	$i0+24 -> cb handler
dyncall/dyncallback/dyncall_callback_sparc32.s:	$i0+28 -> userdata
dyncall/dyncallback/dyncall_callback_sparc32.s:/* Called by thunk - thunk stores pointer to DCCallback */
dyncall/dyncallback/dyncall_callback_sparc32.s:	save %sp, -104, %sp 
dyncall/dyncallback/dyncall_callback_sparc32.s:	retl                    /* Return from proc. -- jmpl %i7 + 8, %g0 */
dyncall/dyncallback/dyncall_args_ppc32.c: Description: Callback's Arguments VM - Implementation for ppc32
dyncall/dyncallback/dyncall_args_ppc32.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_ppc32.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_ppc32.c:  if (p->ireg_count < 8)
dyncall/dyncallback/dyncall_args_ppc32.c:    value = p->ireg_data[p->ireg_count++];
dyncall/dyncallback/dyncall_args_ppc32.c:    value = *( (int*) p->stackptr );
dyncall/dyncallback/dyncall_args_ppc32.c:  p->stackptr += sizeof(int);
dyncall/dyncallback/dyncall_args_ppc32.c:  if (p->ireg_count < 7) { 
dyncall/dyncallback/dyncall_args_ppc32.c:    p->ireg_count+=2;
dyncall/dyncallback/dyncall_args_ppc32.c:  } else if (p->ireg_count == 7) {
dyncall/dyncallback/dyncall_args_ppc32.c:    p->ireg_count = 8;
dyncall/dyncallback/dyncall_args_ppc32.c:  if (p->freg_count < 13) {
dyncall/dyncallback/dyncall_args_ppc32.c:    result = p->freg_data[p->freg_count++];
dyncall/dyncallback/dyncall_args_ppc32.c:    result = * ( (double*) p->stackptr );
dyncall/dyncallback/dyncall_args_ppc32.c:  p->stackptr += sizeof(double);
dyncall/dyncallback/dyncall_args_ppc32.c:  if (p->ireg_count < 8)
dyncall/dyncallback/dyncall_args_ppc32.c:    p->ireg_count++;
dyncall/dyncallback/dyncall_args_ppc32.c:  if (p->freg_count < 13) {
dyncall/dyncallback/dyncall_args_ppc32.c:    result = (DCfloat) p->freg_data[p->freg_count++];
dyncall/dyncallback/dyncall_args_ppc32.c:    result = * ( (float*) p->stackptr );
dyncall/dyncallback/dyncall_args_ppc32.c:  p->stackptr += sizeof(float);
dyncall/dyncallback/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./dyncallback
dyncall/dyncallback/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/dyncallback/dyncall_args_x86.c: Description: Callback's Arguments VM - Implementation for x86
dyncall/dyncallback/dyncall_args_x86.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_x86.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_x86.c:/* ---------------------------------------------------------------------------- */
dyncall/dyncallback/dyncall_args_x86.c:DCint      dcbArgInt     (DCArgs* p) { return p->vt->i32(p); }
dyncall/dyncallback/dyncall_args_x86.c:DClonglong dcbArgLongLong(DCArgs* p) { return p->vt->i64(p); }
dyncall/dyncallback/dyncall_args_x86.c:DCfloat    dcbArgFloat   (DCArgs* p) { return p->vt->f32(p); }
dyncall/dyncallback/dyncall_args_x86.c:DCdouble   dcbArgDouble  (DCArgs* p) { return p->vt->f64(p); }
dyncall/dyncallback/dyncall_args_x86.c:/* ---------------------------------------------------------------------------- */
dyncall/dyncallback/dyncall_args_x86.c:	return *args->stack_ptr++;
dyncall/dyncallback/dyncall_args_x86.c:	long long result = * (long long*) args->stack_ptr;
dyncall/dyncallback/dyncall_args_x86.c:	args->stack_ptr += 2;
dyncall/dyncallback/dyncall_args_x86.c:	float result = * ( (float*) args->stack_ptr );
dyncall/dyncallback/dyncall_args_x86.c:	args->stack_ptr++;
dyncall/dyncallback/dyncall_args_x86.c:	double result = * ( (double*) args->stack_ptr );
dyncall/dyncallback/dyncall_args_x86.c:	args->stack_ptr += 2;
dyncall/dyncallback/dyncall_args_x86.c:	if(args->fast_data[0]) { /* ecx register = this pointer */
dyncall/dyncallback/dyncall_args_x86.c:		int thisArg = args->fast_data[0];
dyncall/dyncallback/dyncall_args_x86.c:		args->fast_data[0] = 0;
dyncall/dyncallback/dyncall_args_x86.c:	return *args->stack_ptr++;
dyncall/dyncallback/dyncall_args_x86.c:	if(args->fast_count < 2)
dyncall/dyncallback/dyncall_args_x86.c:		return args->fast_data[args->fast_count++];
dyncall/dyncallback/dyncall_args_x86.c:	args->fast_count += 2;
dyncall/dyncallback/dyncall_callback_sparc64.s: Description: Callback - Implementation for Sparc 64-bit
dyncall/dyncallback/dyncall_callback_sparc64.s:   Copyright (c) 2017 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_sparc64.s:	$i0    -> thunk
dyncall/dyncallback/dyncall_callback_sparc64.s:	$i0+56 -> cb handler
dyncall/dyncallback/dyncall_callback_sparc64.s:	$i0+64 -> userdata
dyncall/dyncallback/dyncall_callback_sparc64.s:/* Called by thunk - thunk stores pointer to DCCallback */
dyncall/dyncallback/dyncall_callback_sparc64.s:	save %sp, -336, %sp
dyncall/dyncallback/dyncall_callback_sparc64.s:	retl                    /* Return from proc. -- jmpl %i7 + 8, %g0 */
dyncall/dyncallback/dyncall_thunk.h: Description: Thunk - Interface
dyncall/dyncallback/dyncall_thunk.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk.h: ** thunks are small-size hybrid code/data objects, created at run-time to
dyncall/dyncallback/dyncall_callback_x86.c: Description: Callback - Implementation for x86
dyncall/dyncallback/dyncall_callback_x86.c:   Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_x86.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_x86.c:  pcb->handler = handler;
dyncall/dyncallback/dyncall_callback_x86.c:  pcb->userdata = userdata;
dyncall/dyncallback/dyncall_callback_x86.c:      pcb->args_vt = &dcArgsVT_default;
dyncall/dyncallback/dyncall_callback_x86.c:      pcb->stack_cleanup = dcbCleanupSize_x86_cdecl(ptr);
dyncall/dyncallback/dyncall_callback_x86.c:      pcb->args_vt = &dcArgsVT_default;
dyncall/dyncallback/dyncall_callback_x86.c:      pcb->stack_cleanup = dcbCleanupSize_x86_std(ptr);
dyncall/dyncallback/dyncall_callback_x86.c:      pcb->args_vt = &dcArgsVT_fast_ms;
dyncall/dyncallback/dyncall_callback_x86.c:      pcb->stack_cleanup = dcbCleanupSize_x86_fast_ms(ptr);
dyncall/dyncallback/dyncall_callback_x86.c:      pcb->args_vt = &dcArgsVT_fast_gnu;
dyncall/dyncallback/dyncall_callback_x86.c:      pcb->stack_cleanup = dcbCleanupSize_x86_fast_gnu(ptr);
dyncall/dyncallback/dyncall_callback_x86.c:      pcb->args_vt = &dcArgsVT_this_ms;
dyncall/dyncallback/dyncall_callback_x86.c:      pcb->stack_cleanup = dcbCleanupSize_x86_this_ms(ptr);
dyncall/dyncallback/dyncall_callback_x86.c:  /* HACK for Plan9 - 'reuse' pcb->stack_cleanup as a flag
dyncall/dyncallback/dyncall_callback_x86.c:     takes into account an extra stack-parameter (pointer
dyncall/dyncallback/dyncall_callback_x86.c:      pcb->stack_cleanup = (*ptr == DC_SIGCHAR_LONGLONG) || (*ptr == DC_SIGCHAR_ULONGLONG);
dyncall/dyncallback/dyncall_callback_x86.c:  dcbInitThunk(&pcb->thunk, dcCallbackThunkEntry);
dyncall/dyncallback/dyncall_callback_x86.c:  return pcb->userdata;
dyncall/dyncallback/dyncall_thunk_arm32.c: Description: Thunk - Implementation for ARM32 (ARM and THUMB mode)
dyncall/dyncallback/dyncall_thunk_arm32.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_arm32.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_arm32.c:      ldr %r15, [%r15, #-4]
dyncall/dyncallback/dyncall_thunk_arm32.c:  /* Then it loads the callback 'entry' into PC. The -4 is needed, also bc */
dyncall/dyncallback/dyncall_thunk_arm32.c:  p->code[0]  = 0xe24fc008UL;  /* sub %r12, %r15, #8 */
dyncall/dyncallback/dyncall_thunk_arm32.c:  p->code[1]  = 0xe51ff004UL;  /* ldr %r15, [%r15, #-4] */
dyncall/dyncallback/dyncall_thunk_arm32.c:  p->entry = entry;
dyncall/dyncallback/dyncall_callback_arm64_masm.asm: stp x29, x30, [sp, #-208 ]!
dyncall/dyncallback/dyncall_thunk_arm32.h: Description: Thunk - Header for ARM32 (ARM and THUMB mode)
dyncall/dyncallback/dyncall_thunk_arm32.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_arm32.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_ppc64.S: Description: Callback Thunk - Implementation for PowerPC 64-bit
dyncall/dyncallback/dyncall_callback_ppc64.S:   Copyright (c) 2014-2015 Masanori Mitsugi <mitsugi@linux.vnet.ibm.com>
dyncall/dyncallback/dyncall_callback_ppc64.S:#include "../portasm/portasm-ppc64.S"
dyncall/dyncallback/dyncall_callback_ppc64.S:#define ALIGN(M,X) ( M+(X-1) & (-X) )
dyncall/dyncallback/dyncall_callback_ppc64.S:/* --------------------------------------------------------------------------
dyncall/dyncallback/dyncall_callback_ppc64.S:        r3-r10  Integer Arguments        
dyncall/dyncallback/dyncall_callback_ppc64.S:        f1-f8   Floating-point Arguments 
dyncall/dyncallback/dyncall_callback_ppc64.S:	std     r31, -8(r1)            /* store preserved registers (r31) */
dyncall/dyncallback/dyncall_callback_ppc64.S:	stdu    r1, -FRAMESIZE(r1)     /* save callers stack pointer and make new stack frame. */
dyncall/dyncallback/dyncall_callback_ppc64.S:	/* branch-and-link to DCCallback.handler */
dyncall/dyncallback/dyncall_callback_ppc64.S:	ld     r31, -8(r1)       /* restore preserved registers */
dyncall/dyncallback/dyncall_callback_mips_n64.S: Description: Callback Thunk - Implementation for mips64 n64
dyncall/dyncallback/dyncall_callback_mips_n64.S:   Copyright (c) 2016-2018 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_mips_n64.S:		$t8    -> thunk
dyncall/dyncallback/dyncall_callback_mips_n64.S:		$t8+56 -> cb handler
dyncall/dyncallback/dyncall_callback_mips_n64.S:		$t8+64 -> userdata
dyncall/dyncallback/dyncall_callback_mips_n64.S:/* Frame size is 160b for hard- and 128b for soft-float, as follows: */
dyncall/dyncallback/dyncall_callback_mips_n64.S:SP_LR     = SP_SP-8
dyncall/dyncallback/dyncall_callback_mips_n64.S:SP_RVAL   = SP_SP-16
dyncall/dyncallback/dyncall_callback_mips_n64.S:SP_ARG_SP = SP_SP-24
dyncall/dyncallback/dyncall_callback_mips_n64.S:SP_ARG_RC = SP_SP-32
dyncall/dyncallback/dyncall_callback_mips_n64.S:	daddiu $sp, $sp, -SP_SP   /* open frame */
dyncall/dyncallback/dyncall_callback_mips_n64.S:	                      /* code below doesn't use $fp though, as n/a with -O1 */
dyncall/dyncallback/dyncall_callback_mips_n64.S:	/* Copy result in corresponding registers $2-$3 ($v0-$v1) and $f0 */
dyncall/dyncallback/dyncall_args_ppc32.h: Description: Callback's Arguments VM - Header for ppc32
dyncall/dyncallback/dyncall_args_ppc32.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_ppc32.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_sparc64.h: Description: Callback's Arguments VM - Header for sparc64 - not yet
dyncall/dyncallback/dyncall_args_sparc64.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_sparc64.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args.h: Description: Callback's Arguments VM - Interface
dyncall/dyncallback/dyncall_args.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/Makefile.generic:CFLAGS += -I${TOP}/dyncall 
dyncall/dyncallback/Makefile.generic:	rm -f ${OBJS} ${LIB}
dyncall/dyncallback/Makefile.generic:	mkdir -p ${PREFIX}/lib
dyncall/dyncallback/Makefile.generic:	mkdir -p ${PREFIX}/include
dyncall/dyncallback/dyncall_callback_ppc64.c: Description: Callback - Implementation Header for ppc64
dyncall/dyncallback/dyncall_callback_ppc64.c:   Copyright (c) 2014-2016 Masanori Mitsugi <mitsugi@linux.vnet.ibm.com>
dyncall/dyncallback/dyncall_callback_ppc64.c:{                                   /* ------------------+------------------ */
dyncall/dyncallback/dyncall_callback_ppc64.c:  pcb->handler  = handler;
dyncall/dyncallback/dyncall_callback_ppc64.c:  pcb->userdata = userdata;
dyncall/dyncallback/dyncall_callback_ppc64.c:  dcbInitThunk(&pcb->thunk, dcCallbackThunkEntry);
dyncall/dyncallback/dyncall_callback_ppc64.c:  return pcb->userdata;
dyncall/dyncallback/dyncall_callback_x86.S:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>
dyncall/dyncallback/dyncall_callback_x86.S:#include "../portasm/portasm-x86.S"
dyncall/dyncallback/dyncall_callback_x86.S:frame_CTX     = -4
dyncall/dyncallback/dyncall_callback_x86.S:frame_DCArgs  = -24
dyncall/dyncallback/dyncall_callback_x86.S:frame_DCValue = -32
dyncall/dyncallback/dyncall_callback_x86.S:	PUSH(ECX)				/* stack-ptr */
dyncall/dyncallback/dyncall_callback_x86.S:	PUSH(DWORD(EAX,CTX_pargsvt))		/* vtbl-ptr */
dyncall/dyncallback/dyncall_callback_x86.S:	ANDL(LIT(-16),ESP)			/* align stack to 16 bytes. */
dyncall/dyncallback/gen-masm.sh:../portasm/gen-masm.sh dyncall_callback_x86 _masm
dyncall/dyncallback/gen-masm.sh:../portasm/gen-masm.sh dyncall_callback_x64 _masm
dyncall/dyncallback/dyncall_callback_arm32_arm_gas.S: Description: Callback Thunk - Implementation for ARM32 (ARM mode)
dyncall/dyncallback/dyncall_callback_arm32_arm_gas.S:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_arm32_arm_gas.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_arm32_arm_gas.S:/* Called by thunk - thunk stores pointer to DCCallback in r12 */
dyncall/dyncallback/dyncall_callback_arm32_arm_gas.S:	stmdb	%r13, {%r4-%r11, %r13, %r14}	/* Permanent registers and stack pointer, etc... -> save area on stack (except counter). */
dyncall/dyncallback/dyncall_callback_arm32_arm_gas.S:	fstmdbd	%r13!, {d0-d7}					/* Store all fp-registers in DCArgs' f[16] */
dyncall/dyncallback/dyncall_callback_arm32_arm_gas.S:	stmdb	%r13!, {%r0-%r4, %r11}			/* Spill first 4 args to DCArgs, along with reg_count (init to 0) and (stack) pointer to remaining args. */
dyncall/dyncallback/dyncall_callback_arm32_arm_gas.S:	mov		%r14, %r15						/* Branch return address(r15) -> link register (r14) -- r15 always points to address of current + 2 instructions (= Epilog code). */
dyncall/dyncallback/dyncall_callback_arm32_arm_gas.S:	ldmdb	%r11, {%r4-%r11, %r13, %r15}	/* Restore permanent registers (restore stack ptr and program counter).@@@db not needed since we rewrite r13? */
dyncall/dyncallback/dyncall_callback_arm32.c: Description: Callback - Implementation for ARM32 (ARM and THUMB mode)
dyncall/dyncallback/dyncall_callback_arm32.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_arm32.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_arm32.c:  pcb->handler  = handler;
dyncall/dyncallback/dyncall_callback_arm32.c:  pcb->userdata = userdata;
dyncall/dyncallback/dyncall_callback_arm32.c:  dcbInitThunk(&pcb->thunk, dcCallbackThunkEntry);
dyncall/dyncallback/dyncall_callback_arm32.c:  return pcb->userdata;
dyncall/dyncallback/mkfile:# Copyright (c) 2013 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncallback/mkfile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_x86.h: Description: Thunk - Header for x86
dyncall/dyncallback/dyncall_thunk_x86.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_x86.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_arch.S: Description: Callback Thunk - Implementation Back-end selector
dyncall/dyncallback/dyncall_callback_arch.S:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_arch.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_arch.S:/* Use .note.GNU-stack to explicitly indicate a non-exec stack, b/c of bad   */
dyncall/dyncallback/dyncall_callback_arch.S:.section .note.GNU-stack,"",%progbits
dyncall/dyncallback/dyncall_callback_mips_o32.S: Description: Callback Thunk - Implementation mips32 o32
dyncall/dyncallback/dyncall_callback_mips_o32.S:   Copyright (c) 2016 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_mips_o32.S:		$t4    -> thunk
dyncall/dyncallback/dyncall_callback_mips_o32.S:		$t4+20 -> cb handler
dyncall/dyncallback/dyncall_callback_mips_o32.S:		$t4+24 -> userdata
dyncall/dyncallback/dyncall_callback_mips_o32.S:/* Called by thunk - thunk stores pointer to DCCallback in $12 ($t4), and */
dyncall/dyncallback/dyncall_callback_mips_o32.S:	                    /* code below doesn't use $fp though, as n/a with -O1 */
dyncall/dyncallback/dyncall_callback_mips_o32.S:	/* For $4-$7 ($a0-$a3), use dedicated spill area (caller doesn't spill, but */
dyncall/dyncallback/dyncall_callback_mips_o32.S:	s.d $f12, 40($sp)   /* -16($fp) */
dyncall/dyncallback/dyncall_callback_mips_o32.S:	s.d $f14, 48($sp)   /*  -8($fp) */
dyncall/dyncallback/dyncall_callback_mips_o32.S:	/* stackptr to the area where the non-float args start (which is at $fp). */
dyncall/dyncallback/dyncall_callback_mips_o32.S:	addiu $4, $sp, 56   /* <- non-$fp replacement for: */
dyncall/dyncallback/dyncall_callback_mips_o32.S:	sw    $4, 28($sp)   /* <-   sw $fp, 28($sp)        */
dyncall/dyncallback/dyncall_callback_mips_o32.S:	sw $zero, 24($sp)   /* init num float-regs (unused for soft-float) */
dyncall/dyncallback/dyncall_callback_mips_o32.S:	/* Handle single precision soft-float retvals differently on big-endian */
dyncall/dyncallback/dyncall_callback_mips_o32.S:	/* targets as they are right-justified in their 8b stack lots           */
dyncall/dyncallback/dyncall_callback_mips_o32.S:	xori  $4, $2, 'f'   /* $4 = 0 if cb-handler returned 'f' in $2 */
dyncall/dyncallback/dyncall_thunk_x86.c: Description: Thunk - Implementation for x86
dyncall/dyncallback/dyncall_thunk_x86.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_x86.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_x86.c:  p->code_load  = 0xb8909090UL; /* nop;nop;nop;mov %eax, ... */
dyncall/dyncallback/dyncall_thunk_x86.c:  p->addr_self  = p;
dyncall/dyncallback/dyncall_thunk_x86.c:  p->code_jump  = 0x900C60ffUL; /* jmp [%eax+12] ; nop */
dyncall/dyncallback/dyncall_thunk_x86.c:  p->addr_entry = entry;
dyncall/dyncallback/dyncall_callback.c: Description: Callback - Implementation back-end selector
dyncall/dyncallback/dyncall_callback.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_x86.h: Description: Callback's Arguments VM - Header for x86
dyncall/dyncallback/dyncall_args_x86.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_x86.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_x86.h:	/* fast data / 'this-ptr' info */
dyncall/dyncallback/dyncall_alloc_wx_malloc.c: Description: Allocate write/executable memory - Fallback implementation based
dyncall/dyncallback/dyncall_alloc_wx_malloc.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_alloc_wx_malloc.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_ppc32_apple.s: Description: Callback Thunk - PowerPC 32-bit System V ABI
dyncall/dyncallback/dyncall_callback_ppc32_apple.s:   Copyright (c) 2007-2015 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_ppc32_apple.s:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_ppc32_apple.s:/* Callback Thunk Entry code for PowerPC 32-bit Darwin/Apple Mac OS X. */
dyncall/dyncallback/dyncall_callback_ppc32_apple.s:FRAME_SIZE = ((LOCALS_OFFSET+LOCALS_SIZE)+15 & (-16))
dyncall/dyncallback/dyncall_callback_ppc32_apple.s:	stwu    r1, -FRAME_SIZE(r1)   /* save callers stack pointer and make new stack frame. */
dyncall/dyncallback/dyncall_callback_ppc32_apple.s:	/* branch-and-link to DCCallback.handler */
dyncall/dyncallback/dyncall_alloc_wx.h: Description: Allocate write/executable memory - Interface
dyncall/dyncallback/dyncall_alloc_wx.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_alloc_wx.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_ppc64.c: Description: Callback's Arguments VM - Implementation for ppc64
dyncall/dyncallback/dyncall_args_ppc64.c:   Copyright (c) 2014-2015 Masanori Mitsugi <mitsugi@linux.vnet.ibm.com>
dyncall/dyncallback/dyncall_args_ppc64.c:  if (p->ireg_count < 8) {
dyncall/dyncallback/dyncall_args_ppc64.c:    value = p->ireg_data[p->ireg_count++];
dyncall/dyncallback/dyncall_args_ppc64.c:    value = *( (long long*) p->stackptr );
dyncall/dyncallback/dyncall_args_ppc64.c:  p->stackptr += sizeof(long long);
dyncall/dyncallback/dyncall_args_ppc64.c:  if (p->freg_count < 13) {
dyncall/dyncallback/dyncall_args_ppc64.c:    result = p->freg_data[p->freg_count++];
dyncall/dyncallback/dyncall_args_ppc64.c:    if (p->ireg_count < 8) {
dyncall/dyncallback/dyncall_args_ppc64.c:      p->ireg_count++;
dyncall/dyncallback/dyncall_args_ppc64.c:    result = * ( (double*) p->stackptr );
dyncall/dyncallback/dyncall_args_ppc64.c:  p->stackptr += sizeof(double);
dyncall/dyncallback/dyncall_args_ppc64.c:  if (p->freg_count < 13) {
dyncall/dyncallback/dyncall_args_ppc64.c:    result = (float)p->freg_data[p->freg_count++];
dyncall/dyncallback/dyncall_args_ppc64.c:    if (p->ireg_count < 8) {
dyncall/dyncallback/dyncall_args_ppc64.c:      p->ireg_count++;
dyncall/dyncallback/dyncall_args_ppc64.c:    sf = * ( (struct sf*) p->stackptr );
dyncall/dyncallback/dyncall_args_ppc64.c:  p->stackptr += sizeof(double);
dyncall/dyncallback/dyncall_callback_sparc64.c: Description: Callback - Implementation for sparc64
dyncall/dyncallback/dyncall_callback_sparc64.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_sparc64.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_sparc64.c:  pcb->handler  = handler;
dyncall/dyncallback/dyncall_callback_sparc64.c:  pcb->userdata = userdata;
dyncall/dyncallback/dyncall_callback_sparc64.c:  dcbInitThunk(&pcb->thunk, dcCallbackThunkEntry);
dyncall/dyncallback/dyncall_callback_sparc64.c:  return pcb->userdata;
dyncall/dyncallback/dyncall_args_x64.h: Description: Callback's Arguments VM - Header for x64
dyncall/dyncallback/dyncall_args_x64.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_x64.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_mips_eabi_gas.s: Description: Callback Thunk - Implementation for mips32 eabi
dyncall/dyncallback/dyncall_callback_mips_eabi_gas.s:   Copyright (c) 2016 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_mips_eabi_gas.s:	$t4    -> thunk
dyncall/dyncallback/dyncall_callback_mips_eabi_gas.s:	$t4+20 -> cb handler
dyncall/dyncallback/dyncall_callback_mips_eabi_gas.s:	$t4+24 -> userdata
dyncall/dyncallback/dyncall_callback_mips_eabi_gas.s:/* Called by thunk - thunk stores pointer to DCCallback in $12 ($t4), and */
dyncall/dyncallback/dyncall_callback_mips_eabi_gas.s:	                    /* code below doesn't use $fp though, as n/a with -O1 */
dyncall/dyncallback/dyncall_callback_mips_eabi_gas.s:	/* Copy result in corresponding registers $2-$3 ($v0-$v1) and $f0 */
dyncall/dyncallback/dyncall_callback.h: Description: Callback - Interface
dyncall/dyncallback/dyncall_callback.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_ppc64.c: Description: Thunk - Implementation for ppc64
dyncall/dyncallback/dyncall_thunk_ppc64.c:   Copyright (c) 2014-2015 Masanori Mitsugi <mitsugi@linux.vnet.ibm.com>
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->thunk_entry  = (void *)&(p->code_load_hi);
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->toc_thunk    = ((long)(p->thunk_entry) & 0xffffffff00000000UL);
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->code_load_hi = 0x644bU;     /* oris  r11, r2, HI16(p) */
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->addr_self_hi = HI16(p);
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->code_load_lo = 0x616bU;     /* ori   r11,r11, LO16(p) */
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->addr_self_lo = LO16(p);
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->code_jump[0] = 0xe98b0030U; /* ld    r12,48(r11) */
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->code_jump[1] = 0xe84b0038U; /* ld    r2,56(r11) */
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->code_jump[2] = 0x7d8903a6U; /* mtclr r12 */
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->code_jump[3] = 0x4e800420U; /* bctr */
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->addr_entry   = (void *)*((long *)entry);
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->toc_entry    = *((long *)(entry + 8));
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->code_load_hist = 0x3d60U;     /* lis    r11,HIST16(p) */
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->addr_self_hist = HIST16(p);
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->code_load_hier = 0x616bU;     /* ori    r11,r11, HIER16(p) */
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->addr_self_hier = HIER16(p);
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->code_rot       = 0x796b07c6U; /* rldicr r11,r11,32,31 */
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->code_load_hi   = 0x656bU;     /* oris   r11,r11, HI16(p) */
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->addr_self_hi   = HI16(p);
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->code_load_lo   = 0x616bU;     /* ori    r11,r11, LO16(p) */
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->addr_self_lo   = LO16(p);
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->code_jump[0]   = 0xe98b0028U; /* ld     r12,40(r11) */
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->code_jump[1]   = 0x7d8903a6U; /* mtclr  r12 */
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->code_jump[2]   = 0x4e800420U; /* bctr */
dyncall/dyncallback/dyncall_thunk_ppc64.c:  p->addr_entry     = (void *)(entry);
dyncall/dyncallback/dyncall_args_sparc32.c: Description: Callback's Arguments VM - Implementation for sparc32 - not yet
dyncall/dyncallback/dyncall_args_sparc32.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_sparc32.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_sparc32.c:/* Compiler aligns this to 8-byte boundaries, b/c of dword members, a fact needed below */
dyncall/dyncallback/dyncall_args_sparc32.c:  return args->arg_ptr++;
dyncall/dyncallback/dyncall_args_sparc32.c:  void *p = args->arg_ptr;
dyncall/dyncallback/dyncall_args_sparc32.c:  args->arg_ptr += 2;
dyncall/dyncallback/dyncall_args_sparc32.c:/* copy words so that dwords are 8-byte aligned, for 64bit value indirection; unaligned
dyncall/dyncallback/dyncall_callback_ppc32.S: Description: Callback Thunk Entry for PowerPC 32-bit System V Big-Endian ABI
dyncall/dyncallback/dyncall_callback_ppc32.S:   Copyright (c) 2015-2018 Daniel Adler <dadler@uni-goettingen.de>
dyncall/dyncallback/dyncall_callback_ppc32.S:#include "../portasm/portasm-ppc.S"
dyncall/dyncallback/dyncall_callback_ppc32.S:#define ALIGN(M,X) ( M+(X-1) & (-X) )
dyncall/dyncallback/dyncall_callback_ppc32.S:/* --------------------------------------------------------------------------
dyncall/dyncallback/dyncall_callback_ppc32.S:	r3-r10  Integer Arguments        
dyncall/dyncallback/dyncall_callback_ppc32.S:	f1-f8   Floating-point Arguments 
dyncall/dyncallback/dyncall_callback_ppc32.S:	stwu    r1, -FRAMESIZE(r1)
dyncall/dyncallback/dyncall_callback_ppc32.S:	/* branch-and-link to DCCallback.handler */
dyncall/dyncallback/dyncall_callback_sparc32.c: Description: Callback - Implementation for sparc32
dyncall/dyncallback/dyncall_callback_sparc32.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_sparc32.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_sparc32.c:  pcb->handler  = handler;
dyncall/dyncallback/dyncall_callback_sparc32.c:  pcb->userdata = userdata;
dyncall/dyncallback/dyncall_callback_sparc32.c:  dcbInitThunk(&pcb->thunk, dcCallbackThunkEntry);
dyncall/dyncallback/dyncall_callback_sparc32.c:  return pcb->userdata;
dyncall/dyncallback/dyncall_callback_x64.c: Description: Callback - Implementation for x64
dyncall/dyncallback/dyncall_callback_x64.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_x64.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_x64.c:  pcb->handler  = handler;
dyncall/dyncallback/dyncall_callback_x64.c:  pcb->userdata = userdata;
dyncall/dyncallback/dyncall_callback_x64.c:  dcbInitThunk(&pcb->thunk, dcCallback_x64_win64); 
dyncall/dyncallback/dyncall_callback_x64.c:  dcbInitThunk(&pcb->thunk, dcCallback_x64_sysv); 
dyncall/dyncallback/dyncall_callback_x64.c:  return pcb->userdata;
dyncall/dyncallback/dyncall_args_ppc32_sysv.c: Description: Callback's Args Implementation for PowerPC 32-bit System V ABI
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:   Copyright (c) 2015-2018 Daniel Adler <dadler@uni-goettingen.de>
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:  if (p->ireg_count < 8)
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    value = p->ireg_data[p->ireg_count++];
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    value = *( (int*) p->stackptr );
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    p->stackptr += sizeof(int);
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:  if (p->ireg_count < 7)
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    p->ireg_count = (p->ireg_count + 1) & -2;
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    value = * (unsigned long long*) ( & p->ireg_data[p->ireg_count] );
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    p->ireg_count += 2;
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    p->ireg_count = 8;
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    /* 64-bit values are naturally aligned on stack */
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    p->stackptr = (unsigned char*) ( ( ( (ptrdiff_t) (p->stackptr) ) + 7) & ( (ptrdiff_t) -8 ) );
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    value = * ( (unsigned long long*) p->stackptr );
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    p->stackptr += sizeof(unsigned long long);
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:  if (p->freg_count < 8) {
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    result = p->freg_data[p->freg_count++];
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    p->stackptr = (unsigned char*) ( ( ( (ptrdiff_t) (p->stackptr) ) + 7) & ( (ptrdiff_t) -8 ) );
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    result = * ( (double*) p->stackptr );
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    p->stackptr += sizeof(double);
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:  if (p->freg_count < 8) {
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    result = (DCfloat) p->freg_data[p->freg_count++];
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    result = * ( (float*) p->stackptr );
dyncall/dyncallback/dyncall_args_ppc32_sysv.c:    p->stackptr += sizeof(float);
dyncall/dyncallback/dyncall_thunk_sparc64.h: Description: Thunk - Header for sparc64
dyncall/dyncallback/dyncall_thunk_sparc64.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_sparc64.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk.c: Description: Thunk - Implementation Back-end selection
dyncall/dyncallback/dyncall_thunk.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_sparc32.h: Description: Callback's Arguments VM - Header for sparc32
dyncall/dyncallback/dyncall_args_sparc32.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_sparc32.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_sparc32.c: Description: Thunk - Implementation for sparc32
dyncall/dyncallback/dyncall_thunk_sparc32.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_sparc32.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_sparc32.c:                      ; jump - write link to %g0, effectively discarding it; also nop for delay slot
dyncall/dyncallback/dyncall_thunk_sparc32.c:  p->code[0] = 0x03000000 | ((unsigned int)p >> 10);       /* sethi %hi(p), %g1      -- hi 22 bits */
dyncall/dyncallback/dyncall_thunk_sparc32.c:  p->code[1] = 0x82106000 | ((unsigned int)p & 0x3ff);     /* or %g1, <p&0x3ff>, %g1 -- lo 10 bits */
dyncall/dyncallback/dyncall_thunk_sparc32.c:  p->code[2] = 0x05000000 | ((unsigned int)entry >> 10);   /* sethi %hi(entry), %g2                */
dyncall/dyncallback/dyncall_thunk_sparc32.c:  p->code[3] = 0x8410a000 | ((unsigned int)entry & 0x3ff); /* or %g2, <entry&0x3ff>, %g2           */
dyncall/dyncallback/dyncall_thunk_sparc32.c:  p->code[4] = 0x81c08000;                                 /* jmpl %g2, %g0  -- discards link addr */
dyncall/dyncallback/dyncall_thunk_sparc32.c:  p->code[5] = 0x01000000;                                 /* nop                                  */
dyncall/dyncallback/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/dyncallback/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/Nmakefile:	$(AR) -rc $(ARFLAGS) "$@" $(OBJS)
dyncall/dyncallback/Nmakefile:#	$(AR) -rc $(ARFLAGS) "$@" $(OBJS)
dyncall/dyncallback/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/dyncallback/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:# Disable VCS-based implicit rules.
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_callback_arch.S.o"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_callback_arch.S.o -MF CMakeFiles/dyncallback_s.dir/dyncall_callback_arch.S.o.d -o CMakeFiles/dyncallback_s.dir/dyncall_callback_arch.S.o -c /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_callback_arch.S
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dyncallback_s.dir/dyncall_callback_arch.S.i"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_callback_arch.S > CMakeFiles/dyncallback_s.dir/dyncall_callback_arch.S.i
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dyncallback_s.dir/dyncall_callback_arch.S.s"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_callback_arch.S -o CMakeFiles/dyncallback_s.dir/dyncall_callback_arch.S.s
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Building C object dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_thunk.c.o"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_thunk.c.o -MF CMakeFiles/dyncallback_s.dir/dyncall_thunk.c.o.d -o CMakeFiles/dyncallback_s.dir/dyncall_thunk.c.o -c /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_thunk.c
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dyncallback_s.dir/dyncall_thunk.c.i"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_thunk.c > CMakeFiles/dyncallback_s.dir/dyncall_thunk.c.i
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dyncallback_s.dir/dyncall_thunk.c.s"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_thunk.c -o CMakeFiles/dyncallback_s.dir/dyncall_thunk.c.s
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Building C object dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_alloc_wx.c.o"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_alloc_wx.c.o -MF CMakeFiles/dyncallback_s.dir/dyncall_alloc_wx.c.o.d -o CMakeFiles/dyncallback_s.dir/dyncall_alloc_wx.c.o -c /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_alloc_wx.c
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dyncallback_s.dir/dyncall_alloc_wx.c.i"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_alloc_wx.c > CMakeFiles/dyncallback_s.dir/dyncall_alloc_wx.c.i
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dyncallback_s.dir/dyncall_alloc_wx.c.s"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_alloc_wx.c -o CMakeFiles/dyncallback_s.dir/dyncall_alloc_wx.c.s
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_4) "Building C object dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_args.c.o"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_args.c.o -MF CMakeFiles/dyncallback_s.dir/dyncall_args.c.o.d -o CMakeFiles/dyncallback_s.dir/dyncall_args.c.o -c /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_args.c
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dyncallback_s.dir/dyncall_args.c.i"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_args.c > CMakeFiles/dyncallback_s.dir/dyncall_args.c.i
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dyncallback_s.dir/dyncall_args.c.s"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_args.c -o CMakeFiles/dyncallback_s.dir/dyncall_args.c.s
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_5) "Building C object dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_callback.c.o"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -MD -MT dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_callback.c.o -MF CMakeFiles/dyncallback_s.dir/dyncall_callback.c.o.d -o CMakeFiles/dyncallback_s.dir/dyncall_callback.c.o -c /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_callback.c
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/dyncallback_s.dir/dyncall_callback.c.i"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_callback.c > CMakeFiles/dyncallback_s.dir/dyncall_callback.c.i
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/dyncallback_s.dir/dyncall_callback.c.s"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_callback.c -o CMakeFiles/dyncallback_s.dir/dyncall_callback.c.s
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_6) "Linking C static library libdyncallback_s.a"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && $(CMAKE_COMMAND) -P CMakeFiles/dyncallback_s.dir/cmake_clean_target.cmake
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/dyncallback_s.dir/link.txt --verbose=$(VERBOSE)
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/dyncallback && $(CMAKE_COMMAND) -P CMakeFiles/dyncallback_s.dir/cmake_clean.cmake
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/dyncallback /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/dyncallback /home/chenningcong/Desktop/dyncall-1.2/dyncallback/CMakeFiles/dyncallback_s.dir/DependInfo.cmake --color=$(COLOR)
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/flags.make:C_INCLUDES = -I/home/chenningcong/Desktop/dyncall-1.2/dyncall
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/flags.make:C_FLAGS =   -fPIC
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_alloc_wx.c" "dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_alloc_wx.c.o" "gcc" "dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_alloc_wx.c.o.d"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_args.c" "dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_args.c.o" "gcc" "dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_args.c.o.d"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_callback.c" "dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_callback.c.o" "gcc" "dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_callback.c.o.d"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_callback_arch.S" "dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_callback_arch.S.o" "gcc" "dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_callback_arch.S.o.d"
dyncall/dyncallback/CMakeFiles/dyncallback_s.dir/DependInfo.cmake:  "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_thunk.c" "dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_thunk.c.o" "gcc" "dyncallback/CMakeFiles/dyncallback_s.dir/dyncall_thunk.c.o.d"
dyncall/dyncallback/dyncall_thunk_x64.c: Description: Thunk - Implementation for x64
dyncall/dyncallback/dyncall_thunk_x64.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_x64.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_x64.c:  p->code[0] = 0xfffffffff9058d48ULL;
dyncall/dyncallback/dyncall_thunk_x64.c:  p->code[1] = 0x9090900000000325ULL;
dyncall/dyncallback/dyncall_thunk_x64.c:  p->entry   = entry;
dyncall/dyncallback/dyncall_thunk_sparc64.c: Description: Thunk - Implementation for sparc64
dyncall/dyncallback/dyncall_thunk_sparc64.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_sparc64.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_sparc64.c:                      ; jump - write link to %g0, effectively discarding it; also nop for delay slot
dyncall/dyncallback/dyncall_thunk_sparc64.c:  p->code[ 0] = 0x03000000 | (t.x[0] >> 10);      /* sethi %hi(p), %g1      -- hi 22 bits */
dyncall/dyncallback/dyncall_thunk_sparc64.c:  p->code[ 1] = 0x82106000 | (t.x[0] & 0x3ff);    /* or %g1, <p&0x3ff>, %g1 -- lo 10 bits */
dyncall/dyncallback/dyncall_thunk_sparc64.c:  p->code[ 2] = 0x83287020;                       /* sllx %g1, 0x20, %g1                  */
dyncall/dyncallback/dyncall_thunk_sparc64.c:  p->code[ 3] = 0x21000000 | (t.x[1] >> 10);      /* sethi %hi(p), %l0                    */
dyncall/dyncallback/dyncall_thunk_sparc64.c:  p->code[ 4] = 0xa0142000 | (t.x[1] & 0x3ff);    /* or %l0, <p&0x3ff>, %l0               */
dyncall/dyncallback/dyncall_thunk_sparc64.c:  p->code[ 5] = 0x82040001;                       /* add %l0, %g1, %g1                    */
dyncall/dyncallback/dyncall_thunk_sparc64.c:  p->code[ 6] = 0x05000000 | (e.x[0] >> 10);      /* sethi %hi(entry), %g2                */
dyncall/dyncallback/dyncall_thunk_sparc64.c:  p->code[ 7] = 0x8410a000 | (e.x[0] & 0x3ff);    /* or %g2, <entry&0x3ff>, %g2           */
dyncall/dyncallback/dyncall_thunk_sparc64.c:  p->code[ 8] = 0x8528b020;                       /* sllx %g2, 0x20, %g2                  */
dyncall/dyncallback/dyncall_thunk_sparc64.c:  p->code[ 9] = 0x21000000 | (e.x[1] >> 10);      /* sethi %hi(entry), %l0                */
dyncall/dyncallback/dyncall_thunk_sparc64.c:  p->code[10] = 0xa0142000 | (e.x[1] & 0x3ff);    /* or %l0, <entry&0x3ff>, %l0           */
dyncall/dyncallback/dyncall_thunk_sparc64.c:  p->code[11] = 0x84040002;                       /* add %l0, %g2, %g2                    */
dyncall/dyncallback/dyncall_thunk_sparc64.c:  p->code[12] = 0x81c08000;                       /* jmpl %g2, %g0  -- discards link addr */
dyncall/dyncallback/dyncall_thunk_sparc64.c:  p->code[13] = 0x01000000;                       /* nop                                  */
dyncall/dyncallback/dyncall_callback_mips_n32.S: Description: Callback Thunk - Implementation for mips64 n32
dyncall/dyncallback/dyncall_callback_mips_n32.S:   Copyright (c) 2016 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_ppc64.h: Description: Callback's Arguments VM - Header for ppc64
dyncall/dyncallback/dyncall_args_ppc64.h:   Copyright (c) 2014-2015 Masanori Mitsugi <mitsugi@linux.vnet.ibm.com>
dyncall/dyncallback/dyncall_args.c: Description: Callback's Arguments VM - Implementation back-end selector
dyncall/dyncallback/dyncall_args.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_alloc_wx.c: Description: Allocate write/executable memory - Implementation back-end selector (mmap or win32)
dyncall/dyncallback/dyncall_alloc_wx.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_alloc_wx.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_mips64.c: Description: Callback's Arguments VM - Implementation for MIPS64 n32&n64
dyncall/dyncallback/dyncall_args_mips64.c:   Copyright (c) 2016-2018 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_mips64.c:  if(p->reg_count < DCARGS_MIPS_NUM_REGS)
dyncall/dyncallback/dyncall_args_mips64.c:    value = p->ireg_data[p->reg_count++];
dyncall/dyncallback/dyncall_args_mips64.c:    value = *((DClonglong*)p->stackptr);
dyncall/dyncallback/dyncall_args_mips64.c:    p->stackptr += sizeof(DClonglong);
dyncall/dyncallback/dyncall_args_mips64.c:  if(p->reg_count < DCARGS_MIPS_NUM_REGS)
dyncall/dyncallback/dyncall_args_mips64.c:    result = p->freg_data[p->reg_count++];
dyncall/dyncallback/dyncall_args_mips64.c:    result = *((DCdouble*)p->stackptr);
dyncall/dyncallback/dyncall_args_mips64.c:    p->stackptr += sizeof(DCdouble);
dyncall/dyncallback/dyncall_args_mips64.c:  if(p->reg_count < DCARGS_MIPS_NUM_REGS) {
dyncall/dyncallback/dyncall_args_mips64.c:    result = ((DCfloat*)&p->freg_data[p->reg_count++])
dyncall/dyncallback/dyncall_args_mips64.c:      [1]; /* single precision floats are right-justified in big-endian registers */
dyncall/dyncallback/dyncall_args_mips64.c:    result = *((DCfloat*)p->stackptr); /* single precision floats are left-justified on stack in 64bit slots */
dyncall/dyncallback/dyncall_args_mips64.c:    p->stackptr += sizeof(DCdouble);
dyncall/dyncallback/dyncall_args_arm32.h: Description: Callback's Arguments VM - Header for ARM32 (ARM and THUMB mode)
dyncall/dyncallback/dyncall_args_arm32.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_arm32.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/Makefile.embedded:CFLAGS += -I../dyncall
dyncall/dyncallback/Makefile.embedded:	rm -f ${OBJS} ${TARGET}
dyncall/dyncallback/Makefile.embedded:	mkdir -p ${DESTDIR}${PREFIX}/include
dyncall/dyncallback/Makefile.embedded:	mkdir -p ${DESTDIR}${PREFIX}/lib
dyncall/dyncallback/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/dyncallback
dyncall/dyncallback/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/dyncallback/cmake_install.cmake:  file(INSTALL DESTINATION "${CMAKE_INSTALL_PREFIX}/lib" TYPE STATIC_LIBRARY FILES "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/libdyncallback_s.a")
dyncall/dyncallback/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_thunk.h"
dyncall/dyncallback/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_thunk_x86.h"
dyncall/dyncallback/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_thunk_ppc32.h"
dyncall/dyncallback/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_thunk_x64.h"
dyncall/dyncallback/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_thunk_arm32.h"
dyncall/dyncallback/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_alloc_wx.h"
dyncall/dyncallback/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_args.h"
dyncall/dyncallback/cmake_install.cmake:    "/home/chenningcong/Desktop/dyncall-1.2/dyncallback/dyncall_callback.h"
dyncall/dyncallback/dyncall_alloc_wx_win32.c: Description: Allocate write/executable memory  - Implementation for win32 platform
dyncall/dyncallback/dyncall_alloc_wx_win32.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_alloc_wx_win32.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_alloc_wx_win32.c:  if (p == NULL) return -1;
dyncall/dyncallback/dyncall_thunk_x64.h: Description: Thunk - Header for x64
dyncall/dyncallback/dyncall_thunk_x64.h:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_x64.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_mips_o32.c: Description: Callback's Arguments VM - Implementation for MIPS o32
dyncall/dyncallback/dyncall_args_mips_o32.c:   Copyright (c) 2013-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_mips_o32.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_mips_o32.c:  p->freg_count = 2;
dyncall/dyncallback/dyncall_args_mips_o32.c:  value = *((int*)p->stackptr);
dyncall/dyncallback/dyncall_args_mips_o32.c:  p->stackptr += sizeof(int);
dyncall/dyncallback/dyncall_args_mips_o32.c:  p->stackptr += ((int)p->stackptr & 4); /* Skip one slot if not aligned. */
dyncall/dyncallback/dyncall_args_mips_o32.c:  if(p->freg_count < 2) {
dyncall/dyncallback/dyncall_args_mips_o32.c:	/* relative to a diverging p->stackptr, we need consider this. Only works    */
dyncall/dyncallback/dyncall_args_mips_o32.c:    result = ((DCfloat*)(p->stackptr + ((int)p->stackptr & 4)) - 4) /* '-4' b/c those regs are stored right before the args */
dyncall/dyncallback/dyncall_args_mips_o32.c:	++p->freg_count;
dyncall/dyncallback/dyncall_args_mips_o32.c:    result = *((DCfloat*)p->stackptr);
dyncall/dyncallback/dyncall_args_mips_o32.c:  p->stackptr += sizeof(DCfloat);
dyncall/dyncallback/dyncall_args_mips_o32.c:  p->stackptr += ((int)p->stackptr & 4); /* Skip one slot if not aligned. */
dyncall/dyncallback/dyncall_args_mips_o32.c:  if(p->freg_count < 2) {
dyncall/dyncallback/dyncall_args_mips_o32.c:    /*result = *((DCdouble*)p->stackptr-2); this changes the value, slightly*/
dyncall/dyncallback/dyncall_args_mips_o32.c:    d.f[0] = ((DCfloat*)p->stackptr-4)[0]; /* '-4' b/c those regs are stored right before the args */
dyncall/dyncallback/dyncall_args_mips_o32.c:    d.f[1] = ((DCfloat*)p->stackptr-4)[1];
dyncall/dyncallback/dyncall_args_mips_o32.c:    ++p->freg_count;
dyncall/dyncallback/dyncall_args_mips_o32.c:    /*result = *((DCdouble*)p->stackptr); this changes the value, slightly*/
dyncall/dyncallback/dyncall_args_mips_o32.c:    d.f[0] = ((DCfloat*)p->stackptr)[0];
dyncall/dyncallback/dyncall_args_mips_o32.c:    d.f[1] = ((DCfloat*)p->stackptr)[1];
dyncall/dyncallback/dyncall_args_mips_o32.c:  p->stackptr += sizeof(DCdouble);
dyncall/dyncallback/dyncall_callback_ppc32.c: Description: Callback - Implementation Header for ppc32
dyncall/dyncallback/dyncall_callback_ppc32.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_ppc32.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_ppc32.c:  pcb->handler  = handler;
dyncall/dyncallback/dyncall_callback_ppc32.c:  pcb->userdata = userdata;
dyncall/dyncallback/dyncall_callback_ppc32.c:  dcbInitThunk(&pcb->thunk, dcCallbackThunkEntry);
dyncall/dyncallback/dyncall_callback_ppc32.c:  return pcb->userdata;
dyncall/dyncallback/dyncall_callback_arm64.c: Description: Callback - Implementation for ARM64 / ARMv8 / AAPCS64
dyncall/dyncallback/dyncall_callback_arm64.c:   Copyright (c) 2015-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_arm64.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_arm64.c:{                               /* ----|----- */
dyncall/dyncallback/dyncall_callback_arm64.c:  pcb->handler = handler;
dyncall/dyncallback/dyncall_callback_arm64.c:  pcb->userdata = userdata;
dyncall/dyncallback/dyncall_callback_arm64.c:  dcbInitThunk(&pcb->thunk, dcCallbackThunkEntry);
dyncall/dyncallback/dyncall_callback_arm64.c:  return pcb->userdata;
dyncall/dyncallback/dyncall_callback_x86_8a.s:   Copyright (c) 2013 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_x86_8a.s:		AX    -> thunk
dyncall/dyncallback/dyncall_callback_x86_8a.s:		AX+16 -> cb handler
dyncall/dyncallback/dyncall_callback_x86_8a.s:		AX+20 -> dcargsvt
dyncall/dyncallback/dyncall_callback_x86_8a.s:		AX+24 -> stack cleanup <-- not used for stack cleaning as caller cleans up,
dyncall/dyncallback/dyncall_callback_x86_8a.s:		AX+28 -> userdata          however reused as flag to indicate 64bit return value)
dyncall/dyncallback/dyncall_callback_x86_8a.s:	MOVL  SP, CX       /* DCArgs-ptr (data pushed above) */
dyncall/dyncallback/dyncall_callback_x86_8a.s:	CMPL  AX, $0x6c    /* 'l' @@@ compares return from handler, might be different from sig - design currently in discussion */
dyncall/dyncallback/dyncall_callback_x86_8a.s:	CMPL  AX, $0x4c    /* 'L' @@@ compares return from handler, might be different from sig - design currently in discussion */
dyncall/dyncallback/dyncall_callback_x86_8a.s:	CMPL  AX, $0x66    /* 'f' @@@ compares return from handler, might be different from sig - design currently in discussion */
dyncall/dyncallback/dyncall_callback_x86_8a.s:	CMPL  AX, $0x64    /* 'd' @@@ compares return from handler, might be different from sig - design currently in discussion */
dyncall/dyncallback/dyncall_callback_x86_8a.s:	MOVL (BX), AX      /* 32bit non-fp are returned in AX */
dyncall/dyncallback/dyncall_thunk_mips.h: Description: Thunk - Header for MIPS
dyncall/dyncallback/dyncall_thunk_mips.h:   Copyright (c) 2013-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_mips.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_mips64.h: Description: Thunk - Header for MIPS64
dyncall/dyncallback/dyncall_thunk_mips64.h:   Copyright (c) 2016-2018 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_ppc32.c: Description: Thunk - Implementation for ppc32 darwin/apple
dyncall/dyncallback/dyncall_thunk_ppc32.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_ppc32.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_ppc32.c:  p->code_load_hi = 0x3c40U;     /* lis  r2, HI16(p) */
dyncall/dyncallback/dyncall_thunk_ppc32.c:  p->addr_self_hi = hi16(p);
dyncall/dyncallback/dyncall_thunk_ppc32.c:  p->code_load_lo = 0x6042U;     /* ori  r2, r2, LO16(p) */
dyncall/dyncallback/dyncall_thunk_ppc32.c:  p->addr_self_lo = lo16(p);
dyncall/dyncallback/dyncall_thunk_ppc32.c:  p->code_jump[0] = 0x81820014U; /* lwz   r12, 20(r2) */
dyncall/dyncallback/dyncall_thunk_ppc32.c:  p->code_jump[1] = 0x7d8903a6U; /* mtclr r12 */
dyncall/dyncallback/dyncall_thunk_ppc32.c:  p->code_jump[2] = 0x4e800420U; /* bctr */
dyncall/dyncallback/dyncall_thunk_ppc32.c:  p->addr_entry   = entry;
dyncall/dyncallback/dyncall_thunk_ppc32_sysv.c: Description: Thunks on PowerPC 32-bit System V ABI
dyncall/dyncallback/dyncall_thunk_ppc32_sysv.c:   Copyright (c) 2015-2018 Daniel Adler <dadler@uni-goettingen.de>
dyncall/dyncallback/dyncall_thunk_ppc32_sysv.c:  p->code_load_hi = 0x3d60U;     /* lis  r11, HI16(p) */
dyncall/dyncallback/dyncall_thunk_ppc32_sysv.c:  p->addr_self_hi = hi16(p);
dyncall/dyncallback/dyncall_thunk_ppc32_sysv.c:  p->code_load_lo = 0x616bU;     /* ori  r11, r11, LO16(p) */
dyncall/dyncallback/dyncall_thunk_ppc32_sysv.c:  p->addr_self_lo = lo16(p);
dyncall/dyncallback/dyncall_thunk_ppc32_sysv.c:  p->code_jump[0] = 0x818b0014U; /* lwz   r12, 20(r11) */
dyncall/dyncallback/dyncall_thunk_ppc32_sysv.c:  p->code_jump[1] = 0x7d8903a6U; /* mtclr r12 */
dyncall/dyncallback/dyncall_thunk_ppc32_sysv.c:  p->code_jump[2] = 0x4e800420U; /* bctr */
dyncall/dyncallback/dyncall_thunk_ppc32_sysv.c:  p->addr_entry   = entry;
dyncall/dyncallback/CMakeLists.txt:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>
dyncall/dyncallback/dyncall_args_mips.c: Description: Callback's Arguments VM - Implementation for non-o32 MIPS
dyncall/dyncallback/dyncall_args_mips.c:   Copyright (c) 2013-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_mips.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_mips.c:  if(p->reg_count.i < DCARGS_MIPS_NUM_IREGS)
dyncall/dyncallback/dyncall_args_mips.c:    value = p->ireg_data[p->reg_count.i++];
dyncall/dyncallback/dyncall_args_mips.c:    value = *((DCint*)p->stackptr);
dyncall/dyncallback/dyncall_args_mips.c:    p->stackptr += sizeof(DCint);
dyncall/dyncallback/dyncall_args_mips.c:  p->reg_count.i += (p->reg_count.i & 1);         /* Skip one reg if not aligned. */
dyncall/dyncallback/dyncall_args_mips.c:  p->stackptr += ((DCulong)p->stackptr & 4) & -4; /* 64bit values are also always aligned on stack */
dyncall/dyncallback/dyncall_args_mips.c:  if(p->reg_count.f < DCARGS_MIPS_NUM_FREGS)
dyncall/dyncallback/dyncall_args_mips.c:    result = p->freg_data[p->reg_count.f++];
dyncall/dyncallback/dyncall_args_mips.c:    result = *((DCfloat*)p->stackptr);
dyncall/dyncallback/dyncall_args_mips.c:    p->stackptr += sizeof(DCfloat);
dyncall/dyncallback/dyncall_args_arm32.c: Description: Callback's Arguments VM - Implementation for ARM32 (ARM and THUMB mode)
dyncall/dyncallback/dyncall_args_arm32.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_arm32.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_arm32.c:    if(args->reg_count < 4)
dyncall/dyncallback/dyncall_args_arm32.c:      args->reg_count = (args->reg_count+1)&~1;
dyncall/dyncallback/dyncall_args_arm32.c:    if(args->reg_count >= 4 && (int)args->stack_ptr & 4)
dyncall/dyncallback/dyncall_args_arm32.c:      ++args->stack_ptr;
dyncall/dyncallback/dyncall_args_arm32.c:  if(args->reg_count < 4)
dyncall/dyncallback/dyncall_args_arm32.c:    return &args->reg_data[args->reg_count++];
dyncall/dyncallback/dyncall_args_arm32.c:    return (void*)args->stack_ptr++;
dyncall/dyncallback/dyncall_args_arm32.c:  if(args->freg_count < 16) {
dyncall/dyncallback/dyncall_args_arm32.c:    f = args->f[args->freg_count++];
dyncall/dyncallback/dyncall_args_arm32.c:    if(!(args->freg_count & 1) && (args->freg_count < args->dreg_count))
dyncall/dyncallback/dyncall_args_arm32.c:      args->freg_count = args->dreg_count;
dyncall/dyncallback/dyncall_args_arm32.c:  if(args->dreg_count < args->freg_count)
dyncall/dyncallback/dyncall_args_arm32.c:    args->dreg_count = (args->freg_count+1)&0x1e; /* clear last bit, counter won't be higher than 16, anyways */
dyncall/dyncallback/dyncall_args_arm32.c:  if(args->dreg_count < 16) {
dyncall/dyncallback/dyncall_args_arm32.c:    d.d = *(DCdouble*)&args->f[args->dreg_count];
dyncall/dyncallback/dyncall_args_arm32.c:    args->dreg_count += 2;
dyncall/dyncallback/dyncall_args_arm32.c:    if(!(args->freg_count & 1))
dyncall/dyncallback/dyncall_args_arm32.c:      args->freg_count = args->dreg_count;
dyncall/dyncallback/dyncall_args_arm32.c:  args->freg_count = 16; /* fp registers all full - need to use stack now: stop filling gaps for single precision, also */
dyncall/dyncallback/dyncall_args_arm32.c:// ----------------------------------------------------------------------------
dyncall/dyncallback/dyncall_callback_mips.c: Description: Callback - Implementation Header for MIPS
dyncall/dyncallback/dyncall_callback_mips.c:   Copyright (c) 2013-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_callback_mips.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_callback_mips.c:{                              /* ------------------+------------------ */
dyncall/dyncallback/dyncall_callback_mips.c:  pcb->handler  = handler;
dyncall/dyncallback/dyncall_callback_mips.c:  pcb->userdata = userdata;
dyncall/dyncallback/dyncall_callback_mips.c:  dcbInitThunk(&pcb->thunk, dcCallbackThunkEntry);
dyncall/dyncallback/dyncall_callback_mips.c:  return pcb->userdata;
dyncall/dyncallback/dyncall_thunk_arm64.c: Description: Thunk - Implementation for ARM64 / ARMv8 / AAPCS64
dyncall/dyncallback/dyncall_thunk_arm64.c:   Copyright (c) 2015-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_thunk_arm64.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_thunk_arm64.c:-- Encoded in:
dyncall/dyncallback/dyncall_thunk_arm64.c:  p->code[0] = 0x10000009; //   adr x9, 0
dyncall/dyncallback/dyncall_thunk_arm64.c:  p->code[1] = 0x5800006a; //	ldr x9, entry
dyncall/dyncallback/dyncall_thunk_arm64.c:  p->code[2] = 0xd61f0140; //   br  x9
dyncall/dyncallback/dyncall_thunk_arm64.c:  p->code[3] = 0xd503201f; //   nop
dyncall/dyncallback/dyncall_thunk_arm64.c:  p->entry   = entry;      // entry: 
dyncall/dyncallback/dyncall_alloc_wx_mmap.c: Description: Allocate write/executable memory - Implementation for posix
dyncall/dyncallback/dyncall_alloc_wx_mmap.c:   Copyright (c) 2007-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_alloc_wx_mmap.c:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_alloc_wx_mmap.c:  if(fd == -1)
dyncall/dyncallback/dyncall_alloc_wx_mmap.c:    return -1;
dyncall/dyncallback/dyncall_alloc_wx_mmap.c:    return -1;
dyncall/dyncallback/dyncall_alloc_wx_mmap.c:  p = mmap(0, size, MMAP_PROT_INIT, MAP_PRIVATE|MAP_ANON, -1, 0);
dyncall/dyncallback/dyncall_alloc_wx_mmap.c:    return -1;
dyncall/dyncallback/dyncall_alloc_wx_mmap.c:  /* Fixup pointer for no-MAP_ANON workaround (see above) */
dyncall/dyncallback/dyncall_alloc_wx_mmap.c:  p -= sizeof(int);
dyncall/dyncallback/dyncall_alloc_wx_mmap.c:  /* Close file descriptor for no-MAP_ANON workaround (see above) */
dyncall/dyncallback/dyncall_alloc_wx_mmap.c:  p -= sizeof(int);
dyncall/dyncallback/dyncall_args_mips.h: Description: Callback's Arguments VM - Header for MIPS
dyncall/dyncallback/dyncall_args_mips.h:   Copyright (c) 2013-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/dyncallback/dyncall_args_mips.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/dyncallback/dyncall_args_mips.h:	DCint freg_count; /* unused on soft-float targets, but keep as 4b-padding */
dyncall/dyncallback/dyncall_args_mips.h:   /* skipping over other/type's reg, or only using int regs on soft-float   */
dyncall/mkfile:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/mkfile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/ToDo:----
dyncall/ToDo:- test atpcs thumb on arm and verify if ellipsis and C++ thiscalls work, if so adapt doc appendix
dyncall/ToDo:- test eabi thumb on arm and verify if ellipsis and C++ thiscalls work, if so adapt doc appendix
dyncall/ToDo:- new platform matrix
dyncall/ToDo:- openbsd-4.0-* test/resolve_self fails, but unsure why. dlopen correctly returns RTLD_DEFAULT, which
dyncall/ToDo:- test/thunk win/x64 doesn't output anything decent for stack test (neither sigsegv nor output), which can create a problem for test log file as it'll mess with the subsequent test's output)
dyncall/ToDo:- remove test/gen-masm alltogether
dyncall/ToDo:- test code: add sparc tests for when out of register windows, meaning multiple layers deep in the call stack
dyncall/ToDo:- ./configure on macOS does not pass CFLAGS etc.. to Makefile.config
dyncall/ToDo:- support platforms without shared libraries so they can be built by just typing `./configure;make` (e.g. minix < 3.2.1)
dyncall/ToDo:- dyncall supports calls to functions where prototype exists (with and without varargs); however not when no
dyncall/ToDo:- dyncallback's "stack_cleanup" can be removed from non x86 impls... test if they still work
dyncall/ToDo:- target a minimum c version, for use with -pedantic, etc.? Right now we use e.g. extensions
dyncall/ToDo:  for anon structs, etc. -> we do now target c99
dyncall/ToDo:- the CallVM-free functions are per VTable, however the latter can be changed out
dyncall/ToDo:  same goes for functions setting the mode. think about how to make this safer - currently
dyncall/ToDo:- check all vararg calling conv implementations if they promote correctly
dyncall/ToDo:  implementations -> also write testcode specifically for that
dyncall/ToDo:- autovar was never really pushed all the way through and still plays second
dyncall/ToDo:- add portable "make install"
dyncall/ToDo:- fix for NDS:
dyncall/ToDo:    - callback_plain retval wrong (not only platform), area on stack where
dyncall/ToDo:      it's stored is probably not zeroed, so half-words, etc., come with garbage
dyncall/ToDo:    - ellipsis (might be test itself, not respecting fixed part of args)
dyncall/ToDo:    - callback_plain retval, see above under ARM
dyncall/ToDo:    - callf
dyncall/ToDo:- support Solaris11 CFLAGS with -D_FILE_OFFSET_BITS=64
dyncall/ToDo:- make sure selinux works (esp. regarding NX bits)
dyncall/ToDo:- support /SAFESEH on cl/win32
dyncall/ToDo:- test code functions should be in .so files, optionally, so the suites can directly be used to test dyncall bindings
dyncall/ToDo:- pkg-config support?
dyncall/ToDo:- add tests using alloca(), as this might depend on the frame pointer being correctly set (we don't
dyncall/ToDo:  check for this, currently, at all - but might not affect dyncall's stubs, anyways) - verify
dyncall/ToDo:--------
dyncall/ToDo:- add solaris support for x64
dyncall/ToDo:--------
dyncall/ToDo:- dyncall sparc v7/v8: -xO3 on SunPro segfaults in tests (observed years ago)
dyncall/ToDo:- callbacks and use of CC signature characters (only x86 has any support for different CCs for callbacks):
dyncall/ToDo:- think about using 'inline' for all/most dyncall_api.c functions?
dyncall/ToDo:- support for where syscalls originate from on OpenBSD: http://undeadly.org/cgi?action=article;sid=20191202105849
dyncall/ToDo:- merge arm32_thumb_{gas/apple} and include thumb support for portasm
dyncall/ToDo:- x64 verification: return values are passed via RAX and RDX, and XMM0 and XMM1.
dyncall/ToDo:- find big endian arm box (also hardfloat), e.g. cubietruck: http://blog.netbsd.org/tnf/entry/working_arm_multiprocessor_support
dyncall/ToDo:- test if armhf/thumb is actually working... pulls in arm mode code in dyncall_callvm.c
dyncall/ToDo:- dyncall_call_mips_n32.h and dyncall_call_mips_n64.h are pretty much the same, share code
dyncall/ToDo:- support for return values: aggregate return values
dyncall/ToDo:- support for argument values: structures, half-precision, vector types, long double (c89)
dyncall/ToDo:- support for argument values: _Complex (c99)
dyncall/ToDo:- support for argument values: Fixed-width integer types (c99) - could be just aliases but would help abstracting it away from library users
dyncall/ToDo:- consider automatic type-promotion for arguments passed through DC_CALL_C_ELLIPSIS_VARARGS;
dyncall/ToDo:  type promotions (this is partly done, see todo-item above under 1.1)
dyncall/ToDo:- other syscalls
dyncall/ToDo:- test MIPS32 eabi big endian (current port works on psp, which is little endian)
dyncall/ToDo:- implement MIPS64 N32 (gcc -mabi=n32); both, little and big-endian (looks like NetNBSD on and
dyncall/ToDo:- MIPS64 n32 softfloat support (-msoft-float)
dyncall/ToDo:- implement MIPS64 EABI (gcc -mabi=eabi); both, little and big-endian
dyncall/ToDo:- support for Minix/arm
dyncall/ToDo:- improve ellipsis test:
dyncall/ToDo:--------
dyncall/ToDo:- investigate issue where if dlGetLibraryPath() is called from within a .so,
dyncall/ToDo:- dlGetLibraryPath: dl_iterate_phdr() used on OpenBSD, but not available on version < 3.7
dyncall/ToDo:- bug: test/nm crashes on qemu mips linux o32 debian etch
dyncall/ToDo:- rename SymsInit to InitSyms and similar for cleanup function to reflect naming
dyncall/ToDo:- get rid of Dl_info and friends (_GNU_SOURCE) in dynload/dynload_syms_elf.c
dyncall/ToDo:- check if PSP can support dynload (missing elf.h, dlfcn.h, etc.); fixup readme if successful
dyncall/ToDo:- some functionality like java's System.mapLibraryName('name') might be helpful?
dyncall/ToDo:- Failed On Open Solaris 11:
dyncall/ToDo:------------
dyncall/ToDo:- callback_plain's return value not correct anymore on NDS (maybe just broken testcode?),
dyncall/ToDo:- test MIPS32 eabi big endian (current port works on psp, which is little endian)
dyncall/ToDo:- implement MIPS64 N32 (gcc -mabi=n32); both, little and big-endian (looks like NetNBSD on and
dyncall/ToDo:- MIPS64 n32 softfloat support (-msoft-float)
dyncall/ToDo:- implement MIPS64 EABI (gcc -mabi=eabi); both, little and big-endian
dyncall/ToDo:- support for Minix/arm
dyncall/ToDo:---------
dyncall/ToDo:- release bindings as standalone packages (already done for rbdc as a gem and rdyncall on cran)
dyncall/ToDo:- add rdoc documentation to ruby gem
dyncall/ToDo:- add pydoc for python
dyncall/ToDo:- add manpage for shdc
dyncall/ToDo:- expose callf-convenience functions to godc
dyncall/ToDo:- add godoc for godc
dyncall/ToDo:- add javadoc to java
dyncall/ToDo:- add more bindings
dyncall/ToDo:- add callback support for erlang, go, java, lua, python and ruby (and shell? how?)
dyncall/ToDo:- add call-conv-mode-support for rbdc through signature
dyncall/ToDo:-------
dyncall/ToDo:- introduce doc overview tables and common vocab for calling convention specifics, following example of table on page 13 of
dyncall/ToDo:  https://www.linux-mips.org/pub/linux/mips/doc/ABI/MIPS-N32-ABI-Handbook.pdf; also as inspiration, e.g. user 'preserved' instead of 'permanent', etc.
dyncall/ToDo:  https://developer.apple.com/library/content/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARMv6FunctionCallingConventions.html#//apple_ref/doc/uid/TP40009021-SW4
dyncall/ToDo:- make stack layout diagrams better, e.g. add grow direction (example: https://developer.apple.com/library/content/documentation/Xcode/Conceptual/iPhoneOSABIReference/art/arm_stack.jpg on https://developer.apple.com/library/content/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARMv6FunctionCallingConventions.html#//apple_ref/doc/uid/TP40009021-SW1)
dyncall/ToDo:  * another example, chapter 3 of: ftp://www.sourceware.org/pub/binutils/ppc-docs/ppc-poweropen/
dyncall/ToDo:- provide more examples on how to use dyncall, dynload and dyncallback
dyncall/ToDo:- manuals for bindings (as stated in bindings-section, above)
dyncall/ToDo:- under "dyncall support", in each calling convention appendix, list crucial details of e.g. big/little endian support, etc.
dyncall/ToDo:- specify integer models in use, use common ILP32, LLP64, etc. terms
dyncall/ToDo:------------
dyncall/ToDo:- Solaris/gmake build doesn't build dynload and tests anymore (maybe not even dyncallback)
dyncall/ToDo:- look over code and fix TODO or @@@ marks
dyncall/ToDo:-------------
dyncall/ToDo:- update: microsoft visual c++ build files - integrate all test suites in solution file
dyncall/ToDo:- consistency: on x64 platforms: make both ABIs available ('win64','sysv') for all x64 OS ports
dyncall/ToDo:- microsoft build enhancement: autodetect assembly via C preprocessor (like with .S gcc files)
dyncall/ToDo:- test/thunk: some platforms do not allow for allocation of executable code on heap and stack -- 
dyncall/ToDo:- PSP
dyncall/ToDo:	- automate ppsspp stuff, seems to print to stdout for callback_suite? but not for call_suite.. (?)
dyncall/ToDo:	- fix link with dummy versions of the following for test-bins:
dyncall/ToDo:-----
dyncall/ToDo:- setting callconv, specifically for platforms that have only one (default)) excepts on some
dyncall/ToDo:  platforms, eg. setting X64_sysv on amd64/Linux - keeping cdecl which is the same in
dyncall/ToDo:- vararg function calls don't work for ARM THUMB mode (Daniel's new interface for modesetting for varag
dyncall/ToDo:----------------------------------------------
dyncall/ToDo:- riscv
dyncall/ToDo:- itanium
dyncall/ToDo:- superh/j-core
dyncall/ToDo:- 68k, 88k, 6502, etc.
dyncall/ToDo:- arc
dyncall/ToDo:- alpha
dyncall/ToDo:- cell
dyncall/ToDo:- blackfin
dyncall/ToDo:- seaforth
dyncall/ToDo:- s/390
dyncall/ToDo:- z80
dyncall/ToDo:- hppa
dyncall/ToDo:- vax
dyncall/ToDo:- atmel avr
dyncall/ToDo:- propeller
dyncall/ToDo:- amd29k
dyncall/portasm/README.txt:portasm - a toolkit for writing portable generic assembler sources 
dyncall/portasm/README.txt:------------------------------------------------------------------
dyncall/portasm/README.txt:Copyright (C) 2011 Daniel Adler <dadler@uni-goettingen.de>.
dyncall/portasm/README.txt:Licensed under BSD two-clause license.
dyncall/portasm/README.txt:------------
dyncall/portasm/README.txt:- C Preprocessor
dyncall/portasm/README.txt:Supported Architectures and Tool-chains:
dyncall/portasm/README.txt:----------------------------------------
dyncall/portasm/README.txt:- x86: gas, apple as, masm
dyncall/portasm/README.txt:- x64: gas, apple as, masm
dyncall/portasm/README.txt:- ppc: gas, apple as
dyncall/portasm/README.txt:- arm: gas, apple as
dyncall/portasm/README.txt:------
dyncall/portasm/README.txt:#include portasm-<ARCH>.S at front
dyncall/portasm/README.txt:  'gen-masm.sh <name> [<outsuffix>]' script which reads <name>.S and outputs <name><outsuffix>.masm file.
dyncall/portasm/README.txt:--------------
dyncall/portasm/gen-masm.sh:`which gcc || which clang` -E -P -DGEN_MASM ${1:?Usage: $0 <name> [<outsuffix>]}.S \
dyncall/portasm/gen-masm.sh:; auto-generated by `basename $0`
dyncall/portasm/portasm-x64.S: File: portasm/portasm-x64.S
dyncall/portasm/portasm-x64.S:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>
dyncall/portasm/portasm-arm.S: File: portasm/portasm-arm.S
dyncall/portasm/portasm-arm.S:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/portasm/portasm-arm.S:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/portasm/portasm-ppc.S: File: portasm/portasm-ppc.S
dyncall/portasm/portasm-ppc.S:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>
dyncall/portasm/portasm-arm64.S: File: portasm/portasm-arm.S
dyncall/portasm/portasm-arm64.S:   Copyright (c) 2020 Bernhard Urban-Forster <beurba@microsoft.com>
dyncall/portasm/portasm-x86.S: File: portasm/portasm-x86.S
dyncall/portasm/portasm-x86.S:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>
dyncall/portasm/portasm-ppc64.S: File: portasm/portasm-ppc64.S
dyncall/portasm/portasm-ppc64.S:   Copyright (c) 2014-2015 Masanori Mitsugi <mitsugi@linux.vnet.ibm.com>
dyncall/portasm/portasm-ppc64.S:addis r2, r12,.TOC.-0b@ha; \
dyncall/portasm/portasm-ppc64.S:addi  r2, r2,.TOC.-0b@l; \
dyncall/portasm/portasm-ppc64.S:.localentry X,.-X;
dyncall/ChangeLog:  o support clang's integrated as (didn't build on non-Darwin PPC32 platforms)
dyncall/ChangeLog:  o support clang's integrated as (didn't build on non-Darwin PPC32 platforms)
dyncall/ChangeLog:  o support for loading macos >= 11.0.1 (Big Sur) dylibs provided by system's "built-in dynamic
dyncall/ChangeLog:    linker cache of all system-provided libraries" (those dylibs are no longer present on the fs)
dyncall/ChangeLog:  o support for soft-float MIPS o32 & n64 (big- and little-endian, each)
dyncall/ChangeLog:  o support for soft-float MIPS o32 & n64 (big- and little-endian, each)
dyncall/ChangeLog:  o added UTF-8 support for pathnames on windows
dyncall/ChangeLog:  o dlLoadLibrary() on windows: no more auto-suffixing of the .dll file ext anymore, to be
dyncall/ChangeLog:  o more detail in support matrix for bi-endian platforms
dyncall/ChangeLog:  o dynload_plain test extended to test UTF-8 library paths
dyncall/ChangeLog:  o default ./configure: FreeBSD/mips*hf needed -mhard-float compiler flag set explicitly
dyncall/ChangeLog:  o PPC64 single-precision float fixes for more than 13 float args (thanks Masanori Mitsugi!)
dyncall/ChangeLog:  o fixed ARM32-THUMB stack alignment issues (found on Cortex-m0, thanks Darren Whobrey!)
dyncall/ChangeLog:  o PPC64 single-precision float fixes for more than 13 float args (thanks Masanori Mitsugi!)
dyncall/ChangeLog:  o MIPS o32 (big- and little-endian), EABI (32 bit, little-endian) and n64 (big-endian) support
dyncall/ChangeLog:  o major reliability/stability fixes for Mach-O dlSyms* functions to (thanks Stphane Mons for help):
dyncall/ChangeLog:    64-bit platform fixes (was broken on x64 and never supported on others)
dyncall/ChangeLog:  o allowing Mach-O dlSyms* lib to be used standalone (consistent with ELF and PE impls now)
dyncall/ChangeLog:  o assembly code now built by explicitily asking for non-execstack, for safer/easier integration
dyncall/ChangeLog:  o using -fPIC by default for FreeBSD
dyncall/ChangeLog:  o helper script for generic .elf -> EBOOT.PBP creation for PSP
dyncall/ChangeLog:  o big simplification make-based build system, no more distinct GNU and BSD makefiles anymore
dyncall/ChangeLog:  o new, much simpler ./configure for new make-based build-system
dyncall/ChangeLog:  o support for in-source and out-of-source builds for make-based build systems
dyncall/ChangeLog:  o fix for ARMv7 Thumb-2 code (tested on iPhone 4 CDMA / iOS 6.0.1)
dyncall/ChangeLog:  o bugfixes for -O2 builds for SPARC-v9 and SPARC-v7
dyncall/ChangeLog:  o new optimized call kernel for SPARC-v9 without conditionals
dyncall/ChangeLog:  o shdc: renamed shell binding to shdc and added feature to list shared-objects' symbols
dyncall/ChangeLog:  o added subproject: portasm - portable (GNU AS,+Apple and MASM) assembly framework
dyncall/ChangeLog:  o added subproject: autovar - predefined macro framework (was dyncall_macros.h)
dyncall/ChangeLog:  o improved auto-detection via preprocessor defines
dyncall/ChangeLog:  o added support for sparc (32-bit) (tested on linux/debian,openbsd,solaris)
dyncall/ChangeLog:  o added support for sparc (64-bit) (tested on linux/debian,openbsd,solaris)
dyncall/ChangeLog:  o added support for mingw32-w64 on x64
dyncall/ChangeLog:  o minor fix for amd64/sysv: alignment to 32-byte
dyncall/ChangeLog:  o fixes for self-resolving symbols on windows
dyncall/ChangeLog:  o added zero-config (BSD,GNU,SUN) make files (Makefile.embedded)
dyncall/ChangeLog:  o added in/out-of-source configure2 w/ (BSD,GNU) make files (Makefile.generic)
dyncall/ChangeLog:  o improved cross-compilation for iOS (upgrade to 4.3 sdk)
dyncall/ChangeLog:  o added support for msvc/x64 tool-chain
dyncall/ChangeLog:  o default settings for build-dir changed to '.'
dyncall/ChangeLog:  o cleanup: removed top-level Make{Prolog,Epilog,Rules} files and updated all sub-projects and tests
dyncall/ChangeLog:  o added support for using dyncall as sub-project (via *Config.cmake files)
dyncall/ChangeLog:  o added experimental 'dynMake' portable make-based build-system (not stable, yet)
dyncall/ChangeLog:  o updates to resolve-self test (adding additional link flags to export symbols)
dyncall/ChangeLog:  o improved dir name portability (renamed plain_c++ -> plain_cxx)
dyncall/ChangeLog:  o renamed *.cpp -> *.cc files (OpenBSD/Sun make has no implicit rules for cpp)
dyncall/ChangeLog:  o x64 bugfix: added "-fPIC" even for static libs
dyncall/ChangeLog:  o enum symbols update: Mach-O and Win64 (thanks Olivier)
dyncall/ChangeLog:  o added non-EABI ABI for arm32 (before, EABI was the default implementation)
dyncall/ChangeLog:  o added a couple of new options to configure scripts (e.g. prefix-bd, new targets, etc.)
dyncall/ChangeLog:    C Strings: 'S' -> 'Z'
dyncall/ChangeLog:    long: 'l' -> 'j'
dyncall/ChangeLog:    long long: 'L' -> 'l'
dyncall/ChangeLog:  o configure (shell version) option "--prefix" changed to "--prefix=<path>"
dyncall/autovar/LICENSE.txt:Copyright (c) 2011 Daniel Adler <dadler@uni-goettingen.de> 
dyncall/autovar/autovar_ARCH.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/autovar/autovar_ARCH.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/autovar/README.txt:autovar -- a small macro auto-detection library
dyncall/autovar/autovar_CC.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/autovar/autovar_CC.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/autovar/autovar_OS.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/autovar/autovar_OS.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/autovar/autovar_ABI.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/autovar/autovar_ABI.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/autovar/autovar_OSFAMILY.h:   Copyright (c) 2011-2018 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/autovar/autovar_OSFAMILY.h:                           Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/LICENSE:Copyright (c) 2007-2021 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/LICENSE:                        Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/configure.bat:REM Copyright (c) 2007-2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/configure.bat:REM                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/configure.bat:	ECHO.dyncall configuration shell-script
dyncall/configure.bat:	ECHO.  /prefix-bd PATH   set build directory prefix ^(GNU make only^)
dyncall/configure.bat:	ECHO.  /target-x86       build for x86 architecture
dyncall/configure.bat:	ECHO.  /target-x64       build for x64 architecture
dyncall/configure.bat:	ECHO.  /target-psp       build for PlayStation Portable ^(homebrew SDK^)
dyncall/configure.bat:	ECHO.  /target-nds-arm   build for Nintendo DS ^(devkitPro, ARM mode^)
dyncall/configure.bat:	ECHO.  /target-nds-thumb build for Nintendo DS ^(devkitPro, THUMB mode^)
dyncall/configure.bat:	ECHO.  /tool-msvc        use Microsoft Visual C++ compiler ^(default^)
dyncall/configure.bat:	ECHO.  /tool-gcc         use GNU Compiler Collection
dyncall/configure.bat:	ECHO.  /asm-ml           use Microsoft Macro Assembler ^(default^)
dyncall/configure.bat:	ECHO.  /asm-as           use the GNU Assembler
dyncall/configure.bat:	ECHO.  /asm-nasm         use NASM Assembler
dyncall/configure.bat:	ECHO.  /config-release   build release version ^(default^)
dyncall/configure.bat:	ECHO.  /config-debug     build debug version
dyncall/configure.bat:) ELSE IF [%1]==[/prefix-bd] (
dyncall/configure.bat:) ELSE IF [%1]==[/target-x86] (
dyncall/configure.bat:) ELSE IF [%1]==[/target-x64] (
dyncall/configure.bat:) ELSE IF [%1]==[/target-psp] (
dyncall/configure.bat:) ELSE IF [%1]==[/target-nds-arm] (
dyncall/configure.bat:) ELSE IF [%1]==[/target-nds-thumb] (
dyncall/configure.bat:) ELSE IF [%1]==[/tool-gcc] (
dyncall/configure.bat:) ELSE IF [%1]==[/tool-msvc] (
dyncall/configure.bat:) ELSE IF [%1]==[/asm-as] (
dyncall/configure.bat:) ELSE IF [%1]==[/asm-nasm] (
dyncall/configure.bat:) ELSE IF [%1]==[/asm-ml] (
dyncall/configure.bat:) ELSE IF [%1]==[/config-release] (
dyncall/configure.bat:) ELSE IF [%1]==[/config-debug] (
dyncall/configure.bat:ECHO # auto-generated by configure.bat >ConfigVars
dyncall/configure.bat:		buildsys\scripts\conf-nds.bat
dyncall/CPackSourceConfig.cmake:#  cpack --help-variable-list
dyncall/CPackSourceConfig.cmake:set(CPACK_BUILD_SOURCE_DIRS "/home/chenningcong/Desktop/dyncall-1.2;/home/chenningcong/Desktop/dyncall-1.2")
dyncall/CPackSourceConfig.cmake:set(CPACK_DEFAULT_PACKAGE_DESCRIPTION_FILE "/usr/share/cmake-3.21/Templates/CPack.GenericDescription.txt")
dyncall/CPackSourceConfig.cmake:set(CPACK_INSTALLED_DIRECTORIES "/home/chenningcong/Desktop/dyncall-1.2;/")
dyncall/CPackSourceConfig.cmake:set(CPACK_OUTPUT_CONFIG_FILE "/home/chenningcong/Desktop/dyncall-1.2/CPackConfig.cmake")
dyncall/CPackSourceConfig.cmake:set(CPACK_PACKAGE_DESCRIPTION_FILE "/home/chenningcong/Desktop/dyncall-1.2/README")
dyncall/CPackSourceConfig.cmake:set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "dyncall enables dynamic invocation of machine-level function calls")
dyncall/CPackSourceConfig.cmake:set(CPACK_PACKAGE_FILE_NAME "dyncall-0.1.1-Source")
dyncall/CPackSourceConfig.cmake:set(CPACK_RESOURCE_FILE_LICENSE "/home/chenningcong/Desktop/dyncall-1.2/LICENSE")
dyncall/CPackSourceConfig.cmake:set(CPACK_RESOURCE_FILE_README "/usr/share/cmake-3.21/Templates/CPack.GenericDescription.txt")
dyncall/CPackSourceConfig.cmake:set(CPACK_RESOURCE_FILE_WELCOME "/usr/share/cmake-3.21/Templates/CPack.GenericWelcome.txt")
dyncall/CPackSourceConfig.cmake:set(CPACK_SOURCE_INSTALLED_DIRECTORIES "/home/chenningcong/Desktop/dyncall-1.2;/")
dyncall/CPackSourceConfig.cmake:set(CPACK_SOURCE_OUTPUT_CONFIG_FILE "/home/chenningcong/Desktop/dyncall-1.2/CPackSourceConfig.cmake")
dyncall/CPackSourceConfig.cmake:set(CPACK_SOURCE_PACKAGE_FILE_NAME "dyncall-0.1.1-Source")
dyncall/CPackSourceConfig.cmake:set(CPACK_SOURCE_TOPLEVEL_TAG "Linux-Source")
dyncall/CPackSourceConfig.cmake:set(CPACK_TOPLEVEL_TAG "Linux-Source")
dyncall/CPackSourceConfig.cmake:  set(CPACK_PROPERTIES_FILE "/home/chenningcong/Desktop/dyncall-1.2/CPackProperties.cmake")
dyncall/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/Nmakefile:# Pseudo-targets are always out of date...
dyncall/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/CMakeFiles/CMakeOutput.log:The system is: Linux - 5.14.7-2-MANJARO - x86_64
dyncall/CMakeFiles/CMakeOutput.log:The C compiler identification is GNU, found in "/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/3.21.3/CompilerIdC/a.out"
dyncall/CMakeFiles/CMakeOutput.log:Change Dir: /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/CMakeTmp
dyncall/CMakeFiles/CMakeOutput.log:Run Build Command(s):/usr/bin/make -f Makefile cmTC_8546e/fast && /usr/bin/make  -f CMakeFiles/cmTC_8546e.dir/build.make CMakeFiles/cmTC_8546e.dir/build
dyncall/CMakeFiles/CMakeOutput.log:make[1]: Entering directory '/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/CMakeTmp'
dyncall/CMakeFiles/CMakeOutput.log:/usr/bin/cc   -v -o CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.o -c /usr/share/cmake-3.21/Modules/CMakeCCompilerABI.c
dyncall/CMakeFiles/CMakeOutput.log:Using built-in specs.
dyncall/CMakeFiles/CMakeOutput.log:Target: x86_64-pc-linux-gnu
dyncall/CMakeFiles/CMakeOutput.log:Configured with: /build/gcc/src/gcc/configure --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c,c++,ada,fortran,go,lto,objc,obj-c++,d --with-isl --with-linker-hash-style=gnu --with-system-zlib --enable-__cxa_atexit --enable-cet=auto --enable-checking=release --enable-clocale=gnu --enable-default-pie --enable-default-ssp --enable-gnu-indirect-function --enable-gnu-unique-object --enable-install-libiberty --enable-linker-build-id --enable-lto --enable-multilib --enable-plugin --enable-shared --enable-threads=posix --disable-libssp --disable-libstdcxx-pch --disable-libunwind-exceptions --disable-werror gdc_include_dir=/usr/include/dlang/gdc
dyncall/CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.o' '-c' '-mtune=generic' '-march=x86-64' '-dumpdir' 'CMakeFiles/cmTC_8546e.dir/'
dyncall/CMakeFiles/CMakeOutput.log: /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/cc1 -quiet -v /usr/share/cmake-3.21/Modules/CMakeCCompilerABI.c -quiet -dumpdir CMakeFiles/cmTC_8546e.dir/ -dumpbase CMakeCCompilerABI.c.c -dumpbase-ext .c -mtune=generic -march=x86-64 -version -o /tmp/cckrKOf1.s
dyncall/CMakeFiles/CMakeOutput.log:GNU C17 (GCC) version 11.1.0 (x86_64-pc-linux-gnu)
dyncall/CMakeFiles/CMakeOutput.log:	compiled by GNU C version 11.1.0, GMP version 6.2.1, MPFR version 4.1.0, MPC version 1.2.1, isl version isl-0.24-GMP
dyncall/CMakeFiles/CMakeOutput.log:warning: MPFR header version 4.1.0 differs from library version 4.1.0-p13.
dyncall/CMakeFiles/CMakeOutput.log:GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
dyncall/CMakeFiles/CMakeOutput.log:ignoring nonexistent directory "/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../x86_64-pc-linux-gnu/include"
dyncall/CMakeFiles/CMakeOutput.log: /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include
dyncall/CMakeFiles/CMakeOutput.log: /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed
dyncall/CMakeFiles/CMakeOutput.log:GNU C17 (GCC) version 11.1.0 (x86_64-pc-linux-gnu)
dyncall/CMakeFiles/CMakeOutput.log:	compiled by GNU C version 11.1.0, GMP version 6.2.1, MPFR version 4.1.0, MPC version 1.2.1, isl version isl-0.24-GMP
dyncall/CMakeFiles/CMakeOutput.log:warning: MPFR header version 4.1.0 differs from library version 4.1.0-p13.
dyncall/CMakeFiles/CMakeOutput.log:GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
dyncall/CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.o' '-c' '-mtune=generic' '-march=x86-64' '-dumpdir' 'CMakeFiles/cmTC_8546e.dir/'
dyncall/CMakeFiles/CMakeOutput.log: as -v --64 -o CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.o /tmp/cckrKOf1.s
dyncall/CMakeFiles/CMakeOutput.log:GNU assembler version 2.36.1 (x86_64-pc-linux-gnu) using BFD version (GNU Binutils) 2.36.1
dyncall/CMakeFiles/CMakeOutput.log:COMPILER_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/
dyncall/CMakeFiles/CMakeOutput.log:LIBRARY_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../:/lib/:/usr/lib/
dyncall/CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.o' '-c' '-mtune=generic' '-march=x86-64' '-dumpdir' 'CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.'
dyncall/CMakeFiles/CMakeOutput.log:/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_8546e.dir/link.txt --verbose=1
dyncall/CMakeFiles/CMakeOutput.log:/usr/bin/cc  -v -rdynamic CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.o -o cmTC_8546e 
dyncall/CMakeFiles/CMakeOutput.log:Using built-in specs.
dyncall/CMakeFiles/CMakeOutput.log:COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/lto-wrapper
dyncall/CMakeFiles/CMakeOutput.log:Target: x86_64-pc-linux-gnu
dyncall/CMakeFiles/CMakeOutput.log:Configured with: /build/gcc/src/gcc/configure --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c,c++,ada,fortran,go,lto,objc,obj-c++,d --with-isl --with-linker-hash-style=gnu --with-system-zlib --enable-__cxa_atexit --enable-cet=auto --enable-checking=release --enable-clocale=gnu --enable-default-pie --enable-default-ssp --enable-gnu-indirect-function --enable-gnu-unique-object --enable-install-libiberty --enable-linker-build-id --enable-lto --enable-multilib --enable-plugin --enable-shared --enable-threads=posix --disable-libssp --disable-libstdcxx-pch --disable-libunwind-exceptions --disable-werror gdc_include_dir=/usr/include/dlang/gdc
dyncall/CMakeFiles/CMakeOutput.log:COMPILER_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/
dyncall/CMakeFiles/CMakeOutput.log:LIBRARY_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../:/lib/:/usr/lib/
dyncall/CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_8546e' '-mtune=generic' '-march=x86-64' '-dumpdir' 'cmTC_8546e.'
dyncall/CMakeFiles/CMakeOutput.log: /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/collect2 -plugin /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/lto-wrapper -plugin-opt=-fresolution=/tmp/cc2D9HFt.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -o cmTC_8546e /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/Scrt1.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crti.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtbeginS.o -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0 -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../.. CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtendS.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crtn.o
dyncall/CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_8546e' '-mtune=generic' '-march=x86-64' '-dumpdir' 'cmTC_8546e.'
dyncall/CMakeFiles/CMakeOutput.log:make[1]: Leaving directory '/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/CMakeTmp'
dyncall/CMakeFiles/CMakeOutput.log:    add: [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include]
dyncall/CMakeFiles/CMakeOutput.log:    add: [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed]
dyncall/CMakeFiles/CMakeOutput.log:  collapse include dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include] ==> [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include]
dyncall/CMakeFiles/CMakeOutput.log:  collapse include dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed] ==> [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed]
dyncall/CMakeFiles/CMakeOutput.log:  implicit include dirs: [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include;/usr/local/include;/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed;/usr/include]
dyncall/CMakeFiles/CMakeOutput.log:  link line regex: [^( *|.*[/\])(ld|CMAKE_LINK_STARTFILE-NOTFOUND|([^/\]+-)?ld|collect2)[^/\]*( |$)]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Change Dir: /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/CMakeTmp]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Run Build Command(s):/usr/bin/make -f Makefile cmTC_8546e/fast && /usr/bin/make  -f CMakeFiles/cmTC_8546e.dir/build.make CMakeFiles/cmTC_8546e.dir/build]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [make[1]: Entering directory '/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/CMakeTmp']
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [/usr/bin/cc   -v -o CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.o -c /usr/share/cmake-3.21/Modules/CMakeCCompilerABI.c]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Using built-in specs.]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Target: x86_64-pc-linux-gnu]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Configured with: /build/gcc/src/gcc/configure --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c c++ ada fortran go lto objc obj-c++ d --with-isl --with-linker-hash-style=gnu --with-system-zlib --enable-__cxa_atexit --enable-cet=auto --enable-checking=release --enable-clocale=gnu --enable-default-pie --enable-default-ssp --enable-gnu-indirect-function --enable-gnu-unique-object --enable-install-libiberty --enable-linker-build-id --enable-lto --enable-multilib --enable-plugin --enable-shared --enable-threads=posix --disable-libssp --disable-libstdcxx-pch --disable-libunwind-exceptions --disable-werror gdc_include_dir=/usr/include/dlang/gdc]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.o' '-c' '-mtune=generic' '-march=x86-64' '-dumpdir' 'CMakeFiles/cmTC_8546e.dir/']
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/cc1 -quiet -v /usr/share/cmake-3.21/Modules/CMakeCCompilerABI.c -quiet -dumpdir CMakeFiles/cmTC_8546e.dir/ -dumpbase CMakeCCompilerABI.c.c -dumpbase-ext .c -mtune=generic -march=x86-64 -version -o /tmp/cckrKOf1.s]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [GNU C17 (GCC) version 11.1.0 (x86_64-pc-linux-gnu)]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [	compiled by GNU C version 11.1.0  GMP version 6.2.1  MPFR version 4.1.0  MPC version 1.2.1  isl version isl-0.24-GMP]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [warning: MPFR header version 4.1.0 differs from library version 4.1.0-p13.]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [ignoring nonexistent directory "/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../x86_64-pc-linux-gnu/include"]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [GNU C17 (GCC) version 11.1.0 (x86_64-pc-linux-gnu)]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [	compiled by GNU C version 11.1.0  GMP version 6.2.1  MPFR version 4.1.0  MPC version 1.2.1  isl version isl-0.24-GMP]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [warning: MPFR header version 4.1.0 differs from library version 4.1.0-p13.]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.o' '-c' '-mtune=generic' '-march=x86-64' '-dumpdir' 'CMakeFiles/cmTC_8546e.dir/']
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [ as -v --64 -o CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.o /tmp/cckrKOf1.s]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [GNU assembler version 2.36.1 (x86_64-pc-linux-gnu) using BFD version (GNU Binutils) 2.36.1]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../:/lib/:/usr/lib/]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.o' '-c' '-mtune=generic' '-march=x86-64' '-dumpdir' 'CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.']
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_8546e.dir/link.txt --verbose=1]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [/usr/bin/cc  -v -rdynamic CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.o -o cmTC_8546e ]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Using built-in specs.]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/lto-wrapper]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Target: x86_64-pc-linux-gnu]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Configured with: /build/gcc/src/gcc/configure --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c c++ ada fortran go lto objc obj-c++ d --with-isl --with-linker-hash-style=gnu --with-system-zlib --enable-__cxa_atexit --enable-cet=auto --enable-checking=release --enable-clocale=gnu --enable-default-pie --enable-default-ssp --enable-gnu-indirect-function --enable-gnu-unique-object --enable-install-libiberty --enable-linker-build-id --enable-lto --enable-multilib --enable-plugin --enable-shared --enable-threads=posix --disable-libssp --disable-libstdcxx-pch --disable-libunwind-exceptions --disable-werror gdc_include_dir=/usr/include/dlang/gdc]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../:/lib/:/usr/lib/]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_8546e' '-mtune=generic' '-march=x86-64' '-dumpdir' 'cmTC_8546e.']
dyncall/CMakeFiles/CMakeOutput.log:  link line: [ /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/collect2 -plugin /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/lto-wrapper -plugin-opt=-fresolution=/tmp/cc2D9HFt.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -o cmTC_8546e /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/Scrt1.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crti.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtbeginS.o -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0 -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../.. CMakeFiles/cmTC_8546e.dir/CMakeCCompilerABI.c.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtendS.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crtn.o]
dyncall/CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/collect2] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/liblto_plugin.so] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/lto-wrapper] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-fresolution=/tmp/cc2D9HFt.res] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lc] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [--build-id] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [--eh-frame-hdr] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [--hash-style=gnu] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-m] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-export-dynamic] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-dynamic-linker] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [/lib64/ld-linux-x86-64.so.2] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-pie] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-o] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/Scrt1.o] ==> obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/Scrt1.o]
dyncall/CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crti.o] ==> obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crti.o]
dyncall/CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtbeginS.o] ==> obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtbeginS.o]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0] ==> dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib] ==> dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-L/lib/../lib] ==> dir [/lib/../lib]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/../lib] ==> dir [/usr/lib/../lib]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../..] ==> dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../..]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-lgcc] ==> lib [gcc]
dyncall/CMakeFiles/CMakeOutput.log:    arg [--push-state] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [--as-needed] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-lgcc_s] ==> lib [gcc_s]
dyncall/CMakeFiles/CMakeOutput.log:    arg [--pop-state] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-lc] ==> lib [c]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-lgcc] ==> lib [gcc]
dyncall/CMakeFiles/CMakeOutput.log:    arg [--push-state] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [--as-needed] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-lgcc_s] ==> lib [gcc_s]
dyncall/CMakeFiles/CMakeOutput.log:    arg [--pop-state] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtendS.o] ==> obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtendS.o]
dyncall/CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crtn.o] ==> obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crtn.o]
dyncall/CMakeFiles/CMakeOutput.log:  collapse obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/Scrt1.o] ==> [/usr/lib/Scrt1.o]
dyncall/CMakeFiles/CMakeOutput.log:  collapse obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crti.o] ==> [/usr/lib/crti.o]
dyncall/CMakeFiles/CMakeOutput.log:  collapse obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crtn.o] ==> [/usr/lib/crtn.o]
dyncall/CMakeFiles/CMakeOutput.log:  collapse library dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0] ==> [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0]
dyncall/CMakeFiles/CMakeOutput.log:  collapse library dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib] ==> [/usr/lib]
dyncall/CMakeFiles/CMakeOutput.log:  collapse library dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../..] ==> [/usr/lib]
dyncall/CMakeFiles/CMakeOutput.log:  implicit objs: [/usr/lib/Scrt1.o;/usr/lib/crti.o;/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtbeginS.o;/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtendS.o;/usr/lib/crtn.o]
dyncall/CMakeFiles/CMakeOutput.log:  implicit dirs: [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0;/usr/lib;/lib]
dyncall/CMakeFiles/CMakeOutput.log:The CXX compiler identification is GNU, found in "/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/3.21.3/CompilerIdCXX/a.out"
dyncall/CMakeFiles/CMakeOutput.log:Change Dir: /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/CMakeTmp
dyncall/CMakeFiles/CMakeOutput.log:Run Build Command(s):/usr/bin/make -f Makefile cmTC_2a0ac/fast && /usr/bin/make  -f CMakeFiles/cmTC_2a0ac.dir/build.make CMakeFiles/cmTC_2a0ac.dir/build
dyncall/CMakeFiles/CMakeOutput.log:make[1]: Entering directory '/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/CMakeTmp'
dyncall/CMakeFiles/CMakeOutput.log:/usr/bin/c++   -v -o CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.o -c /usr/share/cmake-3.21/Modules/CMakeCXXCompilerABI.cpp
dyncall/CMakeFiles/CMakeOutput.log:Using built-in specs.
dyncall/CMakeFiles/CMakeOutput.log:Target: x86_64-pc-linux-gnu
dyncall/CMakeFiles/CMakeOutput.log:Configured with: /build/gcc/src/gcc/configure --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c,c++,ada,fortran,go,lto,objc,obj-c++,d --with-isl --with-linker-hash-style=gnu --with-system-zlib --enable-__cxa_atexit --enable-cet=auto --enable-checking=release --enable-clocale=gnu --enable-default-pie --enable-default-ssp --enable-gnu-indirect-function --enable-gnu-unique-object --enable-install-libiberty --enable-linker-build-id --enable-lto --enable-multilib --enable-plugin --enable-shared --enable-threads=posix --disable-libssp --disable-libstdcxx-pch --disable-libunwind-exceptions --disable-werror gdc_include_dir=/usr/include/dlang/gdc
dyncall/CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mtune=generic' '-march=x86-64' '-dumpdir' 'CMakeFiles/cmTC_2a0ac.dir/'
dyncall/CMakeFiles/CMakeOutput.log: /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/cc1plus -quiet -v -D_GNU_SOURCE /usr/share/cmake-3.21/Modules/CMakeCXXCompilerABI.cpp -quiet -dumpdir CMakeFiles/cmTC_2a0ac.dir/ -dumpbase CMakeCXXCompilerABI.cpp.cpp -dumpbase-ext .cpp -mtune=generic -march=x86-64 -version -o /tmp/ccn3Urv8.s
dyncall/CMakeFiles/CMakeOutput.log:GNU C++17 (GCC) version 11.1.0 (x86_64-pc-linux-gnu)
dyncall/CMakeFiles/CMakeOutput.log:	compiled by GNU C version 11.1.0, GMP version 6.2.1, MPFR version 4.1.0, MPC version 1.2.1, isl version isl-0.24-GMP
dyncall/CMakeFiles/CMakeOutput.log:warning: MPFR header version 4.1.0 differs from library version 4.1.0-p13.
dyncall/CMakeFiles/CMakeOutput.log:GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
dyncall/CMakeFiles/CMakeOutput.log:ignoring nonexistent directory "/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../x86_64-pc-linux-gnu/include"
dyncall/CMakeFiles/CMakeOutput.log: /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../include/c++/11.1.0
dyncall/CMakeFiles/CMakeOutput.log: /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../include/c++/11.1.0/x86_64-pc-linux-gnu
dyncall/CMakeFiles/CMakeOutput.log: /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../include/c++/11.1.0/backward
dyncall/CMakeFiles/CMakeOutput.log: /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include
dyncall/CMakeFiles/CMakeOutput.log: /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed
dyncall/CMakeFiles/CMakeOutput.log:GNU C++17 (GCC) version 11.1.0 (x86_64-pc-linux-gnu)
dyncall/CMakeFiles/CMakeOutput.log:	compiled by GNU C version 11.1.0, GMP version 6.2.1, MPFR version 4.1.0, MPC version 1.2.1, isl version isl-0.24-GMP
dyncall/CMakeFiles/CMakeOutput.log:warning: MPFR header version 4.1.0 differs from library version 4.1.0-p13.
dyncall/CMakeFiles/CMakeOutput.log:GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
dyncall/CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mtune=generic' '-march=x86-64' '-dumpdir' 'CMakeFiles/cmTC_2a0ac.dir/'
dyncall/CMakeFiles/CMakeOutput.log: as -v --64 -o CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.o /tmp/ccn3Urv8.s
dyncall/CMakeFiles/CMakeOutput.log:GNU assembler version 2.36.1 (x86_64-pc-linux-gnu) using BFD version (GNU Binutils) 2.36.1
dyncall/CMakeFiles/CMakeOutput.log:COMPILER_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/
dyncall/CMakeFiles/CMakeOutput.log:LIBRARY_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../:/lib/:/usr/lib/
dyncall/CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mtune=generic' '-march=x86-64' '-dumpdir' 'CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.'
dyncall/CMakeFiles/CMakeOutput.log:/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_2a0ac.dir/link.txt --verbose=1
dyncall/CMakeFiles/CMakeOutput.log:/usr/bin/c++  -v -rdynamic CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.o -o cmTC_2a0ac 
dyncall/CMakeFiles/CMakeOutput.log:Using built-in specs.
dyncall/CMakeFiles/CMakeOutput.log:COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/lto-wrapper
dyncall/CMakeFiles/CMakeOutput.log:Target: x86_64-pc-linux-gnu
dyncall/CMakeFiles/CMakeOutput.log:Configured with: /build/gcc/src/gcc/configure --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c,c++,ada,fortran,go,lto,objc,obj-c++,d --with-isl --with-linker-hash-style=gnu --with-system-zlib --enable-__cxa_atexit --enable-cet=auto --enable-checking=release --enable-clocale=gnu --enable-default-pie --enable-default-ssp --enable-gnu-indirect-function --enable-gnu-unique-object --enable-install-libiberty --enable-linker-build-id --enable-lto --enable-multilib --enable-plugin --enable-shared --enable-threads=posix --disable-libssp --disable-libstdcxx-pch --disable-libunwind-exceptions --disable-werror gdc_include_dir=/usr/include/dlang/gdc
dyncall/CMakeFiles/CMakeOutput.log:COMPILER_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/
dyncall/CMakeFiles/CMakeOutput.log:LIBRARY_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../:/lib/:/usr/lib/
dyncall/CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_2a0ac' '-shared-libgcc' '-mtune=generic' '-march=x86-64' '-dumpdir' 'cmTC_2a0ac.'
dyncall/CMakeFiles/CMakeOutput.log: /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/collect2 -plugin /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/lto-wrapper -plugin-opt=-fresolution=/tmp/ccB0GWSR.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --build-id --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -o cmTC_2a0ac /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/Scrt1.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crti.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtbeginS.o -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0 -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../.. CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtendS.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crtn.o
dyncall/CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_2a0ac' '-shared-libgcc' '-mtune=generic' '-march=x86-64' '-dumpdir' 'cmTC_2a0ac.'
dyncall/CMakeFiles/CMakeOutput.log:make[1]: Leaving directory '/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/CMakeTmp'
dyncall/CMakeFiles/CMakeOutput.log:    add: [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../include/c++/11.1.0]
dyncall/CMakeFiles/CMakeOutput.log:    add: [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../include/c++/11.1.0/x86_64-pc-linux-gnu]
dyncall/CMakeFiles/CMakeOutput.log:    add: [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../include/c++/11.1.0/backward]
dyncall/CMakeFiles/CMakeOutput.log:    add: [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include]
dyncall/CMakeFiles/CMakeOutput.log:    add: [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed]
dyncall/CMakeFiles/CMakeOutput.log:  collapse include dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../include/c++/11.1.0] ==> [/usr/include/c++/11.1.0]
dyncall/CMakeFiles/CMakeOutput.log:  collapse include dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../include/c++/11.1.0/x86_64-pc-linux-gnu] ==> [/usr/include/c++/11.1.0/x86_64-pc-linux-gnu]
dyncall/CMakeFiles/CMakeOutput.log:  collapse include dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../include/c++/11.1.0/backward] ==> [/usr/include/c++/11.1.0/backward]
dyncall/CMakeFiles/CMakeOutput.log:  collapse include dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include] ==> [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include]
dyncall/CMakeFiles/CMakeOutput.log:  collapse include dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed] ==> [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed]
dyncall/CMakeFiles/CMakeOutput.log:  implicit include dirs: [/usr/include/c++/11.1.0;/usr/include/c++/11.1.0/x86_64-pc-linux-gnu;/usr/include/c++/11.1.0/backward;/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include;/usr/local/include;/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed;/usr/include]
dyncall/CMakeFiles/CMakeOutput.log:  link line regex: [^( *|.*[/\])(ld|CMAKE_LINK_STARTFILE-NOTFOUND|([^/\]+-)?ld|collect2)[^/\]*( |$)]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Change Dir: /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/CMakeTmp]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Run Build Command(s):/usr/bin/make -f Makefile cmTC_2a0ac/fast && /usr/bin/make  -f CMakeFiles/cmTC_2a0ac.dir/build.make CMakeFiles/cmTC_2a0ac.dir/build]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [make[1]: Entering directory '/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/CMakeTmp']
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [/usr/bin/c++   -v -o CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.o -c /usr/share/cmake-3.21/Modules/CMakeCXXCompilerABI.cpp]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Using built-in specs.]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Target: x86_64-pc-linux-gnu]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Configured with: /build/gcc/src/gcc/configure --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c c++ ada fortran go lto objc obj-c++ d --with-isl --with-linker-hash-style=gnu --with-system-zlib --enable-__cxa_atexit --enable-cet=auto --enable-checking=release --enable-clocale=gnu --enable-default-pie --enable-default-ssp --enable-gnu-indirect-function --enable-gnu-unique-object --enable-install-libiberty --enable-linker-build-id --enable-lto --enable-multilib --enable-plugin --enable-shared --enable-threads=posix --disable-libssp --disable-libstdcxx-pch --disable-libunwind-exceptions --disable-werror gdc_include_dir=/usr/include/dlang/gdc]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mtune=generic' '-march=x86-64' '-dumpdir' 'CMakeFiles/cmTC_2a0ac.dir/']
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/cc1plus -quiet -v -D_GNU_SOURCE /usr/share/cmake-3.21/Modules/CMakeCXXCompilerABI.cpp -quiet -dumpdir CMakeFiles/cmTC_2a0ac.dir/ -dumpbase CMakeCXXCompilerABI.cpp.cpp -dumpbase-ext .cpp -mtune=generic -march=x86-64 -version -o /tmp/ccn3Urv8.s]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [GNU C++17 (GCC) version 11.1.0 (x86_64-pc-linux-gnu)]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [	compiled by GNU C version 11.1.0  GMP version 6.2.1  MPFR version 4.1.0  MPC version 1.2.1  isl version isl-0.24-GMP]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [warning: MPFR header version 4.1.0 differs from library version 4.1.0-p13.]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [ignoring nonexistent directory "/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../x86_64-pc-linux-gnu/include"]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../include/c++/11.1.0]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../include/c++/11.1.0/x86_64-pc-linux-gnu]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../include/c++/11.1.0/backward]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [GNU C++17 (GCC) version 11.1.0 (x86_64-pc-linux-gnu)]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [	compiled by GNU C version 11.1.0  GMP version 6.2.1  MPFR version 4.1.0  MPC version 1.2.1  isl version isl-0.24-GMP]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [warning: MPFR header version 4.1.0 differs from library version 4.1.0-p13.]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mtune=generic' '-march=x86-64' '-dumpdir' 'CMakeFiles/cmTC_2a0ac.dir/']
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [ as -v --64 -o CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.o /tmp/ccn3Urv8.s]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [GNU assembler version 2.36.1 (x86_64-pc-linux-gnu) using BFD version (GNU Binutils) 2.36.1]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../:/lib/:/usr/lib/]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mtune=generic' '-march=x86-64' '-dumpdir' 'CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.']
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_2a0ac.dir/link.txt --verbose=1]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [/usr/bin/c++  -v -rdynamic CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.o -o cmTC_2a0ac ]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Using built-in specs.]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/lto-wrapper]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Target: x86_64-pc-linux-gnu]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [Configured with: /build/gcc/src/gcc/configure --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c c++ ada fortran go lto objc obj-c++ d --with-isl --with-linker-hash-style=gnu --with-system-zlib --enable-__cxa_atexit --enable-cet=auto --enable-checking=release --enable-clocale=gnu --enable-default-pie --enable-default-ssp --enable-gnu-indirect-function --enable-gnu-unique-object --enable-install-libiberty --enable-linker-build-id --enable-lto --enable-multilib --enable-plugin --enable-shared --enable-threads=posix --disable-libssp --disable-libstdcxx-pch --disable-libunwind-exceptions --disable-werror gdc_include_dir=/usr/include/dlang/gdc]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../:/lib/:/usr/lib/]
dyncall/CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_2a0ac' '-shared-libgcc' '-mtune=generic' '-march=x86-64' '-dumpdir' 'cmTC_2a0ac.']
dyncall/CMakeFiles/CMakeOutput.log:  link line: [ /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/collect2 -plugin /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/lto-wrapper -plugin-opt=-fresolution=/tmp/ccB0GWSR.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --build-id --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -o cmTC_2a0ac /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/Scrt1.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crti.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtbeginS.o -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0 -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../.. CMakeFiles/cmTC_2a0ac.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtendS.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crtn.o]
dyncall/CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/collect2] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/liblto_plugin.so] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/lto-wrapper] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-fresolution=/tmp/ccB0GWSR.res] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lc] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [--build-id] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [--eh-frame-hdr] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [--hash-style=gnu] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-m] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-export-dynamic] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-dynamic-linker] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [/lib64/ld-linux-x86-64.so.2] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-pie] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [-o] ==> ignore
dyncall/CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/Scrt1.o] ==> obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/Scrt1.o]
dyncall/CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crti.o] ==> obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crti.o]
dyncall/CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtbeginS.o] ==> obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtbeginS.o]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0] ==> dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib] ==> dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-L/lib/../lib] ==> dir [/lib/../lib]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/../lib] ==> dir [/usr/lib/../lib]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../..] ==> dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../..]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-lstdc++] ==> lib [stdc++]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-lm] ==> lib [m]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-lgcc_s] ==> lib [gcc_s]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-lgcc] ==> lib [gcc]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-lc] ==> lib [c]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-lgcc_s] ==> lib [gcc_s]
dyncall/CMakeFiles/CMakeOutput.log:    arg [-lgcc] ==> lib [gcc]
dyncall/CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtendS.o] ==> obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtendS.o]
dyncall/CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crtn.o] ==> obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crtn.o]
dyncall/CMakeFiles/CMakeOutput.log:  collapse obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/Scrt1.o] ==> [/usr/lib/Scrt1.o]
dyncall/CMakeFiles/CMakeOutput.log:  collapse obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crti.o] ==> [/usr/lib/crti.o]
dyncall/CMakeFiles/CMakeOutput.log:  collapse obj [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crtn.o] ==> [/usr/lib/crtn.o]
dyncall/CMakeFiles/CMakeOutput.log:  collapse library dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0] ==> [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0]
dyncall/CMakeFiles/CMakeOutput.log:  collapse library dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib] ==> [/usr/lib]
dyncall/CMakeFiles/CMakeOutput.log:  collapse library dir [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../..] ==> [/usr/lib]
dyncall/CMakeFiles/CMakeOutput.log:  implicit objs: [/usr/lib/Scrt1.o;/usr/lib/crti.o;/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtbeginS.o;/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtendS.o;/usr/lib/crtn.o]
dyncall/CMakeFiles/CMakeOutput.log:  implicit dirs: [/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0;/usr/lib;/lib]
dyncall/CMakeFiles/CMakeOutput.log:Change Dir: /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/CMakeTmp
dyncall/CMakeFiles/CMakeOutput.log:Run Build Command(s):/usr/bin/make -f Makefile cmTC_8eb2a/fast && /usr/bin/make  -f CMakeFiles/cmTC_8eb2a.dir/build.make CMakeFiles/cmTC_8eb2a.dir/build
dyncall/CMakeFiles/CMakeOutput.log:make[1]: Entering directory '/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/CMakeTmp'
dyncall/CMakeFiles/CMakeOutput.log:/usr/bin/cc -DCOMPILER_HAS_FPIC  -fPIC -Werror -o CMakeFiles/cmTC_8eb2a.dir/src.c.o -c /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/CMakeTmp/src.c
dyncall/CMakeFiles/CMakeOutput.log:/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_8eb2a.dir/link.txt --verbose=1
dyncall/CMakeFiles/CMakeOutput.log:/usr/bin/cc -rdynamic CMakeFiles/cmTC_8eb2a.dir/src.c.o -o cmTC_8eb2a 
dyncall/CMakeFiles/CMakeOutput.log:make[1]: Leaving directory '/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/CMakeTmp'
dyncall/CMakeFiles/CMakeOutput.log:Checking whether the ASM compiler is GNU using "--version" matched "(GNU assembler)|(GCC)|(Free Software Foundation)":
dyncall/CMakeFiles/Makefile2:# Disable VCS-based implicit rules.
dyncall/CMakeFiles/Makefile2:# Disable VCS-based implicit rules.
dyncall/CMakeFiles/Makefile2:# Disable VCS-based implicit rules.
dyncall/CMakeFiles/Makefile2:# Disable VCS-based implicit rules.
dyncall/CMakeFiles/Makefile2:# Disable VCS-based implicit rules.
dyncall/CMakeFiles/Makefile2:# Command-line flag to silence nested $(MAKE).
dyncall/CMakeFiles/Makefile2:$(VERBOSE)MAKESILENT = -s
dyncall/CMakeFiles/Makefile2:RM = /usr/bin/cmake -E rm -f
dyncall/CMakeFiles/Makefile2:# The top-level source directory on which CMake was run.
dyncall/CMakeFiles/Makefile2:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/CMakeFiles/Makefile2:# The top-level build directory on which CMake was run.
dyncall/CMakeFiles/Makefile2:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f dynload/CMakeFiles/dynload_s.dir/build.make dynload/CMakeFiles/dynload_s.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f dynload/CMakeFiles/dynload_s.dir/build.make dynload/CMakeFiles/dynload_s.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=35,36,37 "Built target dynload_s"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 3
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 dynload/CMakeFiles/dynload_s.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f dynload/CMakeFiles/dynload_s.dir/build.make dynload/CMakeFiles/dynload_s.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f dyncall/CMakeFiles/dyncall_s.dir/build.make dyncall/CMakeFiles/dyncall_s.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f dyncall/CMakeFiles/dyncall_s.dir/build.make dyncall/CMakeFiles/dyncall_s.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=19,20,21,22,23,24,25,26 "Built target dyncall_s"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 8
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 dyncall/CMakeFiles/dyncall_s.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f dyncall/CMakeFiles/dyncall_s.dir/build.make dyncall/CMakeFiles/dyncall_s.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f dyncallback/CMakeFiles/dyncallback_s.dir/build.make dyncallback/CMakeFiles/dyncallback_s.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f dyncallback/CMakeFiles/dyncallback_s.dir/build.make dyncallback/CMakeFiles/dyncallback_s.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=27,28,29,30,31,32 "Built target dyncallback_s"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 6
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 dyncallback/CMakeFiles/dyncallback_s.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f dyncallback/CMakeFiles/dyncallback_s.dir/build.make dyncallback/CMakeFiles/dyncallback_s.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f doc/manual/CMakeFiles/manual.dir/build.make doc/manual/CMakeFiles/manual.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f doc/manual/CMakeFiles/manual.dir/build.make doc/manual/CMakeFiles/manual.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=43 "Built target manual"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 1
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 doc/manual/CMakeFiles/manual.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f doc/manual/CMakeFiles/manual.dir/build.make doc/manual/CMakeFiles/manual.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/plain_c++/CMakeFiles/plain_cxx.dir/build.make test/plain_c++/CMakeFiles/plain_cxx.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/plain_c++/CMakeFiles/plain_cxx.dir/build.make test/plain_c++/CMakeFiles/plain_cxx.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=49,50 "Built target plain_cxx"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 10
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/plain_c++/CMakeFiles/plain_cxx.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/plain_c++/CMakeFiles/plain_cxx.dir/build.make test/plain_c++/CMakeFiles/plain_cxx.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/suite2/CMakeFiles/suite2.dir/build.make test/suite2/CMakeFiles/suite2.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/suite2/CMakeFiles/suite2.dir/build.make test/suite2/CMakeFiles/suite2.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=58,59,60 "Built target suite2"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 11
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/suite2/CMakeFiles/suite2.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/suite2/CMakeFiles/suite2.dir/build.make test/suite2/CMakeFiles/suite2.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/suite3/CMakeFiles/suite3.dir/build.make test/suite3/CMakeFiles/suite3.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/suite3/CMakeFiles/suite3.dir/build.make test/suite3/CMakeFiles/suite3.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=61,62,63 "Built target suite3"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 11
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/suite3/CMakeFiles/suite3.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/suite3/CMakeFiles/suite3.dir/build.make test/suite3/CMakeFiles/suite3.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/suite_floats/CMakeFiles/suite_floats.dir/build.make test/suite_floats/CMakeFiles/suite_floats.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/suite_floats/CMakeFiles/suite_floats.dir/build.make test/suite_floats/CMakeFiles/suite_floats.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=64,65,66 "Built target suite_floats"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 11
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/suite_floats/CMakeFiles/suite_floats.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/suite_floats/CMakeFiles/suite_floats.dir/build.make test/suite_floats/CMakeFiles/suite_floats.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/ellipsis/CMakeFiles/ellipsis.dir/build.make test/ellipsis/CMakeFiles/ellipsis.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/ellipsis/CMakeFiles/ellipsis.dir/build.make test/ellipsis/CMakeFiles/ellipsis.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=38,39,40 "Built target ellipsis"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 11
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/ellipsis/CMakeFiles/ellipsis.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/ellipsis/CMakeFiles/ellipsis.dir/build.make test/ellipsis/CMakeFiles/ellipsis.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/call_suite/CMakeFiles/call_suite.dir/build.make test/call_suite/CMakeFiles/call_suite.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/call_suite/CMakeFiles/call_suite.dir/build.make test/call_suite/CMakeFiles/call_suite.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=1,2,3,4,5 "Built target call_suite"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 13
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/call_suite/CMakeFiles/call_suite.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/call_suite/CMakeFiles/call_suite.dir/build.make test/call_suite/CMakeFiles/call_suite.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/callback_suite/CMakeFiles/callback_suite.dir/build.make test/callback_suite/CMakeFiles/callback_suite.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/callback_suite/CMakeFiles/callback_suite.dir/build.make test/callback_suite/CMakeFiles/callback_suite.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=8,9,10,11,12,13,14,15,16 "Built target callback_suite"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 15
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/callback_suite/CMakeFiles/callback_suite.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/callback_suite/CMakeFiles/callback_suite.dir/build.make test/callback_suite/CMakeFiles/callback_suite.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/plain/CMakeFiles/plain.dir/build.make test/plain/CMakeFiles/plain.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/plain/CMakeFiles/plain.dir/build.make test/plain/CMakeFiles/plain.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=46,47,48 "Built target plain"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 11
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/plain/CMakeFiles/plain.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/plain/CMakeFiles/plain.dir/build.make test/plain/CMakeFiles/plain.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/suite/CMakeFiles/suite.dir/build.make test/suite/CMakeFiles/suite.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/suite/CMakeFiles/suite.dir/build.make test/suite/CMakeFiles/suite.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=55,56,57 "Built target suite"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 11
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/suite/CMakeFiles/suite.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/suite/CMakeFiles/suite.dir/build.make test/suite/CMakeFiles/suite.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/callf/CMakeFiles/callf.dir/build.make test/callf/CMakeFiles/callf.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/callf/CMakeFiles/callf.dir/build.make test/callf/CMakeFiles/callf.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=17,18 "Built target callf"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 10
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/callf/CMakeFiles/callf.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/callf/CMakeFiles/callf.dir/build.make test/callf/CMakeFiles/callf.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/nm/CMakeFiles/nm.dir/build.make test/nm/CMakeFiles/nm.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/nm/CMakeFiles/nm.dir/build.make test/nm/CMakeFiles/nm.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=44,45 "Built target nm"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 5
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/nm/CMakeFiles/nm.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/nm/CMakeFiles/nm.dir/build.make test/nm/CMakeFiles/nm.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/dynload_plain/CMakeFiles/x.dir/build.make test/dynload_plain/CMakeFiles/x.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/dynload_plain/CMakeFiles/x.dir/build.make test/dynload_plain/CMakeFiles/x.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=71,72 "Built target x"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 2
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/dynload_plain/CMakeFiles/x.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/dynload_plain/CMakeFiles/x.dir/build.make test/dynload_plain/CMakeFiles/x.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make test/dynload_plain/CMakeFiles/dynload_plain.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make test/dynload_plain/CMakeFiles/dynload_plain.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=33,34 "Built target dynload_plain"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 5
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/dynload_plain/CMakeFiles/dynload_plain.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/dynload_plain/CMakeFiles/dynload_plain.dir/build.make test/dynload_plain/CMakeFiles/dynload_plain.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/resolve_self/CMakeFiles/resolve_self.dir/build.make test/resolve_self/CMakeFiles/resolve_self.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/resolve_self/CMakeFiles/resolve_self.dir/build.make test/resolve_self/CMakeFiles/resolve_self.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=51,52 "Built target resolve_self"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 5
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/resolve_self/CMakeFiles/resolve_self.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/resolve_self/CMakeFiles/resolve_self.dir/build.make test/resolve_self/CMakeFiles/resolve_self.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/thunk/CMakeFiles/test_thunk.dir/build.make test/thunk/CMakeFiles/test_thunk.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/thunk/CMakeFiles/test_thunk.dir/build.make test/thunk/CMakeFiles/test_thunk.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=69,70 "Built target test_thunk"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 8
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/thunk/CMakeFiles/test_thunk.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/thunk/CMakeFiles/test_thunk.dir/build.make test/thunk/CMakeFiles/test_thunk.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make test/malloc_wx/CMakeFiles/malloc_wx.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make test/malloc_wx/CMakeFiles/malloc_wx.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=41,42 "Built target malloc_wx"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 8
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/malloc_wx/CMakeFiles/malloc_wx.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/malloc_wx/CMakeFiles/malloc_wx.dir/build.make test/malloc_wx/CMakeFiles/malloc_wx.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/callback_plain/CMakeFiles/callback_plain.dir/build.make test/callback_plain/CMakeFiles/callback_plain.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/callback_plain/CMakeFiles/callback_plain.dir/build.make test/callback_plain/CMakeFiles/callback_plain.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=6,7 "Built target callback_plain"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 8
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/callback_plain/CMakeFiles/callback_plain.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/callback_plain/CMakeFiles/callback_plain.dir/build.make test/callback_plain/CMakeFiles/callback_plain.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/sharedlib/CMakeFiles/sharedlib.dir/build.make test/sharedlib/CMakeFiles/sharedlib.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/sharedlib/CMakeFiles/sharedlib.dir/build.make test/sharedlib/CMakeFiles/sharedlib.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=53,54 "Built target sharedlib"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 5
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/sharedlib/CMakeFiles/sharedlib.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/sharedlib/CMakeFiles/sharedlib.dir/build.make test/sharedlib/CMakeFiles/sharedlib.dir/clean
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/syscall/CMakeFiles/syscall.dir/build.make test/syscall/CMakeFiles/syscall.dir/depend
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/syscall/CMakeFiles/syscall.dir/build.make test/syscall/CMakeFiles/syscall.dir/build
dyncall/CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=67,68 "Built target syscall"
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 10
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 test/syscall/CMakeFiles/syscall.dir/all
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/chenningcong/Desktop/dyncall-1.2/CMakeFiles 0
dyncall/CMakeFiles/Makefile2:	$(MAKE) $(MAKESILENT) -f test/syscall/CMakeFiles/syscall.dir/build.make test/syscall/CMakeFiles/syscall.dir/clean
dyncall/CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 0
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeASMCompiler.cmake.in"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeASMInformation.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeCCompiler.cmake.in"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeCCompilerABI.c"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeCInformation.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeCXXCompiler.cmake.in"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeCXXCompilerABI.cpp"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeCXXInformation.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeCheckCompilerFlagCommonPatterns.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeCommonLanguageInclude.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeCompilerIdDetection.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeDetermineASMCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeDetermineCCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeDetermineCXXCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeDetermineCompileFeatures.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeDetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeDetermineCompilerABI.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeDetermineCompilerId.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeDetermineSystem.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeFindBinUtils.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeGenericSystem.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeInitializeConfigs.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeLanguageInformation.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeParseImplicitIncludeInfo.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeParseImplicitLinkInfo.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeParseLibraryArchitecture.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeSystem.cmake.in"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeSystemSpecificInformation.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeSystemSpecificInitialize.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeTestASMCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeTestCCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeTestCXXCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeTestCompilerCommon.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CMakeUnixFindMake.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CPack.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CPackComponent.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CheckCCompilerFlag.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/CheckCSourceCompiles.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/ADSP-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/ARMCC-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/ARMClang-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/AppleClang-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/Borland-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/Bruce-C-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/CMakeCommonCompilerMacros.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/Clang-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/Clang-DetermineCompilerInternal.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/Comeau-CXX-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/Compaq-C-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/Compaq-CXX-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/Cray-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/Embarcadero-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/Fujitsu-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/FujitsuClang-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/GHS-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/GNU-ASM.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/GNU-C-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/GNU-C.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/GNU-CXX-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/GNU-CXX.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/GNU-FindBinUtils.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/GNU.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/HP-C-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/HP-CXX-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/IAR-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/IBMCPP-C-DetermineVersionInternal.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/IBMCPP-CXX-DetermineVersionInternal.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/Intel-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/IntelLLVM-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/MSVC-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/NVHPC-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/NVIDIA-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/OpenWatcom-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/PGI-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/PathScale-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/SCO-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/SDCC-C-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/SunPro-C-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/SunPro-CXX-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/TI-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/TinyCC-C-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/VisualAge-C-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/VisualAge-CXX-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/Watcom-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/XL-C-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/XL-CXX-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/XLClang-C-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/XLClang-CXX-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/zOS-C-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Compiler/zOS-CXX-DetermineCompiler.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/FindLATEX.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/FindPackageHandleStandardArgs.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/FindPackageMessage.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Internal/CheckCompilerFlag.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Internal/CheckSourceCompiles.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Internal/FeatureTesting.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Platform/Linux-Determine-CXX.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Platform/Linux-GNU-C.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Platform/Linux-GNU-CXX.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Platform/Linux-GNU.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Platform/Linux.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Modules/Platform/UnixPaths.cmake"
dyncall/CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.21/Templates/CPackConfig.cmake.in"
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dynload/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dynload/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dynload/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dynload/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dynload/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dynload/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dynload/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dynload/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dynload/CMakeFiles/dynload_s.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncall/CMakeFiles/dyncall_s.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncallback/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncallback/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncallback/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncallback/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncallback/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncallback/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncallback/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncallback/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/dyncallback/CMakeFiles/dyncallback_s.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/doc/manual/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/doc/manual/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/doc/manual/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/doc/manual/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/doc/manual/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/doc/manual/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/doc/manual/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/doc/manual/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/doc/manual/CMakeFiles/manual.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain_c++/CMakeFiles/plain_cxx.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite2/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite2/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite2/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite2/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite2/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite2/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite2/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite2/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite2/CMakeFiles/suite2.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite3/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite3/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite3/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite3/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite3/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite3/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite3/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite3/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite3/CMakeFiles/suite3.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite_floats/CMakeFiles/suite_floats.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/ellipsis/CMakeFiles/ellipsis.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/call_suite/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/call_suite/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/call_suite/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/call_suite/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/call_suite/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/call_suite/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/call_suite/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/call_suite/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/call_suite/CMakeFiles/call_suite.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_suite/CMakeFiles/callback_suite.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/plain/CMakeFiles/plain.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/suite/CMakeFiles/suite.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callf/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callf/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callf/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callf/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callf/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callf/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callf/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callf/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callf/CMakeFiles/callf.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/nm/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/nm/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/nm/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/nm/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/nm/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/nm/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/nm/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/nm/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/nm/CMakeFiles/nm.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/CMakeFiles/x.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/dynload_plain/CMakeFiles/dynload_plain.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/resolve_self/CMakeFiles/resolve_self.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/thunk/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/thunk/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/thunk/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/thunk/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/thunk/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/thunk/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/thunk/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/thunk/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/thunk/CMakeFiles/test_thunk.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/malloc_wx/CMakeFiles/malloc_wx.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/callback_plain/CMakeFiles/callback_plain.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/sharedlib/CMakeFiles/sharedlib.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/syscall/CMakeFiles/install/strip.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/syscall/CMakeFiles/install/local.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/syscall/CMakeFiles/package_source.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/syscall/CMakeFiles/install.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/syscall/CMakeFiles/list_install_components.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/syscall/CMakeFiles/rebuild_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/syscall/CMakeFiles/package.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/syscall/CMakeFiles/edit_cache.dir
dyncall/CMakeFiles/TargetDirectories.txt:/home/chenningcong/Desktop/dyncall-1.2/test/syscall/CMakeFiles/syscall.dir
dyncall/CMakeFiles/3.21.3/CMakeCXXCompiler.cmake:set(CMAKE_CXX_COMPILER_AR "/usr/bin/gcc-ar")
dyncall/CMakeFiles/3.21.3/CMakeCXXCompiler.cmake:set(CMAKE_CXX_COMPILER_RANLIB "/usr/bin/gcc-ranlib")
dyncall/CMakeFiles/3.21.3/CMakeCXXCompiler.cmake:set(CMAKE_CXX_IMPLICIT_INCLUDE_DIRECTORIES "/usr/include/c++/11.1.0;/usr/include/c++/11.1.0/x86_64-pc-linux-gnu;/usr/include/c++/11.1.0/backward;/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include;/usr/local/include;/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed;/usr/include")
dyncall/CMakeFiles/3.21.3/CMakeCXXCompiler.cmake:set(CMAKE_CXX_IMPLICIT_LINK_DIRECTORIES "/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0;/usr/lib;/lib")
dyncall/CMakeFiles/3.21.3/CMakeCCompiler.cmake:set(CMAKE_C_COMPILER_AR "/usr/bin/gcc-ar")
dyncall/CMakeFiles/3.21.3/CMakeCCompiler.cmake:set(CMAKE_C_COMPILER_RANLIB "/usr/bin/gcc-ranlib")
dyncall/CMakeFiles/3.21.3/CMakeCCompiler.cmake:set(CMAKE_C_IMPLICIT_INCLUDE_DIRECTORIES "/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include;/usr/local/include;/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed;/usr/include")
dyncall/CMakeFiles/3.21.3/CMakeCCompiler.cmake:set(CMAKE_C_IMPLICIT_LINK_DIRECTORIES "/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0;/usr/lib;/lib")
dyncall/CMakeFiles/3.21.3/CompilerIdCXX/CMakeCXXCompilerId.cpp:   /* The third version component from --version is an update index,
dyncall/CMakeFiles/3.21.3/CompilerIdCXX/CMakeCXXCompilerId.cpp:# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
dyncall/CMakeFiles/3.21.3/CompilerIdCXX/CMakeCXXCompilerId.cpp:#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
dyncall/CMakeFiles/3.21.3/CompilerIdCXX/CMakeCXXCompilerId.cpp:# define PLATFORM_ID "HP-UX"
dyncall/CMakeFiles/3.21.3/CompilerIdCXX/CMakeCXXCompilerId.cpp:# define PLATFORM_ID "MP-RAS"
dyncall/CMakeFiles/3.21.3/CompilerIdCXX/CMakeCXXCompilerId.cpp:/*--------------------------------------------------------------------------*/
dyncall/CMakeFiles/3.21.3/CMakeSystem.cmake:set(CMAKE_HOST_SYSTEM "Linux-5.14.7-2-MANJARO")
dyncall/CMakeFiles/3.21.3/CMakeSystem.cmake:set(CMAKE_HOST_SYSTEM_VERSION "5.14.7-2-MANJARO")
dyncall/CMakeFiles/3.21.3/CMakeSystem.cmake:set(CMAKE_SYSTEM "Linux-5.14.7-2-MANJARO")
dyncall/CMakeFiles/3.21.3/CMakeSystem.cmake:set(CMAKE_SYSTEM_VERSION "5.14.7-2-MANJARO")
dyncall/CMakeFiles/3.21.3/CMakeASMCompiler.cmake:set(CMAKE_ASM_COMPILER_AR "/usr/bin/gcc-ar")
dyncall/CMakeFiles/3.21.3/CMakeASMCompiler.cmake:set(CMAKE_ASM_COMPILER_RANLIB "/usr/bin/gcc-ranlib")
dyncall/CMakeFiles/3.21.3/CompilerIdC/CMakeCCompilerId.c:/* cv-qualifiers did not exist in K&R C */
dyncall/CMakeFiles/3.21.3/CompilerIdC/CMakeCCompilerId.c:   /* The third version component from --version is an update index,
dyncall/CMakeFiles/3.21.3/CompilerIdC/CMakeCCompilerId.c:# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
dyncall/CMakeFiles/3.21.3/CompilerIdC/CMakeCCompilerId.c:#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
dyncall/CMakeFiles/3.21.3/CompilerIdC/CMakeCCompilerId.c:# define PLATFORM_ID "HP-UX"
dyncall/CMakeFiles/3.21.3/CompilerIdC/CMakeCCompilerId.c:# define PLATFORM_ID "MP-RAS"
dyncall/CMakeFiles/3.21.3/CompilerIdC/CMakeCCompilerId.c:/*--------------------------------------------------------------------------*/
dyncall/Makefile.embedded:MAKE_CMD = ${MAKE} -f ${MAKEFILE} 
dyncall/Makefile.embedded:	CFLAGS="${CFLAGS} -m64" ASFLAGS="${ASFLAGS} -m64" ${MAKE_CMD} all
dyncall/Makefile.embedded:minix-gcc:
dyncall/Makefile.embedded:	${MAKE_CMD} CC=gcc AS="gcc -c" all
dyncall/Makefile.embedded:osx-universal:
dyncall/Makefile.embedded:	CFLAGS="${CFLAGS} -arch i386 -arch x86_64 -arch ppc" ASFLAGS="${ASFLAGS} -arch i386 -arch x86_64 -arch ppc" AR="libtool" ARFLAGS="-static -o" ${MAKE_CMD} all
dyncall/Makefile.embedded:osx-template:
dyncall/Makefile.embedded:osx-i386:
dyncall/Makefile.embedded:	OSX_ARCH="-arch i386" ${MAKE_CMD} osx-template
dyncall/Makefile.embedded:sun-64bit:
dyncall/Makefile.embedded:	CFLAGS="${CFLAGS} -m64" ASFLAGS="${ASFLAGS} -m64" ${MAKE_CMD} all
dyncall/Makefile.embedded:sun-gcc:
dyncall/Makefile.embedded:	CC=gcc CFLAGS="${CFLAGS} -fPIC" ${MAKE_CMD} all
dyncall/Makefile.embedded:sun-gcc-64bit:
dyncall/Makefile.embedded:	CC=gcc CFLAGS="${CFLAGS} -m64" ASFLAGS="${ASFLAGS} -m64" ${MAKE_CMD} all
dyncall/Makefile.embedded:ios-sdkroot:
dyncall/Makefile.embedded:  AS="${CC} ${IOS_ARCH} -miphoneos-version-min=${IOS_SDK}"\
dyncall/Makefile.embedded:  CC="${CC} ${IOS_ARCH} -miphoneos-version-min=${IOS_SDK}"\
dyncall/Makefile.embedded:  CXX="${CXX} ${IOS_ARCH} -miphoneos-version-min=${IOS_SDK}"\
dyncall/Makefile.embedded:  LD="${LD} ${IOS_ARCH} -miphoneos-version-min=${IOS_SDK}"\
dyncall/Makefile.embedded:  ASFLAGS="-isysroot ${IOS_SDKROOT}"\
dyncall/Makefile.embedded:  CFLAGS="-isysroot ${IOS_SDKROOT}"\
dyncall/Makefile.embedded:  CXXFLAGS="-isysroot ${IOS_SDKROOT}"\
dyncall/Makefile.embedded:  LDFLAGS="-Wl,-syslibroot ${IOS_SDKROOT}"\
dyncall/Makefile.embedded:	IOS_SDKROOT="`xcode-select -print-path`/Platforms/iPhone${IOS_PLATFORM}.platform/Developer/SDKs/iPhone${IOS_PLATFORM}${IOS_SDK}.sdk" ${MAKE_CMD} ios-sdkroot
dyncall/Makefile.embedded:ios-sim:
dyncall/Makefile.embedded:ios-os:
dyncall/Makefile.embedded:ios61-os:
dyncall/Makefile.embedded:	IOS_SDK="6.1" IOS_ARCH="-arch armv7"             ${MAKE_CMD} ios-os
dyncall/Makefile.embedded:ios61-os-no-thumb:
dyncall/Makefile.embedded:	IOS_SDK="6.1" IOS_ARCH="-arch armv7 -mno-thumb"  ${MAKE_CMD} ios-os
dyncall/Makefile.embedded:ios61-sim:
dyncall/Makefile.embedded:	IOS_SDK="6.1" IOS_ARCH="-arch i386"              ${MAKE_CMD} ios-sim
dyncall/Makefile.embedded:ios83-os-universal:
dyncall/Makefile.embedded:	IOS_SDK="8.3" IOS_ARCH="-arch armv7 -arch arm64" ${MAKE_CMD} ios-os
dyncall/Makefile.embedded:ios83-sim:
dyncall/Makefile.embedded:	IOS_SDK="8.3" IOS_ARCH="-arch i386"              ${MAKE_CMD} ios-sim
dyncall/Makefile.embedded:.PHONY: all tests clean install bsd linux linux64 minix-gcc mingw32 osx osx-universal sun sun-64bit sun-gcc sun-gcc-64bit
dyncall/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2
dyncall/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/dynload/cmake_install.cmake")
dyncall/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/dyncall/cmake_install.cmake")
dyncall/cmake_install.cmake:  include("/home/chenningcong/Desktop/dyncall-1.2/dyncallback/cmake_install.cmake")
dyncall/cmake_install.cmake:file(WRITE "/home/chenningcong/Desktop/dyncall-1.2/${CMAKE_INSTALL_MANIFEST}"
dyncall/buildsys/cmake/Modules/FindDynLoad.cmake:# - Try to find dynload library
dyncall/buildsys/cmake/Modules/FindDynLoad.cmake:# ----------------------------------------------------------------------------
dyncall/buildsys/cmake/Modules/FindDynLoad.cmake:# Copyright (c) 2010-2011 Daniel Adler <dadler@uni-goettingen.de>
dyncall/buildsys/cmake/Modules/FindDynCallback.cmake:# - Try to find DynLoad library
dyncall/buildsys/cmake/Modules/FindDynCallback.cmake:# ----------------------------------------------------------------------------
dyncall/buildsys/cmake/Modules/FindDynCallback.cmake:# Copyright (c) 2010,2011 Daniel Adler <dadler@uni-goettingen.de>
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:# Under the terms of Contract DE-AC04-94AL85000, there is a non-exclusive
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:#       handy if you want to do in-source builds.
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:#       sub-tex files for multipart tex files.
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:    MESSAGE("${MAKEINDEX_COMPILER} ${MAKEGLOSSARIES_COMPILER_FLAGS} -s ${istfile} -t ${glossary_log} -o ${glossary_out} ${glossary_in}")
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      -s ${istfile} -t ${glossary_log} -o ${glossary_out} ${glossary_in}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:  SET(LATEX_COMPILER_FLAGS "-interaction=nonstopmode"
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:  SET(DVIPS_CONVERTER_FLAGS "-Ppdf -G0 -t letter"
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:  SET(PS2PDF_CONVERTER_FLAGS "-dMaxSubsetPct=100 -dCompatibilityLevel=1.3 -dSubsetFonts=true -dEmbedAllFonts=true -dAutoFilterColorImages=false -dAutoFilterGrayImages=false -dColorImageFilter=/FlateEncode -dGrayImageFilter=/FlateEncode -dMonoImageFilter=/FlateEncode"
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      SET (convert_flags "-dEPSCrop ${flags}")
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:        ARGS -E copy ${input_dir}/${input_file} ${output_dir}/${input_file}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:          SET(convert_flags -resize ${LATEX_RASTER_SCALE}%)
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:        ARGS -E copy ${CMAKE_CURRENT_SOURCE_DIR}/${file} ${output_dir}/${file}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:    ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:    ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      -D LATEX_BUILD_COMMAND=makeglossaries
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      -D LATEX_TARGET=${LATEX_TARGET}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      -D MAKEINDEX_COMPILER=${MAKEINDEX_COMPILER}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      -D MAKEGLOSSARIES_COMPILER_FLAGS=${MAKEGLOSSARIES_COMPILER_FLAGS}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      -P ${LATEX_USE_LATEX_LOCATION}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      -D LATEX_BUILD_COMMAND=makeglossaries
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      -D LATEX_TARGET=${LATEX_TARGET}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      -D MAKEINDEX_COMPILER=${MAKEINDEX_COMPILER}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      -D MAKEGLOSSARIES_COMPILER_FLAGS=${MAKEGLOSSARIES_COMPILER_FLAGS}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      -P ${LATEX_USE_LATEX_LOCATION}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:    COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:    COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:    COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:    COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      COMMAND ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:        ${DVIPS_CONVERTER} ${DVIPS_CONVERTER_FLAGS} -o ${LATEX_TARGET}.ps ${LATEX_TARGET}.dvi
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:        ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:      ${CMAKE_COMMAND} -E chdir ${output_dir}
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:    ${CMAKE_COMMAND} -E remove ${output_dir}/${LATEX_TARGET}.aux ${output_dir}/${LATEX_TARGET}.idx ${output_dir}/${LATEX_TARGET}.ind
dyncall/buildsys/cmake/Modules/UseLATEX.cmake:        ARGS -E copy ${CMAKE_CURRENT_SOURCE_DIR}/${bib_file} ${output_dir}/${bib_file}
dyncall/buildsys/cmake/Modules/FindDynCall.cmake:# - Try to find dyncall library
dyncall/buildsys/cmake/Modules/FindDynCall.cmake:# ----------------------------------------------------------------------------
dyncall/buildsys/cmake/Modules/FindDynCall.cmake:# Copyright (c) 2010,2011 Daniel Adler <dadler@uni-goettingen.de>
dyncall/buildsys/scripts/conf-nds.bat:REM Copyright (c) 2007-2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/buildsys/scripts/conf-nds.bat:REM                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/buildsys/scripts/batch-build-psp.sh:# ------------------------------------------------------------- #
dyncall/buildsys/scripts/batch-build-psp.sh:# ------------------------------------------------------------- #
dyncall/buildsys/scripts/batch-build-psp.sh:./configure --target=PSP
dyncall/buildsys/scripts/batch-build-psp.sh:make libdyncall libdyncallback tests-libdyncall # tests-libdyncallback
dyncall/buildsys/scripts/setenv-cross-ios.sh:export TARGET_MACH="-arch ${IOS_ARCH}" 
dyncall/buildsys/scripts/setenv-cross-ios.sh:export TARGET_ARCH="-arch ${IOS_ARCH} -isysroot /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS${IOS_SDK_VERSION}.sdk" 
dyncall/buildsys/scripts/batch-build-minix.sh:# ---------------------------------------------------------- #
dyncall/buildsys/scripts/batch-build-minix.sh:# ---------------------------------------------------------- #
dyncall/buildsys/scripts/batch-build-minix.sh:make libdyncall libdyncallback tests-libdyncallback tests-libdyncall
dyncall/buildsys/scripts/elf-to-psp-eboot.sh:if ! [ -x "$1" ]; then
dyncall/buildsys/scripts/elf-to-psp-eboot.sh:psp-fixup-imports -o $FIXED_ELF $1
dyncall/buildsys/scripts/elf-to-psp-eboot.sh:psp-strip         $FIXED_ELF -o $STRIPPED_ELF
dyncall/buildsys/scripts/elf-to-psp-eboot.sh:pack-pbp          EBOOT.PBP $SFO NULL NULL NULL NULL NULL $STRIPPED_ELF NULL
dyncall/buildsys/scripts/batch-build-linux.sh:make -f Makefile.generic clean all
dyncall/buildsys/scripts/batch-build-linux.sh:# Build tests: dynload tests need '-ldl'.
dyncall/buildsys/scripts/batch-build-linux.sh:( cd test ; make -f Makefile.generic clean )
dyncall/buildsys/scripts/batch-build-linux.sh:( cd test ; LDLIBS=-ldl make -f Makefile.generic all-dynload )
dyncall/buildsys/scripts/batch-build-linux.sh:( cd test ; make -f Makefile.generic all )
dyncall/buildsys/scripts/setenv-sdk-ios.sh:#export PATH=`xcode-select -print-path`/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:${PATH}
dyncall/buildsys/scripts/setenv-sdk-ios.sh:DEVELOPER=`xcode-select -print-path`
dyncall/buildsys/scripts/setenv-sdk-ios.sh:#if [ -z "${DEVELOPER}" ]; then
dyncall/buildsys/scripts/setenv-sdk-ios.sh:#if [ `exec sw_vers -productVersion` ]; then
dyncall/buildsys/scripts/setenv-sdk-ios.sh:#  case `sw_vers -productVersion` in
dyncall/buildsys/mk/app.mk:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/buildsys/mk/app.mk:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/buildsys/mk/lib.mk:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/buildsys/mk/lib.mk:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/buildsys/mk/prolog.mk:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/buildsys/mk/prolog.mk:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/buildsys/mk/dirs.mk:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/buildsys/mk/dirs.mk:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/buildsys/mk/dirs.mk:		 echo Handling sub-directory $i...
dyncall/buildsys/mk/dirs.mk:		 cd $i && rfork && rm /env/DIRS && $MK -f mkfile $MKFLAGS
dyncall/buildsys/mk/epilog.mk:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/buildsys/mk/epilog.mk:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/buildsys/mk/pcc.mk:# Copyright (c) 2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/buildsys/mk/pcc.mk:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/buildsys/mk/pcc.mk:#@@@ add -g option or similar
dyncall/buildsys/mk/pcc.mk:CPPFLAGS = -D__Plan9__ -D__${objtype}__
dyncall/buildsys/mk/pcc.mk:CFLAGS   = -D__Plan9__ -D__${objtype}__ -I$TOP/dyncall -I$TOP/dyncallback -c
dyncall/buildsys/mk/pcc.mk:#CXXFLAGS = $CXXFLAGS -D__Plan9__
dyncall/buildsys/mk/pcc.mk:#ASFLAGS  = -D__Plan9__
dyncall/buildsys/mk/pcc.mk:# JUST TEMPORARY AS LONG AS I'M WORKING ON IT - Plan9's sed doesn't support sed comments
dyncall/buildsys/mk/pcc.mk:#        s/([A-Z]+)[  ]*E(..)[,   ]*E(..)/\1L \3, \2/                        # Convert 32bit instructions with 2 register operands.
dyncall/buildsys/mk/pcc.mk:#        s/([A-Z]+)[  ]*E(..)[,   ]*([0-9]+)/\1L $\3, \2/                    # Convert 32bit instructions with register and constant as
dyncall/buildsys/mk/pcc.mk:#        s/([A-Z]+)[  ]*E(..)[,   ]*\[E(..)\+([0-9]+)\]/\1L \4(\3), \2/      # Convert 32bit instructions with register and address as 
dyncall/buildsys/mk/pcc.mk:#        s/([A-Z]+)[  ]*E(..)[,   ]*\[E(..)\]/\1L 0(\3), \2/                 # Convert 32bit instructions with register and address as 
dyncall/buildsys/mk/pcc.mk:#        s/(CALL)[    ]*\[E(..)\+([0-9]+)\]/\1 \3(\2)/                       # Convert CALL instructions with addressing mode.
dyncall/buildsys/mk/pcc.mk:#        s/([A-Z]+)[  ]*E(..)[    ]*$/\1L \2/                                # Convert 32bit instructions with register operand.
dyncall/buildsys/mk/pcc.mk:#        s/([A-Z]+)[  ]*\[E(..)\+([0-9]+)\]/\1L \3(\2)/                      # Convert 32bit instructions with address operand.
dyncall/buildsys/mk/pcc.mk:#        s/([A-Z]+)[  ]*\[E(..)\]/\1L 0(\2)/                                 # Convert 32bit instructions with address operand.
dyncall/buildsys/mk/pcc.mk:	pcc -E $CPPFLAGS $prereq.c > $stem.s # replace with cpp? pcc requires .c suffix
dyncall/buildsys/nmake/tool_gcc.nmake:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/buildsys/nmake/tool_gcc.nmake:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/buildsys/nmake/tool_gcc.nmake:CC  =arm-eabi-gcc
dyncall/buildsys/nmake/tool_gcc.nmake:CXX =arm-eabi-g++
dyncall/buildsys/nmake/tool_gcc.nmake:AR  =arm-eabi-ar
dyncall/buildsys/nmake/tool_gcc.nmake:AS  =arm-eabi-as
dyncall/buildsys/nmake/tool_gcc.nmake:LD  =arm-eabi-g++#arm-eabi-ld
dyncall/buildsys/nmake/tool_gcc.nmake:OCP =arm-eabi-objcopy
dyncall/buildsys/nmake/tool_gcc.nmake:ASFLAGS  = -g -mthumb -mthumb-interwork
dyncall/buildsys/nmake/tool_gcc.nmake:CFLAGS   = -g -Wall -O2 -I$(TOP)\dyncall -I$(TOP)\dyncallback -fomit-frame-pointer -ffast-math -fno-strict-aliasing -mthumb -mthumb-interwork
dyncall/buildsys/nmake/tool_gcc.nmake:CXXFLAGS = $(CFLAGS) -fno-rtti -fno-exceptions
dyncall/buildsys/nmake/tool_gcc.nmake:LDFLAGS  = -g -mno-fpu -mthumb -mthumb-interwork
dyncall/buildsys/nmake/tool_gcc.nmake:ASFLAGS  = -g
dyncall/buildsys/nmake/tool_gcc.nmake:CFLAGS   = -g -Wall -O2 -I$(TOP)\dyncall -I$(TOP)\dyncallback -fomit-frame-pointer -ffast-math -fno-strict-aliasing
dyncall/buildsys/nmake/tool_gcc.nmake:CXXFLAGS = $(CFLAGS) -fno-rtti -fno-exceptions
dyncall/buildsys/nmake/tool_gcc.nmake:LDFLAGS  = -g -mno-fpu
dyncall/buildsys/nmake/tool_gcc.nmake:CFLAGS   = $(CFLAGS) -DARM9 -mcpu=arm9tdmi -mtune=arm9tdmi -D__nds__ -I"$(DEVKITPRO_PATH)/libnds/include"
dyncall/buildsys/nmake/tool_gcc.nmake:CXXFLAGS = $(CXXFLAGS) -D__nds__ -I"$(DEVKITPRO_PATH)/libnds/include"
dyncall/buildsys/nmake/tool_gcc.nmake:LDFLAGS  = $(LDFLAGS) -specs=ds_arm9.specs
dyncall/buildsys/nmake/tool_gcc.nmake:	$(CC) $(ASFLAGS) $(CFLAGS) -o $@ -c $<
dyncall/buildsys/nmake/tool_gcc.nmake:	$(CC) $(CFLAGS) -o $@ -c $<
dyncall/buildsys/nmake/tool_gcc.nmake:	$(CXX) $(CXXFLAGS) -o $@ -c $<
dyncall/buildsys/nmake/tool_gcc.nmake:	$(CXX) $(CXXFLAGS) -o $@ -c $<
dyncall/buildsys/nmake/common.nmake:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/buildsys/nmake/common.nmake:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/buildsys/nmake/common.nmake:	!echo Handling sub-directory $** ... && cd $** && $(MAKE) /NOLOGO /F Nmakefile && cd ..
dyncall/buildsys/nmake/common.nmake:#	!echo Handling sub-directory $** ... && cd $** && $(MAKE) /NOLOGO /F Nmakefile $** && cd ..
dyncall/buildsys/nmake/common.nmake:	!echo Handling sub-directory $** ... && cd $** && $(MAKE) /NOLOGO /F Nmakefile $@ && cd ..
dyncall/buildsys/nmake/common.nmake:	!echo Handling sub-directory $** ... && cd $** && $(MAKE) /NOLOGO /F Nmakefile $@ && cd ..
dyncall/buildsys/nmake/common.nmake:	echo Cleaning auto-generated files in $(MAKEDIR) ...
dyncall/buildsys/nmake/prolog.nmake:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/buildsys/nmake/prolog.nmake:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/buildsys/nmake/epilog.nmake:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/buildsys/nmake/epilog.nmake:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/buildsys/nmake/tool_msvc.nmake:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/buildsys/nmake/tool_msvc.nmake:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/buildsys/nmake/tool_msvc.nmake:CFLAGS   = /EHsc /GR- /GS- /Ox /c /nologo /I$(TOP)\dyncall /I$(TOP)\dyncallback
dyncall/buildsys/lua/Makefile:all: lua-5.1.4
dyncall/buildsys/lua/Makefile:lua-5.1.4.tar.gz: 
dyncall/buildsys/lua/Makefile:	${DL} http://www.lua.org/ftp/lua-5.1.4.tar.gz
dyncall/buildsys/lua/Makefile:lua-5.1.4: lua-5.1.4.tar.gz
dyncall/buildsys/lua/Makefile:	gunzip -c $? | tar xf -
dyncall/buildsys/lua/Makefile:	rm -rf lua-5.1.4.tar.gz lua-5.1.4
dyncall/buildsys/lua/mkfile:# Copyright (c) 2013 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/buildsys/lua/mkfile:#                    Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/buildsys/lua/mkfile:LUA = lua-$VER
dyncall/buildsys/lua/mkfile:	tar -xf $TGZ
dyncall/buildsys/lua/mkfile:	rm -rf $LUA $TGZ
dyncall/buildsys/lua/setenv.sh:PATH=$PWD/lua-5.1.4/src:$PATH
dyncall/buildsys/lua/cleanup.sh:if [ -d lua-5.1.4 ]; then
dyncall/buildsys/lua/cleanup.sh:  (cd lua-5.1.4;make clean)
dyncall/buildsys/lua/bootstrap.sh:if [ -z "${DL}" ]; then
dyncall/buildsys/lua/bootstrap.sh:case `uname -s` in
dyncall/buildsys/lua/bootstrap.sh:DL="${DL}" make -f `dirname $0`/Makefile lua-5.1.4
dyncall/buildsys/lua/bootstrap.sh:(cd lua-5.1.4; make ${LPLAF})
dyncall/buildsys/vs2005/vs2005.sln:Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dyncall", "dyncall\dyncall.vcproj", "{DF67B85F-C8F8-4FB1-A701-867A9C835ABA}"
dyncall/buildsys/vs2005/vs2005.sln:		{DF67B85F-C8F8-4FB1-A701-867A9C835ABA}.Debug|Win32.ActiveCfg = Debug|Win32
dyncall/buildsys/vs2005/vs2005.sln:		{DF67B85F-C8F8-4FB1-A701-867A9C835ABA}.Debug|Win32.Build.0 = Debug|Win32
dyncall/buildsys/vs2005/vs2005.sln:		{DF67B85F-C8F8-4FB1-A701-867A9C835ABA}.Release|Win32.ActiveCfg = Release|Win32
dyncall/buildsys/vs2005/vs2005.sln:		{DF67B85F-C8F8-4FB1-A701-867A9C835ABA}.Release|Win32.Build.0 = Release|Win32
dyncall/buildsys/vs2005/dyncall/dyncall.vcproj:<?xml version="1.0" encoding="Windows-1252"?>
dyncall/buildsys/vs2005/dyncall/dyncall.vcproj:	ProjectGUID="{DF67B85F-C8F8-4FB1-A701-867A9C835ABA}"
dyncall/buildsys/vs2005/dyncall/dyncall.vcproj:			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
dyncall/buildsys/vs2005/dyncall/dyncall.vcproj:			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
dyncall/buildsys/vs2005/dyncall/dyncall.vcproj:			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
dyncall/doc/README-Cross.txt:Cross-compilation of dyncall with gcc
dyncall/doc/README-Cross.txt:Make sure cross-compile tools are installed and in your path, and set the
dyncall/doc/README-Cross.txt:CC, AR and LD envvars, explicitly (where $PREFIX is arm-eabi, etc., depending
dyncall/doc/README-Cross.txt:  $ export CC=$PREFIX-gcc
dyncall/doc/README-Cross.txt:  $ export AR=$PREFIX-ar
dyncall/doc/README-Cross.txt:  $ export LD=$PREFIX-ld
dyncall/doc/README-Cross.txt:  $ export CXX=$PREFIX-g++
dyncall/doc/README-Cross.txt:Then, build dyncall - one way would be to simply use Makefile.embedded:
dyncall/doc/README-Cross.txt:  $ make -f Makefile.embedded sun
dyncall/doc/README-Cross.txt:  $ (cd test; make -f Makefile.embedded)
dyncall/doc/README.SunOS:Supported Build-Systems: configure/make, Makefile.embedded and CMake.
dyncall/doc/README.SunOS:OpenSolaris distributions - the library builds and runs fine on Nexenta
dyncall/doc/README.SunOS:On Solaris, it also cross-builds for amd64 just fine, but the we don't
dyncall/doc/README.SunOS:-----------------
dyncall/doc/README.SunOS:-------------------------------------------------------------------
dyncall/doc/README.SunOS:  $ make -f Makefile.embedded sun
dyncall/doc/README.SunOS:  $ (cd test; make -f Makefile.embedded sun)
dyncall/doc/README.SunOS:-------------------------------------------------------------------------------
dyncall/doc/README.SunOS:  $ make -f Makefile.embedded sun-64bit
dyncall/doc/README.SunOS:  $ (cd test; make -f Makefile.embedded sun-64bit)
dyncall/doc/README.SunOS:---------------------------------------------------------------
dyncall/doc/README.SunOS:  $ make -f Makefile.embedded sun-gcc
dyncall/doc/README.SunOS:  $ (cd test; make -f Makefile.embedded sun-gcc)
dyncall/doc/README.SunOS:---------------------------------------------------------------------------
dyncall/doc/README.SunOS:  $ make -f Makefile.embedded sun-gcc-64bit
dyncall/doc/README.SunOS:  $ (cd test; make -f Makefile.embedded sun-gcc-64bit)
dyncall/doc/README.SunOS:--------------------------------------------------
dyncall/doc/README.SunOS:  $ cmake -DCMAKE_C_FLAGS=-m64 -DCMAKE_ASM_FLAGS=-m64 -DCMAKE_CXX_FLAGS=-m64 .
dyncall/doc/README.SunOS:------------
dyncall/doc/README.SunOS:  $ make -f Makefile.embedded PREFIX=<some/prefix> install
dyncall/doc/README.SunOS:----------------
dyncall/doc/README.SunOS:  - using Solaris 10 using SunPro Tools
dyncall/doc/README.SunOS:  - using Nexenta (SunOS 5.11 kernel) using GNU tools
dyncall/doc/README.SunOS:  - SunOS 5.1 using SunPro and GCC on a Sun Fire V440 via developer account
dyncall/doc/disas_examples/x86.plan9call.disas:; output from plan9-4th_edition-x86 w/ 8c x.c && 8l -a x.8
dyncall/doc/disas_examples/x86.plan9call.disas:001058    b878000000          (8)       MOVL                        $120,AX            ; return value: 'x' -> eax
dyncall/doc/disas_examples/x86.plan9call.disas:001064    c7042400000000      (13)      MOVL                        $0,(SP)            ; arg 0 -> "push" onto stack
dyncall/doc/disas_examples/x86.plan9call.disas:00106b    b801000000          (13)      MOVL                        $1,AX              ; arg 1 -> eax, then ...
dyncall/doc/disas_examples/x86.plan9call.disas:001074    b802000000          (13)      MOVL                        $2,AX              ; arg 2 -> eax, then ...
dyncall/doc/disas_examples/x86.plan9call.disas:001098    b806000000          (13)      MOVL                        $6,AX              ; arg 6 -> eax, then ...
dyncall/doc/disas_examples/arm.armhf.disas:; output from raspbian-wheezy_20120715-raspberrypi w/ gcc 4.6.3
dyncall/doc/disas_examples/arm.armhf.disas:; note: this is arm mode, -mthumb says "sorry, unimplemented: Thumb-1 hard-float VFP ABI" (however, -msoft-float -mthumb is supported)
dyncall/doc/disas_examples/arm.armhf.disas:;       not sure about thumb-2 as there is no flag for it, but I don't think this exists if using the VFP
dyncall/doc/disas_examples/arm.armhf.disas:   0:   e52db004        push    {fp} ; (str fp, [sp, #-4]!)
dyncall/doc/disas_examples/arm.armhf.disas:   c:   e50b0008        str     r0, [fp, #-8]
dyncall/doc/disas_examples/arm.armhf.disas:  10:   e50b100c        str     r1, [fp, #-12]
dyncall/doc/disas_examples/arm.armhf.disas:  14:   e50b2010        str     r2, [fp, #-16]
dyncall/doc/disas_examples/arm.armhf.disas:  18:   e50b3014        str     r3, [fp, #-20]
dyncall/doc/disas_examples/arm.armhf.disas:  34:   e50b0008        str     r0, [fp, #-8]     ; in arg 0 -> temp space in local area
dyncall/doc/disas_examples/arm.armhf.disas:  38:   e50b100c        str     r1, [fp, #-12]    ; in arg 1 -> temp space in local area
dyncall/doc/disas_examples/arm.armhf.disas:  3c:   e50b2010        str     r2, [fp, #-16]    ; in arg 2 -> temp space in local area
dyncall/doc/disas_examples/arm.armhf.disas:  40:   e50b3014        str     r3, [fp, #-20]    ; in arg 3 -> temp space in local area
dyncall/doc/disas_examples/arm.armhf.disas:  44:   e24dd0e8        sub     sp, sp, #232      ; alloca(220) - with padding to guarantee alignment
dyncall/doc/disas_examples/arm.armhf.disas:  50:   e1a031a3        lsr     r3, r3, #3        ; | start of (aligned) alloca()'d memory -> r3, leaving room at top of stack for param area
dyncall/doc/disas_examples/arm.armhf.disas:  58:   e3a0204c        mov     r2, #76           ; 'L' -> r2, and ...
dyncall/doc/disas_examples/arm.armhf.disas:  78:   e51b000c        ldr     r0, [fp, #-12]    ; arg 0
dyncall/doc/disas_examples/arm.armhf.disas:  7c:   e51b1010        ldr     r1, [fp, #-16]    ; arg 1
dyncall/doc/disas_examples/arm.armhf.disas:  80:   e51b2014        ldr     r2, [fp, #-20]    ; arg 2
dyncall/doc/disas_examples/arm.armhf.disas:  88:   ebfffffe        bl      0 <leaf_call>     ; return address -> r14/lr, and call
dyncall/doc/disas_examples/arm.armhf.disas:  d0:   ebfffffe        bl      28 <nonleaf_call> ; return address -> r14/lr, and call
dyncall/doc/disas_examples/ppc.darwin.disas:; output from darwin-8.0.1-ppc w/ gcc 3.3
dyncall/doc/disas_examples/ppc.darwin.disas:       0:       bf c1 ff f8     stmw 30, -8(1)
dyncall/doc/disas_examples/ppc.darwin.disas:       4:       94 21 ff d0     stwu 1, -48(1)
dyncall/doc/disas_examples/ppc.darwin.disas:      2c:       bb c1 ff f8     lmw 30, -8(1)
dyncall/doc/disas_examples/ppc.darwin.disas:      34:       7c 08 02 a6     mflr 0          ; |         lr -> gpr0
dyncall/doc/disas_examples/ppc.darwin.disas:      38:       bf c1 ff f8     stmw 30, -8(1)  ; |         store gpr{30,31}
dyncall/doc/disas_examples/ppc.darwin.disas:      40:       94 21 ff b0     stwu 1, -80(1)  ; |         open frame and store sp at top of stack
dyncall/doc/disas_examples/ppc.darwin.disas:      44:       7c 3e 0b 78     mr 30, 1        ; /         sp -> gpr30, latter used for some fixed addressing below
dyncall/doc/disas_examples/ppc.darwin.disas:      58:       90 fe 00 78     stw 7, 120(30)  ; | all in args -> spill area in prev frame
dyncall/doc/disas_examples/ppc.darwin.disas:      68:       80 01 00 00     lwz 0, 0(1)     ; fetch back-chain ptr (parent frame's sp) from stack of top by prolog -> gpr0, and ...
dyncall/doc/disas_examples/ppc.darwin.disas:      6c:       94 01 ff 10     stwu 0, -240(1) ; ... update it further up the stack for alloca(220) - with padding to guarantee alignment
dyncall/doc/disas_examples/ppc.darwin.disas:      74:       38 02 00 0f     addi 0, 2, 15   ; | start of alloca()'d memory -> gpr2, by ...
dyncall/doc/disas_examples/ppc.darwin.disas:      80:       38 00 00 4c     li 0, 76        ; 'L' -> gpr0, and ...
dyncall/doc/disas_examples/ppc.darwin.disas:      a4:       4b ff ff 5d     bl .+67108700   ; call and put return address -> lr
dyncall/doc/disas_examples/ppc.darwin.disas:      b4:       bb c1 ff f8     lmw 30, -8(1)   ; |
dyncall/doc/disas_examples/ppc.darwin.disas:      c0:       bf c1 ff f8     stmw 30, -8(1)  ; |
dyncall/doc/disas_examples/ppc.darwin.disas:      c8:       94 21 ff b0     stwu 1, -80(1)  ; |
dyncall/doc/disas_examples/ppc.darwin.disas:      f0:       4b ff ff 45     bl .+67108676   ; call and put return address -> lr
dyncall/doc/disas_examples/ppc.darwin.disas:     108:       bb c1 ff f8     lmw 30, -8(1)   ; |
dyncall/doc/disas_examples/ppc.darwin.disas:; ------------- more than 8 int args ----------->
dyncall/doc/disas_examples/ppc.darwin.disas:; output from darwin-8.0.1-ppc w/ gcc 3.3
dyncall/doc/disas_examples/ppc.darwin.disas:       0:       bf c1 ff f8     stmw 30, -8(1)
dyncall/doc/disas_examples/ppc.darwin.disas:       4:       94 21 ff d0     stwu 1, -48(1)
dyncall/doc/disas_examples/ppc.darwin.disas:      30:       bb c1 ff f8     lmw 30, -8(1)
dyncall/doc/disas_examples/ppc.darwin.disas:      3c:       bf c1 ff f8     stmw 30, -8(1)  ; |
dyncall/doc/disas_examples/ppc.darwin.disas:      44:       94 21 ff a0     stwu 1, -96(1)  ; |
dyncall/doc/disas_examples/ppc.darwin.disas:      5c:       90 fe 00 88     stw 7, 136(30)  ; | in args 0,1,2,3,4,5,6,7 -> spill area in prev frame
dyncall/doc/disas_examples/ppc.darwin.disas:      6c:       80 01 00 00     lwz 0, 0(1)     ; fetch back-chain ptr (parent frame's sp) from stack of top by prolog -> gpr0, and ...
dyncall/doc/disas_examples/ppc.darwin.disas:      70:       94 01 ff 10     stwu 0, -240(1) ; ... update it further up the stack for alloca(220) - with padding to guarantee alignment
dyncall/doc/disas_examples/ppc.darwin.disas:      78:       38 02 00 0f     addi 0, 2, 15   ; | start of alloca()'d memory -> gpr2, by ...
dyncall/doc/disas_examples/ppc.darwin.disas:      84:       38 00 00 4c     li 0, 76        ; 'L' -> gpr0, and ...
dyncall/doc/disas_examples/ppc.darwin.disas:      b4:       4b ff ff 4d     bl .+67108684   ; call and put return address -> lr
dyncall/doc/disas_examples/ppc.darwin.disas:      c4:       bb c1 ff f8     lmw 30, -8(1)   ; |
dyncall/doc/disas_examples/ppc.darwin.disas:      d0:       bf c1 ff f8     stmw 30, -8(1)  ; |
dyncall/doc/disas_examples/ppc.darwin.disas:      d8:       94 21 ff a0     stwu 1, -96(1)  ; |
dyncall/doc/disas_examples/ppc.darwin.disas:     110:       4b ff ff 29     bl .+67108648   ; call and put return address -> lr
dyncall/doc/disas_examples/ppc.darwin.disas:     128:       bb c1 ff f8     lmw 30, -8(1)   ; |
dyncall/doc/disas_examples/ppc.darwin.disas:; ------------- var args with ints and floats to see spilling (which remains only int regs), b/c doubles are passed via them and floats are promoted to doubles in (...) ----------->
dyncall/doc/disas_examples/ppc.darwin.disas:; output from darwin-8.0.1-ppc w/ gcc 3.3
dyncall/doc/disas_examples/ppc.darwin.disas:       0:       bf c1 ff f8     stmw 30, -8(1)
dyncall/doc/disas_examples/ppc.darwin.disas:       4:       94 21 ff d0     stwu 1, -48(1)
dyncall/doc/disas_examples/ppc.darwin.disas:      34:       bb c1 ff f8     lmw 30, -8(1)
dyncall/doc/disas_examples/ppc.darwin.disas:      40:       bf c1 ff f8     stmw 30, -8(1)  ; |
dyncall/doc/disas_examples/ppc.darwin.disas:      48:       94 21 ff 70     stwu 1, -144(1) ; |
dyncall/doc/disas_examples/ppc.darwin.disas:      60:       91 1e 00 bc     stw 8, 188(30)  ; | in args ,1,2,3,4,5,6,7 -> spill area in prev frame
dyncall/doc/disas_examples/ppc.darwin.disas:      6c:       90 7e 00 a8     stw 3, 168(30)  ; |                  <- this is in arg 0, the only named arg
dyncall/doc/disas_examples/ppc.darwin.disas:      78:       81 3e 00 74     lwz 9, 116(30)  ; \              read ptr -> gpr0
dyncall/doc/disas_examples/ppc.darwin.disas:     15c:       80 01 00 00     lwz 0, 0(1)     ; fetch back-chain ptr (parent frame's sp) from stack of top by prolog -> gpr0, and ...
dyncall/doc/disas_examples/ppc.darwin.disas:     160:       94 01 ff 10     stwu 0, -240(1) ; ... update it further up the stack for alloca
dyncall/doc/disas_examples/ppc.darwin.disas:     168:       38 02 00 0f     addi 0, 2, 15   ; | start of alloca()'d memory -> gpr2, by ...
dyncall/doc/disas_examples/ppc.darwin.disas:     174:       38 00 00 4c     li 0, 76        ; 'L' -> gpr0, and ...
dyncall/doc/disas_examples/ppc.darwin.disas:     1a0:       4b ff fe 61     bl .+67108448   ; call and put return address -> lr
dyncall/doc/disas_examples/ppc.darwin.disas:     1b0:       bb c1 ff f8     lmw 30, -8(1)   ; |
dyncall/doc/disas_examples/ppc.darwin.disas:     1bc:       bf c1 ff f8     stmw 30, -8(1)  ; |
dyncall/doc/disas_examples/ppc.darwin.disas:     1c4:       94 21 ff 90     stwu 1, -112(1) ; |
dyncall/doc/disas_examples/ppc.darwin.disas:     1e4:       3c 40 40 22     lis 2, 16418    ; | arg 9, top-half (double b/c of vararg), and ...
dyncall/doc/disas_examples/ppc.darwin.disas:     1e8:       38 60 00 00     li 3, 0         ; | ... bottom-half ...
dyncall/doc/disas_examples/ppc.darwin.disas:     1f4:       38 00 00 00     li 0, 0         ; arg 6, bottom-half, ...
dyncall/doc/disas_examples/ppc.darwin.disas:     1f8:       90 01 00 38     stw 0, 56(1)    ; ... "pushed" onto stack (first word in param area, top-half passed via gpr10, see below)
dyncall/doc/disas_examples/ppc.darwin.disas:     210:       3d 20 40 14     lis 9, 16404    ; | prep arg 5 (double b/c of vararg) for move to arg reg later: top-half -> gpr9
dyncall/doc/disas_examples/ppc.darwin.disas:     214:       39 40 00 00     li 10, 0        ; |                                                           bottom-half -> gpr10
dyncall/doc/disas_examples/ppc.darwin.disas:     218:       3c 5f 00 00     addis 2, 31, 0  ; PC -> gpr2, to ...
dyncall/doc/disas_examples/ppc.darwin.disas:     21c:       c8 02 00 98     lfd 0, 152(2)   ; ... load some static data (arg 5, the float) stored right after this function -> gpr0
dyncall/doc/disas_examples/ppc.darwin.disas:     220:       7d 28 4b 78     mr 8, 9         ; arg 5, top-half
dyncall/doc/disas_examples/ppc.darwin.disas:     224:       7d 49 53 78     mr 9, 10        ; arg 5, bottom-half
dyncall/doc/disas_examples/ppc.darwin.disas:     22c:       3d 60 40 18     lis 11, 16408   ; | prep arg 6 (double b/c of vararg) for move to arg reg later: top-half -> gpr11
dyncall/doc/disas_examples/ppc.darwin.disas:     230:       39 80 00 00     li 12, 0        ; |                                                           bottom-half -> gpr12 (this one is pointless, unused, bottom-half already placed on stack)
dyncall/doc/disas_examples/ppc.darwin.disas:     234:       3c 5f 00 00     addis 2, 31, 0  ; PC -> gpr2, to ...
dyncall/doc/disas_examples/ppc.darwin.disas:     238:       c8 02 00 a0     lfd 0, 160(2)   ; ... load some static data (arg 6, the 2nd float) stored right after this function -> gpr0
dyncall/doc/disas_examples/ppc.darwin.disas:     23c:       7d 6a 5b 78     mr 10, 11       ; arg 6, top-half
dyncall/doc/disas_examples/ppc.darwin.disas:     248:       fc 60 00 90     fmr 3, 0        ; ... -> 3rd fp reg
dyncall/doc/disas_examples/ppc.darwin.disas:     24c:       4b ff fd f1     bl .+67108336   ; call and put return address -> lr
dyncall/doc/disas_examples/ppc.darwin.disas:     260:       bb c1 ff f8     lmw 30, -8(1)   ; |
dyncall/doc/disas_examples/x86.fastcall_borland.disas:; from http://codeverge.com/embarcadero.cppbuilder.cpp/does-fastcall-have-any-bearing-on/1043767
dyncall/doc/disas_examples/x86.fastcall_borland.disas:  add esp,-0x0c                ; |
dyncall/doc/disas_examples/x86.fastcall_borland.disas:  mov [ebp-0x04],eax           ; pointer to hidden param in eax -> local area
dyncall/doc/disas_examples/x86.fastcall_borland.disas:  mov [ebp-0x0c],0x00000001    ; val 1 -> local area
dyncall/doc/disas_examples/x86.fastcall_borland.disas:  mov [ebp-0x08],0x00000002    ; val 2 -> local area
dyncall/doc/disas_examples/x86.fastcall_borland.disas:  mov eax,[ebp-0x04]           ; refetch eax (pointlessly)
dyncall/doc/disas_examples/x86.fastcall_borland.disas:  mov edx,[ebp-0x0c]           ; get val 1 in edx and ...
dyncall/doc/disas_examples/x86.fastcall_borland.disas:  mov edx,[ebp-0x08]           ; get val 2 in edx and ...
dyncall/doc/disas_examples/x86.fastcall_borland.disas:  mov eax, [ebp-0x04]          ; return value
dyncall/doc/disas_examples/arm.darwin_thumb.disas:; output from iOS 6 w/ clang 3.7.1, dumped with llvm-objdump -triple thumbv7-unknown-unknown-macho ...
dyncall/doc/disas_examples/arm.darwin_thumb.disas:      56:       07 f8 29 5c     strb    r5, [r7, #-41]
dyncall/doc/disas_examples/arm.darwin_thumb.disas:      7a:       ff f7 c1 ff     bl      #-126
dyncall/doc/disas_examples/arm.darwin_thumb.disas:      ae:       ff f7 bc ff     bl      #-136
dyncall/doc/disas_examples/arm.darwin_thumb.disas:; ----------------- with spilling ------------->
dyncall/doc/disas_examples/arm.darwin_thumb.disas:; output from iOS 6 w/ clang 3.7.1, dumped with llvm-objdump -triple thumbv7-unknown-unknown-macho ...
dyncall/doc/disas_examples/arm.darwin_thumb.disas:      8a:       07 f8 25 1c     strb    r1, [r7, #-37]
dyncall/doc/disas_examples/arm.darwin_thumb.disas:      ae:       ff f7 a7 ff     bl      #-178
dyncall/doc/disas_examples/arm.darwin_thumb.disas:      e8:       ff f7 9f ff     bl      #-194
dyncall/doc/disas_examples/mips.o32.disas:; output from freebsd-12.0_r333647-malta_mipselhf w/ gcc 4.2.1 ----->
dyncall/doc/disas_examples/mips.o32.disas:   c:   27bdfff8        addiu   sp,sp,-8
dyncall/doc/disas_examples/mips.o32.disas:  44:   27bdffc8        addiu   sp,sp,-56  ; | prolog
dyncall/doc/disas_examples/mips.o32.disas:  68:   27bdff18        addiu   sp,sp,-232 ; alloca(220) - with padding to guarantee alignment
dyncall/doc/disas_examples/mips.o32.disas:  74:   8fc30028        lw      v1,40(s8)  ; | start of alloca()'d memory -> v1, by ...
dyncall/doc/disas_examples/mips.o32.disas:  8c:   2402004c        li      v0,76      ; 'L' -> v0, and...
dyncall/doc/disas_examples/mips.o32.disas:  bc:   8f990000        lw      t9,0(gp)   ; func to call -> t9
dyncall/doc/disas_examples/mips.o32.disas:  c0:   0320f809        jalr    t9         ; call and ret addr -> ra
dyncall/doc/disas_examples/mips.o32.disas:  ec:   27bdffd0        addiu   sp,sp,-48  ; | prolog
dyncall/doc/disas_examples/mips.o32.disas: 130:   8f990000        lw      t9,0(gp)   ; func to call -> t9
dyncall/doc/disas_examples/mips.o32.disas: 134:   0320f809        jalr    t9         ; call and ret addr -> ra
dyncall/doc/disas_examples/mips.o32.disas:; output from netbsd-5.0.2-pmax_mipsel_o32 w/ gcc 4.1.3 ----->
dyncall/doc/disas_examples/mips.o32.disas:; nearly the same, equivalent to above except non-optimal use of branch delay slots and $gp preserving in leaf call
dyncall/doc/disas_examples/mips.o32.disas:   0:   27bdfff8        addiu   sp,sp,-8
dyncall/doc/disas_examples/mips.o32.disas:  3c:   27bdffc8        addiu   sp,sp,-56
dyncall/doc/disas_examples/mips.o32.disas:  60:   27bdff18        addiu   sp,sp,-232
dyncall/doc/disas_examples/mips.o32.disas:  fc:   27bdffd0        addiu   sp,sp,-48
dyncall/doc/disas_examples/arm.atpcs_arm.disas:; output from netbsd-4.0.1-cats w/ gcc 4.1.2
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  10:   e50b0010        str     r0, [fp, #-16]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  14:   e50b1014        str     r1, [fp, #-20]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  18:   e50b2018        str     r2, [fp, #-24]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  1c:   e50b301c        str     r3, [fp, #-28]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  38:   e50b0010        str     r0, [fp, #-16]         ; in arg 0 -> temp space in local area
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  3c:   e50b1014        str     r1, [fp, #-20]         ; in arg 1 -> temp space in local area
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  40:   e50b2018        str     r2, [fp, #-24]         ; in arg 2 -> temp space in local area
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  44:   e50b301c        str     r3, [fp, #-28]         ; in arg 3 -> temp space in local area
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  48:   e24dd0e0        sub     sp, sp, #224           ; alloca(220) - with padding to guarantee alignment
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  50:   e50b2020        str     r2, [fp, #-32]         ; |        @@@ pointless push of r2 to local area to put it back ...
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  54:   e51b2020        ldr     r2, [fp, #-32]         ; |        @@@ ... into r2
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  58:   e2823003        add     r3, r2, #3             ; | start of (aligned) alloca()'d memory -> r3, leaving room at top of stack for param area
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  64:   e50b3020        str     r3, [fp, #-32]         ; \
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  68:   e51b2020        ldr     r2, [fp, #-32]         ; | r2 -> r3, to free r2 (kinda pointless as followup code could use r2 and r3 the other way round)
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  6c:   e3a0304c        mov     r3, #76                ; 'L' -> r3, and ...
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  8c:   e51b0014        ldr     r0, [fp, #-20]         ; arg 0
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  90:   e51b1018        ldr     r1, [fp, #-24]         ; arg 1
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  94:   e51b201c        ldr     r2, [fp, #-28]         ; arg 2
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  9c:   ebfffffe        bl      9c <nonleaf_call+0x74> ; return address -> r14/lr, and call
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  e8:   ebfffffe        bl      e8 <main+0x40>         ; return address -> r14/lr, and call
dyncall/doc/disas_examples/arm.atpcs_arm.disas:; output from freebsd-11.0_r260099-raspberrypi w/ clang 3.3
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  50:   e50b001c        str     r0, [fp, #-28]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  54:   e50b1020        str     r1, [fp, #-32]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  58:   e50b2024        str     r2, [fp, #-36]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  5c:   e50b3028        str     r3, [fp, #-40]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  64:   e50bc02c        str     ip, [fp, #-44]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  6c:   e50bc030        str     ip, [fp, #-48]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  74:   e50bc034        str     ip, [fp, #-52]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  7c:   e50bc038        str     ip, [fp, #-56]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  88:   e51bc020        ldr     ip, [fp, #-32]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  8c:   e51be024        ldr     lr, [fp, #-36]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  90:   e51b4028        ldr     r4, [fp, #-40]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  94:   e51b502c        ldr     r5, [fp, #-44]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  98:   e51b6030        ldr     r6, [fp, #-48]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  9c:   e51b7034        ldr     r7, [fp, #-52]
dyncall/doc/disas_examples/arm.atpcs_arm.disas:  a0:   e51b8038        ldr     r8, [fp, #-56]
dyncall/doc/disas_examples/arm.atpcs_arm.disas: 110:   e50b0004        str     r0, [fp, #-4]
dyncall/doc/disas_examples/arm.atpcs_arm.disas: 144:   e50b0008        str     r0, [fp, #-8]
dyncall/doc/disas_examples/arm.atpcs_arm.disas: 14c:   e51b0008        ldr     r0, [fp, #-8]
dyncall/doc/disas_examples/ppc64.elfabi.disas:; output from freebsd-11.0-ppc64 w/ gcc 4.2.1
dyncall/doc/disas_examples/ppc64.elfabi.disas:   0:	fb e1 ff f8 	std     r31,-8(r1)
dyncall/doc/disas_examples/ppc64.elfabi.disas:   4:	f8 21 ff c1 	stdu    r1,-64(r1)
dyncall/doc/disas_examples/ppc64.elfabi.disas:  38:	eb e1 ff f8 	ld      r31,-8(r1)
dyncall/doc/disas_examples/ppc64.elfabi.disas:  50:	fb e1 ff f8 	std     r31,-8(r1)               ; |
dyncall/doc/disas_examples/ppc64.elfabi.disas:  58:	f8 21 ff 71 	stdu    r1,-144(r1)              ; |
dyncall/doc/disas_examples/ppc64.elfabi.disas:  60:	7c 60 1b 78 	mr      r0,r3                    ; in arg 0 -> gpr0
dyncall/doc/disas_examples/ppc64.elfabi.disas:  64:	7c 8b 23 78 	mr      r11,r4                   ; in arg 1 -> gpr11
dyncall/doc/disas_examples/ppc64.elfabi.disas:  78:	90 ff 00 e0 	stw     r7,224(r31)              ; | all in args -> spill area in prev frame (jump over own frame (144) + linkage area of prev frame (48) = 192)
dyncall/doc/disas_examples/ppc64.elfabi.disas:  88:	e8 01 00 00 	ld      r0,0(r1)                 ; fetch back-chain ptr (parent frame's sp) from stack of top by prolog -> gpr0, and ...
dyncall/doc/disas_examples/ppc64.elfabi.disas:  8c:	f8 01 ff 11 	stdu    r0,-240(r1)              ; ... update it further up the stack for alloca(220) - with padding to guarantee alignment
dyncall/doc/disas_examples/ppc64.elfabi.disas:  9c:	38 09 00 0f 	addi    r0,r9,15                 ; | start of alloca()'d memory -> gpr9, by ...
dyncall/doc/disas_examples/ppc64.elfabi.disas:  b0:	38 00 00 4c 	li      r0,76                    ; 'L' -> gpr0, and ...
dyncall/doc/disas_examples/ppc64.elfabi.disas:  bc:	7c 08 07 b4 	extsw   r8,r0                    ; ... -> gpr8 (w/ sign extension b/c int param in 64bit reg)
dyncall/doc/disas_examples/ppc64.elfabi.disas:  c4:	7c 07 07 b4 	extsw   r7,r0                    ; ... -> gpr7
dyncall/doc/disas_examples/ppc64.elfabi.disas:  cc:	7c 06 07 b4 	extsw   r6,r0                    ; ... -> gpr6
dyncall/doc/disas_examples/ppc64.elfabi.disas:  d4:	7c 09 07 b4 	extsw   r9,r0                    ; ... -> gpr9
dyncall/doc/disas_examples/ppc64.elfabi.disas:  dc:	7c 0b 07 b4 	extsw   r11,r0                   ; ... -> gpr11
dyncall/doc/disas_examples/ppc64.elfabi.disas:  e4:	7c 0a 07 b4 	extsw   r10,r0                   ; ... -> gpr10
dyncall/doc/disas_examples/ppc64.elfabi.disas:  ec:	7c 00 07 b4 	extsw   r0,r0                    ; ... -> gpr0
dyncall/doc/disas_examples/ppc64.elfabi.disas: 10c:	48 00 00 01 	bl      10c <.nonleaf_call+0xc0> ; call and put return address -> lr
dyncall/doc/disas_examples/ppc64.elfabi.disas: 11c:	eb e1 ff f8 	ld      r31,-8(r1)               ; |
dyncall/doc/disas_examples/ppc64.elfabi.disas: 130:	7c 08 02 a6 	mflr    r0                       ; |             lr -> gpr0
dyncall/doc/disas_examples/ppc64.elfabi.disas: 134:	fb e1 ff f8 	std     r31,-8(r1)               ; |             preseve gpr31 (as used in func as helper addr)
dyncall/doc/disas_examples/ppc64.elfabi.disas: 13c:	f8 21 ff 81 	stdu    r1,-128(r1)              ; |             open frame
dyncall/doc/disas_examples/ppc64.elfabi.disas: 164:	48 00 00 01 	bl      164 <.main+0x34>         ; call and put return address -> lr
dyncall/doc/disas_examples/ppc64.elfabi.disas: 17c:	eb e1 ff f8 	ld      r31,-8(r1)               ; |
dyncall/doc/disas_examples/ppc64.elfabi.disas:; ------------- ints and floats, var args, struct return value (meaning implicit first param), more than 8 params (11, with implicit return value ptr) ----------->
dyncall/doc/disas_examples/ppc64.elfabi.disas:; output from freebsd-11.0-ppc64 w/ gcc 4.2.1
dyncall/doc/disas_examples/ppc64.elfabi.disas:   0:	fb e1 ff f8 	std     r31,-8(r1)
dyncall/doc/disas_examples/ppc64.elfabi.disas:   4:	f8 21 ff c1 	stdu    r1,-64(r1)
dyncall/doc/disas_examples/ppc64.elfabi.disas:  44:	eb e1 ff f8 	ld      r31,-8(r1)
dyncall/doc/disas_examples/ppc64.elfabi.disas:  58:	fb e1 ff f8 	std     r31,-8(r1)       ; |
dyncall/doc/disas_examples/ppc64.elfabi.disas:  5c:	f8 21 ff 91 	stdu    r1,-112(r1)      ; | prolog
dyncall/doc/disas_examples/ppc64.elfabi.disas:  64:	7c 8b 23 78 	mr      r11,r4           ; in arg 1 (first explicit arg, b/c of struct return value ptr being arg0) -> r11
dyncall/doc/disas_examples/ppc64.elfabi.disas:  68:	7c a8 2b 78 	mr      r8,r5            ; in arg 2 -> r8 (free reg, was skipped for float param)
dyncall/doc/disas_examples/ppc64.elfabi.disas:  6c:	d0 3f 00 b8 	stfs    f1,184(r31)      ; |                  in arg 3 (float) -> prev frame's spill area: 184 = 112 (frame) + 48 (prev frame's linkage area) + 8 (arg 0 = return value ptr) + 16 (first two explicit args)
dyncall/doc/disas_examples/ppc64.elfabi.disas:  70:	d0 5f 00 c8 	stfs    f2,200(r31)      ; |                  in arg 5 (float) -> prev frame's spill area
dyncall/doc/disas_examples/ppc64.elfabi.disas:  74:	f9 5f 00 d8 	std     r10,216(r31)     ; |                  in arg 7 (float, also held in gpr reg b/c vararg) -> prev frame's spill area
dyncall/doc/disas_examples/ppc64.elfabi.disas:  7c:	91 7f 00 a8 	stw     r11,168(r31)     ; |                  in arg 1 (int) -> prev frame's spill area
dyncall/doc/disas_examples/ppc64.elfabi.disas:  80:	91 1f 00 b0 	stw     r8,176(r31)      ; |                  in arg 2 (int) -> prev frame's spill area
dyncall/doc/disas_examples/ppc64.elfabi.disas:  84:	90 ff 00 c0 	stw     r7,192(r31)      ; |                  in arg 4 (int) -> prev frame's spill area
dyncall/doc/disas_examples/ppc64.elfabi.disas:  88:	90 1f 00 d0 	stw     r0,208(r31)      ; /                  in arg 6 (int) -> prev frame's spill area
dyncall/doc/disas_examples/ppc64.elfabi.disas:  bc:	7c 08 02 a6 	mflr    r0               ; |             lr -> gpr0
dyncall/doc/disas_examples/ppc64.elfabi.disas:  c0:	fb e1 ff f8 	std     r31,-8(r1)       ; |             preseve gpr31 (as used in func as helper addr)
dyncall/doc/disas_examples/ppc64.elfabi.disas:  c8:	f8 21 ff 41 	stdu    r1,-192(r1)      ; |             open frame
dyncall/doc/disas_examples/ppc64.elfabi.disas:  d0:	39 61 00 30 	addi    r11,r1,48        ; ptr to param area -> r11
dyncall/doc/disas_examples/ppc64.elfabi.disas:  d8:	c1 a9 00 00 	lfs     f13,0(r9)        ; ... load from static data -> f13
dyncall/doc/disas_examples/ppc64.elfabi.disas:  e0:	c1 89 00 00 	lfs     f12,0(r9)        ; ... load from static data -> f12
dyncall/doc/disas_examples/ppc64.elfabi.disas:  e8:	c8 09 00 00 	lfd     f0,0(r9)         ; ... load from static data -> f0
dyncall/doc/disas_examples/ppc64.elfabi.disas: 10c:	c8 09 00 00 	lfd     f0,0(r9)         ; ... load from static data -> fpr0, and ...
dyncall/doc/disas_examples/ppc64.elfabi.disas: 124:	c8 09 00 00 	lfd     f0,0(r9)         ; ... load from static data -> fpr0, and ...
dyncall/doc/disas_examples/ppc64.elfabi.disas: 12c:	c8 0b 00 50 	lfd     f0,80(r11)       ; ... also held in f0 (prep, see where it's used below), in theory pointless reload of arg10 -> fpr0
dyncall/doc/disas_examples/ppc64.elfabi.disas: 130:	38 1f 00 90 	addi    r0,r31,144       ; ptr to return value struct in local space -> gpr0
dyncall/doc/disas_examples/ppc64.elfabi.disas: 15c:	48 00 00 01 	bl      15c <.main+0xa0> ; call and put return address -> lr
dyncall/doc/disas_examples/ppc64.elfabi.disas: 174:	eb e1 ff f8 	ld      r31,-8(r1)       ; |
dyncall/doc/disas_examples/sparc.sparc.disas:; output from debian-4.0_r3-sparc w/ gcc 4.1.2
dyncall/doc/disas_examples/sparc.sparc.disas:   0:   9d e3 bf 98     save  %sp, -104, %sp
dyncall/doc/disas_examples/sparc.sparc.disas:  28:   9d e3 bf 88     save  %sp, -120, %sp         ; prolog
dyncall/doc/disas_examples/sparc.sparc.disas:  44:   9c 03 bf 20     add  %sp, -224, %sp          ; alloca(220) - with 4b padding (multiple of 8), and ...
dyncall/doc/disas_examples/sparc.sparc.disas:  4c:   c2 27 bf f4     st  %g1, [ %fp + -12 ]       ; ... local space (pointlessly) ...
dyncall/doc/disas_examples/sparc.sparc.disas:  50:   c4 07 bf f4     ld  [ %fp + -12 ], %g2       ; ... to g2
dyncall/doc/disas_examples/sparc.sparc.disas:  60:   c2 27 bf f4     st  %g1, [ %fp + -12 ]       ; free g1 again by copy via temp space, ...
dyncall/doc/disas_examples/sparc.sparc.disas:  64:   c4 07 bf f4     ld  [ %fp + -12 ], %g2       ; ... to g2
dyncall/doc/disas_examples/sparc.sparc.disas:  68:   82 10 20 4c     mov  0x4c, %g1               ; 'L' -> g1, and ...
dyncall/doc/disas_examples/sparc.sparc.disas:  a4:   9d e3 bf 90     save  %sp, -112, %sp         ; prolog
dyncall/doc/disas_examples/sparc.sparc.disas:; output from netbsd-6.0-sparc w/ gcc 4.5.3
dyncall/doc/disas_examples/sparc.sparc.disas:   0:   9d e3 bf a0     save  %sp, -96, %sp
dyncall/doc/disas_examples/sparc.sparc.disas:  28:   9d e3 bf 98     save  %sp, -104, %sp
dyncall/doc/disas_examples/sparc.sparc.disas:  44:   9c 03 bf 20     add  %sp, -224, %sp
dyncall/doc/disas_examples/sparc.sparc.disas:  94:   9d e3 bf 98     save  %sp, -104, %sp
dyncall/doc/disas_examples/sparc.sparc.disas:; output from openbsd-5.8-sparc w/ gcc 4.2.1
dyncall/doc/disas_examples/sparc.sparc.disas:   0:   9d e3 bf 90     save  %sp, -112, %sp
dyncall/doc/disas_examples/sparc.sparc.disas:  34:   9d e3 bf 80     save  %sp, -128, %sp
dyncall/doc/disas_examples/sparc.sparc.disas:  70:   c4 27 bf f4     st  %g2, [ %fp + -12 ]
dyncall/doc/disas_examples/sparc.sparc.disas:  78:   9c 03 bf 20     add  %sp, -224, %sp
dyncall/doc/disas_examples/sparc.sparc.disas:  80:   c6 27 bf ec     st  %g3, [ %fp + -20 ]
dyncall/doc/disas_examples/sparc.sparc.disas:  84:   c4 07 bf ec     ld  [ %fp + -20 ], %g2
dyncall/doc/disas_examples/sparc.sparc.disas:  94:   c2 27 bf ec     st  %g1, [ %fp + -20 ]
dyncall/doc/disas_examples/sparc.sparc.disas:  98:   c4 07 bf ec     ld  [ %fp + -20 ], %g2
dyncall/doc/disas_examples/sparc.sparc.disas:  d8:   c6 07 bf f4     ld  [ %fp + -12 ], %g3
dyncall/doc/disas_examples/sparc.sparc.disas: 114:   9d e3 bf 88     save  %sp, -120, %sp
dyncall/doc/disas_examples/sparc.sparc.disas:; --------------------- with float params and aggregate return value ------------------->
dyncall/doc/disas_examples/sparc.sparc.disas:; output from debian-4.0_r3-sparc w/ gcc 4.1.2
dyncall/doc/disas_examples/sparc.sparc.disas:   0:   9d e3 bf 98     save  %sp, -104, %sp
dyncall/doc/disas_examples/sparc.sparc.disas:  28:   9d e3 bf 78     save  %sp, -136, %sp            ; prolog
dyncall/doc/disas_examples/sparc.sparc.disas:  2c:   e0 07 a0 40     ld  [ %fp + 0x40 ], %l0         ; pointer to struct to return -> l0
dyncall/doc/disas_examples/sparc.sparc.disas:  4c:   c2 27 bf ec     st  %g1, [ %fp + -20 ]          ; |
dyncall/doc/disas_examples/sparc.sparc.disas:  54:   c2 27 bf f0     st  %g1, [ %fp + -16 ]          ; | ... copied to temp space in local area for later use
dyncall/doc/disas_examples/sparc.sparc.disas:  5c:   c2 27 bf f4     st  %g1, [ %fp + -12 ]          ; |
dyncall/doc/disas_examples/sparc.sparc.disas:  60:   9c 03 bf 20     add  %sp, -224, %sp             ; alloca(220) - with 4b padding (multiple of 8), and ...
dyncall/doc/disas_examples/sparc.sparc.disas:  68:   c2 27 bf e4     st  %g1, [ %fp + -28 ]          ; ... local space (pointlessly) ...
dyncall/doc/disas_examples/sparc.sparc.disas:  6c:   c4 07 bf e4     ld  [ %fp + -28 ], %g2          ; ... to g2
dyncall/doc/disas_examples/sparc.sparc.disas:  7c:   c2 27 bf e4     st  %g1, [ %fp + -28 ]          ; free g1 again by copy via temp space, ...
dyncall/doc/disas_examples/sparc.sparc.disas:  80:   c4 07 bf e4     ld  [ %fp + -28 ], %g2          ; ... to g2
dyncall/doc/disas_examples/sparc.sparc.disas:  84:   82 10 20 4c     mov  0x4c, %g1                  ; 'L' -> g1, and ...
dyncall/doc/disas_examples/sparc.sparc.disas:  b4:   c2 07 bf ec     ld  [ %fp + -20 ], %g1          ; |
dyncall/doc/disas_examples/sparc.sparc.disas:  bc:   c2 07 bf f0     ld  [ %fp + -16 ], %g1          ; |
dyncall/doc/disas_examples/sparc.sparc.disas:  c4:   c2 07 bf f4     ld  [ %fp + -12 ], %g1          ; |
dyncall/doc/disas_examples/sparc.sparc.disas:  dc:   9d e3 bf 80     save  %sp, -128, %sp            ; prolog
dyncall/doc/disas_examples/sparc.sparc.disas: 108:   82 07 bf ec     add  %fp, -20, %g1              ; store pointer to some frame local data between ...
dyncall/doc/disas_examples/sparc.sparc.disas: 118:   d1 27 bf f8     st  %f8, [ %fp + -8 ]           ; | arg 2, from f8 via temp space ...
dyncall/doc/disas_examples/sparc.sparc.disas: 11c:   d4 07 bf f8     ld  [ %fp + -8 ], %o2           ; | ... to o2
dyncall/doc/disas_examples/sparc.sparc.disas: 124:   d3 27 bf f8     st  %f9, [ %fp + -8 ]           ; | arg 4, from f9 via temp space ...
dyncall/doc/disas_examples/sparc.sparc.disas: 128:   d8 07 bf f8     ld  [ %fp + -8 ], %o4           ; | ... to o4
dyncall/doc/disas_examples/x86.cdecl.disas:; output from arch_linux-2011.08.19-x86 w/ gcc 4.6.1
dyncall/doc/disas_examples/x86.cdecl.disas:  18:   c7 45 f4 10 00 00 00    movl   $0x10,-0xc(%ebp)       ; | size comp wtf?      \
dyncall/doc/disas_examples/x86.cdecl.disas:  24:   f7 75 f4                divl   -0xc(%ebp)             ; |                     | obviously fastest way to round to multiple of 16
dyncall/doc/disas_examples/x86.cdecl.disas:  30:   83 c0 0f                add    $0xf,%eax              ; | start of alloca()'d memory -> eax, by ...
dyncall/doc/disas_examples/x86.cdecl.disas:  39:   c6 00 4c                movb   $0x4c,(%eax)           ; 'L' -> alloca()'d space
dyncall/doc/disas_examples/x86.cdecl.disas:  51:   8b 45 18                mov    0x18(%ebp),%eax        ; | read in args 1-7 from prev frame's param area, and ...
dyncall/doc/disas_examples/x86.cdecl.disas:  54:   89 44 24 0c             mov    %eax,0xc(%esp)         ; | ... "push" onto stack as arg 0-6
dyncall/doc/disas_examples/x86.cdecl.disas:  7c:   c7 44 24 1c 07 00 00 00 movl   $0x7,0x1c(%esp)        ; arg 7 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  84:   c7 44 24 18 06 00 00 00 movl   $0x6,0x18(%esp)        ; arg 6 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  8c:   c7 44 24 14 05 00 00 00 movl   $0x5,0x14(%esp)        ; arg 5 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  94:   c7 44 24 10 04 00 00 00 movl   $0x4,0x10(%esp)        ; arg 4 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  9c:   c7 44 24 0c 03 00 00 00 movl   $0x3,0xc(%esp)         ; arg 3 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  a4:   c7 44 24 08 02 00 00 00 movl   $0x2,0x8(%esp)         ; arg 2 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  ac:   c7 44 24 04 01 00 00 00 movl   $0x1,0x4(%esp)         ; arg 1 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  b4:   c7 04 24 00 00 00 00    movl   $0x0,(%esp)            ; arg 0 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:; output from darwin-8.0.1-x86 w/ gcc 3.3
dyncall/doc/disas_examples/x86.cdecl.disas:   e:   81 ec e0 00 00 00       subl   $224, %esp           ; alloca(220) - with 4b padding
dyncall/doc/disas_examples/x86.cdecl.disas:  18:   c6 00 4c                movb   $76, (%eax)          ; / 'L' -> alloca()'d space
dyncall/doc/disas_examples/x86.cdecl.disas:  30:   8b 45 18                movl   24(%ebp), %eax       ; | read in args 1-7 from prev frame's param area, and ...
dyncall/doc/disas_examples/x86.cdecl.disas:  33:   89 44 24 0c             movl   %eax, 12(%esp)       ; | ... "push" onto stack as arg 0-6
dyncall/doc/disas_examples/x86.cdecl.disas:  4b:   e8 b0 ff ff ff          calll  -80 <_leaf_call>     ; push return address and call
dyncall/doc/disas_examples/x86.cdecl.disas:  5a:   c7 44 24 1c 07 00 00 00 movl   $7, 28(%esp)         ; arg 7 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  62:   c7 44 24 18 06 00 00 00 movl   $6, 24(%esp)         ; arg 6 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  6a:   c7 44 24 14 05 00 00 00 movl   $5, 20(%esp)         ; arg 5 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  72:   c7 44 24 10 04 00 00 00 movl   $4, 16(%esp)         ; arg 4 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  7a:   c7 44 24 0c 03 00 00 00 movl   $3, 12(%esp)         ; arg 3 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  82:   c7 44 24 08 02 00 00 00 movl   $2, 8(%esp)          ; arg 2 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  8a:   c7 44 24 04 01 00 00 00 movl   $1, 4(%esp)          ; arg 1 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  92:   c7 04 24 00 00 00 00    movl   $0, (%esp)           ; arg 0 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  99:   e8 6a ff ff ff          calll  -150 <_nonleaf_call> ; push return address and call
dyncall/doc/disas_examples/x86.cdecl.disas:; output from freebsd-9.3-x86 w/ gcc 4.2.1
dyncall/doc/disas_examples/x86.cdecl.disas:  16:   81 ec f0 00 00 00       sub    $0xf0,%esp             ; alloca(220) - with padding for 16b alignment
dyncall/doc/disas_examples/x86.cdecl.disas:  20:   89 45 fc                mov    %eax,-0x4(%ebp)        ; |
dyncall/doc/disas_examples/x86.cdecl.disas:  23:   8b 45 fc                mov    -0x4(%ebp),%eax        ; |
dyncall/doc/disas_examples/x86.cdecl.disas:  26:   83 c0 0f                add    $0xf,%eax              ; | start of alloca()'d memory -> eax, by ...
dyncall/doc/disas_examples/x86.cdecl.disas:  2f:   89 45 fc                mov    %eax,-0x4(%ebp)        ; |
dyncall/doc/disas_examples/x86.cdecl.disas:  32:   8b 45 fc                mov    -0x4(%ebp),%eax        ; |
dyncall/doc/disas_examples/x86.cdecl.disas:  35:   c6 00 4c                movb   $0x4c,(%eax)           ; 'L' -> alloca()'d space
dyncall/doc/disas_examples/x86.cdecl.disas:  4d:   8b 45 18                mov    0x18(%ebp),%eax        ; | read in args 1-7 from prev frame's param area, and ...
dyncall/doc/disas_examples/x86.cdecl.disas:  50:   89 44 24 0c             mov    %eax,0xc(%esp)         ; | ... "push" onto stack as arg 0-6
dyncall/doc/disas_examples/x86.cdecl.disas:  77:   ff 71 fc                pushl  -0x4(%ecx)             ; |
dyncall/doc/disas_examples/x86.cdecl.disas:  81:   c7 44 24 1c 07 00 00 00 movl   $0x7,0x1c(%esp)        ; arg 7 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  89:   c7 44 24 18 06 00 00 00 movl   $0x6,0x18(%esp)        ; arg 6 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  91:   c7 44 24 14 05 00 00 00 movl   $0x5,0x14(%esp)        ; arg 5 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  99:   c7 44 24 10 04 00 00 00 movl   $0x4,0x10(%esp)        ; arg 4 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  a1:   c7 44 24 0c 03 00 00 00 movl   $0x3,0xc(%esp)         ; arg 3 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  a9:   c7 44 24 08 02 00 00 00 movl   $0x2,0x8(%esp)         ; arg 2 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  b1:   c7 44 24 04 01 00 00 00 movl   $0x1,0x4(%esp)         ; arg 1 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  b9:   c7 04 24 00 00 00 00    movl   $0x0,(%esp)            ; arg 0 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  cf:   8d 61 fc                lea    -0x4(%ecx),%esp        ; |
dyncall/doc/disas_examples/x86.cdecl.disas:; output from gentoo_linux-20191029-x86 w/ gcc 8.3.0
dyncall/doc/disas_examples/x86.cdecl.disas:  26:   89 45 f4                mov    %eax,-0xc(%ebp)
dyncall/doc/disas_examples/x86.cdecl.disas:  76:   8b 45 f4                mov    -0xc(%ebp),%eax
dyncall/doc/disas_examples/x86.cdecl.disas:  90:   ff 71 fc                pushl  -0x4(%ecx)        ; |
dyncall/doc/disas_examples/x86.cdecl.disas:  a4:   6a 07                   push   $0x7              ; arg 7 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  a6:   6a 06                   push   $0x6              ; arg 6 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  a8:   6a 05                   push   $0x5              ; arg 5 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  aa:   6a 04                   push   $0x4              ; arg 4 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  ac:   6a 03                   push   $0x3              ; arg 3 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  ae:   6a 02                   push   $0x2              ; arg 2 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  b0:   6a 01                   push   $0x1              ; arg 1 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  b2:   6a 00                   push   $0x0              ; arg 0 -> stack
dyncall/doc/disas_examples/x86.cdecl.disas:  c1:   8b 4d fc                mov    -0x4(%ebp),%ecx   ; |           ???
dyncall/doc/disas_examples/x86.cdecl.disas:  c5:   8d 61 fc                lea    -0x4(%ecx),%esp   ; | epilog    ???
dyncall/doc/disas_examples/x86.cdecl.disas:  4c:   8b 5d fc                mov    -0x4(%ebp),%ebx
dyncall/doc/disas_examples/x86.cdecl.disas:  58:   ff 71 fc                pushl  -0x4(%ecx)
dyncall/doc/disas_examples/x86.cdecl.disas:  89:   8d 65 f8                lea    -0x8(%ebp),%esp
dyncall/doc/disas_examples/x86.cdecl.disas:  92:   8d 61 fc                lea    -0x4(%ecx),%esp
dyncall/doc/disas_examples/x86.cdecl.disas:; output from nexenta-1.0.1-b85-x86 w/ gcc 4.0.3
dyncall/doc/disas_examples/x86.cdecl.disas:; output from openbsd-4.0-x86 w/ gcc 3.3.5 (propolice)
dyncall/doc/disas_examples/ppc.sysv.disas:; output from debian-4.1.1-21-ppc w/ gcc 4.1.2
dyncall/doc/disas_examples/ppc.sysv.disas:   0:   94 21 ff d0     stwu    r1,-48(r1)
dyncall/doc/disas_examples/ppc.sysv.disas:  2c:   83 eb ff fc     lwz     r31,-4(r11)
dyncall/doc/disas_examples/ppc.sysv.disas:  38:   94 21 ff c0     stwu    r1,-64(r1)             ; |           open frame and store sp at top of stack
dyncall/doc/disas_examples/ppc.sysv.disas:  3c:   7c 08 02 a6     mflr    r0                     ; |           lr -> gpr0
dyncall/doc/disas_examples/ppc.sysv.disas:  48:   7c 3f 0b 78     mr      r31,r1                 ; /           sp -> gpr31, latter used for some fixed addressing below
dyncall/doc/disas_examples/ppc.sysv.disas:  5c:   90 ff 00 18     stw     r7,24(r31)             ; | all in args -> temp space in local area
dyncall/doc/disas_examples/ppc.sysv.disas:  6c:   80 01 00 00     lwz     r0,0(r1)               ; fetch sp saved on stack of top by prolog -> gpr0, and ...
dyncall/doc/disas_examples/ppc.sysv.disas:  70:   94 01 ff 10     stwu    r0,-240(r1)            ; ... update it further up the stack for alloca(220) - with padding to guarantee alignment
dyncall/doc/disas_examples/ppc.sysv.disas:  80:   38 09 00 0f     addi    r0,r9,15               ; | start of alloca()'d memory -> gpr9, by ...
dyncall/doc/disas_examples/ppc.sysv.disas:  94:   38 00 00 4c     li      r0,76                  ; 'L' -> gpr0, and ...
dyncall/doc/disas_examples/ppc.sysv.disas:  b8:   48 00 00 01     bl      b8 <nonleaf_call+0x80> ; call and put return address -> lr
dyncall/doc/disas_examples/ppc.sysv.disas:  c8:   83 eb ff fc     lwz     r31,-4(r11)            ; | epilog
dyncall/doc/disas_examples/ppc.sysv.disas:  d4:   94 21 ff f0     stwu    r1,-16(r1)             ; |
dyncall/doc/disas_examples/ppc.sysv.disas: 108:   48 00 00 01     bl      108 <main+0x34>        ; call and put return address -> lr
dyncall/doc/disas_examples/ppc.sysv.disas: 120:   83 eb ff fc     lwz     r31,-4(r11)            ; | epilog
dyncall/doc/disas_examples/ppc.sysv.disas:; output from netbsd-4.0.1-macppc w/ gcc 4.1.2
dyncall/doc/disas_examples/ppc.sysv.disas:   0:   94 21 ff c0     stwu    r1,-64(r1)
dyncall/doc/disas_examples/ppc.sysv.disas:  2c:   83 eb ff fc     lwz     r31,-4(r11)
dyncall/doc/disas_examples/ppc.sysv.disas:  38:   94 21 ff c0     stwu    r1,-64(r1)
dyncall/doc/disas_examples/ppc.sysv.disas:  70:   94 01 ff 10     stwu    r0,-240(r1)
dyncall/doc/disas_examples/ppc.sysv.disas:  c8:   83 eb ff fc     lwz     r31,-4(r11)
dyncall/doc/disas_examples/ppc.sysv.disas:  d4:   94 21 ff e0     stwu    r1,-32(r1)
dyncall/doc/disas_examples/ppc.sysv.disas: 120:   83 eb ff fc     lwz     r31,-4(r11)
dyncall/doc/disas_examples/ppc.sysv.disas:; ------------- check register skipping for 64bit args ----------->
dyncall/doc/disas_examples/ppc.sysv.disas:; output from debian-4.1.1-21-ppc w/ gcc 4.1.2
dyncall/doc/disas_examples/ppc.sysv.disas:   0:   94 21 ff d0     stwu    r1,-48(r1)
dyncall/doc/disas_examples/ppc.sysv.disas:  2c:   83 eb ff fc     lwz     r31,-4(r11)
dyncall/doc/disas_examples/ppc.sysv.disas:  38:   94 21 ff e0     stwu    r1,-32(r1)     ; |
dyncall/doc/disas_examples/ppc.sysv.disas:  78:   48 00 00 01     bl      78 <main+0x40> ; call and put return address -> lr
dyncall/doc/disas_examples/ppc.sysv.disas:  90:   83 eb ff fc     lwz     r31,-4(r11)    ; | epilog
dyncall/doc/disas_examples/ppc.sysv.disas:; ------------- var args with ints and floats to see spilling (which remains only int regs), b/c doubles are passed via them and floats are promoted to doubles in (...) ----------->
dyncall/doc/disas_examples/ppc.sysv.disas:; output from debian-4.1.1-21-ppc w/ gcc 4.1.2
dyncall/doc/disas_examples/ppc.sysv.disas:   0:   94 21 ff c0     stwu    r1,-64(r1)
dyncall/doc/disas_examples/ppc.sysv.disas:  34:   83 eb ff fc     lwz     r31,-4(r11)
dyncall/doc/disas_examples/ppc.sysv.disas:  40:   94 21 ff 30     stwu    r1,-208(r1)
dyncall/doc/disas_examples/ppc.sysv.disas:  70:   40 86 00 24     bne-    cr1,94 <nonleaf_call+0x54>
dyncall/doc/disas_examples/ppc.sysv.disas:  c4:   40 9c 00 30     bge-    cr7,f4 <nonleaf_call+0xb4>
dyncall/doc/disas_examples/ppc.sysv.disas: 11c:   40 9c 00 30     bge-    cr7,14c <nonleaf_call+0x10c>
dyncall/doc/disas_examples/ppc.sysv.disas: 174:   40 9c 00 30     bge-    cr7,1a4 <nonleaf_call+0x164>
dyncall/doc/disas_examples/ppc.sysv.disas: 1cc:   40 9c 00 30     bge-    cr7,1fc <nonleaf_call+0x1bc>
dyncall/doc/disas_examples/ppc.sysv.disas: 224:   40 9c 00 34     bge-    cr7,258 <nonleaf_call+0x218>
dyncall/doc/disas_examples/ppc.sysv.disas: 28c:   40 9c 00 34     bge-    cr7,2c0 <nonleaf_call+0x280>
dyncall/doc/disas_examples/ppc.sysv.disas: 2f4:   40 9c 00 30     bge-    cr7,324 <nonleaf_call+0x2e4>
dyncall/doc/disas_examples/ppc.sysv.disas: 34c:   40 9c 00 30     bge-    cr7,37c <nonleaf_call+0x33c>
dyncall/doc/disas_examples/ppc.sysv.disas: 3a4:   40 9c 00 34     bge-    cr7,3d8 <nonleaf_call+0x398>
dyncall/doc/disas_examples/ppc.sysv.disas: 404:   94 01 ff 10     stwu    r0,-240(r1)
dyncall/doc/disas_examples/ppc.sysv.disas: 464:   83 eb ff fc     lwz     r31,-4(r11)
dyncall/doc/disas_examples/ppc.sysv.disas: 470:   94 21 ff f0     stwu    r1,-16(r1)      ; |
dyncall/doc/disas_examples/ppc.sysv.disas: 4c8:   48 00 00 01     bl      4c8 <main+0x58> ; call and put return address -> lr
dyncall/doc/disas_examples/ppc.sysv.disas: 4e0:   83 eb ff fc     lwz     r31,-4(r11)     ; | epilog
dyncall/doc/disas_examples/x64.sysv.disas:; output from freebsd-12.0-x64 w/ clang 6.0.1
dyncall/doc/disas_examples/x64.sysv.disas:   7:   89 7d fc                mov    %edi,-0x4(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:   a:   89 75 f8                mov    %esi,-0x8(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:   d:   89 55 f4                mov    %edx,-0xc(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  10:   89 4d f0                mov    %ecx,-0x10(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  13:   44 89 45 ec             mov    %r8d,-0x14(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  17:   44 89 4d e8             mov    %r9d,-0x18(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  1b:   89 45 e4                mov    %eax,-0x1c(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  2f:   89 7d fc                mov    %edi,-0x4(%rbp)      ; in arg 0 -> local area (as temp store)
dyncall/doc/disas_examples/x64.sysv.disas:  32:   89 75 f8                mov    %esi,-0x8(%rbp)      ; in arg 1 -> local area (as temp store)
dyncall/doc/disas_examples/x64.sysv.disas:  35:   89 55 f4                mov    %edx,-0xc(%rbp)      ; in arg 2 -> local area (as temp store)
dyncall/doc/disas_examples/x64.sysv.disas:  38:   89 4d f0                mov    %ecx,-0x10(%rbp)     ; in arg 3 -> local area (as temp store)
dyncall/doc/disas_examples/x64.sysv.disas:  3b:   44 89 45 ec             mov    %r8d,-0x14(%rbp)     ; in arg 4 -> local area (as temp store)
dyncall/doc/disas_examples/x64.sysv.disas:  3f:   44 89 4d e8             mov    %r9d,-0x18(%rbp)     ; in arg 5 -> local area (as temp store)
dyncall/doc/disas_examples/x64.sysv.disas:  43:   c6 45 d0 4c             movb   $0x4c,-0x30(%rbp)    ; 'L' -> local area (of alloca()'d space)
dyncall/doc/disas_examples/x64.sysv.disas:  47:   8b 7d f8                mov    -0x8(%rbp),%edi      ; arg 0
dyncall/doc/disas_examples/x64.sysv.disas:  4a:   8b 75 f4                mov    -0xc(%rbp),%esi      ; arg 1
dyncall/doc/disas_examples/x64.sysv.disas:  4d:   8b 55 f0                mov    -0x10(%rbp),%edx     ; arg 2
dyncall/doc/disas_examples/x64.sysv.disas:  50:   8b 4d ec                mov    -0x14(%rbp),%ecx     ; arg 3
dyncall/doc/disas_examples/x64.sysv.disas:  53:   44 8b 45 e8             mov    -0x18(%rbp),%r8d     ; arg 4
dyncall/doc/disas_examples/x64.sysv.disas:  57:   44 8b 4d 10             mov    0x10(%rbp),%r9d      ; arg 5 (fetched from prev frame's param area - behind return addr on 16b aligned stack)
dyncall/doc/disas_examples/x64.sysv.disas:  63:   44 89 55 cc             mov    %r10d,-0x34(%rbp)    ; unsure... write something to local area @@@?
dyncall/doc/disas_examples/x64.sysv.disas:  67:   89 45 c8                mov    %eax,-0x38(%rbp)     ; unsure... write something to local area @@@?
dyncall/doc/disas_examples/x64.sysv.disas:  b0:   c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)      ; unsure... write 0 to local area @@@?
dyncall/doc/disas_examples/x64.sysv.disas:  c6:   44 89 55 f8             mov    %r10d,-0x8(%rbp)     ; unsure... write something to local area @@@?
dyncall/doc/disas_examples/x64.sysv.disas:  ca:   89 45 f4                mov    %eax,-0xc(%rbp)      ; unsure... write something to local area @@@?
dyncall/doc/disas_examples/x64.sysv.disas:; output from arch_linux-2011.08.19-x64 w/ gcc 4.6.1 (w/ alloca(220) instead of 10)
dyncall/doc/disas_examples/x64.sysv.disas:   4:   89 7d fc                mov    %edi,-0x4(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:   7:   89 75 f8                mov    %esi,-0x8(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:   a:   89 55 f4                mov    %edx,-0xc(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:   d:   89 4d f0                mov    %ecx,-0x10(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  10:   44 89 45 ec             mov    %r8d,-0x14(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  14:   44 89 4d e8             mov    %r9d,-0x18(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  22:   89 7d fc                mov    %edi,-0x4(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  25:   89 75 f8                mov    %esi,-0x8(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  28:   89 55 f4                mov    %edx,-0xc(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  2b:   89 4d f0                mov    %ecx,-0x10(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  2e:   44 89 45 ec             mov    %r8d,-0x14(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  32:   44 89 4d e8             mov    %r9d,-0x18(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  45:   48 c7 45 e0 10 00 00 00 movq   $0x10,-0x20(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  52:   48 f7 75 e0             divq   -0x20(%rbp)
dyncall/doc/disas_examples/x64.sysv.disas:  71:   44 8b 45 e8             mov    -0x18(%rbp),%r8d
dyncall/doc/disas_examples/x64.sysv.disas:  75:   8b 4d ec                mov    -0x14(%rbp),%ecx
dyncall/doc/disas_examples/x64.sysv.disas:  78:   8b 55 f0                mov    -0x10(%rbp),%edx
dyncall/doc/disas_examples/x64.sysv.disas:  7b:   8b 75 f4                mov    -0xc(%rbp),%esi
dyncall/doc/disas_examples/x64.sysv.disas:  7e:   8b 45 f8                mov    -0x8(%rbp),%eax
dyncall/doc/disas_examples/arm.darwin_arm.disas:; output from iOS 6 w/ clang 3.7.1, dumped with llvm-objdump -triple armv7-unknown-unknown-macho ...
dyncall/doc/disas_examples/arm.darwin_arm.disas:      18:       04 00 07 e5     str     r0, [r7, #-4]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      1c:       08 10 07 e5     str     r1, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      20:       0c 20 07 e5     str     r2, [r7, #-12]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      50:       0c e0 97 e5     ldr     lr, [r7, #12]         ; | in args 4,5,6,7 from prev frame's param area -> regs ...
dyncall/doc/disas_examples/arm.darwin_arm.disas:      58:       4c 50 00 e3     movw    r5, #76               ; 'L' -> r5
dyncall/doc/disas_examples/arm.darwin_arm.disas:      5c:       0c 00 07 e5     str     r0, [r7, #-12]        ; in arg 0 -> temp space in local area
dyncall/doc/disas_examples/arm.darwin_arm.disas:      60:       10 10 07 e5     str     r1, [r7, #-16]        ; in arg 1 -> temp space in local area
dyncall/doc/disas_examples/arm.darwin_arm.disas:      64:       14 20 07 e5     str     r2, [r7, #-20]        ; in arg 2 -> temp space in local area
dyncall/doc/disas_examples/arm.darwin_arm.disas:      68:       18 30 07 e5     str     r3, [r7, #-24]        ; in arg 3 -> temp space in local area
dyncall/doc/disas_examples/arm.darwin_arm.disas:      74:       14 c0 8d e5     str     r12, [sp, #20]        ; | ... in args 4,5,6,7 in regs -> local area ...
dyncall/doc/disas_examples/arm.darwin_arm.disas:      7c:       0f 50 cd e5     strb    r5, [sp, #15]         ; 'L' (in r5) -> local area
dyncall/doc/disas_examples/arm.darwin_arm.disas:      80:       10 00 17 e5     ldr     r0, [r7, #-16]        ; arg 0
dyncall/doc/disas_examples/arm.darwin_arm.disas:      84:       14 10 17 e5     ldr     r1, [r7, #-20]        ; arg 1
dyncall/doc/disas_examples/arm.darwin_arm.disas:      88:       18 20 17 e5     ldr     r2, [r7, #-24]        ; arg 2
dyncall/doc/disas_examples/arm.darwin_arm.disas:      94:       14 c0 9d e5     ldr     r12, [sp, #20]        ; | args 4,5,6 (fetched from local area previously copied to) -> regs, and ...
dyncall/doc/disas_examples/arm.darwin_arm.disas:      a8:       d4 ff ff eb     bl      #-176 <_leaf_call>    ; return address -> r14/lr, and call
dyncall/doc/disas_examples/arm.darwin_arm.disas:      e0:       08 00 07 e5     str     r0, [r7, #-8]         ; unsure... why place arg 0 in local area? @@@
dyncall/doc/disas_examples/arm.darwin_arm.disas:      f4:       d0 ff ff eb     bl      #-192 <_nonleaf_call> ; return address -> r14/lr, and call
dyncall/doc/disas_examples/arm.darwin_arm.disas:; ----------------- with spilling ------------->
dyncall/doc/disas_examples/arm.darwin_arm.disas:; output from iOS 6 w/ clang 3.7.1, dumped with llvm-objdump -triple armv7-unknown-unknown-macho ...
dyncall/doc/disas_examples/arm.darwin_arm.disas:      18:       04 00 07 e5     str     r0, [r7, #-4]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      1c:       08 10 07 e5     str     r1, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      20:       0c 20 07 e5     str     r2, [r7, #-12]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      60:       04 00 07 e5     str     r0, [r7, #-4]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      6c:       08 00 17 e5     ldr     r0, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      74:       08 20 07 e5     str     r2, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      7c:       0c 00 07 e5     str     r0, [r7, #-12]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      80:       08 00 17 e5     ldr     r0, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      88:       08 20 07 e5     str     r2, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      90:       10 00 07 e5     str     r0, [r7, #-16]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      94:       08 00 17 e5     ldr     r0, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      9c:       08 20 07 e5     str     r2, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      a4:       14 00 07 e5     str     r0, [r7, #-20]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      a8:       08 00 17 e5     ldr     r0, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      b0:       08 20 07 e5     str     r2, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      b8:       18 00 07 e5     str     r0, [r7, #-24]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      bc:       08 00 17 e5     ldr     r0, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      c4:       08 20 07 e5     str     r2, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      d0:       08 00 17 e5     ldr     r0, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      d8:       08 20 07 e5     str     r2, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      e4:       08 00 17 e5     ldr     r0, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      ec:       08 20 07 e5     str     r2, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:      fc:       0c 00 17 e5     ldr     r0, [r7, #-12]
dyncall/doc/disas_examples/arm.darwin_arm.disas:     100:       10 10 17 e5     ldr     r1, [r7, #-16]
dyncall/doc/disas_examples/arm.darwin_arm.disas:     104:       14 20 17 e5     ldr     r2, [r7, #-20]
dyncall/doc/disas_examples/arm.darwin_arm.disas:     108:       18 30 17 e5     ldr     r3, [r7, #-24]
dyncall/doc/disas_examples/arm.darwin_arm.disas:     124:       b5 ff ff eb     bl      #-300 <_leaf_call>
dyncall/doc/disas_examples/arm.darwin_arm.disas:     164:       08 00 07 e5     str     r0, [r7, #-8]
dyncall/doc/disas_examples/arm.darwin_arm.disas:     178:       af ff ff eb     bl      #-324 <_nonleaf_call>
dyncall/doc/disas_examples/mips64.n64.disas:; output from freebsd-12.0_r333647-malta_mips64elhf w/ gcc 4.2.1
dyncall/doc/disas_examples/mips64.n64.disas:   0:   67bdffd0        daddiu  sp,sp,-48
dyncall/doc/disas_examples/mips64.n64.disas:  88:   67bdff90        daddiu  sp,sp,-112 ; |
dyncall/doc/disas_examples/mips64.n64.disas:  e8:   00061000        sll     v0,a2,0x0  ; | (using the set of pointlessly moved-to regs, above)
dyncall/doc/disas_examples/mips64.n64.disas: 108:   67bdff10        daddiu  sp,sp,-240 ; alloca(220) - with padding to guarantee alignment
dyncall/doc/disas_examples/mips64.n64.disas: 110:   dfc30020        ld      v1,32(s8)  ; | start of alloca()'d memory -> v1, by ...
dyncall/doc/disas_examples/mips64.n64.disas: 128:   2402004c        li      v0,76      ; 'L' -> v0, and ...
dyncall/doc/disas_examples/mips64.n64.disas: 154:   df990000        ld      t9,0(gp)   ; addr of callee -> t9
dyncall/doc/disas_examples/mips64.n64.disas: 158:   0320f809        jalr    t9         ; return address -> ra, and call
dyncall/doc/disas_examples/mips64.n64.disas: 178:   67bdffe0        daddiu  sp,sp,-32  ; |
dyncall/doc/disas_examples/mips64.n64.disas: 1b8:   df990000        ld      t9,0(gp)   ; address of callee -> t9
dyncall/doc/disas_examples/mips64.n64.disas: 1bc:   0320f809        jalr    t9         ; return address -> ra, and call
dyncall/doc/disas_examples/mips64.n64.disas:; output from debian-sid_20150616-malta_mips64el_n64 w/ gcc 4.9.2
dyncall/doc/disas_examples/mips64.n64.disas:   0:   67bdffd0        daddiu  sp,sp,-48
dyncall/doc/disas_examples/mips64.n64.disas:  70:   67bdffc0        daddiu  sp,sp,-64  ; |
dyncall/doc/disas_examples/mips64.n64.disas:  d0:   00052800        sll     a1,a1,0x0  ; | (using the set of pointlessly moved-to regs, above)
dyncall/doc/disas_examples/mips64.n64.disas:  f0:   67bdff10        daddiu  sp,sp,-240 ; alloca(220) - with padding to guarantee alignment
dyncall/doc/disas_examples/mips64.n64.disas:  f8:   6442000f        daddiu  v0,v0,15   ; | start of alloca()'d memory -> v1, by ...
dyncall/doc/disas_examples/mips64.n64.disas: 108:   2402004c        li      v0,76      ; 'L' -> v0, and ...
dyncall/doc/disas_examples/mips64.n64.disas: 138:   0040c82d        move    t9,v0      ; ... -> t9
dyncall/doc/disas_examples/mips64.n64.disas: 13c:   0320f809        jalr    t9         ; return address -> ra, and call
dyncall/doc/disas_examples/mips64.n64.disas: 160:   67bdffe0        daddiu  sp,sp,-32  ; |
dyncall/doc/disas_examples/mips64.n64.disas: 1a8:   0320f809        jalr    t9         ; return address -> ra, and call
dyncall/doc/disas_examples/mips64.n64.disas:; ------------- var args with ints and floats to see spilling (which remains only a?-a7 regs), b/c doubles are passed via them and floats are promoted to doubles in (...) ----------->
dyncall/doc/disas_examples/mips64.n64.disas:; output from freebsd-12.0_r333647-malta_mips64elhf w/ gcc 4.2.1
dyncall/doc/disas_examples/mips64.n64.disas:   0:   67bdffd0        daddiu  sp,sp,-48
dyncall/doc/disas_examples/mips64.n64.disas:  80:   67bdff50        daddiu  sp,sp,-176
dyncall/doc/disas_examples/mips64.n64.disas:  cc:   6442ffc8        daddiu  v0,v0,-56
dyncall/doc/disas_examples/mips64.n64.disas: 1dc:   67bdff10        daddiu  sp,sp,-240
dyncall/doc/disas_examples/mips64.n64.disas: 258:   67bdffd0        daddiu  sp,sp,-48
dyncall/doc/disas_examples/mips64.n64.disas:; output from debian-sid_20150616-malta_mips64el_n64 w/ gcc 4.9.2
dyncall/doc/disas_examples/mips64.n64.disas:   0:   67bdffd0        daddiu  sp,sp,-48
dyncall/doc/disas_examples/mips64.n64.disas:  70:   67bdff50        daddiu  sp,sp,-176  ; |         leaving 64b extra space adjacent to prev frame's param area for spilling
dyncall/doc/disas_examples/mips64.n64.disas:  9c:   ffc80090        sd      a4,144(s8)  ; | in args 1,2,3,4,5,6,7 -> spill area in current frame (adjacent to prev frame's param area)
dyncall/doc/disas_examples/mips64.n64.disas:  bc:   6442ffc8        daddiu  v0,v0,-56   ; |
dyncall/doc/disas_examples/mips64.n64.disas: 19c:   67bdff10        daddiu  sp,sp,-240  ; alloca(220) - with padding to guarantee alignment
dyncall/doc/disas_examples/mips64.n64.disas: 1a8:   0002113a        dsrl    v0,v0,0x4   ; | start of alloca()'d memory -> v1, by ...
dyncall/doc/disas_examples/mips64.n64.disas: 1b4:   2402004c        li      v0,76       ; 'L' -> v0, and ...
dyncall/doc/disas_examples/mips64.n64.disas: 1dc:   c7d00020        lwc1    $f16,32(s8) ; arg 4 (so skipping f12-f15)
dyncall/doc/disas_examples/mips64.n64.disas: 1e0:   c7d10024        lwc1    $f17,36(s8) ; arg 5 (so skipping f12-f15)
dyncall/doc/disas_examples/mips64.n64.disas: 1f4:   0320f809        jalr    t9          ; return address -> ra, and call
dyncall/doc/disas_examples/mips64.n64.disas: 218:   67bdffd0        daddiu  sp,sp,-48   ; |
dyncall/doc/disas_examples/mips64.n64.disas: 284:   0320f809        jalr    t9          ; return address -> ra, and call
dyncall/doc/disas_examples/sparc64.sparc64.disas:; output from debian-9.0-sparc64 w/ gcc 6.1.1
dyncall/doc/disas_examples/sparc64.sparc64.disas:   0:   9d e3 bf 50     save  %sp, -176, %sp
dyncall/doc/disas_examples/sparc64.sparc64.disas:  3c:   9d e3 bf 40     save  %sp, -192, %sp         ; prolog
dyncall/doc/disas_examples/sparc64.sparc64.disas:  6c:   9c 03 bf 10     add  %sp, -240, %sp          ; alloca(220) - with padding, and ...
dyncall/doc/disas_examples/sparc64.sparc64.disas:  84:   82 10 20 4c     mov  0x4c, %g1               ; 'L' -> g1, and ...
dyncall/doc/disas_examples/sparc64.sparc64.disas:  90:   b9 38 60 00     sra  %g1, 0, %i4             ; ... -> i4
dyncall/doc/disas_examples/sparc64.sparc64.disas:  98:   bb 38 60 00     sra  %g1, 0, %i5             ; ... -> i5
dyncall/doc/disas_examples/sparc64.sparc64.disas:  a0:   8b 38 60 00     sra  %g1, 0, %g5             ; ... -> g5
dyncall/doc/disas_examples/sparc64.sparc64.disas:  a8:   89 38 60 00     sra  %g1, 0, %g4             ; ... -> g4
dyncall/doc/disas_examples/sparc64.sparc64.disas:  b0:   87 38 60 00     sra  %g1, 0, %g3             ; ... -> g3
dyncall/doc/disas_examples/sparc64.sparc64.disas:  b8:   85 38 60 00     sra  %g1, 0, %g2             ; ... -> g2
dyncall/doc/disas_examples/sparc64.sparc64.disas:  c0:   83 38 60 00     sra  %g1, 0, %g1             ; ... -> g1, and ...
dyncall/doc/disas_examples/sparc64.sparc64.disas:  f4:   9d e3 bf 40     save  %sp, -192, %sp         ; prolog
dyncall/doc/disas_examples/sparc64.sparc64.disas:; output from freebsd-11.0-sparc64 w/ gcc 4.2.1
dyncall/doc/disas_examples/sparc64.sparc64.disas:   0:   9d e3 bf 40     save  %sp, -192, %sp
dyncall/doc/disas_examples/sparc64.sparc64.disas:  40:   9d e3 bf 20     save  %sp, -224, %sp
dyncall/doc/disas_examples/sparc64.sparc64.disas:  74:   9c 03 bf 20     add  %sp, -224, %sp
dyncall/doc/disas_examples/sparc64.sparc64.disas: 120:   9d e3 bf 30     save  %sp, -208, %sp
dyncall/doc/disas_examples/sparc64.sparc64.disas:; output from netbsd-7.1-sparc64 w/ gcc 4.8.5
dyncall/doc/disas_examples/sparc64.sparc64.disas:   0:   9d e3 bf 50     save  %sp, -176, %sp
dyncall/doc/disas_examples/sparc64.sparc64.disas:  38:   9d e3 bf 40     save  %sp, -192, %sp
dyncall/doc/disas_examples/sparc64.sparc64.disas:  68:   9c 03 bf 10     add  %sp, -240, %sp
dyncall/doc/disas_examples/sparc64.sparc64.disas:  e8:   9d e3 bf 40     save  %sp, -192, %sp
dyncall/doc/disas_examples/sparc64.sparc64.disas:; output from openbsd-7.1-sparc64 w/ gcc 4.2.1
dyncall/doc/disas_examples/sparc64.sparc64.disas:   0:   9d e3 bf 30     save  %sp, -208, %sp
dyncall/doc/disas_examples/sparc64.sparc64.disas:  44:   9d e3 bf 10     save  %sp, -240, %sp
dyncall/doc/disas_examples/sparc64.sparc64.disas:  a0:   9c 03 bf 20     add  %sp, -224, %sp
dyncall/doc/disas_examples/sparc64.sparc64.disas: 170:   9d e3 bf 20     save  %sp, -224, %sp
dyncall/doc/disas_examples/sparc64.sparc64.disas:; --------------------- with float params, aggregate return value (<32b, passed in regs) and ellipsis with float ------------------->
dyncall/doc/disas_examples/sparc64.sparc64.disas:; output from netbsd-7.1-sparc64 w/ gcc 4.8.5
dyncall/doc/disas_examples/sparc64.sparc64.disas:   0:   9d e3 bf 50     save  %sp, -176, %sp            ; prolog
dyncall/doc/disas_examples/sparc64.sparc64.disas:  38:   9d e3 bf 20     save  %sp, -224, %sp            ; prolog
dyncall/doc/disas_examples/sparc64.sparc64.disas:  68:   c2 27 a7 db     st  %g1, [ %fp + 0x7db ]        ; ... copied to local space (0x7db - bias = -36)
dyncall/doc/disas_examples/sparc64.sparc64.disas:  70:   c2 27 a7 df     st  %g1, [ %fp + 0x7df ]        ; ... copied to local space (0x7df - bias = -32)
dyncall/doc/disas_examples/sparc64.sparc64.disas:  78:   c2 27 a7 e3     st  %g1, [ %fp + 0x7e3 ]        ; ... copied to local space (0x7e3 - bias = -28)
dyncall/doc/disas_examples/sparc64.sparc64.disas:  7c:   82 07 a8 af     add  %fp, 0x8af, %g1            ; va_list: pointer to arg 5 -> g1 ...
dyncall/doc/disas_examples/sparc64.sparc64.disas:  80:   c2 77 a7 e7     stx  %g1, [ %fp + 0x7e7 ]       ; ... store to local space (0x7e7 - bias = -24)
dyncall/doc/disas_examples/sparc64.sparc64.disas:  90:   c4 27 a7 fb     st  %g2, [ %fp + 0x7fb ]        ; ... copied to local space (0x7fb - bias = -4) helper var (probably int g)
dyncall/doc/disas_examples/sparc64.sparc64.disas:  98:   c2 77 a7 e7     stx  %g1, [ %fp + 0x7e7 ]       ; ... store in local space (0x7fb - bias = -24)
dyncall/doc/disas_examples/sparc64.sparc64.disas:  9c:   91 d0 20 05     ta  5                           ; trap - not sure what else is involved (objdump was made from .o, not finally linked exec) - maybe just b/c objdump skipped this for the output?
dyncall/doc/disas_examples/sparc64.sparc64.disas:  a0:   9d e3 bf 30     save  %sp, -208, %sp            ; prolog
dyncall/doc/disas_examples/sparc64.sparc64.disas: 128:   86 10 3f ff     mov  -1, %g3                    ; \
dyncall/doc/disas_examples/sparc64.sparc64.disas: 134:   c6 07 a7 f7     ld  [ %fp + 0x7f7 ], %g3        ; | store 2nd struct field (int) by (-1 >> 32) & g2 (and then some other operations unnecessary here)
dyncall/doc/disas_examples/arm64.aapcs.disas:; output from freebsd-13.0_r348764-arm64 w/ clang 8.0.0
dyncall/doc/disas_examples/arm64.aapcs.disas:  38:   88 09 80 52     mov     w8, #76              ; 'L' -> w8
dyncall/doc/disas_examples/arm64.aapcs.disas:  3c:   a0 c3 1e b8     stur    w0, [x29, #-20]      ; in arg 0 -> local area (as temp store)
dyncall/doc/disas_examples/arm64.aapcs.disas:  40:   a1 83 1e b8     stur    w1, [x29, #-24]      ; in arg 1 -> local area (as temp store)
dyncall/doc/disas_examples/arm64.aapcs.disas:  44:   a2 43 1e b8     stur    w2, [x29, #-28]      ; in arg 2 -> local area (as temp store)
dyncall/doc/disas_examples/arm64.aapcs.disas:  48:   a3 03 1e b8     stur    w3, [x29, #-32]      ; in arg 3 -> local area (as temp store)
dyncall/doc/disas_examples/arm64.aapcs.disas:  4c:   a4 c3 1d b8     stur    w4, [x29, #-36]      ; in arg 4 -> local area (as temp store)
dyncall/doc/disas_examples/arm64.aapcs.disas:  50:   a5 83 1d b8     stur    w5, [x29, #-40]      ; in arg 5 -> local area (as temp store)
dyncall/doc/disas_examples/arm64.aapcs.disas:  54:   a6 43 1d b8     stur    w6, [x29, #-44]      ; in arg 6 -> local area (as temp store)
dyncall/doc/disas_examples/arm64.aapcs.disas:  58:   a7 03 1d b8     stur    w7, [x29, #-48]      ; in arg 7 -> local area (as temp store)
dyncall/doc/disas_examples/arm64.aapcs.disas:  60:   a0 83 5e b8     ldur    w0, [x29, #-24]      ; arg 0
dyncall/doc/disas_examples/arm64.aapcs.disas:  64:   a1 43 5e b8     ldur    w1, [x29, #-28]      ; arg 1
dyncall/doc/disas_examples/arm64.aapcs.disas:  68:   a2 03 5e b8     ldur    w2, [x29, #-32]      ; arg 2
dyncall/doc/disas_examples/arm64.aapcs.disas:  6c:   a3 c3 5d b8     ldur    w3, [x29, #-36]      ; arg 3
dyncall/doc/disas_examples/arm64.aapcs.disas:  70:   a4 83 5d b8     ldur    w4, [x29, #-40]      ; arg 4
dyncall/doc/disas_examples/arm64.aapcs.disas:  74:   a5 43 5d b8     ldur    w5, [x29, #-44]      ; arg 5
dyncall/doc/disas_examples/arm64.aapcs.disas:  78:   a6 03 5d b8     ldur    w6, [x29, #-48]      ; arg 6
dyncall/doc/disas_examples/arm64.aapcs.disas:  7c:   e1 ff ff 97     bl      #-124                ; return address -> r30/lr, and call
dyncall/doc/disas_examples/arm64.aapcs.disas:  bc:   bf c3 1f b8     stur    wzr, [x29, #-4]      ; unsure... store a zero in local area@@@
dyncall/doc/disas_examples/arm64.aapcs.disas:  c8:   d8 ff ff 97     bl      #-160                ; return address -> r30/lr, and call
dyncall/doc/disas_examples/arm64.aapcs.disas:; ---------- same with more args so stack is also used ---------->
dyncall/doc/disas_examples/arm64.aapcs.disas:; output from freebsd-13.0_r348764-arm64 w/ clang 8.0.0
dyncall/doc/disas_examples/arm64.aapcs.disas:      48:       a9 1b 40 b9     ldr     w9, [x29, #24]       ; | in args 8,9 from prev frame's param area -> regs, no we have args 0-9 all in r0-r9
dyncall/doc/disas_examples/arm64.aapcs.disas:      4c:       8a 09 80 52     mov     w10, #76             ; 'L' -> w10
dyncall/doc/disas_examples/arm64.aapcs.disas:      50:       a0 c3 1e b8     stur    w0, [x29, #-20]      ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:      54:       a1 83 1e b8     stur    w1, [x29, #-24]      ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:      58:       a2 43 1e b8     stur    w2, [x29, #-28]      ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:      5c:       a3 03 1e b8     stur    w3, [x29, #-32]      ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:      60:       a4 c3 1d b8     stur    w4, [x29, #-36]      ; | ... in args 0,1,2,3,4,5,6,7,8,9 -> temp space in local area ...
dyncall/doc/disas_examples/arm64.aapcs.disas:      64:       a5 83 1d b8     stur    w5, [x29, #-40]      ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:      68:       a6 43 1d b8     stur    w6, [x29, #-44]      ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:      6c:       a7 03 1d b8     stur    w7, [x29, #-48]      ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:      70:       a8 c3 1c b8     stur    w8, [x29, #-52]      ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:      74:       a9 83 1c b8     stur    w9, [x29, #-56]      ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:      78:       ea 43 00 39     strb    w10, [sp, #16]       ; 'L' -> local area (alloca()'d memory)
dyncall/doc/disas_examples/arm64.aapcs.disas:      7c:       a0 83 5e b8     ldur    w0, [x29, #-24]      ; arg 0
dyncall/doc/disas_examples/arm64.aapcs.disas:      80:       a1 43 5e b8     ldur    w1, [x29, #-28]      ; arg 1
dyncall/doc/disas_examples/arm64.aapcs.disas:      84:       a2 03 5e b8     ldur    w2, [x29, #-32]      ; arg 2
dyncall/doc/disas_examples/arm64.aapcs.disas:      88:       a3 c3 5d b8     ldur    w3, [x29, #-36]      ; arg 3
dyncall/doc/disas_examples/arm64.aapcs.disas:      8c:       a4 83 5d b8     ldur    w4, [x29, #-40]      ; arg 4
dyncall/doc/disas_examples/arm64.aapcs.disas:      90:       a5 43 5d b8     ldur    w5, [x29, #-44]      ; arg 5
dyncall/doc/disas_examples/arm64.aapcs.disas:      94:       a6 03 5d b8     ldur    w6, [x29, #-48]      ; arg 6
dyncall/doc/disas_examples/arm64.aapcs.disas:      98:       a7 c3 5c b8     ldur    w7, [x29, #-52]      ; arg 7
dyncall/doc/disas_examples/arm64.aapcs.disas:      9c:       a8 83 5c b8     ldur    w8, [x29, #-56]      ; arg 8 -> w8, and ...
dyncall/doc/disas_examples/arm64.aapcs.disas:      a8:       d6 ff ff 97     bl      #-168 <leaf_call>    ; return address -> r30/lr, and call
dyncall/doc/disas_examples/arm64.aapcs.disas:      e8:       e9 03 1d 32     orr     w9, wzr, #0x8        ; arg 8 -> r9
dyncall/doc/disas_examples/arm64.aapcs.disas:      ec:       2a 01 80 52     mov     w10, #9              ; arg 9 -> r10
dyncall/doc/disas_examples/arm64.aapcs.disas:      f0:       bf c3 1f b8     stur    wzr, [x29, #-4]      ; unsure... store a zero in local area@@@
dyncall/doc/disas_examples/arm64.aapcs.disas:     108:       a8 83 1f b8     stur    w8, [x29, #-8]       ; temp storing 0 in local area @@@ why?
dyncall/doc/disas_examples/arm64.aapcs.disas:     10c:       ca ff ff 97     bl      #-216 <nonleaf_call> ; return address -> r30/lr, and call
dyncall/doc/disas_examples/arm64.aapcs.disas:     110:       a0 83 5f b8     ldur    w0, [x29, #-8]       ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:; ---------- for spilling ---------->
dyncall/doc/disas_examples/arm64.aapcs.disas:; output from freebsd-13.0_r348764-arm64 w/ clang 8.0.0
dyncall/doc/disas_examples/arm64.aapcs.disas:      34:       fc 4f be a9     stp     x28, x19, [sp, #-32]! ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:      68:       a7 03 1a f8     stur    x7, [x29, #-96]       ; \
dyncall/doc/disas_examples/arm64.aapcs.disas:      6c:       a6 83 19 f8     stur    x6, [x29, #-104]      ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:      70:       a5 03 19 f8     stur    x5, [x29, #-112]      ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:      74:       a4 83 18 f8     stur    x4, [x29, #-120]      ; | spill integer args (adjacent to prev frame's param area)
dyncall/doc/disas_examples/arm64.aapcs.disas:      78:       a3 03 18 f8     stur    x3, [x29, #-128]      ; | note: only needed ones are spilled
dyncall/doc/disas_examples/arm64.aapcs.disas:      7c:       a2 83 17 f8     stur    x2, [x29, #-136]      ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:      80:       a1 03 17 f8     stur    x1, [x29, #-144]      ; |
dyncall/doc/disas_examples/arm64.aapcs.disas:      84:       a0 c3 1e b8     stur    w0, [x29, #-20]
dyncall/doc/disas_examples/arm64.aapcs.disas:      8c:       a0 43 1c b8     stur    w0, [x29, #-60]
dyncall/doc/disas_examples/arm64.aapcs.disas:      90:       e0 06 80 12     mov     w0, #-56
dyncall/doc/disas_examples/arm64.aapcs.disas:      94:       a0 03 1c b8     stur    w0, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:      a0:       a1 83 1b f8     stur    x1, [x29, #-72]
dyncall/doc/disas_examples/arm64.aapcs.disas:      ac:       a1 03 1b f8     stur    x1, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:      b4:       a1 83 1a f8     stur    x1, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:      c0:       a0 03 5c b8     ldur    w0, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:      f8:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     10c:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     114:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     128:       a9 83 1e b8     stur    w9, [x29, #-24]
dyncall/doc/disas_examples/arm64.aapcs.disas:     134:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     16c:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     180:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     188:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     19c:       a9 43 1e b8     stur    w9, [x29, #-28]
dyncall/doc/disas_examples/arm64.aapcs.disas:     1a8:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     1e0:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     1f4:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     1fc:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     210:       a9 03 1e b8     stur    w9, [x29, #-32]
dyncall/doc/disas_examples/arm64.aapcs.disas:     21c:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     254:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     268:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     270:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     284:       a9 c3 1d b8     stur    w9, [x29, #-36]
dyncall/doc/disas_examples/arm64.aapcs.disas:     290:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     2c8:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     2dc:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     2e4:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     2f8:       a9 83 1d b8     stur    w9, [x29, #-40]
dyncall/doc/disas_examples/arm64.aapcs.disas:     304:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     33c:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     350:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     358:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     36c:       a9 43 1d b8     stur    w9, [x29, #-44]
dyncall/doc/disas_examples/arm64.aapcs.disas:     378:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     3b0:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     3c4:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     3cc:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     3e0:       a9 03 1d b8     stur    w9, [x29, #-48]
dyncall/doc/disas_examples/arm64.aapcs.disas:     3ec:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     424:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     438:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     440:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     454:       a9 c3 1c b8     stur    w9, [x29, #-52]
dyncall/doc/disas_examples/arm64.aapcs.disas:     460:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     498:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4ac:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4b4:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4c8:       a9 83 1c b8     stur    w9, [x29, #-56]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4dc:       09 01 12 38     sturb   w9, [x8, #-224]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4e0:       a0 83 5e b8     ldur    w0, [x29, #-24]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4e4:       a1 43 5e b8     ldur    w1, [x29, #-28]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4e8:       a2 03 5e b8     ldur    w2, [x29, #-32]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4ec:       a3 c3 5d b8     ldur    w3, [x29, #-36]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4f0:       a4 83 5d b8     ldur    w4, [x29, #-40]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4f4:       a5 43 5d b8     ldur    w5, [x29, #-44]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4f8:       a6 03 5d b8     ldur    w6, [x29, #-48]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4fc:       a7 c3 5c b8     ldur    w7, [x29, #-52]
dyncall/doc/disas_examples/arm64.aapcs.disas:     500:       a9 83 5c b8     ldur    w9, [x29, #-56]
dyncall/doc/disas_examples/arm64.aapcs.disas:     510:       bc fe ff 97     bl      #-1296 <leaf_call>
dyncall/doc/disas_examples/arm64.aapcs.disas:     55c:       bf c3 1f b8     stur    wzr, [x29, #-4]
dyncall/doc/disas_examples/arm64.aapcs.disas:     574:       a8 83 1f b8     stur    w8, [x29, #-8]
dyncall/doc/disas_examples/arm64.aapcs.disas:     578:       af fe ff 97     bl      #-1348 <nonleaf_call>
dyncall/doc/disas_examples/arm64.aapcs.disas:     57c:       a0 83 5f b8     ldur    w0, [x29, #-8]
dyncall/doc/disas_examples/arm64.aapcs.disas:; ---------- for spilling with a float ---------->
dyncall/doc/disas_examples/arm64.aapcs.disas:; output from freebsd-13.0_r348764-arm64 w/ clang 8.0.0
dyncall/doc/disas_examples/arm64.aapcs.disas:      30:       fc 4f be a9     stp     x28, x19, [sp, #-32]!
dyncall/doc/disas_examples/arm64.aapcs.disas:      64:       a7 03 1a f8     stur    x7, [x29, #-96]
dyncall/doc/disas_examples/arm64.aapcs.disas:      68:       a6 83 19 f8     stur    x6, [x29, #-104]
dyncall/doc/disas_examples/arm64.aapcs.disas:      6c:       a5 03 19 f8     stur    x5, [x29, #-112]
dyncall/doc/disas_examples/arm64.aapcs.disas:      70:       a4 83 18 f8     stur    x4, [x29, #-120]
dyncall/doc/disas_examples/arm64.aapcs.disas:      74:       a3 03 18 f8     stur    x3, [x29, #-128]
dyncall/doc/disas_examples/arm64.aapcs.disas:      78:       a2 83 17 f8     stur    x2, [x29, #-136]
dyncall/doc/disas_examples/arm64.aapcs.disas:      7c:       a1 03 17 f8     stur    x1, [x29, #-144]
dyncall/doc/disas_examples/arm64.aapcs.disas:      80:       a0 c3 1e b8     stur    w0, [x29, #-20]
dyncall/doc/disas_examples/arm64.aapcs.disas:      88:       a0 43 1c b8     stur    w0, [x29, #-60]
dyncall/doc/disas_examples/arm64.aapcs.disas:      8c:       e0 06 80 12     mov     w0, #-56
dyncall/doc/disas_examples/arm64.aapcs.disas:      90:       a0 03 1c b8     stur    w0, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:      9c:       a1 83 1b f8     stur    x1, [x29, #-72]
dyncall/doc/disas_examples/arm64.aapcs.disas:      a8:       a1 03 1b f8     stur    x1, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:      b0:       a1 83 1a f8     stur    x1, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:      bc:       a0 03 5c b8     ldur    w0, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:      f4:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     108:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     110:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     124:       a9 83 1e b8     stur    w9, [x29, #-24]
dyncall/doc/disas_examples/arm64.aapcs.disas:     130:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     168:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     17c:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     184:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     198:       a9 43 1e b8     stur    w9, [x29, #-28]
dyncall/doc/disas_examples/arm64.aapcs.disas:     1a4:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     1dc:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     1f0:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     1f8:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     20c:       a9 03 1e b8     stur    w9, [x29, #-32]
dyncall/doc/disas_examples/arm64.aapcs.disas:     218:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     250:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     264:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     26c:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     280:       a9 c3 1d b8     stur    w9, [x29, #-36]
dyncall/doc/disas_examples/arm64.aapcs.disas:     28c:       a9 43 5c b8     ldur    w9, [x29, #-60]
dyncall/doc/disas_examples/arm64.aapcs.disas:     2c4:       a8 83 5b f8     ldur    x8, [x29, #-72]
dyncall/doc/disas_examples/arm64.aapcs.disas:     2d8:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     2e0:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     2f4:       a0 83 1c bc     stur    s0, [x29, #-56]
dyncall/doc/disas_examples/arm64.aapcs.disas:     300:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     338:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     34c:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     354:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     368:       a9 83 1d b8     stur    w9, [x29, #-40]
dyncall/doc/disas_examples/arm64.aapcs.disas:     374:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     3ac:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     3c0:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     3c8:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     3dc:       a9 43 1d b8     stur    w9, [x29, #-44]
dyncall/doc/disas_examples/arm64.aapcs.disas:     3e8:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     420:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     434:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     43c:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     450:       a9 03 1d b8     stur    w9, [x29, #-48]
dyncall/doc/disas_examples/arm64.aapcs.disas:     45c:       a9 03 5c b8     ldur    w9, [x29, #-64]
dyncall/doc/disas_examples/arm64.aapcs.disas:     494:       a8 03 5b f8     ldur    x8, [x29, #-80]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4a8:       a8 83 5a f8     ldur    x8, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4b0:       a9 83 1a f8     stur    x9, [x29, #-88]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4c4:       a9 c3 1c b8     stur    w9, [x29, #-52]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4d8:       09 01 12 38     sturb   w9, [x8, #-224]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4dc:       a0 83 5e b8     ldur    w0, [x29, #-24]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4e0:       a1 43 5e b8     ldur    w1, [x29, #-28]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4e4:       a2 03 5e b8     ldur    w2, [x29, #-32]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4e8:       a3 c3 5d b8     ldur    w3, [x29, #-36]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4ec:       a0 83 5c bc     ldur    s0, [x29, #-56]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4f0:       a4 83 5d b8     ldur    w4, [x29, #-40]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4f4:       a5 43 5d b8     ldur    w5, [x29, #-44]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4f8:       a6 03 5d b8     ldur    w6, [x29, #-48]
dyncall/doc/disas_examples/arm64.aapcs.disas:     4fc:       a7 c3 5c b8     ldur    w7, [x29, #-52]
dyncall/doc/disas_examples/arm64.aapcs.disas:     500:       c0 fe ff 97     bl      #-1280 <leaf_call>
dyncall/doc/disas_examples/arm64.aapcs.disas:     54c:       bf c3 1f b8     stur    wzr, [x29, #-4]
dyncall/doc/disas_examples/arm64.aapcs.disas:     560:       b4 fe ff 97     bl      #-1328 <nonleaf_call>
dyncall/doc/disas_examples/mips.eabi.disas:; output from psptoolchain-20111215-psp w/ gcc 4.9.3
dyncall/doc/disas_examples/mips.eabi.disas:   0:   27bdffd8        addiu   sp,sp,-40
dyncall/doc/disas_examples/mips.eabi.disas:  3c:   27bdffd8        addiu   sp,sp,-40     ; |
dyncall/doc/disas_examples/mips.eabi.disas:  5c:   afc80010        sw      t0,16(s8)     ; | in args 0,1,2,3,4,5,6,7 -> temp space in local area
dyncall/doc/disas_examples/mips.eabi.disas:  6c:   27bdff18        addiu   sp,sp,-232    ; alloca(220) - with padding to guarantee alignment
dyncall/doc/disas_examples/mips.eabi.disas:  78:   000210c2        srl     v0,v0,0x3     ; | start of alloca()'d memory -> v1, by ...
dyncall/doc/disas_examples/mips.eabi.disas:  84:   2402004c        li      v0,76         ; 'L' -> v0, and...
dyncall/doc/disas_examples/mips.eabi.disas:  a8:   0c000000        jal     0 <leaf_call> ; call and ret addr -> ra
dyncall/doc/disas_examples/mips.eabi.disas:  c8:   27bdfff8        addiu   sp,sp,-8      ; |
dyncall/doc/disas_examples/mips.eabi.disas:  f8:   0c000000        jal     0 <leaf_call> ; call and ret addr -> ra
dyncall/doc/disas_examples/mips.eabi.disas:; ------------- as above but more args to use stack params ----------->
dyncall/doc/disas_examples/mips.eabi.disas:; output from psptoolchain-20111215-psp w/ gcc 4.9.3
dyncall/doc/disas_examples/mips.eabi.disas:   0:   27bdffd8        addiu   sp,sp,-40
dyncall/doc/disas_examples/mips.eabi.disas:  40:   27bdffd0        addiu   sp,sp,-48     ; |
dyncall/doc/disas_examples/mips.eabi.disas:  60:   afc80018        sw      t0,24(s8)     ; | in args 0,1,2,3,4,5,6,7 -> temp space in local area
dyncall/doc/disas_examples/mips.eabi.disas:  70:   27bdff18        addiu   sp,sp,-232    ; alloca(220) - with padding to guarantee alignment
dyncall/doc/disas_examples/mips.eabi.disas:  7c:   000210c2        srl     v0,v0,0x3     ; | start of alloca()'d memory -> v1, by ...
dyncall/doc/disas_examples/mips.eabi.disas:  88:   2402004c        li      v0,76         ; 'L' -> v0, and...
dyncall/doc/disas_examples/mips.eabi.disas:  b8:   0c000000        jal     0 <leaf_call> ; call and ret addr -> ra
dyncall/doc/disas_examples/mips.eabi.disas:  d8:   27bdfff0        addiu   sp,sp,-16     ; |
dyncall/doc/disas_examples/mips.eabi.disas: 118:   0c000000        jal     0 <leaf_call> ; call and ret addr -> ra
dyncall/doc/disas_examples/mips.eabi.disas:; ------------- with var args to see spilling ----------->
dyncall/doc/disas_examples/mips.eabi.disas:; output from psptoolchain-20111215-psp w/ gcc 4.9.3
dyncall/doc/disas_examples/mips.eabi.disas:   0:   27bdffd8        addiu   sp,sp,-40
dyncall/doc/disas_examples/mips.eabi.disas:  40:   27bdffa0        addiu   sp,sp,-96     ; |         leaving 32b extra space adjacent to prev frame's param area for spilling
dyncall/doc/disas_examples/mips.eabi.disas:  5c:   afc80050        sw      t0,80(s8)     ; | in args 1,2,3,4,5,6,7 -> spill area in current frame (adjacent to prev frame's param area)
dyncall/doc/disas_examples/mips.eabi.disas:  6c:   afc40030        sw      a0,48(s8)     ; in arg 0 -> temp space in local area
dyncall/doc/disas_examples/mips.eabi.disas:  74:   2442ffe4        addiu   v0,v0,-28     ; ... to start of spill area (96 - 28 = 68, where we spilled a1)
dyncall/doc/disas_examples/mips.eabi.disas:  88:   8c420000        lw      v0,0(v0)      ; |            ... arg -> v0 (using pre-inc read location), then ...
dyncall/doc/disas_examples/mips.eabi.disas: 130:   27bdff18        addiu   sp,sp,-232    ; alloca(220) - with padding to guarantee alignment
dyncall/doc/disas_examples/mips.eabi.disas: 13c:   000210c2        srl     v0,v0,0x3     ; | start of alloca()'d memory -> v1, by ...
dyncall/doc/disas_examples/mips.eabi.disas: 148:   2402004c        li      v0,76         ; 'L' -> v0, and...
dyncall/doc/disas_examples/mips.eabi.disas: 178:   0c000000        jal     0 <leaf_call> ; call and ret addr -> ra
dyncall/doc/disas_examples/mips.eabi.disas: 198:   27bdfff0        addiu   sp,sp,-16     ; |
dyncall/doc/disas_examples/mips.eabi.disas: 1d8:   0c000000        jal     0 <leaf_call> ; call and ret addr -> ra
dyncall/doc/disas_examples/mips.eabi.disas:; ------------- var args with ints and floats to see spilling (which remains only a?-a7 regs), b/c doubles are passed via them and floats are promoted to doubles in (...) ----------->
dyncall/doc/disas_examples/mips.eabi.disas:; output from psptoolchain-20111215-psp w/ gcc 4.9.3
dyncall/doc/disas_examples/mips.eabi.disas:   0:   27bdffd0        addiu   sp,sp,-48
dyncall/doc/disas_examples/mips.eabi.disas:  44:   27bdffa8        addiu   sp,sp,-88     ; |         leaving 32b extra space adjacent to prev frame's param area for spilling
dyncall/doc/disas_examples/mips.eabi.disas:  60:   afc80048        sw      t0,72(s8)     ; | in args 1,2,3,4,5 (spread out over 7 param regs) -> spill area in current frame (adjacent to prev frame's param area)
dyncall/doc/disas_examples/mips.eabi.disas:  70:   afc40028        sw      a0,40(s8)     ; in arg 0 -> temp space in local area
dyncall/doc/disas_examples/mips.eabi.disas:  78:   2442ffe4        addiu   v0,v0,-28     ; ... to start of spill area (88 - 28 = 60, where we spilled a1)
dyncall/doc/disas_examples/mips.eabi.disas:  8c:   8c420000        lw      v0,0(v0)      ; |            ... arg -> v0 (using pre-inc read location), then ...
dyncall/doc/disas_examples/mips.eabi.disas:  d8:   2402fff8        li      v0,-8         ; |            | align
dyncall/doc/disas_examples/mips.eabi.disas: 10c:   2402fff8        li      v0,-8         ; |
dyncall/doc/disas_examples/mips.eabi.disas: 168:   2402fff8        li      v0,-8         ; |
dyncall/doc/disas_examples/mips.eabi.disas: 194:   27bdff18        addiu   sp,sp,-232    ; alloca(220) - with padding to guarantee alignment
dyncall/doc/disas_examples/mips.eabi.disas: 1a0:   000210c2        srl     v0,v0,0x3     ; | start of alloca()'d memory -> v1, by ...
dyncall/doc/disas_examples/mips.eabi.disas: 1ac:   2402004c        li      v0,76         ; 'L' -> v0, and...
dyncall/doc/disas_examples/mips.eabi.disas: 1d8:   0c000000        jal     0 <leaf_call> ; call and ret addr -> ra
dyncall/doc/disas_examples/mips.eabi.disas: 1f8:   27bdffe0        addiu   sp,sp,-32     ; |
dyncall/doc/disas_examples/mips.eabi.disas: 254:   0c000000        jal     0 <leaf_call> ; call and ret addr -> ra
dyncall/doc/disas_examples/mips.eabi.disas:; --------------------- further notes ------------------->
dyncall/doc/manual/dyncall_logo.svg:<?xml version="1.0" encoding="UTF-8" standalone="no"?>
dyncall/doc/manual/dyncall_logo.svg:   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
dyncall/doc/manual/dyncall_logo.svg:   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
dyncall/doc/manual/dyncall_logo.svg:     inkscape:window-height="575"
dyncall/doc/manual/dyncall_logo.svg:     inkscape:window-width="765"
dyncall/doc/manual/dyncall_logo.svg:     inkscape:guide-bbox="true"
dyncall/doc/manual/dyncall_logo.svg:     inkscape:window-x="186"
dyncall/doc/manual/dyncall_logo.svg:     inkscape:window-y="80"
dyncall/doc/manual/dyncall_logo.svg:     inkscape:current-layer="g6" />
dyncall/doc/manual/dyncall_logo.svg:     transform="matrix(2.2965446,0,0,2.2965446,-189.23706,135.3048)"
dyncall/doc/manual/dyncall_logo.svg:   stroke-miterlimit="10"
dyncall/doc/manual/dyncall_logo.svg:   style="fill:#000000;fill-rule:evenodd;stroke-width:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_logo.svg:   stroke-miterlimit="10"
dyncall/doc/manual/dyncall_logo.svg:   style="fill:#000000;stroke:#000000;stroke-width:0.80000001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10;stroke-opacity:1">
dyncall/doc/manual/dyncall_logo.svg:   style="fill:#000000;stroke:#000000;stroke-opacity:1" />
dyncall/doc/manual/dyncall_logo.svg:   stroke-miterlimit="10"
dyncall/doc/manual/dyncall_logo.svg:   style="fill:#000000;fill-rule:nonzero;stroke-width:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_logo.svg:   stroke-miterlimit="10"
dyncall/doc/manual/dyncall_logo.svg:   style="fill:#000000;stroke:#7f7f7f;stroke-width:0.80000001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_logo.svg:   stroke-miterlimit="10"
dyncall/doc/manual/dyncall_logo.svg:   style="fill:#000000;fill-rule:nonzero;stroke-width:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_logo.svg:   stroke-miterlimit="10"
dyncall/doc/manual/dyncall_logo.svg:   style="fill:#000000;stroke:none;stroke-width:0.80376798;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_logo.svg:   stroke-miterlimit="10"
dyncall/doc/manual/dyncall_logo.svg:   style="fill:#000000;fill-rule:nonzero;stroke-width:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_logo.svg:   stroke-miterlimit="10"
dyncall/doc/manual/dyncall_logo.svg:   style="fill:#000000;stroke:#7f7f7f;stroke-width:0.80376798;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_logo.svg:   stroke-miterlimit="10"
dyncall/doc/manual/dyncall_logo.svg:   style="fill:#000000;fill-rule:nonzero;stroke-width:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_logo.svg:   stroke-miterlimit="10"
dyncall/doc/manual/dyncall_logo.svg:   style="fill:#000000;stroke:none;stroke-width:0.80376798;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_logo.svg:   stroke-miterlimit="10"
dyncall/doc/manual/dyncall_logo.svg:   style="fill:#000000;fill-rule:nonzero;stroke-width:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_logo.svg:   transform="matrix(0.4354368,0,0,0.4354368,82.400777,-58.916687)"
dyncall/doc/manual/dyncall_logo.svg:   stroke-miterlimit="10"
dyncall/doc/manual/dyncall_logo.svg:   style="fill:#000000;fill-rule:nonzero;stroke-width:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_logo.svg:   transform="matrix(0.4354368,0,0,0.4354368,82.400777,-58.916687)"
dyncall/doc/manual/manual.tex:% Copyright (c) 2007-2019 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/manual.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/manual.tex:% Use a sans-serif font.
dyncall/doc/manual/manual.tex:% main document content -->
dyncall/doc/manual/manual_bindings.tex:% Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/manual_bindings.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/manual_bindings.tex:However, please note that some of these bindings are work-in-progress and not
dyncall/doc/manual/manual_bindings.tex:library provides an abstract interface to operating-system specific mechanisms
dyncall/doc/manual/manual_bindings.tex:\item [load] - load a module of compiled code
dyncall/doc/manual/manual_bindings.tex:\item [free] - unload a module of compiled code
dyncall/doc/manual/manual_bindings.tex:\item [find] - find function pointer by symbolic names
dyncall/doc/manual/manual_bindings.tex:\item [call] - invoke a function call
dyncall/doc/manual/manual_bindings.tex:functions to perform automatic type-conversion of the languages' types to the
dyncall/doc/manual/manual_bindings.tex:low-level C/C++ data types.
dyncall/doc/manual/manual_bindings.tex:types provided in scripting languages to the strict machine-level data types
dyncall/doc/manual/manual_bindings.tex:used by C-libraries.
dyncall/doc/manual/manual_bindings.tex:The high-level C interface functions \capi{dcCallF()}, \capi{dcVCallF()},
dyncall/doc/manual/manual_bindings.tex:\sigchar{)} is in left-to-right order of the corresponding C function
dyncall/doc/manual/manual_bindings.tex:only sense if there are multiple co-existing calling conventions on a single platform.
dyncall/doc/manual/manual_bindings.tex:Note that passing a Go-{\tt string} directly to a C-function expecting a pointer is not directly possible. However, the binding comes with
dyncall/doc/manual/manual_bindings.tex:\item Unsigned 32-bit integers are represented as signed integers in R.
dyncall/doc/manual/manual_bindings.tex:\item 64-bit integer types do not exist in R, therefore we use double floats
dyncall/doc/manual/manual_bindings.tex:to represent 64-bit integers (using only the 52-bit mantissa part).
dyncall/doc/manual/manual_design.tex:% Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/manual_design.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/manual_design.tex:\item Specify the calling convention. Some run-time platforms, such as
dyncall/doc/manual/manual_design.tex:Microsoft Windows on a 32-bit X86 architecture, even support multiple calling
dyncall/doc/manual/manual_design.tex:has been compiled and specifies the low-level details on how a function
dyncall/doc/manual/manual_dyncall_api.tex:% Copyright (c) 2007,2010 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/manual_dyncall_api.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/manual_dyncall_api.tex:The library provides low-level functionality to make foreign function calls
dyncall/doc/manual/manual_dyncall_api.tex:from different run-time environments. The flexibility is constrained by the
dyncall/doc/manual/manual_dyncall_api.tex:  & lower-case & \capi{DCint}, \capi{DCfloat}, \capi{DClong}, \ldots\\
dyncall/doc/manual/manual_dyncall_api.tex:  & camel-case 
dyncall/doc/manual/manual_dyncall_api.tex:Functions  & {\tt dc\group{function name}}  & camel-case & \capi{dcNewCallVM}, \capi{dcArgInt}, \ldots\\
dyncall/doc/manual/manual_dyncall_api.tex:\subsection{Call Virtual Machine - CallVM}
dyncall/doc/manual/manual_dyncall_api.tex:\lstinline@DC_CALL_C_ARM_ARMHF@          & C arm call (arm hardfloat - e.g. raspberry pi)\\
dyncall/doc/manual/manual_dyncall_api.tex:Arguments should be bound in \emph{left-to-right} order regarding the C
dyncall/doc/manual/manual_dyncall_api.tex:These functions can be used to operate \product{dyncall} via a printf-style
dyncall/doc/manual/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./doc/manual
dyncall/doc/manual/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/doc/manual/manual_devel.tex:% Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/manual_devel.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/manual_devel.tex:{\tt configure}      & pre-make configuration tool (unix-shell)     \\
dyncall/doc/manual/manual_devel.tex:{\tt configure.bat}  & pre-nmake configuration tool (windows batch) \\
dyncall/doc/manual/manual_devel.tex:{\tt configure.rc}   & pre-mk configuration tool (Plan 9's rc)      \\
dyncall/doc/manual/manual_devel.tex:{\tt CMakeLists.txt} & top-level project information for CMake      \\
dyncall/doc/manual/manual_devel.tex:testing non-callback calls).
dyncall/doc/manual/dyncall_watermark.eps:%!PS-Adobe-3.0 EPSF-3.0
dyncall/doc/manual/dyncall_watermark.eps:0.8 -0.8 scale
dyncall/doc/manual/dyncall_watermark.eps:gsave [2.2965446 0 0 2.2965446 -189.23706 135.3048] concat
dyncall/doc/manual/dyncall_watermark.eps:gsave [0.7802343 0 0 0.7802343 -63.142369 43.042016] concat
dyncall/doc/manual/dyncall_watermark.eps:gsave [0.7802343 0 0 0.7802343 -63.142369 43.042016] concat
dyncall/doc/manual/dyncall_watermark.eps:gsave [0.7802343 0 0 0.7802343 -63.142369 43.042016] concat
dyncall/doc/manual/dyncall_watermark.eps:gsave [0.4572086 0 0 0.4572086 176.55441 -80.651816] concat
dyncall/doc/manual/dyncall_watermark.eps:gsave [0.7802343 0 0 0.7802343 -63.142369 43.042016] concat
dyncall/doc/manual/dyncall_watermark.eps:gsave [0.4572086 0 0 0.4572086 176.55441 -80.651816] concat
dyncall/doc/manual/dyncall_watermark.eps:gsave [0.7802343 0 0 0.7802343 -63.142369 43.042016] concat
dyncall/doc/manual/dyncall_watermark.eps:gsave [0.7802343 0 0 0.7802343 -63.142369 43.042016] concat
dyncall/doc/manual/dyncall_watermark.eps:gsave [0.4354368 0 0 0.4354368 82.400777 -58.916687] concat
dyncall/doc/manual/dyncall_watermark.eps:gsave [0.7802343 0 0 0.7802343 -63.142369 43.042016] concat
dyncall/doc/manual/dyncall_watermark.eps:gsave [0.4354368 0 0 0.4354368 82.400777 -58.916687] concat
dyncall/doc/manual/dyncall_watermark.eps:gsave [0.7802343 0 0 0.7802343 -63.142369 43.042016] concat
dyncall/doc/manual/manual_epilog.tex:% Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/manual_epilog.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/manual_epilog.tex:function itself (except its address), no parameter-type validation is done.
dyncall/doc/manual/manual_epilog.tex:to build the library as build-time dependencies, like a compiler and assembler,
dyncall/doc/manual/manual_epilog.tex:The library uses some heap-memory to store the CallVM and uses by default the
dyncall/doc/manual/manual_epilog.tex:\capi{dcAllocMem} and \capi{dcFreeMem} C-preprocessor definitions will override
dyncall/doc/manual/manual_epilog.tex:\subsection{Multi-threading}
dyncall/doc/manual/manual_epilog.tex:The \product{dyncall} library is thread-safe and reentrant, by means that it
dyncall/doc/manual/manual_epilog.tex:Invoking the call should always be thread-safe, however, whether the called
dyncall/doc/manual/manual_epilog.tex:function is thread-safe is up to the programmer to verify, of course.
dyncall/doc/manual/manual_tex4ht.cfg:% Copyright (c) 2015-2016 Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/manual_tex4ht.cfg:% that next-links recurses.
dyncall/doc/manual/manual_tex4ht.cfg:\Preamble{html,info,index=2,1,pic-tabular,pic-align,charset="utf-8",p-width}
dyncall/doc/manual/manual_tex4ht.cfg:\Configure{TITLE}{\HCode{<title>}dyncall Manual - }{\HCode{</title>}}
dyncall/doc/manual/manual_tex4ht.cfg:\Configure{@HEAD}{\HCode{<meta http-equiv="content-type" content="text/html; charset=utf-8"/>\Hnewline}}
dyncall/doc/manual/manual_tex4ht.cfg:\Configure{@HEAD}{\HCode{<meta name="resource-type" content="document"/>\Hnewline}}
dyncall/doc/manual/manual_tex4ht.cfg:					\advance\c by -1
dyncall/doc/manual/manual_tex4ht.cfg:% Define layout of tables - for some reason tabular* renders fine
dyncall/doc/manual/manual_tex4ht.cfg:% when pic-tabular is *not* used. When it is, it converts tabular
dyncall/doc/manual/manual_tex4ht.cfg:	{\HCode{<tr>}} %{\HCode{<tr class="row-\HRow">}}
dyncall/doc/manual/manual_tex4ht.cfg:% Remove hr-tags that tex4ht inserts by default in around floats (e.g. tables) and replace them with a background.
dyncall/doc/manual/manual_tex4ht.cfg:% Also remove hr-tags around figures, entirely.
dyncall/doc/manual/manual_tex4ht.cfg:\Configure{texttt}{\Tg<span style="background-color:red">}{\Tg</span>}
dyncall/doc/manual/manual_tex4ht.cfg:\Configure{textrm}{\Tg<span style="background-color:red">}{\Tg</span>}
dyncall/doc/manual/manual_tex4ht.cfg:\Configure{textup}{\Tg<span style="background-color:red">}{\Tg</span>}
dyncall/doc/manual/manual_tex4ht.cfg:\Configure{textsl}{\Tg<span style="background-color:red">}{\Tg</span>}
dyncall/doc/manual/manual_tex4ht.cfg:\Configure{textsf}{\Tg<span style="background-color:red">}{\Tg</span>}
dyncall/doc/manual/manual_tex4ht.cfg:\Configure{textsc}{\Tg<span style="background-color:red">}{\Tg</span>}
dyncall/doc/manual/manual_tex4ht.cfg:% paragraph{xxx} - should probably be forced to always be on newline to reflect pdf
dyncall/doc/manual/manual_tex4ht.cfg:%http://www.itisnotoverengineering.com/2013/06/syntax-highlighting-with-tex4ht.html
dyncall/doc/manual/manual_tex4ht.cfg:{}%previous-tail
dyncall/doc/manual/manual_tex4ht.cfg:{\HCode{<div style="width:100\%;text-align:left"><div style="width:30\%;display:inline-block;text-align:left">}}%
dyncall/doc/manual/manual_tex4ht.cfg:{\HCode{<hr><div style="width:100\%;text-align:left"><div style="width:30\%;display:inline-block;text-align:left">}}%
dyncall/doc/manual/manual_tex4ht.cfg:% Hacky - output div stuff before specific crosslinks, has to play together with crosslinks+, above
dyncall/doc/manual/manual_tex4ht.cfg:\Configure{crosslinks:next}{\HCode{</div><div style="width:30\%;display:inline-block;text-align:right">}}
dyncall/doc/manual/manual_tex4ht.cfg:\Configure{crosslinks:up}  {\HCode{</div><div style="width:40\%;display:inline-block;text-align:center">}}
dyncall/doc/manual/manual_literature.tex:% Copyright (c) 2007-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/manual_literature.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/manual_literature.tex:	\url{http://www.r-project.org/}
dyncall/doc/manual/manual_literature.tex:	\url{http://www.ruby-lang.org/}
dyncall/doc/manual/manual_literature.tex:	\url{http://msdn.microsoft.com/en-us/library/zxk0tw93(vs.71).aspx}\\
dyncall/doc/manual/manual_literature.tex:	\url{http://www.cs.cornell.edu/courses/cs412/2001sp/resources/microsoft-calling-conventions.html}
dyncall/doc/manual/manual_literature.tex:	\url{http://msdn.microsoft.com/en-us/library/Aa271991}\\
dyncall/doc/manual/manual_literature.tex:	\url{http://www.cs.cornell.edu/courses/cs412/2001sp/resources/microsoft-calling-conventions.html}
dyncall/doc/manual/manual_literature.tex:	\url{http://www.ohse.de/uwe/articles/gcc-attributes.html#func-fastcall}\\
dyncall/doc/manual/manual_literature.tex:	Watcom 32-bit register-based calling convention\\
dyncall/doc/manual/manual_literature.tex:	\url{http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/function-calling-conventions.html#Watcall32R}
dyncall/doc/manual/manual_literature.tex:	\url{http://www.cs.cornell.edu/courses/cs412/2001sp/resources/microsoft-calling-conventions.html}\\
dyncall/doc/manual/manual_literature.tex:	\url{http://plan9.bell-labs.com/sys/doc/compiler.pdf}\\
dyncall/doc/manual/manual_literature.tex:	\url{http://www.mail-archive.com/9fans@9fans.net/msg16421.html}
dyncall/doc/manual/manual_literature.tex:	ARM-THUMB Procedure Call Standard\\
dyncall/doc/manual/manual_literature.tex:	Procedure Call Standard for the ARM 64-bit Architecture\\
dyncall/doc/manual/manual_literature.tex:	\url{https://docs.microsoft.com/en-us/cpp/build/arm64-windows-abi-conventions}
dyncall/doc/manual/manual_literature.tex:	\url{http://msdn.microsoft.com/en-us/library/ms235286\%28VS.80\%29.aspx}
dyncall/doc/manual/manual_literature.tex:	System V Application Binary Interface - AMD64 Architecture Processor Supplement\\
dyncall/doc/manual/manual_literature.tex:	\url{http://www.x86-64.org/documentation/abi.pdf}
dyncall/doc/manual/manual_literature.tex:	System V Application Binary Interface - SPARC Processor Supplement\\
dyncall/doc/manual/manual_literature.tex:	\url{http://sparc.org/wp-content/uploads/2014/01/psABI3rd.pdf.gz}
dyncall/doc/manual/manual_literature.tex:	System V Application Binary Interface - SPARC Version 9 Processor Supplement\\
dyncall/doc/manual/manual_literature.tex:	\url{http://sparc.org/wp-content/uploads/2014/01/64.psabi\_.1.35.pdf1.gz}
dyncall/doc/manual/manual_literature.tex:	The SPARC Architecture Manual - Version 8\\
dyncall/doc/manual/manual_literature.tex:	\url{http://sparc.org/wp-content/uploads/2014/01/v8.pdf.gz}
dyncall/doc/manual/manual_literature.tex:	The SPARC Architecture Manual - Version 9\\
dyncall/doc/manual/manual_literature.tex:	\url{http://sparc.org/wp-content/uploads/2014/01/SPARCV9.pdf.gz}
dyncall/doc/manual/manual_literature.tex:%	\url{http://docs.oracle.com/cd/E19120-01/open.solaris/816-1681/index.html}
dyncall/doc/manual/manual_literature.tex:	\url{https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/LowLevelABI/000-Introduction/introduction.html}
dyncall/doc/manual/manual_literature.tex:	Linux Standard Base Core Specification for PPC32 3.2 - Chapter 8. Low Level System Information\\
dyncall/doc/manual/manual_literature.tex:	\url{http://refspecs.linuxbase.org/LSB\_3.2.0/LSB-Core-PPC32/LSB-Core-PPC32/callingsequence.html}
dyncall/doc/manual/manual_literature.tex:	PowerPC Embedded Application Binary Interface 32-bit Implementation\\
dyncall/doc/manual/manual_literature.tex:	\url{http://ftp.twaren.net/Unix/sourceware.org/binutils/ppc-docs/ppc-eabi-1995-01.pdf}
dyncall/doc/manual/manual_literature.tex:	\url{ftp://www.sourceware.org/pub/binutils/ppc-docs/ppc-poweropen/}
dyncall/doc/manual/manual_literature.tex:	64-bit PowerPC ELF Application Binary Interface Supplement 1.9\\
dyncall/doc/manual/manual_literature.tex:	\url{http://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi.html}
dyncall/doc/manual/manual_literature.tex:	\url{http://gcc.gnu.org/projects/mipso64-abi.html}
dyncall/doc/manual/manual_literature.tex:	\url{https://www.linux-mips.org/pub/linux/mips/doc/ABI/MIPS-N32-ABI-Handbook.pdf}
dyncall/doc/manual/manual_literature.tex:	\url{http://www.cygwin.com/ml/binutils/2003-06/msg00436.html}
dyncall/doc/manual/manual_literature.tex:	NUBI - A Revised ABI for the MIPS Architecture\\
dyncall/doc/manual/manual_literature.tex:	\url{ftp://ftp.linux-mips.org//pub/linux/mips/doc/NUBI/MD00438-2C-NUBIDESC-SPC-00.20.pdf}
dyncall/doc/manual/manual_literature.tex:	devkitPro - homebrew game development\\
dyncall/doc/manual/manual_literature.tex:	psptoolchain - all the homebrew related material ps2dev.org\\
dyncall/doc/manual/manual_literature.tex:	libffi - a portable foreign function interface library\\
dyncall/doc/manual/manual_literature.tex:	C/Invoke - library for connecting to C libraries at runtime\\
dyncall/doc/manual/manual_literature.tex:	libffcall - foreign function call libraries\\
dyncall/doc/manual/manual_literature.tex:	\url{http://www.haible.de/bruno/packages-ffcall.html}
dyncall/doc/manual/manual_cc.tex:% Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/manual_cc.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/callconvs/callconv_sparc64.tex:% Copyright (c) 2012-2019 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/doc/manual/callconvs/callconv_sparc64.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/callconvs/callconv_sparc64.tex:V7, V8\cite{SPARCV8}\cite{SPARCSysV} and V9\cite{SPARCV9}\cite{SPARCV9SysV}. The former two are 32-bit (see previous chapter) whereas the latter refers to the 64-bit SPARC architecture.
dyncall/doc/manual/callconvs/callconv_sparc64.tex:\product{dyncall} fully supports the SPARC 64-bit instruction set (V9), for calls and callbacks.
dyncall/doc/manual/callconvs/callconv_sparc64.tex:\subsubsection{SPARC (64-bit) Calling Convention}
dyncall/doc/manual/callconvs/callconv_sparc64.tex:\item 32 double precision floating point registers (d0,d2,d4,...,d62, usable as 16 quad precision ones q0,q4,q8,...g60, and also first half of them are usable as 32 single precision registers f0-f31)
dyncall/doc/manual/callconvs/callconv_sparc64.tex:\item 32 64-bit integer/pointer registers out of a bigger (vendor/model dependent) number that are accessible at a time (8 are global ones (g*), whereas the remaining 24 form a register window with 8 input (i*), 8 output (o*) and 8 local (l*) ones)
dyncall/doc/manual/callconvs/callconv_sparc64.tex:{\bf \%g0}                    & \%r0                           & Read-only, hardwired to 0 \\
dyncall/doc/manual/callconvs/callconv_sparc64.tex:{\bf \%g1-\%g7}               & \%r1-\%r7                      & Global \\
dyncall/doc/manual/callconvs/callconv_sparc64.tex:{\bf \%o0-\%o3 and \%i0-\%i3} & \%r8-\%r11 and \%r24-\%r27     & Output and input argument registers, return value \\
dyncall/doc/manual/callconvs/callconv_sparc64.tex:{\bf \%l0-\%l7}               & \%r16-\%r23                    & preserve \\
dyncall/doc/manual/callconvs/callconv_sparc64.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_sparc64.tex:\item first 6 integers are passed in registers using \%o0-\%o5
dyncall/doc/manual/callconvs/callconv_sparc64.tex:\item first 8 quad precision floating point args (or 16 double precision, or 32 single precision) are passed in floating point registers (\%q0,\%q4,...,\%q28 or \%d0,\%d2,...,\%d30 or \%f0-\%f31, respectively)
dyncall/doc/manual/callconvs/callconv_sparc64.tex:\item single precision floating point args are passed in odd \%f* registers, and are "right aligned" in their 8-byte space on the stack
dyncall/doc/manual/callconvs/callconv_sparc64.tex:\item results are expected by caller to be returned in \%o0-\%o3 (after reg window restore, meaning callee writes to \%i0-\%i3) for integers
dyncall/doc/manual/callconvs/callconv_sparc64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_sparc64.tex:\mrlbrace{6}{parameter area}       & arg n-1                     & \mrrbrace{3}{stack parameters} &                               \\
dyncall/doc/manual/callconvs/callconv_sparc64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_sparc64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_sparc64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc64.tex:% Copyright (c) 2007-2019 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/callconvs/callconv_ppc64.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/callconvs/callconv_ppc64.tex:\item Linux PPC 64-bit ABI is specified in "64-bit PowerPC ELF Application Binary Interface Supplement"\cite{ppcelf64abi} which is based on "System V ABI".
dyncall/doc/manual/callconvs/callconv_ppc64.tex:{\bf gpr4-gpr10}    & parameter 1-7 for integer or pointer parameters, scratch\\
dyncall/doc/manual/callconvs/callconv_ppc64.tex:{\bf gpr14-31}      & preserve\\
dyncall/doc/manual/callconvs/callconv_ppc64.tex:{\bf fpr1-fpr4}     & floating point return value, floating point parameter 0-3 (always double precision)\\
dyncall/doc/manual/callconvs/callconv_ppc64.tex:{\bf fpr5-fpr13}    & floating point parameters 4-12 (always double precision)\\
dyncall/doc/manual/callconvs/callconv_ppc64.tex:{\bf fpr14-fpr31}   & preserve\\
dyncall/doc/manual/callconvs/callconv_ppc64.tex:{\bf v0-v1}         & scratch\\
dyncall/doc/manual/callconvs/callconv_ppc64.tex:{\bf v2-v13}        & vector parameters\\
dyncall/doc/manual/callconvs/callconv_ppc64.tex:{\bf v14-v19}       & scratch\\
dyncall/doc/manual/callconvs/callconv_ppc64.tex:{\bf v20-v31}       & preserve\\
dyncall/doc/manual/callconvs/callconv_ppc64.tex:{\bf lr}            & link-register, scratch\\
dyncall/doc/manual/callconvs/callconv_ppc64.tex:{\bf ctr}           & count-register, scratch\\
dyncall/doc/manual/callconvs/callconv_ppc64.tex:{\bf cr0-cr7}       & conditional register fields, each 4-bit wide (cr0-cr1 and cr5-cr7 are scratch)\\
dyncall/doc/manual/callconvs/callconv_ppc64.tex:\caption{Register usage on PowerPC 64-Bit ELF ABI}
dyncall/doc/manual/callconvs/callconv_ppc64.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_ppc64.tex:\item the first 8 integer parameters are passed in registers gpr3-gpr10
dyncall/doc/manual/callconvs/callconv_ppc64.tex:\item the first 13 floating point parameters are passed in registers fpr1-fpr13
dyncall/doc/manual/callconvs/callconv_ppc64.tex:needed - e.g. varargs), meaning a minimum of 64 bytes to hold gpr3-gpr10
dyncall/doc/manual/callconvs/callconv_ppc64.tex:\item all nonvector parameters are aligned on 8-byte boundaries
dyncall/doc/manual/callconvs/callconv_ppc64.tex:\item vector parameters are aligned on 16-byte boundaries
dyncall/doc/manual/callconvs/callconv_ppc64.tex:\item integer parameters \textless\ 64 bit are right-justified (meaning occupy higher-address bytes) in their 8-byte slot on the stack, requiring extra-care for big-endian targets
dyncall/doc/manual/callconvs/callconv_ppc64.tex:Stack frame is always 16-byte aligned.
dyncall/doc/manual/callconvs/callconv_ppc64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_sparc32.tex:% Copyright (c) 2012-2019 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/doc/manual/callconvs/callconv_sparc32.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/callconvs/callconv_sparc32.tex:V7, V8\cite{SPARCV8}\cite{SPARCSysV} and V9\cite{SPARCV9}\cite{SPARCV9SysV}. The former two are 32-bit whereas the latter refers to the 64-bit SPARC architecture (see next chapter).
dyncall/doc/manual/callconvs/callconv_sparc32.tex:\product{dyncall} fully supports the SPARC 32-bit instruction set (V7 and V8), for calls and callbacks.
dyncall/doc/manual/callconvs/callconv_sparc32.tex:\subsubsection{SPARC (32-bit) Calling Convention}
dyncall/doc/manual/callconvs/callconv_sparc32.tex:\item 32 single floating point registers (f0-f31, usable as 8 quad precision q0,q4,q8,...,q28, 16 double precision d0,d2,d4,...,d30)
dyncall/doc/manual/callconvs/callconv_sparc32.tex:\item 32 32-bit integer/pointer registers out of a bigger (vendor/model dependent) number that are accessible at a time (8 are global ones (g*), whereas the remaining 24 form a register window with 8 input (i*), 8 output (o*) and 8 local (l*) ones)
dyncall/doc/manual/callconvs/callconv_sparc32.tex:{\bf \%g0}                    & \%r0                           & Read-only, hardwired to 0 \\
dyncall/doc/manual/callconvs/callconv_sparc32.tex:{\bf \%g1-\%g7}               & \%r1-\%r7                      & Global \\
dyncall/doc/manual/callconvs/callconv_sparc32.tex:{\bf \%o2-\%o5 and \%i2-\%i5} & \%r10-\%r13 and \%r26-\%r29    & Output and input argument registers \\
dyncall/doc/manual/callconvs/callconv_sparc32.tex:{\bf \%l0-\%l7}               & \%r16-\%r23                    & preserve \\
dyncall/doc/manual/callconvs/callconv_sparc32.tex:{\bf \%f2-\%f31}              &                                & scratch \\
dyncall/doc/manual/callconvs/callconv_sparc32.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_sparc32.tex:\item first 6 integers and floats are passed independently in registers using \%o0-\%o5
dyncall/doc/manual/callconvs/callconv_sparc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_sparc32.tex:\mrlbrace{7}{parameter area}       & arg n-1                     & \mrrbrace{3}{stack parameters} &                               \\
dyncall/doc/manual/callconvs/callconv_sparc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_sparc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_sparc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_mips64.tex:% Copyright (c) 2007-2019 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/doc/manual/callconvs/callconv_mips64.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/callconvs/callconv_mips64.tex:uses ILP32 as programming model (32-bit pointers and long integers), whereas
dyncall/doc/manual/callconvs/callconv_mips64.tex:N64 uses LP64 (64-bit pointers and long integers). All registers of a MIPS64
dyncall/doc/manual/callconvs/callconv_mips64.tex:chip are considered to be 64-bit wide, even for the N32 calling convention.\\
dyncall/doc/manual/callconvs/callconv_mips64.tex:Other than that there are correspoding 64-bit versions other MIPS32 ABIs, e.g.
dyncall/doc/manual/callconvs/callconv_mips64.tex:For MIPS 64-bit machines, dyncall supports the N64 calling conventions for calls and callbacks (for all four combinations of big/little-endian, and soft/hard-float targets).
dyncall/doc/manual/callconvs/callconv_mips64.tex:The N32 calling convention might work - it used to, but hasn't been tested, recently.
dyncall/doc/manual/callconvs/callconv_mips64.tex:{\bf \$2-\$3}              & {\bf \$v0-\$v1}      & return value (only integer on hard-float targets), scratch \\
dyncall/doc/manual/callconvs/callconv_mips64.tex:{\bf \$4-\$11}             & {\bf \$a0-\$a7}      & first arguments (only integer on hard-float targets), scratch \\
dyncall/doc/manual/callconvs/callconv_mips64.tex:{\bf \$12-\$15,\$24}       & {\bf \$t4-\$t7,\$t8} & temporaries, scratch \\
dyncall/doc/manual/callconvs/callconv_mips64.tex:{\bf \$16-\$23}            & {\bf \$s0-\$s7}      & preserve \\
dyncall/doc/manual/callconvs/callconv_mips64.tex:{\bf \$f0,\$f2}            &                      & only on hard-float targets: float results, scratch \\
dyncall/doc/manual/callconvs/callconv_mips64.tex:{\bf \$f1,\$f3,\$f4-\$f11} &                      & only on hard-float targets: float temporaries, scratch \\
dyncall/doc/manual/callconvs/callconv_mips64.tex:{\bf \$f12-\$f19}          &                      & only on hard-float targets: float arguments, scratch \\
dyncall/doc/manual/callconvs/callconv_mips64.tex:{\bf \$f20-\$f23}          &                      & only on hard-float targets: float temporaries, scratch \\
dyncall/doc/manual/callconvs/callconv_mips64.tex:{\bf \$f24-\$f31}          &                      & only on hard-float targets: preserved \\
dyncall/doc/manual/callconvs/callconv_mips64.tex:\item Stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_mips64.tex:\item generally, first 8 params \textgreater=\ 64-bit are passed via registers
dyncall/doc/manual/callconvs/callconv_mips64.tex:\item for hard-float targets: register arguments are passed via \$a0-\$a7 for integers and \$f12-\$f19 for floats - with mixed float and int parameters, some registers are left out (e.g. first parameter ends up in \$a0 or \$f12, second in \$a1 or \$f13, etc.)
dyncall/doc/manual/callconvs/callconv_mips64.tex:\item for soft-float targets: register arguments are passed via \$a0-\$a7
dyncall/doc/manual/callconvs/callconv_mips64.tex:\item all stack entries are 64-bit aligned
dyncall/doc/manual/callconvs/callconv_mips64.tex:\item all stack regions are 16-byte aligned
dyncall/doc/manual/callconvs/callconv_mips64.tex:\item only on hard-float targets: floating point results are returned in \$f0
dyncall/doc/manual/callconvs/callconv_mips64.tex:\item if the callee takes the address of one of the parameters and uses it to address other unnamed parameters (e.g. varargs) it has to copy - in its prolog - the the argument registers to a reserved stack area adjacent to the other parameters on the stack (only the unnamed integer parameters require saving, though) % @@@ seems to *ONLY* spill with varargs, never for any other reason
dyncall/doc/manual/callconvs/callconv_mips64.tex:\item float arguments passed in the variable part of a vararg call are passed like integers, meaning float registers don't ever need to be saved that way, so only \$a0-\$a7 are need to be spilled
dyncall/doc/manual/callconvs/callconv_mips64.tex:\item quad precision float arguments are passed in even-odd register pairs, skipping one register if needed
dyncall/doc/manual/callconvs/callconv_mips64.tex:\item integer parameters \textless\ 64 bit are right-justified (meaning occupy higher-address bytes) in their 8-byte slot on the stack, requiring extra-care for big-endian targets
dyncall/doc/manual/callconvs/callconv_mips64.tex:\item single precision float parameters (32 bit) are left-justified in their 8-byte slot on the stack, but are right justified in fp-registers on big endian targets, as they aren't promoted (actually, official docs says "undecided", but real world implementations seem to use what is described here)
dyncall/doc/manual/callconvs/callconv_mips64.tex:% maybe note somewhere that "prolog-based" spilling is neat for dyncall, as we don't have to care
dyncall/doc/manual/callconvs/callconv_mips64.tex:\hhline{~-~~}                            
dyncall/doc/manual/callconvs/callconv_mips64.tex:\hhline{~-~~}                            
dyncall/doc/manual/callconvs/callconv_mips64.tex:\mrlbrace{6}{parameter area}             & arg n-1                  & \mrrbrace{3}{stack parameters}       &                              \\
dyncall/doc/manual/callconvs/callconv_mips64.tex:\hhline{~-~~}                                                                             
dyncall/doc/manual/callconvs/callconv_mips64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_mips64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_mips64.tex:Despite what one might think given the name, this is a MIPS 64-bit calling
dyncall/doc/manual/callconvs/callconv_mips64.tex:\item floating point registers \$f20-\$f23 are to be preserved
dyncall/doc/manual/callconvs/callconv_x64.tex:% Copyright (c) 2007-2019 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/callconvs/callconv_x64.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/callconvs/callconv_x64.tex:architecture, supporting it natively. It is sometimes referred to as x86-64,
dyncall/doc/manual/callconvs/callconv_x64.tex:registers r8-r15.\\
dyncall/doc/manual/callconvs/callconv_x64.tex:{\bf r8-r9}         & scratch, parameter 2 and 3 if integer or pointer\\
dyncall/doc/manual/callconvs/callconv_x64.tex:{\bf r10-r11}       & scratch, permanent if required by caller (used for syscall/sysret)\\
dyncall/doc/manual/callconvs/callconv_x64.tex:{\bf r12-r15}       & permanent\\
dyncall/doc/manual/callconvs/callconv_x64.tex:{\bf xmm1-xmm3}     & scratch, floating point parameters 1-3\\
dyncall/doc/manual/callconvs/callconv_x64.tex:{\bf xmm4-xmm5}     & scratch, permanent if required by caller\\
dyncall/doc/manual/callconvs/callconv_x64.tex:{\bf xmm6-xmm15}    & permanent\\
dyncall/doc/manual/callconvs/callconv_x64.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_x64.tex:\item float and double parameters are passed via xmm0l-xmm3l
dyncall/doc/manual/callconvs/callconv_x64.tex:\item first 4 parameters are passed via the correct register depending on the parameter type - with mixed float and int parameters,
dyncall/doc/manual/callconvs/callconv_x64.tex:\item parameters \textless\ 64bits are not zero extended - zero the upper bits contiaining garbage if needed (but they are always
dyncall/doc/manual/callconvs/callconv_x64.tex:\item if callee takes address of a parameter, first 4 parameters must be dumped (to the reserved space on the stack) - for
dyncall/doc/manual/callconvs/callconv_x64.tex:\item stack is always 16byte aligned - since return address is 64 bits in size, stacks with an odd number of parameters are
dyncall/doc/manual/callconvs/callconv_x64.tex:Stack frame is always 16-byte aligned.
dyncall/doc/manual/callconvs/callconv_x64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x64.tex:\hhline{~-~~}                            
dyncall/doc/manual/callconvs/callconv_x64.tex:\mrlbrace{7}{parameter area}      & arg n-1        & \mrrbrace{3}{stack parameters} &                               \\
dyncall/doc/manual/callconvs/callconv_x64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x64.tex:{\bf r8-r9}         & scratch, parameter 4 and 5 if integer or pointer\\
dyncall/doc/manual/callconvs/callconv_x64.tex:{\bf r10-r11}       & scratch\\
dyncall/doc/manual/callconvs/callconv_x64.tex:{\bf r12-r15}       & permanent\\
dyncall/doc/manual/callconvs/callconv_x64.tex:{\bf xmm1-xmm7}     & scratch, floating point parameters 1-7\\
dyncall/doc/manual/callconvs/callconv_x64.tex:{\bf xmm8-xmm15}    & scratch\\
dyncall/doc/manual/callconvs/callconv_x64.tex:{\bf st0-st1}       & scratch, 16 byte floating point return value\\
dyncall/doc/manual/callconvs/callconv_x64.tex:{\bf st2-st7}       & scratch\\
dyncall/doc/manual/callconvs/callconv_x64.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_x64.tex:\item first 8 floating point parameters \textless=\ 64 bits are passed via xmm0l-xmm7l
dyncall/doc/manual/callconvs/callconv_x64.tex:\item parameters \textless\ 64bits are not zero extended - zero the upper bits contiaining garbage if needed (but they are always
dyncall/doc/manual/callconvs/callconv_x64.tex:\item stack is always 16byte aligned - since return address is 64 bits in size, stacks with an odd number of parameters are
dyncall/doc/manual/callconvs/callconv_x64.tex:\item for types \textgreater\ 64 bits, a secret first parameter with an address to the return value is passed - the passed in address
dyncall/doc/manual/callconvs/callconv_x64.tex:Stack frame is always 16-byte aligned.
dyncall/doc/manual/callconvs/callconv_x64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x64.tex:\mrlbrace{3}{parameter area} & arg n-1        & \mrrbrace{3}{stack parameters} &                              \\
dyncall/doc/manual/callconvs/callconv_x64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x64.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x64.tex:\item register rax holds the return value (values in between -4095 and -1 indicate errors)
dyncall/doc/manual/callconvs/callconv_mips32.tex:% Copyright (c) 2007-2019 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/callconvs/callconv_mips32.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/callconvs/callconv_mips32.tex:Nowadays, MIPS32 and MIPS64 are the main ones used for 32-bit and 64-bit instruction sets, respectively.\\
dyncall/doc/manual/callconvs/callconv_mips32.tex:Given MIPS processors are often used for embedded devices, several add-on extensions exist for the MIPS family, for example: 
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item [MIPS-3D] simple floating-point SIMD instructions dedicated to common 3D tasks.
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item [MDMX] (MaDMaX) more extensive integer SIMD instruction set using 64 bit floating-point registers.
dyncall/doc/manual/callconvs/callconv_mips32.tex:Currently, dyncall supports for MIPS 32-bit architectures the widely-used O32 calling convention (for all four combinations of big/little-endian, and soft/hard-float targets),
dyncall/doc/manual/callconvs/callconv_mips32.tex:as well as EABI (little-endian/hard-float, which is used on the Homebrew SDK for the Playstation Portable). \product{dyncall} currently does not support MIPS16e
dyncall/doc/manual/callconvs/callconv_mips32.tex:(contrary to the like-minded ARM-THUMB, which is supported). Both, calls and callbacks are supported.
dyncall/doc/manual/callconvs/callconv_mips32.tex:\subsubsection{MIPS EABI 32-bit Calling Convention}
dyncall/doc/manual/callconvs/callconv_mips32.tex:{\bf \$2-\$3}                          & {\bf \$v0-\$v1}      & integer results, scratch \\
dyncall/doc/manual/callconvs/callconv_mips32.tex:{\bf \$4-\$11}                         & {\bf \$a0-\$a7}      & integer arguments, or double precision float arguments, scratch \\
dyncall/doc/manual/callconvs/callconv_mips32.tex:{\bf \$12-\$15,\$24}                   & {\bf \$t4-\$t7,\$t8} & integer temporaries, scratch \\
dyncall/doc/manual/callconvs/callconv_mips32.tex:{\bf \$16-\$23}                        & {\bf \$s0-\$s7}      & preserve \\
dyncall/doc/manual/callconvs/callconv_mips32.tex:{\bf \$f1,\$f3,\$f4-\$f11,\$f20-\$f23} &                      & float temporaries, scratch \\
dyncall/doc/manual/callconvs/callconv_mips32.tex:{\bf \$f12-\$f19}                      &                      & single precision float arguments, scratch \\
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item Stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item first 8 integers (\textless=\ 32bit) are passed in registers \$a0-\$a7
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item first 8 single precision floating point arguments are passed in registers \$f12-\$f19
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item 64-bit stack arguments are always aligned to 8 bytes
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item 64-bit integers or double precision floats are passed in two general purpose registers starting at an even register number, skipping one odd register
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item if the callee takes the address of one of the parameters and uses it to address other unnamed parameters (e.g. varargs) it has to copy - in its prolog - the the argument registers to a reserved stack area adjacent to the other parameters on the stack (only the unnamed integer parameters require saving, though) % @@@ seems to *ONLY* spill with varargs, never for any other reason
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item float registers don't seem to ever need to be saved that way, because floats passed to an ellipsis function are promoted to doubles, which in turn are passed in a? register pairs, so only \$a0-\$a7 are need to be spilled
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item results are returned in \$v0 (32-bit), \$v0 and \$v1 (64-bit), \$f0 or \$f0 and \$f2 (2 $\times$ 32 bit float e.g. complex)
dyncall/doc/manual/callconvs/callconv_mips32.tex:\hhline{~-~~}                                                         
dyncall/doc/manual/callconvs/callconv_mips32.tex:\hhline{~-~~}                                                         
dyncall/doc/manual/callconvs/callconv_mips32.tex:\hhline{~-~~}                                                                               
dyncall/doc/manual/callconvs/callconv_mips32.tex:\hhline{~-~~}                                                         
dyncall/doc/manual/callconvs/callconv_mips32.tex:\hhline{~-~~}                                                         
dyncall/doc/manual/callconvs/callconv_mips32.tex:\caption{Stack layout on MIPS EABI 32-bit calling convention}
dyncall/doc/manual/callconvs/callconv_mips32.tex:\subsubsection{MIPS O32 32-bit Calling Convention}
dyncall/doc/manual/callconvs/callconv_mips32.tex:{\bf \$2-\$3}                & {\bf \$v0-\$v1}      & return value (only integer on hard-float targets), scratch \\
dyncall/doc/manual/callconvs/callconv_mips32.tex:{\bf \$4-\$7}                & {\bf \$a0-\$a3}      & first arguments (only integer on hard-float targets), scratch\\
dyncall/doc/manual/callconvs/callconv_mips32.tex:{\bf \$8-\$15,\$24}          & {\bf \$t0-\$t7,\$t8} & temporaries, scratch \\
dyncall/doc/manual/callconvs/callconv_mips32.tex:{\bf \$16-\$23}              & {\bf \$s0-\$s7}      & preserved \\
dyncall/doc/manual/callconvs/callconv_mips32.tex:{\bf \$f0-\$f3}              &                      & only on hard-float targets: float return value, scratch \\
dyncall/doc/manual/callconvs/callconv_mips32.tex:{\bf \$f4-\$f11,\$f16-\$f19} &                      & only on hard-float targets: float temporaries, scratch \\
dyncall/doc/manual/callconvs/callconv_mips32.tex:{\bf \$f12-\$f15}            &                      & only on hard-float targets: first floating point arguments, scratch \\
dyncall/doc/manual/callconvs/callconv_mips32.tex:{\bf \$f20-\$f31}            &                      & only on hard-float targets: preserved \\
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item Stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item Caller is required to always leave a 16-byte spill area for \$a0-\$a3 at the end of {\bf its} frame, to be used and spilled to by the callee, if needed
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item generally, first four 32bit arguments are passed in registers \$a0-\$a3, respectively (only on hard-float targets: see below for exceptions if first arg is a float)
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item 64-bit params passed via registers are passed using either two registers (starting at an even register number, skipping an odd one if necessary), or via the stack using an 8-byte alignment
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item only on hard-float targets: if the very first call argument is a float, up to 2 floats or doubles can be passed via \$f12 and \$f14, respectively, for first and second argument
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item only on hard-float targets: if any arguments are passed via float registers, skip \$a0-\$a3 for subsequent arguments as if the values were passed via them
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item only on hard-float targets: note that if the first argument is not a float, but the second, it'll get passed via the \$a? registers
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item results are returned in \$v0 and \$v1, with \$v0 for all values \textless\ 64bit (only integer on hard-float targets)
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item only on hard-float targets: floating point results are returned in \$f0 (32-bit float), or \$f0 and \$f3 (64bit float)
dyncall/doc/manual/callconvs/callconv_mips32.tex:\item single precision float parameters (32 bit) are right-justified in their 8-byte slot on the stack on big endian targets, as they aren't promoted @@@
dyncall/doc/manual/callconvs/callconv_mips32.tex:\hhline{~-~~}                                                         
dyncall/doc/manual/callconvs/callconv_mips32.tex:\hhline{~-~~}                                                         
dyncall/doc/manual/callconvs/callconv_mips32.tex:\hhline{~-~~}                                                         
dyncall/doc/manual/callconvs/callconv_mips32.tex:\hhline{~-~~}                                                         
dyncall/doc/manual/callconvs/callconv_arm32.tex:% Copyright (c) 2007-2019 Daniel Adler <dadler@uni-goettingen.de>,
dyncall/doc/manual/callconvs/callconv_arm32.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/callconvs/callconv_arm32.tex:For more details, take a look at the ARM-THUMB Procedure Call Standard (ATPCS)
dyncall/doc/manual/callconvs/callconv_arm32.tex:\cite{AAPCS}, as well as Debian's ARM EABI port \cite{armeabi} and hard-float
dyncall/doc/manual/callconvs/callconv_arm32.tex:ARM32 family (ATPCS \cite{ATPCS}, EABI \cite{armeabi}, the ARM hard-float
dyncall/doc/manual/callconvs/callconv_arm32.tex:the ATPCS), excluding manually triggered ARM-THUMB interworking calls.\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:In ARM mode, the ARM32 processor has sixteen 32 bit general purpose registers, namely r0-r15:\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:{\bf r4-r9} & {\bf v1-v6} & permanent\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item first four words are passed using r0-r3
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item if the callee takes the address of one of the parameters and uses it to address other parameters (e.g. varargs) it has to copy - in its prolog - the first four words to a reserved stack area adjacent to the other parameters on the stack
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item structures and unions are passed by value, with the first four words of the parameters in r0-r3
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item keeping the stack eight-byte aligned can improve memory access performance and is required by LDRD and STRD on ARMv5TE processors which are part of the ARM32 family, so, in order to avoid problems one should always align the stack (tests have shown, that GCC does care about the alignment when using the ellipsis)
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_arm32.tex:In THUMB mode, the ARM32 processor family supports eight 32 bit general purpose registers r0-r7 and access to high order registers r8-r15:\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:{\bf r4-r6}  & {\bf v1-v3} & permanent\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:{\bf r8-r11} & {\bf v5-v8} & permanent\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item first four words are passed using r0-r3
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item if the callee takes the address of one of the parameters and uses it to address other parameters (e.g. varargs) it has to copy - in its prolog - the first four words to a reserved stack area adjacent to the other parameters on the stack
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item structures and unions are passed by value, with the first four words of the parameters in r0-r3
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item keeping the stack eight-byte aligned can improve memory access performance and is required by LDRD and STRD on ARMv5TE processors which are part of the ARM32 family, so, in order to avoid problems one should always align the stack (tests have shown, that GCC does care about the alignment when using the ellipsis)
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_arm32.tex:The ARM EABI is very similar to the ABI outlined in ARM-THUMB procedure call
dyncall/doc/manual/callconvs/callconv_arm32.tex:standard (ATPCS) \cite{ATPCS} - however, the EABI requires the stack to be
dyncall/doc/manual/callconvs/callconv_arm32.tex:8-byte aligned at function entries, as well as for 64 bit parameters. The latter
dyncall/doc/manual/callconvs/callconv_arm32.tex:are aligned on 8-byte boundaries on the stack and 2-registers for a parameter
dyncall/doc/manual/callconvs/callconv_arm32.tex:have to be skipped for parameters passed via registers, or 4-bytes on the stack
dyncall/doc/manual/callconvs/callconv_arm32.tex:{\bf r4-r6}  &          & permanent\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:{\bf r10-r11}&          & permanent\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:{\bf r12}    &          & scratch, intra-procedure scratch register (IP) used by dynamic linker\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:{\bf d0-d7}  &          & scratch, aliases s0-s15, on ARMv7 also as q0-q3; not accessible from Thumb mode on ARMv6\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:{\bf d8-d15} &          & permanent, aliases s16-s31, on ARMv7 also as q4-q7; not accesible from Thumb mode on ARMv6\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:{\bf d16-d31}&          & only available in ARMv7, aliases q8-q15\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_arm32.tex:Most debian-based Linux systems on ARMv7 (or ARMv6 with FPU) platforms use a calling convention referred to
dyncall/doc/manual/callconvs/callconv_arm32.tex:as armhf, using 16 32-bit floating point registers of the FPU of the VFPv3-D16 extension to the ARM architecture.
dyncall/doc/manual/callconvs/callconv_arm32.tex:Refer to the debian wiki for more information \cite{armhf}. % The following is for ARM mode, find platform that uses thumb+hard-float @@@
dyncall/doc/manual/callconvs/callconv_arm32.tex:Code is little-endian, rest is similar to EABI with an 8-byte aligned stack, etc..\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:{\bf r4-r9}  & {\bf v1-v6} &  permanent\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:{\bf r12}    & {\bf ip}    &  scratch, intra-procedure scratch register (IP) used by dynamic linker\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:{\bf d0}     &             &  floating point argument, floating point return value, double precision, aliases s0-s1\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:{\bf s1-s15} &             &  floating point arguments, single precision\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:{\bf d1-d7}  &             &  aliases s2-s15, floating point arguments, double precision\\
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item first four non-floating-point words are passed using r0-r3
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item first 16 single-precision, or 8 double-precision arguments are passed via s0-s15 or d0-d7, respectively (note that since s and d registers are aliased, already used ones are skipped)
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item if the callee takes the address of one of the parameters and uses it to address other parameters (e.g. varargs) it has to copy - in its prolog - the first four words (for first 4 integer arguments) to a reserved stack area adjacent to the other parameters on the stack
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item structures and unions are passed by value, with the first four words of the parameters in r0-r3
dyncall/doc/manual/callconvs/callconv_arm32.tex:\item non floating point 64-bit return values use r0 and r1
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_arm32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_arm32.tex:extensions (such as thumb-interworking, more vector registers, ...)
dyncall/doc/manual/callconvs/callconv_arm32.tex:% iPhone 3GS : ARM Cortex-A8
dyncall/doc/manual/callconvs/callconv_arm32.tex:% Cortex-*: ARMv7, Raspberry Pi 2, ...
dyncall/doc/manual/callconvs/callconv_arm64.tex:% Copyright (c) 2014-2020 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/callconvs/callconv_arm64.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/callconvs/callconv_arm64.tex:ARMv8 introduced the AArch64 calling convention. ARM64 chips can be run in 64 or 32bit mode, but not by the same process. Interworking is only intra-process.\\
dyncall/doc/manual/callconvs/callconv_arm64.tex:For more details, take a look at the Procedure Call Standard for the ARM 64-bit Architecture \cite{AAPCS64}.\\
dyncall/doc/manual/callconvs/callconv_arm64.tex:The \product{dyncall} library supports the ARM 64-bit AArch64 PCS ABI, as well as Apple's and Microsoft's conventions which are derived from it, for both, calls and callbacks.
dyncall/doc/manual/callconvs/callconv_arm64.tex:ARM64 features thirty-one 64 bit general purpose registers, namely {\bf r0-r30},
dyncall/doc/manual/callconvs/callconv_arm64.tex:which are referred to as either {\bf x0-x30} for 64bit access, or {\bf w0-w30}
dyncall/doc/manual/callconvs/callconv_arm64.tex:program counter. Additionally, there are thirty-two 128 bit registers {\bf v0-v31},
dyncall/doc/manual/callconvs/callconv_arm64.tex:to be used as SIMD and floating point registers, referred to as {\bf q0-q31}, {\bf d0-d31}
dyncall/doc/manual/callconvs/callconv_arm64.tex:and {\bf s0-s31}, respectively, depending on their use:\\
dyncall/doc/manual/callconvs/callconv_arm64.tex:{\bf x0-x7}   & parameters, scratch, return value\\
dyncall/doc/manual/callconvs/callconv_arm64.tex:{\bf x9-x15}  & scratch\\
dyncall/doc/manual/callconvs/callconv_arm64.tex:{\bf x19-x28} & permanent\\
dyncall/doc/manual/callconvs/callconv_arm64.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_arm64.tex:\item first 8 integer arguments are passed using x0-x7
dyncall/doc/manual/callconvs/callconv_arm64.tex:\item first 8 floating point arguments are passed using d0-d7
dyncall/doc/manual/callconvs/callconv_arm64.tex:\item if the callee takes the address of one of the parameters and uses it to address other parameters (e.g. varargs) it has to copy - in its prolog - the first 8 integer and 8 floating-point registers to a reserved stack area adjacent to the other parameters on the stack (only the unnamed integer parameters require saving, though)
dyncall/doc/manual/callconvs/callconv_arm64.tex:\item structures and unions are passed by value, with the first four words of the parameters in r0-r3
dyncall/doc/manual/callconvs/callconv_arm64.tex:\item stack is required to be throughout eight-byte aligned
dyncall/doc/manual/callconvs/callconv_arm64.tex:\item floating-point return values use d0
dyncall/doc/manual/callconvs/callconv_arm64.tex:\hhline{~-~~}                                                                            
dyncall/doc/manual/callconvs/callconv_arm64.tex:\hhline{~-~~}                                                                             
dyncall/doc/manual/callconvs/callconv_arm64.tex:\mrlbrace{9}{parameter area}             & arg n-1                & \mrrbrace{3}{stack parameters}       &                              \\
dyncall/doc/manual/callconvs/callconv_arm64.tex:\hhline{~-~~}                                                                             
dyncall/doc/manual/callconvs/callconv_arm64.tex:\hhline{~-~~}                                                                             
dyncall/doc/manual/callconvs/callconv_arm64.tex:\hhline{~-~~}                                                                             
dyncall/doc/manual/callconvs/callconv_arm64.tex:\item caller is required to sign and zero-extend arguments smaller than 32bits
dyncall/doc/manual/callconvs/callconv_arm64.tex:\item variadic function calls do not use any SIMD or floating point registers (for fixed and variable args), meaning first 8 params are passed via x0-x7, the rest via the stack
dyncall/doc/manual/callconvs/callconv_x86.tex:% Copyright (c) 2007-2019 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/callconvs/callconv_x86.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/callconvs/callconv_x86.tex:convention \cite{x86Pascal} and a cdecl-like version for Plan9 \cite{x86Plan9}
dyncall/doc/manual/callconvs/callconv_x86.tex:cdecl            & 0          & 4           & $\leftarrow$  & caller  & -          \\
dyncall/doc/manual/callconvs/callconv_x86.tex:Watcom fastcall  & 4          & 2-6         & $\leftarrow$  & callee  & N          \\
dyncall/doc/manual/callconvs/callconv_x86.tex:win32 stdcall    & 0          & 4           & $\leftarrow$  & callee  & -          \\
dyncall/doc/manual/callconvs/callconv_x86.tex:GNU thiscall     & 0          & 4           & $\leftarrow$  & caller  & -          \\
dyncall/doc/manual/callconvs/callconv_x86.tex:pascal           & 0          & 4           & $\rightarrow$ & callee  & -          \\
dyncall/doc/manual/callconvs/callconv_x86.tex:plan9call        & 0          & 0           & $\leftarrow$  & caller  & -          \\
dyncall/doc/manual/callconvs/callconv_x86.tex:{\bf st1-st7} & scratch\\
dyncall/doc/manual/callconvs/callconv_x86.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\mrlbrace{3}{parameter area}      & arg n-1        & \mrrbrace{3}{stack parameters} &                              \\
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:{\bf st1-st7} & scratch\\
dyncall/doc/manual/callconvs/callconv_x86.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:{\bf st1-st7} & scratch\\
dyncall/doc/manual/callconvs/callconv_x86.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}                                                 
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}                                                 
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_x86.tex:{\bf st1-st7} & scratch\\
dyncall/doc/manual/callconvs/callconv_x86.tex:\item stack parameter order: left-to-right
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_x86.tex:{\bf st1-st7} & scratch\\
dyncall/doc/manual/callconvs/callconv_x86.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}                                                  
dyncall/doc/manual/callconvs/callconv_x86.tex:{\bf st1-st7} & scratch\\
dyncall/doc/manual/callconvs/callconv_x86.tex:\item Stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\mrlbrace{3}{parameter area}      & arg n-1        & \mrrbrace{3}{stack parameters} &                              \\
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:{\bf st1-st7} & scratch\\
dyncall/doc/manual/callconvs/callconv_x86.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\mrlbrace{3}{parameter area}      & arg n-1        & \mrrbrace{3}{stack parameters} &                              \\
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:% {\bf st1-st7} & scratch\\
dyncall/doc/manual/callconvs/callconv_x86.tex:% \item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_x86.tex:% \hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:% \hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:% \mrlbrace{3}{parameter area}      & arg n-1        & \mrrbrace{3}{stack parameters} &                              \\
dyncall/doc/manual/callconvs/callconv_x86.tex:% \hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:% \hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:% \hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:% \hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:{\bf st1-st7} & scratch\\
dyncall/doc/manual/callconvs/callconv_x86.tex:\item stack parameter order: left-to-right
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:                                  & arg n-1        &                                &                              \\
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:{\bf st1-st7} & scratch\\
dyncall/doc/manual/callconvs/callconv_x86.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\mrlbrace{3}{parameter area}      & arg n-1        & \mrrbrace{3}{stack parameters} &                              \\
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_x86.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:% Copyright (c) 2007-2019 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/callconvs/callconv_ppc32.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item Processor operates on floats in double precision floating point arithmetc (IEEE-754) values directly (single precision is converted on the fly)
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item Linux PPC 32-bit ABI is specified in "LSB for PPC"\cite{ppc32LSB} which is based on "System V ABI". It uses Big Endian (MSB)
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item PowerPC EABI is defined in the "PowerPC Embedded Application Binary Interface 32-Bit Implementation"\cite{ppceabi}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf gpr5-gpr10}    & parameter 2-7 for integer or pointer parameters, scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf gpr13-31}      & preserve\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf fpr2-fpr13}    & floating point parameters 1-12 (always double precision)\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf fpr14-fpr31}   & preserve\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf v0-v1}         & scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf v2-v13}        & vector parameters\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf v14-v19}       & scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf v20-v31}       & preserve\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf lr}            & link-register, scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf ctr}           & count-register, scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf cr0-cr7}       & conditional register fields, each 4-bit wide (cr0-cr1 and cr5-cr7 are scratch)\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\caption{Register usage on Darwin PowerPC 32-Bit}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item stack parameter order: right-to-left
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item the first 8 integer parameters are passed in registers gpr3-gpr10
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item the first 13 floating point parameters are passed in registers fpr1-fpr13
dyncall/doc/manual/callconvs/callconv_ppc32.tex:the float - 1 register for single precision and 2 for double precision floating point values)
dyncall/doc/manual/callconvs/callconv_ppc32.tex:needed - e.g. varargs)
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item all nonvector parameters are aligned on 4-byte boundaries
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item vector parameters are aligned on 16-byte boundaries
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item composite parameters with size of 1 or 2 bytes occupy low-order bytes of their 4-byte area. INCONSISTENT with other 32-bit PPC
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item composite parameters 3 bytes or larger in size occupy high-order bytes
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item integer parameters \textless\ 32 bit are right-justified (meaning occupy higher-address bytes) in their 4-byte slot on the stack, requiring extra-care for big-endian targets
dyncall/doc/manual/callconvs/callconv_ppc32.tex:Stack frame is always 16-byte aligned. Prolog opens frame with additional, fixed space for a linkage area, to hold a number of values (not all of them are required to be saved, though). Stack directly after function prolog:\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\subsubsection{System V PPC 32-bit}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf r2}          & system-reserved\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf r3-r4}       & parameter passing and return value, scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf r5-r10}      & parameter passing, scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf r11-r12}     & scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf r14-r30}     & local variables, preserve\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf f2-f8}       & parameter passing, scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf f9-13}       & scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf f14-f31}     & local variables, preserve\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf cr0-cr7}     & conditional register fields, each 4-bit wide (cr0-cr1 and cr5-cr7 are scratch)\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf xer}         & fixed-point exception register, scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:{\bf fpscr}       & floating-point Status and Control Register\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:% {\bf v0-v1}         & scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:% {\bf v2-v13}        & vector parameters\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:% {\bf v14-v19}       & scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:% {\bf v20-v31}       & permanent\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:% {\bf lr}            & scratch, link-register\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:% {\bf ctr}           & scratch, count-register\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:% {\bf cr0-cr1}       & scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:% {\bf cr2-cr4}       & permanent\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:% {\bf cr5-cr7}       & scratch\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item Stack pointer (r1) is always 16-byte aligned. The EABI differs here - it is 8-byte alignment.
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item 8 general-purpose registers (r3-r10) for integer and pointer types.
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item 8 floating-pointer registers (f1-f8) for float (promoted to double) and double types.
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item Additional arguments are passed on the stack directly after the back-chain and saved return address (8 bytes structure) on the callers stack frame.
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item 64-bit integer data types are passed in general-purpose registers as a whole in two
dyncall/doc/manual/callconvs/callconv_ppc32.tex: 32-bit general purpose registers (an odd and an even e.g. r3 and r4), skipping an even integer register
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item integer parameters \textless\ 32 bit are right-justified (meaning occupy high-order bytes) in their 4-byte area, requiring extra-care for big-endian targets
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item 32-bit integers use register r3, 64-bit use registers r3 and r4 (hiword in r3, loword in r4).
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\item floating-point values are returned using register f1.
dyncall/doc/manual/callconvs/callconv_ppc32.tex:Stack frame is always 16-byte aligned. Stack directly after function prolog:\\
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\hhline{~-~~}
dyncall/doc/manual/callconvs/callconv_ppc32.tex:\caption{Stack layout on System V ABI for PowerPC 32-bit calling convention}
dyncall/doc/manual/manual_motivation.tex:% Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/manual_motivation.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/manual_motivation.tex:languages such as C, C++ and Objective-C lack this ability.\\
dyncall/doc/manual/manual_motivation.tex:The majority of systems use C function interfaces as their system-level 
dyncall/doc/manual/manual_motivation.tex:\subsection{Anatomy of machine-level calls}
dyncall/doc/manual/manual_motivation.tex:The following example depicts a C source and the corresponding assembly for the X86 32-bit processor architecture.
dyncall/doc/manual/manual_motivation.tex:\begin{lstlisting}[label=x86asm,caption=Assembly X86 32-bit function call,language={[x86masm]Assembler}]
dyncall/doc/manual/manual_motivation.tex:compilers, operating-systems and processor architectures.
dyncall/doc/manual/manual_motivation.tex:does not require just-in-time code generation.
dyncall/doc/manual/manual_motivation.tex:General-purpose programming languages such as C\footnote{and derived programming
dyncall/doc/manual/manual_motivation.tex:languages such as C++ and Objective-C} are powerful statically compiled 
dyncall/doc/manual/manual_motivation.tex:programming languages that allow to implement low-level tasks. They abstract
dyncall/doc/manual/manual_motivation.tex:Although C is very powerful and a portable language to implement time-critical
dyncall/doc/manual/manual_motivation.tex:and performance greedy application - it is limited in the way it handles calls
dyncall/doc/manual/manual_motivation.tex:General-purpose programming languages such as C and C++ are limited in the way 
dyncall/doc/manual/manual_motivation.tex:that is black-box to the language. 
dyncall/doc/manual/manual_motivation.tex: construct a half-baked function-call without providing C code that performs a particular desired function call
dyncall/doc/manual/manual_motivation.tex:arity, argument- and return types.
dyncall/doc/manual/Makefile.generic:#html-single: html/manual.html
dyncall/doc/manual/Makefile.generic:#html-split: html/manual.html
dyncall/doc/manual/Makefile.generic:	cd "${VPATH}" && for i in pdf aux lof log lol lot out toc; do rm -f manual.$$i || true; done
dyncall/doc/manual/Makefile.generic:		for i in 4ct 4tc css dvi html idv lg tmp xref; do rm -f manual.$$i || true; done; \
dyncall/doc/manual/Makefile.generic:		for i in manual*x.png manual*.html texput.log manual_*.log zzmanual.eps zzmanual.ps custom_tex4ht.env multirow.4ht; do rm -f $$i || true; done; \
dyncall/doc/manual/Makefile.generic:		rm -r html || true; \
dyncall/doc/manual/Makefile.generic:# Main target dependencies --->
dyncall/doc/manual/Makefile.generic:	# - create custom, local version of tex4ht.env based on default one, but with
dyncall/doc/manual/Makefile.generic:	# - create empty multirow.4ht file, to simply override tex4ht's default one,
dyncall/doc/manual/Makefile.generic:	#   which produces wrong output in our case - since all the tables where we
dyncall/doc/manual/Makefile.generic:		cp $$(dirname $$(which tex4ht))/../share/texmf-dist/tex4ht/base/unix/tex4ht.env ./custom_tex4ht.env; \
dyncall/doc/manual/Makefile.generic:		sed -E -i '' 's/(Text|Graphics)(AlphaBits)=[1,2,3]([^0-9])/\1\2=4\3/g' custom_tex4ht.env; \
dyncall/doc/manual/Makefile.generic:		mkdir -p ./html/; \
dyncall/doc/manual/Makefile.generic:		htlatex manual.tex manual_tex4ht " -cunihtf -e./custom_tex4ht.env -utf8" "-e./custom_tex4ht.env -d./html/"; \
dyncall/doc/manual/Makefile.generic:		sed -E -i '' $$'s/([[:space:]]class=["\'])lstlisting(["\'])/\\1ttDiv\\2/' "$$f"; \
dyncall/doc/manual/Makefile.generic:	cd "${VPATH}" && for i in 1 2; do pdflatex -output-directory="${PWD}" manual.tex; done
dyncall/doc/manual/manual_dyncallback_api.tex:% Copyright (c) 2007,2013 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/manual_dyncallback_api.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/manual_dyncallback_api.tex:or passed to functions expecting a function-pointer as argument.\\
dyncall/doc/manual/manual_dyncallback_api.tex:Invoking a \product{dyncallback} calls into a user-defined unified handler that 
dyncall/doc/manual/manual_dyncallback_api.tex:permits iteration and thus dynamic handling over the called-back-function's
dyncall/doc/manual/manual_dyncallback_api.tex:one outlined in the language bindings-section of this manual, see Table \ref{sigchar})
dyncall/doc/manual/manual_dyncallback_api.tex:for dynamic iteration over the called-back-function's arguments (input) and
dyncall/doc/manual/manual_dynload_api.tex:% Copyright (c) 2007-2017 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/manual_dynload_api.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/manual_dynload_api.tex:\begin{lstlisting}[language=c,label=dl-load]
dyncall/doc/manual/manual_dynload_api.tex:of the buffer (in bytes) needed to hold the null-terminated string, or 0 if it can't be
dyncall/doc/manual/manual_dynload_api.tex:looked up. If \lstinline{bufSize} \textgreater= return value \textgreater 1, a null-terminted string with the
dyncall/doc/manual/manual_dynload_api.tex:to loading and linking libraries, no (OS-specific) rules for searching libraries in library paths, etc. apply. The handle must be freed with
dyncall/doc/manual/dyncall_watermark.svg:<?xml version="1.0" encoding="UTF-8" standalone="no"?>
dyncall/doc/manual/dyncall_watermark.svg:<!-- Created with Inkscape (http://www.inkscape.org/) -->
dyncall/doc/manual/dyncall_watermark.svg:     transform="matrix(2.2965446,0,0,2.2965446,-189.23706,135.3048)"
dyncall/doc/manual/dyncall_watermark.svg:   transform="matrix(0.7802343,0,0,0.7802343,-63.142369,43.042016)"
dyncall/doc/manual/dyncall_watermark.svg:   style="fill:#e6e6e6;stroke:#e6e6e6;stroke-width:0.80000001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_watermark.svg:   transform="matrix(0.7802343,0,0,0.7802343,-63.142369,43.042016)"
dyncall/doc/manual/dyncall_watermark.svg:   style="fill:#000000;stroke:#e6e6e6;stroke-width:0.80376798;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_watermark.svg:   transform="matrix(0.7802343,0,0,0.7802343,-63.142369,43.042016)"
dyncall/doc/manual/dyncall_watermark.svg:   style="fill:#e6e6e6;stroke:#e6e6e6;stroke-width:0.80000001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10;stroke-opacity:1">
dyncall/doc/manual/dyncall_watermark.svg:   transform="matrix(0.4572086,0,0,0.4572086,176.55441,-80.651816)"
dyncall/doc/manual/dyncall_watermark.svg:   style="fill:#e6e6e6;stroke:#e6e6e6;stroke-width:1.74974835;stroke-opacity:1" />
dyncall/doc/manual/dyncall_watermark.svg:   transform="matrix(0.7802343,0,0,0.7802343,-63.142369,43.042016)"
dyncall/doc/manual/dyncall_watermark.svg:   style="fill:#000000;stroke:#ffffff;stroke-width:0.80376798;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_watermark.svg:   transform="matrix(0.4572086,0,0,0.4572086,176.55441,-80.651816)"
dyncall/doc/manual/dyncall_watermark.svg:   style="fill:#ffffff;stroke:#ffffff;stroke-width:1.75798965" />
dyncall/doc/manual/dyncall_watermark.svg:   transform="matrix(0.7802343,0,0,0.7802343,-63.142369,43.042016)"
dyncall/doc/manual/dyncall_watermark.svg:   style="fill:#e6e6e6;stroke:#e6e6e6;stroke-width:0.80376798;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_watermark.svg:   transform="matrix(0.7802343,0,0,0.7802343,-63.142369,43.042016)"
dyncall/doc/manual/dyncall_watermark.svg:   style="fill:#e6e6e6;fill-rule:nonzero;stroke:#e6e6e6;stroke-width:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_watermark.svg:   transform="matrix(0.4354368,0,0,0.4354368,82.400777,-58.916687)"
dyncall/doc/manual/dyncall_watermark.svg:   transform="matrix(0.7802343,0,0,0.7802343,-63.142369,43.042016)"
dyncall/doc/manual/dyncall_watermark.svg:   style="fill:#e6e6e6;fill-rule:nonzero;stroke:#e6e6e6;stroke-width:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_watermark.svg:   transform="matrix(0.4354368,0,0,0.4354368,82.400777,-58.916687)"
dyncall/doc/manual/dyncall_watermark.svg:   transform="matrix(0.7802343,0,0,0.7802343,-63.142369,43.042016)"
dyncall/doc/manual/dyncall_watermark.svg:   style="fill:#000000;fill-rule:nonzero;stroke-width:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10">
dyncall/doc/manual/dyncall_logo.pdf:%PDF-1.4
dyncall/doc/manual/dyncall_logo.pdf:0.8 0 0 -0.8 0 842 cm
dyncall/doc/manual/dyncall_logo.pdf:2.2965446 0 0 2.2965446 -189.23706 135.3048 cm
dyncall/doc/manual/dyncall_logo.pdf:0.4354368 0 0 0.4354368 82.400777 -58.916687 cm
dyncall/doc/manual/dyncall_logo.pdf:0.4354368 0 0 0.4354368 82.400777 -58.916687 cm
dyncall/doc/manual/dyncall_logo.eps:%!PS-Adobe-3.0 EPSF-3.0
dyncall/doc/manual/dyncall_logo.eps:0.8 -0.8 scale
dyncall/doc/manual/dyncall_logo.eps:gsave [2.2965446 0 0 2.2965446 -189.23706 135.3048] concat
dyncall/doc/manual/dyncall_logo.eps:gsave [0.4354368 0 0 0.4354368 82.400777 -58.916687] concat
dyncall/doc/manual/dyncall_logo.eps:gsave [0.4354368 0 0 0.4354368 82.400777 -58.916687] concat
dyncall/doc/manual/Nmakefile:# Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/Nmakefile:#                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/Nmakefile:# Pseudo-targets are always out of date...
dyncall/doc/manual/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/doc/manual/CMakeFiles/CMakeDirectoryInformation.cmake:set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/chenningcong/Desktop/dyncall-1.2")
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:# Disable VCS-based implicit rules.
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:# Disable VCS-based implicit rules.
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:# Disable VCS-based implicit rules.
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:# Disable VCS-based implicit rules.
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:# Disable VCS-based implicit rules.
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:# Command-line flag to silence nested $(MAKE).
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:$(VERBOSE)MAKESILENT = -s
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:RM = /usr/bin/cmake -E rm -f
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:# The top-level source directory on which CMake was run.
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:CMAKE_SOURCE_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:# The top-level build directory on which CMake was run.
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:CMAKE_BINARY_DIR = /home/chenningcong/Desktop/dyncall-1.2
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/doc/manual && echo
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --blue --bold --progress-dir=/home/chenningcong/Desktop/dyncall-1.2/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Generating manual.pdf"
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/doc/manual && /usr/bin/pdflatex manual.tex
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2/doc/manual && $(CMAKE_COMMAND) -P CMakeFiles/manual.dir/cmake_clean.cmake
dyncall/doc/manual/CMakeFiles/manual.dir/build.make:	cd /home/chenningcong/Desktop/dyncall-1.2 && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/doc/manual /home/chenningcong/Desktop/dyncall-1.2 /home/chenningcong/Desktop/dyncall-1.2/doc/manual /home/chenningcong/Desktop/dyncall-1.2/doc/manual/CMakeFiles/manual.dir/DependInfo.cmake --color=$(COLOR)
dyncall/doc/manual/CMakeFiles/manual.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
dyncall/doc/manual/manual_overview.tex:% Copyright (c) 2007-2019 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/manual_overview.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/manual_overview.tex:The \product{dyncall} library encapsulates architecture-, OS- and compiler-specific
dyncall/doc/manual/manual_overview.tex:change the calling convention used by the CallVM at run-time.
dyncall/doc/manual/manual_overview.tex:conventions, the \product{dyncall} library project intends to be a portable and open-source
dyncall/doc/manual/manual_overview.tex:approach to the variety of compiler-specific binary interfaces, platform specific
dyncall/doc/manual/manual_overview.tex:functions, the latter being pre-compiled for a
dyncall/doc/manual/manual_overview.tex:without writing glue code or prototypes or even knowing its C declaration - 
dyncall/doc/manual/manual_overview.tex:\item Add-on language bindings to Python, R, Ruby, Go, Erlang, Java, Lua, sh, ...
dyncall/doc/manual/manual_overview.tex:\item High-level state machine design using C to model calling convention
dyncall/doc/manual/manual_overview.tex:compared to function interface wrapper tools that generate per call glue-code less code is
dyncall/doc/manual/manual_overview.tex:call.as.sqrt TEX\textlessXET- function(funptr,x)
dyncall/doc/manual/manual_overview.tex:Please note that a green cell (even a light-green one) doesn't imply that all existing calling conventions/features/build tools are supported for that platform (but the most
dyncall/doc/manual/manual_overview.tex:\hhline{*{1}{|~}*{14}{|-}}%       ^- checked   ^- find@@@   ^- checked   ^- find@@@   ^- find@@@   ^- find@@@   ^- checked   ^- checked   ^- checked   ^- new@@@   ^- checked    ^- checked   ^- checked
dyncall/doc/manual/manual_overview.tex:\hline%                           ^- find@@@   ^- dynOS     ^- real      ^- dynOS     ^- dynOS     ^- real/bbb  ^- checked   ^- checked   ^- checked   ^- new@@@   ^- new@@@     ^- checked   ^- checked
dyncall/doc/manual/manual_overview.tex:\hhline{*{1}{|~}*{14}{|-}}%       ^- checked   ^- find@@@   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked
dyncall/doc/manual/manual_overview.tex:\hline%                           ^- checked   ^- find@@@   ^- checked   ^- checked   ^- find@@@   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked
dyncall/doc/manual/manual_overview.tex:\hhline{*{1}{|~}*{14}{|-}}%       ^- checked   ^- dynOS     ^- checked   ^- checked   ^- find@@@   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked
dyncall/doc/manual/manual_overview.tex:\hline%                           ^- checked   ^- find@@@   ^- checked   ^- checked   ^- dynOS     ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked
dyncall/doc/manual/manual_overview.tex:\hhline{*{1}{|~}*{14}{|-}}%       ^- checked   ^- find@@@   ^- checked   ^- checked   ^- find@@@   ^- real/ERlt ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked
dyncall/doc/manual/manual_overview.tex:\hline%                           ^- checked   ^- dynOS     ^- checked   ^- checked   ^- find@@@   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked
dyncall/doc/manual/manual_overview.tex:\hhline{*{1}{|~}*{14}{|-}}%       ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked
dyncall/doc/manual/manual_overview.tex:\hline%                           ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked
dyncall/doc/manual/manual_overview.tex:\hhline{*{1}{|~}*{14}{|-}}%       ^- checked   ^- dynOS     ^-dynOS      ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked
dyncall/doc/manual/manual_overview.tex:\hline%                           ^- checked   ^- find@@@   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked
dyncall/doc/manual/manual_overview.tex:\hhline{*{1}{|~}*{14}{|-}}%       ^- checked   ^- masanori@ ^- checked   ^- dynOS     ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked
dyncall/doc/manual/manual_overview.tex:\hline%                           ^- checked   ^- masanori@ ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked   ^- checked
dyncall/doc/manual/manual_overview.tex:RISC-V                     &    & \marknotx  & \marknimp  & \marknotx  & \marknimp  & \marknimp  & \marknotx  & \marknotx  & \marknotx  & \marknotx  & \marknotx  & \marknotx  & \marknotx  & \marknotx \\%& \\
dyncall/doc/manual/manual_overview.tex:%                              & \ninety{\bf Alpha} & \ninety{\bf ARM} & \ninety{\bf ARM64} & \multicolumn{2}{c!{\color{gray2}\vrule}}{\ninety{\bf MIPS}} & \multicolumn{2}{c!{\color{gray2}\vrule}}{\ninety{\bf MIPS64}} & \ninety{\bf SuperH} & \ninety{\bf PowerPC} & \ninety{\bf PowerPC64} & \ninety{\bf m68k} & \ninety{\bf m88k} & \ninety{\bf x86} & \ninety{\bf x64} & \ninety{\bf Itanium} & \ninety{\bf SPARC} & \ninety{\bf SPARC64} & \ninety{\bf RISC-V} \\
dyncall/doc/manual/manual_build.tex:% Copyright (c) 2007,2009 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/manual_build.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/manual_build.tex:\item Python (optional - for generation of some test cases)
dyncall/doc/manual/manual_build.tex:\item Lua (optional - for generation of some test cases)
dyncall/doc/manual/manual_build.tex:Building \product{dyncall} is a straightforward two-step process, first configure, then make. The
dyncall/doc/manual/manual_build.tex:\textbf{Unix-like}            & GNU/BSD/Sun make    & gcc, clang, sunc                           \\
dyncall/doc/manual/manual_build.tex:./configure [--option ...]
dyncall/doc/manual/manual_build.tex:{\tt --help}                     & display help                             \\
dyncall/doc/manual/manual_build.tex:{\tt --prefix=\textit{path}}     & specify installation prefix (Unix shell) \\
dyncall/doc/manual/manual_build.tex:{\tt --target=\textit{platform}} & MacOSX,iOS,iPhoneSimulator,PSP,...       \\
dyncall/doc/manual/manual_build.tex:{\tt --sdk=\textit{version}}     & SDK version                              \\
dyncall/doc/manual/manual_build.tex:\paragraph{Windows flavour, and cross-build from Windows (PSP, NDS, etc.)}
dyncall/doc/manual/manual_build.tex:{\tt /prefix-bd \textit{path}} & set build directory prefix (GNU make only)    \\
dyncall/doc/manual/manual_build.tex:{\tt /target-x86}              & build for x86 architecture (default)          \\
dyncall/doc/manual/manual_build.tex:{\tt /target-x64}              & build for x64 architecture                    \\
dyncall/doc/manual/manual_build.tex:{\tt /target-psp}              & build for PlayStation Portable (homebrew SDK) \\
dyncall/doc/manual/manual_build.tex:{\tt /target-nds-arm}          & build for Nintendo DS (devkitPro, ARM mode)   \\
dyncall/doc/manual/manual_build.tex:{\tt /target-nds-thumb}        & build for Nintendo DS (devkitPro, THUMB mode) \\
dyncall/doc/manual/manual_build.tex:{\tt /tool-msvc}               & use Microsoft Visual C++ compiler (default)   \\
dyncall/doc/manual/manual_build.tex:{\tt /tool-gcc}                & use GNU Compiler Collection                   \\
dyncall/doc/manual/manual_build.tex:{\tt /asm-ml}                  & use Microsoft Macro Assembler (default)       \\
dyncall/doc/manual/manual_build.tex:{\tt /asm-as}                  & use the GNU Assembler                         \\
dyncall/doc/manual/manual_build.tex:{\tt /asm-nasm}                & use NASM Assembler                            \\
dyncall/doc/manual/manual_build.tex:{\tt /config-release}          & build release version (default)               \\
dyncall/doc/manual/manual_build.tex:{\tt /config-debug}            & build debug version                           \\
dyncall/doc/manual/manual_build.tex:./configure.rc [--option ...]
dyncall/doc/manual/manual_build.tex:{\tt --help} & display help \\
dyncall/doc/manual/manual_build.tex:\subsection{Build-tool specific notes}
dyncall/doc/manual/manual_build.tex:cmake -DCMAKE_INSTALL_PREFIX=<location>
dyncall/doc/manual/cmake_install.cmake:# Install script for directory: /home/chenningcong/Desktop/dyncall-1.2/doc/manual
dyncall/doc/manual/cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
dyncall/doc/manual/manual_title.tex:% Copyright (c) 2007-2014 Daniel Adler <dadler@uni-goettingen.de>, 
dyncall/doc/manual/manual_title.tex:%                         Tassilo Philipp <tphilipp@potion-studios.com>
dyncall/doc/manual/manual_title.tex:\begin{picture}(0,0)(-38,110)%
dyncall/doc/manual/manual_title.tex:	Daniel {\sc Adler} \small{\tt{(dadler@uni-goettingen.de)}}\\%
dyncall/doc/manual/manual_title.tex:	Tassilo {\sc Philipp} \small{\tt{(tphilipp@potion-studios.com)}}%
dyncall/doc/Makefile:VPATH = /home/chenningcong/Desktop/dyncall-1.2/./doc
dyncall/doc/Makefile:include /home/chenningcong/Desktop/dyncall-1.2/Makefile.config
dyncall/doc/README.MacOSX:    --target=MacOSX (optional, auto-detect)
dyncall/doc/README.MacOSX:    --sdk=<version> (optional, auto-detect)
dyncall/doc/README.MacOSX:  configure --target=MacOSX --sdk=10.4u
dyncall/doc/README.iOS:Environment Setup for Cross-Compilation using iPhone SDK:
dyncall/doc/README.iOS:  $ source ./buildsys/scripts/setenv-sdk-ios.sh
dyncall/doc/README.iOS:  $ ./configure --target=iOS --sdk=<MAJOR>.<MINOR>
dyncall/doc/README.iOS:  --target=[iOS|iPhoneSimulator]
dyncall/doc/README.iOS:  --sdk=<version> (tested versions 2.0..4.0, 6.1, 8.3)
dyncall/doc/README.iOS:Supported Tool-chains
dyncall/doc/README.iOS:-------------------
dyncall/doc/README.iOS:  $ make -f Makefile.embedded ios61-os
dyncall/doc/README.iOS:  $ cd test && make -f Makefile.embedded ios61-os
dyncall/doc/README.iOS:  $ make -f Makefile.embedded ios61-os-nothumb
dyncall/doc/README.iOS:  $ cd test && make -f Makefile.embedded ios61-os-nothumb
dyncall/doc/README.iOS:  $ make -f Makefile.embedded ios61-sim
dyncall/doc/README.iOS:  $ cd test && make -f Makefile.embedded ios61-sim
dyncall/doc/README.iOS:  $ make -f Makefile.embedded ios83-os-universal
dyncall/doc/README.iOS:  $ cd test && make -f Makefile.embedded ios83-os-universal
dyncall/doc/README.iOS:  $ source buildsys/scripts/setenv-sdk-ios.sh
dyncall/doc/README.iOS:  $ source buildsys/scripts/setenv-cross-ios.sh
dyncall/doc/README.iOS:  make -f Makefile.generic ...
dyncall/doc/README.iOS:  uses armv6 and sdk 4.3 as default, can be changed in 'setenv-cross-ios.sh'.
dyncall/doc/README.embedded:Makefile.embedded - hybrid DynCall makefiles for GNU, BSD and SUN make
dyncall/doc/README.embedded:--------------
dyncall/doc/README.embedded:operating-systems such as 'bsd'.
dyncall/doc/README.embedded:---------------------
dyncall/doc/README.embedded:$ make -f Makefile.embedded <variant>
dyncall/doc/README.embedded:-------------------
dyncall/doc/README.embedded:$ cd test ; make -f Makefile.embedded <variant>
dyncall/doc/README.embedded:-------------
dyncall/doc/README.embedded:$ make -f Makefile.embedded PREFIX=/usr/local install
dyncall/doc/README.embedded:--------------------------------------
dyncall/doc/README.embedded:$ make -f Makefile.embedded DESTDIR=/tmp/staging PREFIX=/usr/local install
dyncall/doc/README.embedded:-------------------
dyncall/doc/README.embedded:osx-universal         Mac OS X universal binaries (i386,x86_64 and ppc)
dyncall/doc/README.embedded:sun-64bit             SunOS and Sun Pro compiler for sparc64(? amd64) 
dyncall/doc/README.embedded:sun-gcc               SunOS and GCC compiler
dyncall/doc/README.embedded:sun-gcc-64bit         SunOS and GCC compiler for sparc64 (? amd64)
dyncall/doc/README.embedded:ios61-nothumb         iOS SDK 6.1 armv7 -mno-thumb (untested!)
dyncall/doc/README.embedded:-------------------
dyncall/doc/README.embedded:$ VAR1=<VALUE1> VAR2=<VALUE2> .. make -f Makefile.embedded <variant>
dyncall/doc/README.embedded:-----------------
dyncall/doc/README.embedded:The top-level Makefile.embedded controls for building the libraries.
dyncall/doc/README.embedded:----------
dyncall/doc/README.embedded:-----------
dyncall/doc/README.embedded:'libtool -static -o libname.a obj1.o obj2.o ...' instead of 'ar cru libname.a obj1.o obj2.o'.
dyncall/doc/README.embedded:The variant osx-universal uses AR=libtool.
dyncall/doc/README.NDS:  configure.bat /tool-gcc /target-nds-arm
dyncall/doc/README.NDS:  configure.bat /tool-gcc /target-nds-thumb
dyncall/doc/README.NDS:Note that the /tool-gcc flag is needed, because we're
dyncall/doc/README.NDS:GCC toolchain. The /target-nds-* flags don't imply
dyncall/doc/README.Minix:-------
dyncall/doc/README.Minix:- Compiles under GNU tool-chain on Minix 3.1.8 using script for Makefile.generic
dyncall/doc/README.Minix:- dyncall: tests run ok.
dyncall/doc/README.Minix:- dyncallback: minor bugs on dyncallback (some cases fail)
dyncall/doc/README.Minix:- dynload: unsupported due to missing dynamic linker.
dyncall/doc/README.Minix:- Integration of ACK tool-chain is in progress but not functional at the moment...
dyncall/doc/README.Minix:---------
dyncall/doc/README.Minix:$ sh buildsys/scripts/batch-build-minix.sh
dyncall/doc/README.Minix:------------
dyncall/doc/README.Minix:- posix make
dyncall/doc/README.Minix:- ACK (Amsterdam Compiler Kit) compiler for C, Modula-2 and Pascal
dyncall/doc/README.Minix:- ACK Assembler:
dyncall/doc/README.Minix:   if very first character is '#' - C preprocessor is run..
dyncall/doc/README.Minix:- Minix 32-bit: 
dyncall/doc/README.Minix:- ACK 32-bit compiler: long long is not supported
dyncall/doc/README.Minix:- Minix 16-bit: not yet reviewed...
dyncall/doc/README.Windows:------------------------------------------------------
dyncall/doc/README.Windows:  32-bit:
dyncall/doc/README.Windows:    .\configure.bat /target-x86
dyncall/doc/README.Windows:  64-bit:
dyncall/doc/README.Windows:    .\configure.bat /target-x64
dyncall/doc/README.Windows:     executed mistakenly for re-generation of test C code)
dyncall/doc/README.Windows:     timestamps are wrong; workaround: run "svn revert -R ." several times.
dyncall/doc/README.Windows:-----------------------------------------------
dyncall/doc/README.Windows:  32-bit:
dyncall/doc/README.Windows:    .\configure.bat /target-x86 /tool-gcc
dyncall/doc/README.Windows:  64-bit:
dyncall/doc/README.Windows:    .\configure.bat /target-x64 /tool-gcc
dyncall/doc/README.Windows:--------------------------------------------------
dyncall/doc/README.Windows:    > mingw32-make -f Makefile.embedded
dyncall/doc/README.Windows:    $ make -f Makefile.embedded CC=gcc
dyncall/doc/README.Windows:----------------------------
dyncall/doc/README.Windows:  Put the appropriate tool-chain in path (32 or 64-bit version of MSVC), then:
dyncall/doc/README.Windows:    cmake -G "NMake Makefiles" %DYNCALL_SOURCE_DIR%
dyncall/doc/README.Windows:------------------------------------
dyncall/doc/README.Windows:  32-bit:
dyncall/doc/README.Windows:-----------------------------------------------
dyncall/doc/README.Windows:   cmake -G "Visual Studio 16 2019" -A ARM64 ..
dyncall/doc/README.Windows:   cmake --build . --config Release
dyncall/doc/README.CMake:Build with CMake (in-source)
dyncall/doc/README.CMake:----------------------------
dyncall/doc/README.CMake:cd <dyncall-source-dir>
dyncall/doc/README.CMake:  cmake . -G "NMake Makefiles"
dyncall/doc/README.CMake:------------------------------
dyncall/doc/README.CMake:cmake -DCMAKE_INSTALL_PREFIX=<absolute-path>
dyncall/doc/README.CMake:---------------
dyncall/doc/README.CMake:- CMake Unix Makefile generators on Mac OS X and Linux.
dyncall/doc/README.CMake:Using from other CMake-based projects
dyncall/doc/README.CMake:-------------------------------------
dyncall/doc/README.CMake:---------------------
dyncall/doc/README.CMake:cmake -DCMAKE_OSX_ARCHITECTURES="i386;x86_64;ppc"
dyncall/doc/README.CMake:---------------
dyncall/doc/README.CMake:Each library in the source tree represents a target (not a sub-project!).
dyncall/doc/README.CMake:-----------------------------------------------
dyncall/doc/README.CMake:Use as sub-project within CMake top-level project
dyncall/doc/README.CMake:-------------------------------------------------
dyncall/doc/README.CMake:----------------------------------
dyncall/doc/README.CMake:Add -m64 to C, C++ and ASM flags, e.g.
dyncall/doc/README.CMake:$ cmake -DCMAKE_C_FLAGS=-m64 -DCMAKE_ASM_FLAGS=-m64 -DCMAKE_ASM_CXX_FLAGS=-m64
dyncall/doc/README.PSP:Cross-compile DynCall for PSP using PSP-SDK
dyncall/doc/README.PSP:Make sure the PSP SDK's is installed and that the build tools (e.g. psp-gcc) are
dyncall/doc/README.PSP:-------
dyncall/doc/README.PSP:- dyncall: tests run ok.
dyncall/doc/README.PSP:- dyncallback: all good.
dyncall/doc/README.PSP:- dynload: unsupported due to missing dynamic linker and ELF headers.
dyncall/doc/README.PSP:-------------------------------
dyncall/doc/README.PSP:  $ ./configure --target=PSP
dyncall/doc/README.PSP:----------------------------------------------------------
dyncall/doc/README.PSP:  $ sh buildsys/scripts/batch-build-psp.sh
dyncall/doc/README.Generic:-----------
dyncall/doc/README.Generic:Makefile.generic is a simple and _hybrid_ make-based build system setup for dyncall, 
dyncall/doc/README.Generic:This build-flavour supports two operating modes: Embedded and Configure.
dyncall/doc/README.Generic:-------
dyncall/doc/README.Generic:-------------
dyncall/doc/README.Generic:[g|bsd]make [-f Makefile.generic] [all|clean|install|...] [INSTALL_TOP=<path>]
dyncall/doc/README.Generic:-------------
dyncall/doc/README.Generic:Makefile.generic makefiles are taken "as-is" without the need for extra configuration.
dyncall/doc/README.Generic:<VAR1>=<VALUE1> ... bsdmake -f Makefile.generic
dyncall/doc/README.Generic:<VAR1>=<VALUE1> ... gmake -f Makefile.generic
dyncall/doc/README.Generic:  $ bsdmake -f Makefile.generic
dyncall/doc/README.Generic:  $ make -f Makefile.generic
dyncall/doc/README.Generic:  such as math and dynamic linker run-time libs.
dyncall/doc/README.Generic:  $ LDLIBS="-lm -ldl" make -f Makefile.generic
dyncall/doc/README.Generic:--------------
dyncall/doc/README.Generic:  cd <build-dir> # build-dir can be arbitrary
dyncall/doc/README.Generic:  ../<path-to-source>/configure [--prefix=<path>]
dyncall/doc/README.Generic:Two build types are supported: In-source and out-of-Source.
dyncall/doc/README.Generic:in-source builds:
dyncall/doc/README.Generic:out-of-source builds:
dyncall/doc/README.Generic:----------------
dyncall/doc/README.Generic:MAKE_CMD - The make tool (including -f flag) to run sub-directories.
dyncall/doc/README.Generic:SRCTOP   - Source top-level directory (defaults to relative top).
dyncall/doc/README.Generic:BLDTOP   - Build  top-level directory (defaults to SRCTOP).
dyncall/doc/README.Generic:SRCDIR   - Source directory (defaults to '.').
dyncall/doc/README.Generic:BLDDIR   - Build  directory (defaults to SRCDIR).
dyncall/doc/README.Generic:e.g. Makefile.generic in source-tree:
dyncall/doc/README.Generic:SRCTOP ?= ../../../ # relative path to source-top
dyncall/doc/README.Generic:BLDTOP ?= ${SRCTOP} # defaults for in-source builds
dyncall/doc/README.Generic:-------------------
dyncall/doc/README.Generic:Use -I${SRCTOP}/... to refer to other include directories.
dyncall/doc/README.Generic:----------------
dyncall/doc/README.Generic:Use -L${BLDTOP}/... to refer to other build directories.
dyncall/doc/README.Generic:--------------
dyncall/doc/README.Generic:- all: ok.
dyncall/doc/README.Generic:  make -f Makefile.generic all
dyncall/doc/README.Generic:- tests: need 'm' and 'dl' libs. 
dyncall/doc/README.Generic:  ( cd tests ; LDLIBS="-lm -ldl" make -f Makefile.generic )
dyncall/doc/README.Generic:- see batch script: buildsys/scripts/batch-build-linux.sh
dyncall/doc/README.Generic:Minix: No dynload support. No '-fPIC' is allowed.
dyncall/doc/README.Generic:- dynload: unsupport, no dynamic linker present in Minix 3.
dyncall/doc/README.Generic:- dyn{call,callback}: ok, without '-fPIC'!
dyncall/doc/README.Generic:  ( cd dyncall ; CFLAGS= make -f Makefile.generic dyncall dyncallback )
dyncall/doc/README.Generic:- tests: ok
dyncall/doc/README.Generic:  ( cd test ; make -f Makefile.generic all-dyncall all-dyncallback )
dyncall/doc/README.Generic:- see batch script: buildsys/scripts/batch-build-minix.sh
dyncall/doc/README.Generic:- all: ok.
dyncall/doc/README.Generic:  make -f Makefile.generic all
dyncall/doc/README.Generic:- tests: need math lib:
dyncall/doc/README.Generic:  ( cd tests ; LDLIBS="-lm" make -f Makefile.generic )
dyncall/doc/README.Generic:- all: ok.
dyncall/doc/README.Generic:  make -f Makefile.generic all
dyncall/doc/README.Generic:- tests: *.cpp implicit rule not set, therefore only c tests work:
dyncall/doc/README.Generic:  ( cd tests ; LDLIBS="-lm" make -f Makefile.generic all-c )
dyncall/doc/README.Generic:- install: ok.
dyncall/doc/README.Generic:- dynload: elf.h header found, install system source for dynload support
dyncall/doc/README.Generic:- dyn{call,callback}: ok.
dyncall/doc/README.Generic:  make -f Makefile.generic dyncall dyncallback
dyncall/doc/README.Generic:- tests: ok
dyncall/doc/README.Generic:  ( cd test ; make -f Makefile.generic all-dyncall all-dyncallback )
dyncall/doc/README.Generic:-------------------------------
dyncall/doc/README.Generic:  Use '-fPIC' for at least 64-bit systems and when you want the code to be 
dyncall/doc/README.Generic:  Use '-lm' for test/suite - it uses pow function.
dyncall/doc/README.Generic:  Use '-ldl' for dynload examples such as test/nm and test/resolve_self on Linux.
dyncall/doc/README.Generic:--------
dyncall/doc/README.Generic:configure --prefix=<prefix> -> Makefile DESTDIR=variable
dyncall/doc/README.Generic:make -f Makefile.generic DESTDIR=<prefix>
dyncall/doc/README.Generic:-----
dyncall/doc/README.Generic:- sun's make: CXX does not exist.. no rule for *.cpp files but *.cc.
dyncall/CMakeLists.txt:# Copyright (c) 2010-2020 Daniel Adler <dadler@uni-goettingen.de>
dyncall/CMakeLists.txt:#                    2020 armasm64 support: Bernhard Urban-Forster <beurba@microsoft.com>
dyncall/CMakeLists.txt:set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "dyncall enables dynamic invocation of machine-level function calls")
dyncall/CMakeLists.txt:check_c_compiler_flag("-fPIC -Werror" COMPILER_HAS_FPIC)
dyncall/CMakeLists.txt:#    https://github.com/dotnet/runtime/blob/e98fb61d8b4bb6687ccddead861d8b140751647b/eng/native/functions.cmake#L173-L207
dyncall/CMakeLists.txt:                        COMMAND "${CMAKE_ASM_COMPILER}" ${ASM_INCLUDE_DIRECTORIES} -o ${OBJ_FILE} ${ASM_FILE}
dyncall/CMakeLists.txt:                        COMMENT "Assembling ${ASM_FILE} ---> \"${CMAKE_ASM_COMPILER}\" ${ASM_INCLUDE_DIRECTORIES} -o ${OBJ_FILE} ${ASM_FILE}"+                        COMMENT "Assembling ${ASM_FILE} ---> \"${CMAKE_ASM_COMPILER}\" ${ASM_INCLUDE_DIRECTORIES} -o ${OBJ_FILE} ${ASM_FILE}")
dyncall/CMakeLists.txt:    set(CMAKE_ASM_COMPILE_OBJECT "<CMAKE_ASM_COMPILER> <INCLUDES> <FLAGS> -o <OBJECT> <SOURCE>")
dyncall/CMakeLists.txt:    # when used in shared libraries, -fPIC is required by several architectures
dyncall/CMakeLists.txt:    add_definitions("-fPIC")
dyncall/CMakeLists.txt:  # enable gcc as front-end to assembler for .S files
dyncall/CMakeLists.txt:  set(CMAKE_ASM_COMPILER_ARG1 "${CPPFLAGS} -c")
dyncall/CMakeLists.txt:  set(CMAKE_ASM_COMPILER_ARG1 "${CPPFLAGS} -c")
dyncall/CMakeLists.txt:    add_definitions("-fPIC")
dyncall/CMakeLists.txt:  # enable gcc as front-end to assembler for .S files
dyncall/CMakeLists.txt:  set(CMAKE_ASM_COMPILER_ARG1 "${CPPFLAGS} -c")
dyncall/configure:usage: $0 --<option>=<value> <var>=<value> ..
dyncall/configure:  --prefix=<dir>
dyncall/configure:  --target=<platform>       uname/special targets: macos,iOS,iPhoneSimulator
dyncall/configure:  --sdk=<version>           Mac OS X/iOS SDK version (e.g. '6.1' or '10.9.3')
dyncall/configure:  --sdkroot=<dir>
dyncall/configure:printf "# auto-generated by $0\n" >$C
dyncall/configure:while [ $# -gt 0 ]; do
dyncall/configure:    --help|-h|-?)
dyncall/configure:    --prefix=*)
dyncall/configure:      PREFIX=`printf -- "${X}" | cut -c 10-`
dyncall/configure:    --target=*)
dyncall/configure:      TARGET=`printf -- "${X}" | cut -c 10-`
dyncall/configure:    --sdk=*)
dyncall/configure:      SDK=`printf -- "${X}" | cut -c 7-`
dyncall/configure:    --sdkroot=*)
dyncall/configure:      SDKROOT=`printf -- "${X}" | cut -c 11-`
dyncall/configure:    [A-Za-z_]*=*)
dyncall/configure:      k=`printf "${X}" | cut -d = -f 1`
dyncall/configure:      v=`printf "${X}" | cut -d = -f 2`
dyncall/configure:    if [ -z "${CFLAGS}" ]; then
dyncall/configure:      printf "CFLAGS=-fPIC\n" >>$C
dyncall/configure:    printf "LDLIBS=-lm -ldl\n" >>$C
dyncall/configure:    if [ -z "${CFLAGS}" ]; then
dyncall/configure:      if (uname -r | grep '^\([0-2]\.\|3\.[0-6]\)' > /dev/null); then
dyncall/configure:        printf "CFLAGS=-fPIC -DDL_DLADDR_TO_LIBPATH\n" >>$C
dyncall/configure:        printf "CFLAGS=-fPIC\n" >>$C
dyncall/configure:    printf "LDLIBS=-lm\n" >>$C
dyncall/configure:    if [ -z "${CFLAGS}" ]; then
dyncall/configure:      printf "CFLAGS=-fPIC\n" >>$C
dyncall/configure:    printf "LDLIBS=-lm\n" >>$C
dyncall/configure:    if [ -z "${CFLAGS}" ]; then
dyncall/configure:      if [ `uname -m` = "mips" ] && make -V MACHINE_ARCH | grep 'hf$' >/dev/null 2>&1; then
dyncall/configure:        # FBSD12-CURRENT/mipshf needs to be told explicitly to use -mhard-float (at least as of may 2018)
dyncall/configure:        printf "CFLAGS=-fPIC -mhard-float\n" >>$C
dyncall/configure:        printf "CFLAGS=-fPIC\n" >>$C
dyncall/configure:    printf "LDLIBS=-lm\n" >>$C
dyncall/configure:    printf "RM=rm -f\n" >>$C
dyncall/configure:    # if Apple's libtool (not to be confused with GNU's) is available, which is according to libtool(1) "with -static [...] intended
dyncall/configure:    # to replace ar(5) and ranlib", use it - if it is shadowed by some install of GNU's libtool assume that a foreign environment is
dyncall/configure:    # intentionally used, and fall back to using 'ar rs' (the equivalent to 'libtool -static'), for compatibility:
dyncall/configure:    if libtool -V >/dev/null 2>/dev/null; then # Apple's libtool has -V for version, which GNU does not.
dyncall/configure:      printf "ARFLAGS=-static -o\n" >>$C
dyncall/configure:    if [ `uname -n` = 'iPhone' ]; then # building on iPhone itself, uname yields Darwin (gcc setup for current/correct arch)
dyncall/configure:    elif [ -z ${SDK} ]; then
dyncall/configure:      case `sw_vers -productVersion` in
dyncall/configure:          ARCHS="-arch ppc -arch i386 -arch x86_64" 
dyncall/configure:          ARCHS="-arch i386 -arch x86_64 -arch ppc"
dyncall/configure:          ARCHS="-arch i386 -arch x86_64"   # no more ppc
dyncall/configure:          ARCHS="-arch x86_64 -arch i386"
dyncall/configure:          ARCHS="-arch x86_64"              # mojave is final os to run x86 code, but removed build support for it
dyncall/configure:      if [ -z ${SDKROOT} ]; then
dyncall/configure:        SDKROOT="`xcode-select -print-path`/Platforms/MacOSX.platform/Developer/SDKs/MacOSX${SDK}.sdk"
dyncall/configure:      printf "CFLAGS=-isysroot ${SDKROOT}\n" >>$C
dyncall/configure:      printf "CXXFLAGS=-isysroot ${SDKROOT}\n" >>$C
dyncall/configure:    if [ -z ${SDKROOT} ]; then
dyncall/configure:      SDKROOT="`xcode-select -print-path`/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS${SDK}.sdk"
dyncall/configure:    if [ -z "${ARCHS}" ]; then
dyncall/configure:          ARCHS="-arch armv6"
dyncall/configure:          ARCHS="-arch armv7"
dyncall/configure:        [89].*|1[0-9].*)
dyncall/configure:          ARCHS="-arch armv7 -arch arm64"
dyncall/configure:    printf "ASFLAGS=${ARCHS} -isysroot ${SDKROOT}\n" >>$C
dyncall/configure:    printf "CFLAGS=${ARCHS} -isysroot ${SDKROOT}\n" >>$C
dyncall/configure:    printf "CXXFLAGS=${ARCHS} -isysroot ${SDKROOT}\n" >>$C
dyncall/configure:    printf "LDFLAGS=-Wl,-syslibroot ${SDKROOT}\n" >>$C
dyncall/configure:    if [ -z ${SDKROOT} ]; then
dyncall/configure:      SDKROOT="`xcode-select -print-path`/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator${SDK}.sdk"
dyncall/configure:    ARCHS="-arch i386"
dyncall/configure:    printf "ASFLAGS=${ARCHS} -isysroot ${SDKROOT}\n" >>$C
dyncall/configure:    printf "CFLAGS=${ARCHS} -isysroot ${SDKROOT}\n" >>$C
dyncall/configure:    printf "CXXFLAGS=${ARCHS} -isysroot ${SDKROOT}\n" >>$C
dyncall/configure:    printf "LDFLAGS=-Wl,-syslibroot ${SDKROOT}\n" >>$C
dyncall/configure:    printf "CC=` (which cc gcc clang  ) | grep -v '^no ' | head -1`\n" >>$C
dyncall/configure:    printf "CXX=`(which CC g++ clang++) | grep -v '^no ' | head -1`\n" >>$C # C++ compiler traditionally named CC
dyncall/configure:    printf "LDLIBS=-lm -ldl\n" >>$C
dyncall/configure:    SDKROOT="`psp-config --pspsdk-path`"
dyncall/configure:    printf "CC=psp-gcc\n" >>$C
dyncall/configure:    printf "CXX=psp-gcc\n">>$C # don't use psp-g++, buggy
dyncall/configure:    printf "AR=psp-ar\n"  >>$C
dyncall/configure:    printf "CFLAGS=-I${SDKROOT}/include/\n" >>$C
dyncall/configure:    printf "CXXFLAGS=-I${SDKROOT}/include/\n" >>$C
dyncall/configure:    # Pulling in dyncall libs below is a hack, for some reason psp-ld is super-picky about order.
dyncall/configure:    #printf "LDLIBS=-L${SDKROOT}/lib/ -L${SRCTOP}/dyncall -L${SRCTOP}/dyncallback -ldyncall_s -ldyncallback_s -lm -lpspdebug -lpspdisplay -lpspge -lpspctrl -lpspsdk -lstdc++ -lpsplibc -lpspnet -lpspnet_inet -lpspnet_apctl -lpspnet_resolver -lpsputility -lpspuser \n" >>$C
dyncall/configure:    printf "LDLIBS=-L${SDKROOT}/lib/ -L${SRCTOP}/dyncall -L${SRCTOP}/dyncallback -ldyncall_s -ldyncallback_s -lm -lpspdebug -lpspdisplay -lpspge -lpspctrl -lpspsdk -lstdc++ -lc       -lpspnet -lpspnet_inet -lpspnet_apctl -lpspnet_resolver -lpsputility -lpspuser \n" >>$C
dyncall/configure:    cat $0 | awk '/^esac$/{b=0}/^  [A-Za-z0-9|]+\)/{if(b==1) print substr($1,1,length($1)-1)}BEGIN{b=0}/^case.*TARGET.*uname.*in$/{b=1}' | tr '|' '\n'
dyncall/configure:## Neither specifying this per source (e.g. via .section .note.GNU-stack,"",...), nor
dyncall/configure:## per toolchain flags (e.g. as' --noexecstack) turned out to be portable across our
dyncall/configure:## Find needed build flags by running a few tests; use default if none result in "rw-".
dyncall/configure:#  # on some other platforms only CFLAGS is the only one used, others use AFLAGS with cc and thus need -Wa,... Check
dyncall/configure:#  for f in "" "ASFLAGS+=-Wa,--noexecstack" "ACFLAGS+=-Wa,--noexecstack" "AFLAGS+=--noexecstack" "AFLAGS+=-Wa,--noexecstack" "CFLAGS+=-Wa,--noexecstack"; do
dyncall/configure:#    make -f - <<MAKEFILE
dyncall/configure:## Force dependency via .o, to avoid .[sS].out rules that might be set - also set command as not all platforms set .o.out
dyncall/configure:#	\${CC} \${CFLAGS} \${LDFLAGS} $RWXTESTPREFIX.o \${LDLIBS} -o $RWXTESTPREFIX.out
dyncall/configure:#    STACKFLAGS=`(which objdump && objdump -p $RWXTESTPREFIX.out) | sed -e '/STACK/bx' -e 'd' -e ':x' -e 'N' -e 's/^.*flags[ \t]\([^ \t]*\).*/\1/'`
dyncall/configure:#    if [ "$STACKFLAGS" = "rw-" ]; then
dyncall/configure:FILES=`( cd $SRCTOP ; find . -name "Makefile.generic" )`
dyncall/configure:  mkdir -p "$BLDDIR"
ast.scm:(define (deparse-arglist l (sep ", "))
ast.scm:  (if (has-parameters? l)
ast.scm:(define (deparse-prefix-call head args opn cls)
ast.scm:          opn (deparse-arglist args) cls))
ast.scm:(define (deparse-generator e)
ast.scm:      (deparse-flatten e '())
ast.scm:      (string (deparse (cadr e)) " for " (deparse-arglist (cddr e) ", "))))
ast.scm:(define (deparse-flatten e iters (flat #t))
ast.scm:         (deparse-flatten (cadr e) (cons (deparse-arglist (cddr e) ", ") iters) #f))
ast.scm:           (deparse-flatten (cadr e) (cons (deparse-arglist (cddr e) ", ") iters) #t)))
ast.scm:(define (indented-block lst ilvl)
ast.scm:(define (deparse-block head lst ilvl)
ast.scm:  (string head "\n" (indented-block lst ilvl)
ast.scm:(define (deparse-colon-dot e)
ast.scm:(define (deparse-import-path e)
ast.scm:         (string (deparse-import-path (cadr e)) ": "
ast.scm:                 (string.join (map deparse-import-path (cddr e)) ", ")))
ast.scm:(define (deparse-semicolons n)
ast.scm:      (string ";" (deparse-semicolons (1- n)))))
ast.scm:        ((string? e) (print-to-string e))
ast.scm:                        (deparse-colon-dot (cadr (caddr e))))
ast.scm:                        (deparse-colon-dot (cadr (cadr (caddr e)))))
ast.scm:        ((or (syntactic-op? (car e)) (eq? (car e) '|<:|) (eq? (car e) '|>:|) (eq? (car e) '-->))
ast.scm:         (string (deparse-import-path (cadr e)) " as " (deparse (caddr e))))
ast.scm:                   (deparse-prefix-call (cadr e) (cddr e) #\( #\)))))
ast.scm:           ((macrocall) (string (cadr e) " " (deparse-arglist (cddr e) " ")))
ast.scm:           ((parameters) (string "; " (deparse-arglist (cdr e))))
ast.scm:            (string #\( (deparse-arglist (cdr e))
ast.scm:           ((ref)   (deparse-prefix-call (cadr e) (cddr e) #\[ #\]))
ast.scm:           ((curly) (deparse-prefix-call (cadr e) (cddr e) #\{ #\}))
ast.scm:           ((vect)  (string #\[ (deparse-arglist (cdr e) ", ") #\]))
ast.scm:           ((vcat)  (string #\[ (deparse-arglist (cdr e) "; ") #\]))
ast.scm:           ((hcat)        (string #\[ (deparse-arglist (cdr e) " ") #\]))
ast.scm:           ((ncat)        (string #\[ (deparse-arglist (cddr e) (string (deparse-semicolons (cadr e)) " "))
ast.scm:                                          (deparse-semicolons (cadr e))
ast.scm:           ((row)        (deparse-arglist (cdr e) " "))
ast.scm:           ((nrow)       (deparse-arglist (cddr e) (string (deparse-semicolons (cadr e)) " ")))
ast.scm:           ((braces)     (string #\{ (deparse-arglist (cdr e) ", ") #\}))
ast.scm:           ((bracescat)  (string #\{ (deparse-arglist (cdr e) "; ") #\}))
ast.scm:           ((generator)     (string "(" (deparse-generator e) ")"))
ast.scm:           ((flatten)       (string "(" (deparse-generator e) ")"))
ast.scm:           ((comprehension) (string "[ " (deparse-generator (cadr e)) " ]"))
ast.scm:           ((block)    (deparse-block "begin" (cdr e) ilvl))
ast.scm:            (define (block-stmts e)
ast.scm:            (deparse-block (string (car e) " " (deparse (cadr e)))
ast.scm:                           (block-stmts (caddr e))
ast.scm:            (define (if-cond e)
ast.scm:                (deparse-block (string (car e) " " (deparse (if-cond e)))
ast.scm:                (string (car e) " " (deparse (if-cond e)) "\n"
ast.scm:                        (indented-block (cdr (caddr e)) ilvl)
ast.scm:                              (deparse-block "else" (cdr els) ilvl))))))
ast.scm:            (deparse-block (string "let " (string.join (map deparse (cdadr e)) ", "))
ast.scm:                    (indented-block (cdr (cadr e)) ilvl)
ast.scm:                                (indented-block (cdr (cadddr e)) ilvl))
ast.scm:                                      (indented-block (cdr fin) ilvl))
ast.scm:	      (deparse-block (string (deparse call) " do" (if (null? args) "" " ")
ast.scm:				     (deparse-arglist args))
ast.scm:                    (deparse-block (deparse (caddr e)) (cdr (cadddr e)) ilvl)))
ast.scm:            (string (car e) " " (string.join (map deparse-import-path (cdr e)) ", ")))
ast.scm:           ((globalref)    (string (deparse (cadr e)) "." (deparse-colon-dot (caddr e))))
ast.scm:(define *current-gensyms* '())
ast.scm:(define *gensy-counter* 1)
ast.scm:  (if (null? *current-gensyms*)
ast.scm:      (let ((g (symbol (string "#s" *gensy-counter*))))
ast.scm:        (set! *gensy-counter* (+ *gensy-counter* 1))
ast.scm:      (begin0 (car *current-gensyms*)
ast.scm:              (set! *current-gensyms* (cdr *current-gensyms*)))))
ast.scm:(define (named-gensy name)
ast.scm:  (let ((g (symbol (string "#" *gensy-counter* "#" name))))
ast.scm:    (set! *gensy-counter* (+ *gensy-counter* 1))
ast.scm:(define (reset-gensyms)
ast.scm:  (set! *current-gensyms* *gensyms*))
ast.scm:(define make-ssavalue
ast.scm:  (let ((ssavalue-counter 0))
ast.scm:      (begin0 `(ssavalue ,ssavalue-counter)
ast.scm:              (set! ssavalue-counter (+ 1 ssavalue-counter))))))
ast.scm:(define (quoted-sym? e)
ast.scm:(define (lam:argnames x) (llist-vars (lam:args x)))
ast.scm:(define (bad-formal-argument v)
ast.scm:(define (valid-name? s)
ast.scm:(define (arg-name v)
ast.scm:  (cond ((and (symbol? v) (valid-name? v))
ast.scm:         (bad-formal-argument v))
ast.scm:	    (arg-name (cadr v)) ;; to check for errors
ast.scm:	    (decl-var (cadr v)))
ast.scm:                (bad-formal-argument (cadr v)))
ast.scm:            (decl-var v))
ast.scm:           ((meta)  ;; allow certain per-argument annotations
ast.scm:            (if (nospecialize-meta? v #t)
ast.scm:                (arg-name (caddr v))
ast.scm:                (bad-formal-argument v)))
ast.scm:            (arg-name (cadr v)))
ast.scm:           (else (bad-formal-argument v))))))
ast.scm:(define (arg-type v)
ast.scm:         (bad-formal-argument v))
ast.scm:                      `(... ,(decl-type (cadr v)) ,(caddr v))
ast.scm:                      `(... ,(decl-type (cadr v)))))
ast.scm:                (bad-formal-argument (cadr v)))
ast.scm:            (decl-type v))
ast.scm:           ((meta)  ;; allow certain per-argument annotations
ast.scm:            (if (nospecialize-meta? v #t)
ast.scm:                (arg-type (caddr v))
ast.scm:                (bad-formal-argument v)))
ast.scm:            (arg-type (cadr v)))
ast.scm:           (else (bad-formal-argument v))))))
ast.scm:(define (llist-vars lst)
ast.scm:  (map arg-name (filter (lambda (a) (not (and (pair? a)
ast.scm:(define (llist-types lst) (map arg-type lst))
ast.scm:(define (eventually-decl? e)
ast.scm:(define (make-decl n t) `(|::| ,n ,t))
ast.scm:(define (symbol-like? e)
ast.scm:(define (simple-atom? x)
ast.scm:(define (effect-free? e)
ast.scm:  (or (not (pair? e)) (ssavalue? e) (sym-dot? e) (quoted? e) (memq (car e) '(null true false))))
ast.scm:(define (decl-var v)
ast.scm:(define (decl-type v)
ast.scm:(define (sym-dot? e)
ast.scm:       (symbol-like? (cadr e))))
ast.scm:(define (undot-name e)
ast.scm:(define (identifier-name e)
ast.scm:(define (dotop-named? e) (dotop? (identifier-name e)))
ast.scm:(define (check-dotop e)
ast.scm:  (if (dotop-named? e)
ast.scm:              (check-dotop (caddr e))
ast.scm:                  (check-dotop (cadr e))))))
ast.scm:(define (vararg-type-expr? x)
ast.scm:                    (vararg-type-expr? (cadr x)))
ast.scm:                    (vararg-type-expr? (cadr x)))))))
ast.scm:       (vararg-type-expr? (caddr x))))
ast.scm:(define (make-assignment l r) `(= ,l ,r))
ast.scm:(define (complex-return? e) (and (return? e)
ast.scm:                                   (not (simple-atom? x)))))
ast.scm:(define (tuple-call? e)
ast.scm:(define (eq-sym? a b)
ast.scm:(define (make-var-info name) (list name '(core Any) 0))
ast.scm:(define (vinfo:set-type! v t) (set-car! (cdr v) t))
ast.scm:(define (vinfo:never-undef v) (< 0 (logand (caddr v) 4)))
ast.scm:(define (set-bit x b val) (if val (logior x b) (logand x (lognot b))))
ast.scm:(define (vinfo:set-capt! v c)  (set-car! (cddr v) (set-bit (caddr v) 1 c)))
ast.scm:(define (vinfo:set-asgn! v a)  (set-car! (cddr v) (set-bit (caddr v) 2 a)))
ast.scm:(define (vinfo:set-never-undef! v a) (set-car! (cddr v) (set-bit (caddr v) 4 a)))
ast.scm:(define (vinfo:set-read! v a) (set-car! (cddr v) (set-bit (caddr v) 8 a)))
ast.scm:(define (vinfo:set-sa! v a)    (set-car! (cddr v) (set-bit (caddr v) 16 a)))
ast.scm:(define (vinfo:set-called! v a)  (set-car! (cddr v) (set-bit (caddr v) 64 a)))
ast.scm:(define var-info-for assq)
ast.scm:(define (assignment-like? e)
ast.scm:  (and (pair? e) (is-prec-assignment? (car e))))
ast.scm:(define (nospecialize-meta? e (one #f))
ast.scm:(define (if-generated? e)
ast.scm:(define (generated-meta? e)
ast.scm:(define (generated_only-meta? e)
ast.scm:(define (function-def? e)
ast.scm:  (and (pair? e) (or (eq? (car e) 'function) (eq? (car e) '->)
ast.scm:                          (eventually-call? (cadr e))))))
ast.scm:(define (flatten-ex head e)
ast.scm:                              (cdr (flatten-ex head x))
ast.scm:(define (flatten-blocks e) (flatten-ex 'block e))
options.h:// Build-time options for debugging, tweaking, and selecting alternative
options.h:// object layout options ------------------------------------------------------
options.h:// codegen options ------------------------------------------------------------
options.h:// delete julia IR for non-inlineable functions after they're codegen'd
options.h:// fill in the jl_all_methods in world-counter order
options.h:// GC options -----------------------------------------------------------------
options.h:// to help detect corruption due to fence-post write errors
options.h:// method dispatch profiling --------------------------------------------------
options.h:// task options ---------------------------------------------------------------
options.h:// When not using COPY_STACKS the task-system is less memory efficient so
options.h:// you probably want to choose a smaller default stack size (factor of 8-10)
options.h:// threading options ----------------------------------------------------------
options.h:// partr -- parallel tasks runtime options ------------------------------------
options.h:// sanitizer defaults ---------------------------------------------------------
llvm-version.h:#include <llvm/Config/llvm-config.h>
llvm-version.h:// The LLVM version used, JL_LLVM_VERSION, is represented as a 5-digit integer
llvm-version.h:#pragma GCC diagnostic ignored "-Winit-list-lifetime"
llvm-remove-addrspaces.cpp:#include "llvm-version.h"
llvm-remove-addrspaces.cpp:                    remapType(Ty->getElementType()),
llvm-remove-addrspaces.cpp:                    ASRemapper(Ty->getAddressSpace()));
llvm-remove-addrspaces.cpp:            for (unsigned Index = 0; Index < Ty->getNumParams(); ++Index)
llvm-remove-addrspaces.cpp:                Params.push_back(remapType(Ty->getParamType(Index)));
llvm-remove-addrspaces.cpp:                    remapType(Ty->getReturnType()), Params, Ty->isVarArg());
llvm-remove-addrspaces.cpp:            if (Ty->isLiteral()) {
llvm-remove-addrspaces.cpp:                // for literal types (i.e., no self-reference) and thus treated
llvm-remove-addrspaces.cpp:                assert(!Ty->hasName()); // literal type has no name.
llvm-remove-addrspaces.cpp:                NewElTys.reserve(Ty->getNumElements());
llvm-remove-addrspaces.cpp:                for (auto E: Ty->elements())
llvm-remove-addrspaces.cpp:                DstTy = StructType::get(Ty->getContext(), NewElTys, Ty->isPacked());
llvm-remove-addrspaces.cpp:            } else if (!Ty->isOpaque()) {
llvm-remove-addrspaces.cpp:                // self-referential fields (i.e., pointer type of itself as a
llvm-remove-addrspaces.cpp:                StructType *DstTy_ = StructType::create(Ty->getContext());
llvm-remove-addrspaces.cpp:                if (Ty->hasName()) {
llvm-remove-addrspaces.cpp:                    auto Name = std::string(Ty->getName());
llvm-remove-addrspaces.cpp:                    Ty->setName(Name + ".bad");
llvm-remove-addrspaces.cpp:                    DstTy_->setName(Name);
llvm-remove-addrspaces.cpp:                auto Els = Ty->getNumElements();
llvm-remove-addrspaces.cpp:                    NewElTys[i] = remapType(Ty->getElementType(i));
llvm-remove-addrspaces.cpp:                DstTy_->setBody(NewElTys, Ty->isPacked());
llvm-remove-addrspaces.cpp:                    remapType(Ty->getElementType()), Ty->getNumElements());
llvm-remove-addrspaces.cpp:            DstTy = VectorType::get(remapType(Ty->getElementType()), Ty);
llvm-remove-addrspaces.cpp:            Type *Ty = remapType(CE->getType());
llvm-remove-addrspaces.cpp:            if (CE->getOpcode() == Instruction::AddrSpaceCast) {
llvm-remove-addrspaces.cpp:                Constant *Src = mapConstant(CE->getOperand(0));
llvm-remove-addrspaces.cpp:                if (Src->getType()->getPointerAddressSpace() ==
llvm-remove-addrspaces.cpp:                    Ty->getPointerAddressSpace())
llvm-remove-addrspaces.cpp:                for (unsigned Index = 0; Index < CE->getNumOperands();
llvm-remove-addrspaces.cpp:                    Constant *Op = CE->getOperand(Index);
llvm-remove-addrspaces.cpp:                if (CE->getOpcode() == Instruction::GetElementPtr) {
llvm-remove-addrspaces.cpp:                    Constant *Src = CE->getOperand(0);
llvm-remove-addrspaces.cpp:                            cast<PointerType>(Src->getType()->getScalarType())
llvm-remove-addrspaces.cpp:                                    ->getElementType());
llvm-remove-addrspaces.cpp:                    DstV = CE->getWithOperands(Ops, Ty, false, SrcTy);
llvm-remove-addrspaces.cpp:                    DstV = CE->getWithOperands(Ops, Ty);
llvm-remove-addrspaces.cpp:            return TypeMapper->remapType(SrcTy);
llvm-remove-addrspaces.cpp:            if (ASC->getSrcAddressSpace() == ASC->getDestAddressSpace()) {
llvm-remove-addrspaces.cpp:                ASC->replaceAllUsesWith(ASC->getOperand(0));
llvm-remove-addrspaces.cpp:        I->eraseFromParent();
llvm-remove-addrspaces.cpp:    const Comdat *SC = Src->getComdat();
llvm-remove-addrspaces.cpp:    Comdat *DC = Dst->getParent()->getOrInsertComdat(SC->getName());
llvm-remove-addrspaces.cpp:    DC->setSelectionKind(SC->getSelectionKind());
llvm-remove-addrspaces.cpp:    Dst->setComdat(DC);
llvm-remove-addrspaces.cpp:        if (GV->hasName()) {
llvm-remove-addrspaces.cpp:            Name = std::string(GV->getName());
llvm-remove-addrspaces.cpp:            GV->setName(Name + ".bad");
llvm-remove-addrspaces.cpp:                TypeRemapper.remapType(GV->getValueType()),
llvm-remove-addrspaces.cpp:                GV->isConstant(),
llvm-remove-addrspaces.cpp:                GV->getLinkage(),
llvm-remove-addrspaces.cpp:                GV->getThreadLocalMode(),
llvm-remove-addrspaces.cpp:                GV->getType()->getAddressSpace());
llvm-remove-addrspaces.cpp:        NGV->copyAttributesFrom(GV);
llvm-remove-addrspaces.cpp:        if (GA->hasName()) {
llvm-remove-addrspaces.cpp:            Name = std::string(GA->getName());
llvm-remove-addrspaces.cpp:            GA->setName(Name + ".bad");
llvm-remove-addrspaces.cpp:                TypeRemapper.remapType(GA->getValueType()),
llvm-remove-addrspaces.cpp:                GA->getType()->getPointerAddressSpace(),
llvm-remove-addrspaces.cpp:                GA->getLinkage(),
llvm-remove-addrspaces.cpp:        NGA->copyAttributesFrom(GA);
llvm-remove-addrspaces.cpp:        if (F->hasName()) {
llvm-remove-addrspaces.cpp:            Name = std::string(F->getName());
llvm-remove-addrspaces.cpp:            F->setName(Name + ".bad");
llvm-remove-addrspaces.cpp:        FunctionType *FTy = cast<FunctionType>(F->getValueType());
llvm-remove-addrspaces.cpp:        for (Type *Ty : FTy->params())
llvm-remove-addrspaces.cpp:                TypeRemapper.remapType(FTy->getReturnType()),
llvm-remove-addrspaces.cpp:                FTy->isVarArg());
llvm-remove-addrspaces.cpp:                NFTy, F->getLinkage(), F->getAddressSpace(), Name, &M);
llvm-remove-addrspaces.cpp:        if (GV->isDeclaration())
llvm-remove-addrspaces.cpp:        if (GV->hasInitializer())
llvm-remove-addrspaces.cpp:            NGV->setInitializer(MapValue(GV->getInitializer(), VMap));
llvm-remove-addrspaces.cpp:        GV->getAllMetadata(MDs);
llvm-remove-addrspaces.cpp:            NGV->addMetadata(
llvm-remove-addrspaces.cpp:        GV->setInitializer(nullptr);
llvm-remove-addrspaces.cpp:        if (F->isDeclaration())
llvm-remove-addrspaces.cpp:        LLVM_DEBUG(dbgs() << "Processing function " << NF->getName() << "\n");
llvm-remove-addrspaces.cpp:        Function::arg_iterator DestI = NF->arg_begin();
llvm-remove-addrspaces.cpp:        for (Function::const_arg_iterator I = F->arg_begin(); I != F->arg_end();
llvm-remove-addrspaces.cpp:            DestI->setName(I->getName());
llvm-remove-addrspaces.cpp:        AttributeList Attrs = F->getAttributes();
llvm-remove-addrspaces.cpp:        LLVMContext &C = F->getContext();
llvm-remove-addrspaces.cpp:        NF->setAttributes(Attrs);
llvm-remove-addrspaces.cpp:        if (F->hasPersonalityFn())
llvm-remove-addrspaces.cpp:            NF->setPersonalityFn(MapValue(F->getPersonalityFn(), VMap));
llvm-remove-addrspaces.cpp:        F->deleteBody();
llvm-remove-addrspaces.cpp:        if (const Constant *C = GA->getAliasee())
llvm-remove-addrspaces.cpp:            NGA->setAliasee(MapValue(C, VMap));
llvm-remove-addrspaces.cpp:        GA->setAliasee(nullptr);
llvm-remove-addrspaces.cpp:        GV->eraseFromParent();
llvm-remove-addrspaces.cpp:        GA->eraseFromParent();
llvm-remove-addrspaces.cpp:        F->eraseFromParent();
llvm-remove-addrspaces.cpp:            F->replaceAllUsesWith(Remangled.getValue());
llvm-remove-addrspaces.cpp:            F->eraseFromParent();
llvm-remove-addrspaces.cpp:// Julia-specific pass
llvm-remove-addrspaces.cpp:    unwrap(PM)->add(createRemoveJuliaAddrspacesPass());
julia-syntax.scm:(define (fill-missing-argname a unused)
julia-syntax.scm:(define (fix-arglist l (unused #t))
julia-syntax.scm:      (error "invalid \"...\" on non-final argument"))
julia-syntax.scm:                `(kw ,(fill-missing-argname (cadr a) unused) ,(caddr a)))
julia-syntax.scm:                `(... ,(fill-missing-argname (cadr a) unused)))
julia-syntax.scm:                (fill-missing-argname a unused))))
julia-syntax.scm:(define (comp-accum e make-and done? take)
julia-syntax.scm:                    (make-and expr (car ex_rest))))))))
julia-syntax.scm:(define (add-init arg arg2 expr)
julia-syntax.scm:(define (compare-one e)
julia-syntax.scm:                    (make-ssavalue) arg)))
julia-syntax.scm:    (if (and (not (dotop-named? (cadr e)))
julia-syntax.scm:             (dotop-named? (cadddr (cddr e))))
julia-syntax.scm:        ;; initialization of its variable by short-circuiting
julia-syntax.scm:        (let ((s (make-ssavalue)))
julia-syntax.scm:         (add-init arg arg2
julia-syntax.scm:(define (expand-scalar-compare e)
julia-syntax.scm:  (comp-accum e
julia-syntax.scm:              (lambda (x) (or (not (length> x 2)) (dotop-named? (cadr x))))
julia-syntax.scm:              compare-one))
julia-syntax.scm:;; combining as many scalar comparisons as possible into short-circuit
julia-syntax.scm:(define (expand-vector-compare e)
julia-syntax.scm:  (comp-accum e
julia-syntax.scm:                (if (dotop-named? (cadr e))
julia-syntax.scm:                    (compare-one e)
julia-syntax.scm:                    (expand-scalar-compare e)))))
julia-syntax.scm:(define (expand-compare-chain e)
julia-syntax.scm:  (car (expand-vector-compare e)))
julia-syntax.scm:(define (end-val a n tuples last)
julia-syntax.scm:      (let ((dimno `(call (top +) ,(- n (length tuples))
julia-syntax.scm:(define (begin-val a n tuples last)
julia-syntax.scm:      (let ((dimno `(call (top +) ,(- n (length tuples))
julia-syntax.scm:(define (replace-beginend ex a n tuples last)
julia-syntax.scm:  (cond ((eq? ex 'end)                (end-val a n tuples last))
julia-syntax.scm:        ((eq? ex 'begin)              (begin-val a n tuples last))
julia-syntax.scm:         (list* 'ref (replace-beginend (cadr ex) a n tuples last)
julia-syntax.scm:               (map (lambda (x) (replace-beginend x a n tuples last))
julia-syntax.scm:;; returns (values index-list stmts) where stmts are statements that need
julia-syntax.scm:(define (process-indices a i)
julia-syntax.scm:              (if (symbol-like? (cadr idx))
julia-syntax.scm:                        (cons `(... ,(replace-beginend (cadr idx) a n tuples last))
julia-syntax.scm:                  (let ((g (make-ssavalue)))
julia-syntax.scm:                          (cons `(= ,g ,(replace-beginend (cadr idx) a n tuples last))
julia-syntax.scm:                    (cons (replace-beginend idx a n tuples last) ret)))))))
julia-syntax.scm:(define (method-lambda-expr argl body rett)
julia-syntax.scm:                     (let ((n (arg-name x)))
julia-syntax.scm:                       (if (underscore-symbol? n) UNUSED n)))
julia-syntax.scm:             (scope-block
julia-syntax.scm:                   (let ((meta (take-while (lambda (x) (and (pair? x)
julia-syntax.scm:                         (R (make-ssavalue)))
julia-syntax.scm:                       (meta ret-type ,R)
julia-syntax.scm:                       ,@(list-tail body (+ 1 (length meta))))))))))
julia-syntax.scm:;; convert x<:T<:y etc. exprs into (name lower-bound upper-bound)
julia-syntax.scm:(define (analyze-typevar e)
julia-syntax.scm:  (define (check-sym s)
julia-syntax.scm:  (cond ((atom? e) (list (check-sym e) #f #f))
julia-syntax.scm:        ((eq? (car e) 'var-bounds)  (cdr e))
julia-syntax.scm:         (cons (check-sym (cadddr e))
julia-syntax.scm:         (list (check-sym (cadr e)) #f (caddr e)))
julia-syntax.scm:         (list (check-sym (cadr e)) (caddr e) #f))
julia-syntax.scm:(define (sparam-name-bounds params)
julia-syntax.scm:  (let ((bounds (map analyze-typevar params)))
julia-syntax.scm:(define (unmangled-name v)
julia-syntax.scm:            (symbol (last (string-split s "#")))
julia-syntax.scm:(define (bounds-to-TypeVar v (unmangle #f))
julia-syntax.scm:  (let ((v  ((if unmangle unmangled-name identity) (car v)))
julia-syntax.scm:(define (method-expr-name m)
julia-syntax.scm:(define (method-expr-static-parameters m)
julia-syntax.scm:  (let ((type-ex (caddr m)))
julia-syntax.scm:    (if (eq? (car type-ex) 'block)
julia-syntax.scm:        ;; extract ssavalue labels of sparams from the svec-of-sparams argument to `method`
julia-syntax.scm:        (let ((sp-ssavals (cddr (cadddr (last type-ex)))))
julia-syntax.scm:                         (and (pair? e) (eq? (car e) '=) (member (cadr e) sp-ssavals)))
julia-syntax.scm:                       (cdr type-ex))))
julia-syntax.scm:(define (nodot-sym-ref? e)
julia-syntax.scm:(define (sym-ref? e)
julia-syntax.scm:  (or (nodot-sym-ref? e)
julia-syntax.scm:            (or (atom? (cadr e)) (sym-ref? (cadr e)))
julia-syntax.scm:(define (sym-ref-or-overlay? e)
julia-syntax.scm:      (sym-ref? e)))
julia-syntax.scm:(define (dots->vararg a)
julia-syntax.scm:(define (replace-vars e renames)
julia-syntax.scm:        ((memq (car e) '(-> function scope-block)) e)
julia-syntax.scm:               (map (lambda (x) (replace-vars x renames))
julia-syntax.scm:(define (make-generator-function name sp-names arg-names body)
julia-syntax.scm:  (let ((arg-names (append sp-names
julia-syntax.scm:                                arg-names))))
julia-syntax.scm:    (let ((body (insert-after-meta body  ;; don't specialize on generator arguments
julia-syntax.scm:                                   `((meta nospecialize ,@arg-names)))))
julia-syntax.scm:        (function (call ,name ,@arg-names) ,body)))))
julia-syntax.scm:(define (generated-part- x genpart)
julia-syntax.scm:  (cond ((or (atom? x) (quoted? x) (function-def? x)) x)
julia-syntax.scm:        ((if-generated? x)
julia-syntax.scm:                    (map (lambda (e) (generated-part- e genpart)) (cdr x))))))
julia-syntax.scm:(define (generated-version body)
julia-syntax.scm:    ,(julia-bq-macro (generated-part- body #t))))
julia-syntax.scm:(define (non-generated-version body)
julia-syntax.scm:  (generated-part- body #f))
julia-syntax.scm:(define (maybe-remove-functionloc! body)
julia-syntax.scm:  (let* ((prologue (extract-method-prologue body))
julia-syntax.scm:         (prologue-lnos (filter linenum? prologue))
julia-syntax.scm:         (functionloc (if (pair? prologue-lnos)
julia-syntax.scm:                          (car prologue-lnos)
julia-syntax.scm:                          ; Fallback - take first line anywhere in body
julia-syntax.scm:    (if (length> prologue-lnos 1)
julia-syntax.scm:              (set-cdr! stmts (cddr stmts))
julia-syntax.scm:(define (method-def-expr- name sparams argl body (rett '(core Any)))
julia-syntax.scm:         (optional-positional-defs name sparams req opt dfl body
julia-syntax.scm:          (anames (map (lambda (x) (if (underscore-symbol? x) UNUSED x)) (llist-vars argl)))
julia-syntax.scm:          (ename (if (nodot-sym-ref? name) name
julia-syntax.scm:     (if (has-dups unused_anames)
julia-syntax.scm:         (error (string "function argument name not unique: \"" (car (has-dups unused_anames)) "\"")))
julia-syntax.scm:     (if (has-dups names)
julia-syntax.scm:     (if (or (and name (not (sym-ref-or-overlay? name))) (not (valid-name? name)))
julia-syntax.scm:     (let* ((loc (maybe-remove-functionloc! body))
julia-syntax.scm:            (generator (if (expr-contains-p if-generated? body (lambda (x) (not (function-def? x))))
julia-syntax.scm:                           (let* ((gen    (generated-version body))
julia-syntax.scm:                                  (nongen (non-generated-version body))
julia-syntax.scm:                                  (gname  (symbol (string (gensy) "#" (current-julia-module-counter))))
julia-syntax.scm:                                  (gf     (make-generator-function gname names anames gen)))
julia-syntax.scm:                             (set! body (insert-after-meta
julia-syntax.scm:            (types (llist-types argl))
julia-syntax.scm:            (body  (method-lambda-expr argl body rett))
julia-syntax.scm:            ;; might be moved to a different scope by closure-convert.
julia-syntax.scm:            (temps (map (lambda (x) (make-ssavalue)) names))
julia-syntax.scm:                                (call (core svec) ,@(dots->vararg types))
julia-syntax.scm:                                        (sp      (map bounds-to-TypeVar sparams))
julia-syntax.scm:                                         (cons (make-assignment (car t) (replace-vars (car sp) ren))
julia-syntax.scm:                                                   ,@(dots->vararg
julia-syntax.scm:                                                             (replace-vars ty renames))
julia-syntax.scm:(define (keywords-method-def-expr name sparams argl body rett)
julia-syntax.scm:         (annotations (map (lambda (a) `(meta ,(cadr a) ,(arg-name (cadr (caddr a)))))
julia-syntax.scm:                           (filter nospecialize-meta? kargl)))
julia-syntax.scm:                       (if (nospecialize-meta? a) (caddr a) a))
julia-syntax.scm:         (ftype (decl-type (car pargl)))
julia-syntax.scm:         ;; 1-element list of vararg argument, or empty if none
julia-syntax.scm:                        (l- (if (kwarg? l) (cadr l) l)))
julia-syntax.scm:                   (if (or (vararg? l-) (varargexpr? l-))
julia-syntax.scm:         (splatted-vararg (if (null? vararg) '()
julia-syntax.scm:                              (list `(... ,(arg-name (car vararg))))))
julia-syntax.scm:         (pargl-all pargl)
julia-syntax.scm:         (not-optional (map (lambda (a)
julia-syntax.scm:                      (error "invalid \"...\" on non-final keyword argument"))
julia-syntax.scm:         (keynames (map decl-var vars))
julia-syntax.scm:         (ordered-defaults (any (lambda (v) (contains
julia-syntax.scm:         (prologue (extract-method-prologue body))
julia-syntax.scm:         (positional-sparams (filter-sparams (cons 'list pargl-all) sparams))
julia-syntax.scm:         (keyword-sparams
julia-syntax.scm:                              positional-sparams)))
julia-syntax.scm:         (rkw     (if (null? restkw) (make-ssavalue) (symbol (string (car restkw) "..."))))
julia-syntax.scm:         (mangled (let ((und (and name (undot-name name))))
julia-syntax.scm:                                    (string (current-julia-module-counter)))))))
julia-syntax.scm:        ;; forward-declare function so its type can occur in the signature of the inner method below
julia-syntax.scm:        ;; call with keyword args pre-sorted - original method code goes here
julia-syntax.scm:        ,(method-def-expr-
julia-syntax.scm:            ;; then it is ok for cl-convert to move this definition above the original def.
julia-syntax.scm:            ,@not-optional ,@vararg)
julia-syntax.scm:          (insert-after-meta `(block
julia-syntax.scm:        ,(method-def-expr-
julia-syntax.scm:          name positional-sparams pargl-all
julia-syntax.scm:            ,@(without-generated prologue)
julia-syntax.scm:                                       ,@(if ordered-defaults keynames vals)
julia-syntax.scm:                                       ,@(map arg-name pargl)
julia-syntax.scm:                                       ,@splatted-vararg))))
julia-syntax.scm:               (if ordered-defaults
julia-syntax.scm:        ;; call with unsorted keyword args. this sorts and re-dispatches.
julia-syntax.scm:        ,(method-def-expr-
julia-syntax.scm:          name positional-sparams
julia-syntax.scm:                   (filter nospecialize-meta? prologue))
julia-syntax.scm:                     (let* ((k     (decl-var v))
julia-syntax.scm:                            ;; from keyword-sparams then don't assert it here, since those
julia-syntax.scm:                                                       (expr-contains-eq (car s) (caddr v)))
julia-syntax.scm:                                                     keyword-sparams)))
julia-syntax.scm:                                            (temp (make-ssavalue)))
julia-syntax.scm:                            (call (top kwerr) ,kw ,@(map arg-name pargl) ,@splatted-vararg)))
julia-syntax.scm:                              ,@(map arg-name pargl)
julia-syntax.scm:                              ,@splatted-vararg))))))
julia-syntax.scm:(define (extract-method-prologue body)
julia-syntax.scm:      (take-while (lambda (e)
julia-syntax.scm:(define (without-generated stmts)
julia-syntax.scm:  (filter (lambda (x) (not (or (generated-meta? x)
julia-syntax.scm:                               (generated_only-meta? x))))
julia-syntax.scm:(define (filter-sparams expr sparams)
julia-syntax.scm:          ((or (expr-contains-eq (caar params) expr)
julia-syntax.scm:               (any (lambda (v) (expr-contains-eq (caar params) v))
julia-syntax.scm:(define (optional-positional-defs name sparams req opt dfl body overall-argl rett)
julia-syntax.scm:  (let ((prologue (without-generated (extract-method-prologue body))))
julia-syntax.scm:               (let* ((passed (append req (list-head opt n)))
julia-syntax.scm:                      (sp     (filter-sparams (cons 'list passed) sparams))
julia-syntax.scm:                      (vals   (list-tail dfl n))
julia-syntax.scm:                      (absent (list-tail opt n)) ;; absent arguments
julia-syntax.scm:                             (call ,(arg-name (car req)) ,@(map arg-name (cdr passed)) ,(car vals)))
julia-syntax.scm:                             (call ,(arg-name (car req)) ,@(map arg-name (cdr passed)) ,@vals)))))
julia-syntax.scm:                 (method-def-expr- name sp passed body)))
julia-syntax.scm:      ,(method-def-expr- name sparams overall-argl body rett))))
julia-syntax.scm:(define (remove-empty-parameters argl)
julia-syntax.scm:  (if (and (has-parameters? argl) (null? (cdar argl)))
julia-syntax.scm:(define (check-kw-args kw)
julia-syntax.scm:                                              (and (nospecialize-meta? x)
julia-syntax.scm:(define (throw-unassigned-kw-args argl)
julia-syntax.scm:  (define (throw-unassigned argname)
julia-syntax.scm:  (define (to-kw x)
julia-syntax.scm:    (cond ((symdecl? x) `(kw ,x ,(throw-unassigned (decl-var x))))
julia-syntax.scm:          ((nospecialize-meta? x) `(meta ,(cadr x) ,(to-kw (caddr x))))
julia-syntax.scm:  (if (has-parameters? argl)
julia-syntax.scm:                  (map to-kw (cdar argl)))
julia-syntax.scm:;; method-def-expr checks for keyword arguments, and if there are any, calls
julia-syntax.scm:;; keywords-method-def-expr to expand the definition into several method
julia-syntax.scm:;; definitions without keyword arguments are passed to method-def-expr-,
julia-syntax.scm:(define (method-def-expr name sparams argl body rett)
julia-syntax.scm:  (let ((argl (throw-unassigned-kw-args (remove-empty-parameters argl))))
julia-syntax.scm:    (if (has-parameters? argl)
julia-syntax.scm:        (begin (check-kw-args (cdar argl))
julia-syntax.scm:               (keywords-method-def-expr name sparams argl body rett))
julia-syntax.scm:        (method-def-expr- name sparams argl body rett))))
julia-syntax.scm:(define (struct-def-expr name params super fields mut)
julia-syntax.scm:   (params bounds) (sparam-name-bounds params)
julia-syntax.scm:   (struct-def-expr- name params bounds super (flatten-blocks fields) mut)))
julia-syntax.scm:;; replace field names with gensyms if they conflict with field-types
julia-syntax.scm:(define (safe-field-names field-names field-types)
julia-syntax.scm:  (if (any (lambda (v) (contains (lambda (e) (eq? e v)) field-types))
julia-syntax.scm:           field-names)
julia-syntax.scm:      (map (lambda (x) (gensy)) field-names)
julia-syntax.scm:      (map (lambda (x) (if (eq? x '_) (gensy) x)) field-names)))
julia-syntax.scm:(define (with-wheres call wheres)
julia-syntax.scm:(define (default-inner-ctors name field-names field-types params bounds locs)
julia-syntax.scm:  (let* ((field-names (safe-field-names field-names field-types))
julia-syntax.scm:         (any-ctor
julia-syntax.scm:          `(function ,(with-wheres
julia-syntax.scm:                              ,@field-names)
julia-syntax.scm:                       (map (lambda (b) (cons 'var-bounds b)) bounds))
julia-syntax.scm:                      (call new ,@field-names)))))
julia-syntax.scm:                                 field-types))
julia-syntax.scm:                      `(call (core ===) (core Any) ,(car field-types))
julia-syntax.scm:                      (cdr field-types))
julia-syntax.scm:                            ,@(map make-decl field-names field-types))
julia-syntax.scm:                       (new (outerref ,name) ,@field-names))))
julia-syntax.scm:         any-ctor)
julia-syntax.scm:        (list any-ctor))))
julia-syntax.scm:(define (default-outer-ctor name field-names field-types params bounds locs)
julia-syntax.scm:  (let ((field-names (safe-field-names field-names field-types)))
julia-syntax.scm:    `(function ,(with-wheres
julia-syntax.scm:                 `(call ,name ,@(map make-decl field-names field-types))
julia-syntax.scm:                 (map (lambda (b) (cons 'var-bounds b)) bounds))
julia-syntax.scm:                (call (curly ,name ,@params) ,@field-names)))))
julia-syntax.scm:(define (num-non-varargs args)
julia-syntax.scm:(define (new-call Tname type-params sparams params args field-names field-types)
julia-syntax.scm:  (let ((nnv (num-non-varargs type-params)))
julia-syntax.scm:    (if (and (not (any vararg? type-params)) (length> params nnv))
julia-syntax.scm:  (let* ((Texpr (if (null? type-params)
julia-syntax.scm:                            ,@type-params)))
julia-syntax.scm:         (tn (make-ssavalue))
julia-syntax.scm:         (field-convert (lambda (fld fty val)
julia-syntax.scm:                                     ,(if (and (equal? type-params params) (memq fty params) (memq fty sparams))
julia-syntax.scm:                                              ; local variable (currently just handles sparam) for the bijection of params to type-params
julia-syntax.scm:    (cond ((> (num-non-varargs args) (length field-names))
julia-syntax.scm:                                     ,(string "new: too many arguments (expected " (length field-names) ")"))))
julia-syntax.scm:                      field-types)
julia-syntax.scm:               (let ((argt (make-ssavalue))
julia-syntax.scm:                     (nf (make-ssavalue)))
julia-syntax.scm:                   (if (call (top ult_int) ,nf ,(length field-names))
julia-syntax.scm:                                                ,(string "new: too few arguments (expected " (length field-names) ")"))))
julia-syntax.scm:                   (if (call (top ult_int) ,(length field-names) ,nf)
julia-syntax.scm:                                                ,(string "new: too many arguments (expected " (length field-names) ")"))))
julia-syntax.scm:                   (new ,tn ,@(map (lambda (fld fty) (field-convert fld fty `(call (core getfield) ,argt ,(+ fld 1) (false))))
julia-syntax.scm:                                   (iota (length field-names)) (list-head field-types (length field-names))))))))
julia-syntax.scm:              (new ,tn ,@(map field-convert (iota (length args)) (list-head field-types (length args)) args)))))))
julia-syntax.scm:(define (arglist-unshift sig item)
julia-syntax.scm:(define (linenode-string lno)
julia-syntax.scm:(define (ctor-def name Tname ctor-body sig body wheres)
julia-syntax.scm:         (sparams (map car (map analyze-typevar wheres))))
julia-syntax.scm:           `(function ,(with-wheres `(call ,(if curly?
julia-syntax.scm:                      ;; pass '() in order to require user-specified parameters with
julia-syntax.scm:                      ;; new{...} inside a non-ctor inner definition.
julia-syntax.scm:                      ,(ctor-body body '() sparams)))
julia-syntax.scm:           `(function ,(with-wheres `(call ,(if curly?
julia-syntax.scm:                      ,(ctor-body body curlyargs sparams))))))
julia-syntax.scm:(define (rewrite-ctor ctor Tname params field-names field-types)
julia-syntax.scm:  (define (ctor-body body type-params sparams)
julia-syntax.scm:    (pattern-replace (pattern-set
julia-syntax.scm:                      (pattern-lambda
julia-syntax.scm:                       (call (-/ new) . args)
julia-syntax.scm:                       (new-call Tname type-params sparams params
julia-syntax.scm:                                 (map (lambda (a) (ctor-body a type-params sparams)) args)
julia-syntax.scm:                                 field-names field-types))
julia-syntax.scm:                      (pattern-lambda
julia-syntax.scm:                       (call (curly (-/ new) . p) . args)
julia-syntax.scm:                       (new-call Tname p sparams params
julia-syntax.scm:                                 (map (lambda (a) (ctor-body a type-params sparams)) args)
julia-syntax.scm:                                 field-names field-types)))
julia-syntax.scm:  (pattern-replace
julia-syntax.scm:   (pattern-set
julia-syntax.scm:    (pattern-lambda (function       (-$ (call name . sig) (|::| (call name . sig) _t)) body)
julia-syntax.scm:                    (ctor-def name Tname ctor-body sig body #f))
julia-syntax.scm:    (pattern-lambda (= (-$ (call name . sig) (|::| (call name . sig) _t)) body)
julia-syntax.scm:                    (ctor-def name Tname ctor-body sig body #f))
julia-syntax.scm:    (pattern-lambda (function       (where (-$ (call name . sig) (|::| (call name . sig) _t)) . wheres) body)
julia-syntax.scm:                    (ctor-def name Tname ctor-body sig body wheres))
julia-syntax.scm:    (pattern-lambda (= (where (-$ (call name . sig) (|::| (call name . sig) _t)) . wheres) body)
julia-syntax.scm:                    (ctor-def name Tname ctor-body sig body wheres)))
julia-syntax.scm:   (pattern-replace
julia-syntax.scm:    (pattern-set
julia-syntax.scm:     (pattern-lambda (where (where . rest1) . rest2)
julia-syntax.scm:                     (flatten-where-expr __)))
julia-syntax.scm:(define (ctors-min-initialized expr)
julia-syntax.scm:        ((pattern-lambda (call (-/ new) . args)
julia-syntax.scm:        ((pattern-lambda (call (curly (-/ new) . p) . args)
julia-syntax.scm:        (ctors-min-initialized (car expr))
julia-syntax.scm:        (ctors-min-initialized (cdr expr)))))
julia-syntax.scm:(define (struct-def-expr- name params bounds super fields0 mut)
julia-syntax.scm:   (fields defs) (separate (lambda (x) (or (symbol? x) (eventually-decl? x)))
julia-syntax.scm:          (defs        (filter (lambda (x) (not (effect-free? x))) defs))
julia-syntax.scm:          (field-names (map decl-var fields))
julia-syntax.scm:          (field-types (map decl-type fields))
julia-syntax.scm:                     (default-inner-ctors name field-names field-types params bounds locs)
julia-syntax.scm:          (min-initialized (min (ctors-min-initialized defs) (length fields)))
julia-syntax.scm:          (prev (make-ssavalue)))
julia-syntax.scm:     (let ((dups (has-dups field-names)))
julia-syntax.scm:     (for-each (lambda (v)
julia-syntax.scm:               field-names)
julia-syntax.scm:       (scope-block
julia-syntax.scm:         (local-def ,name)
julia-syntax.scm:         ,@(map (lambda (n v) (make-assignment n (bounds-to-TypeVar v #t))) params bounds)
julia-syntax.scm:         (toplevel-only struct (outerref ,name))
julia-syntax.scm:                        (call (core svec) ,@(map quotify field-names))
julia-syntax.scm:                        ,mut ,min-initialized))
julia-syntax.scm:         (call (core _typebody!) ,name (call (core svec) ,@field-types))
julia-syntax.scm:       (scope-block
julia-syntax.scm:                  (rewrite-ctor c name params field-names field-types))
julia-syntax.scm:                  (let loop ((root-types field-types)
julia-syntax.scm:                          (and (expr-contains-eq (car p) (cons 'list root-types))
julia-syntax.scm:                               (loop (append (cdr p) root-types)
julia-syntax.scm:             `((scope-block
julia-syntax.scm:                 ,(default-outer-ctor name field-names field-types
julia-syntax.scm:(define (abstract-type-def-expr name params super)
julia-syntax.scm:   (params bounds) (sparam-name-bounds params)
julia-syntax.scm:     (scope-block
julia-syntax.scm:       (local-def ,name)
julia-syntax.scm:       ,@(map (lambda (n v) (make-assignment n (bounds-to-TypeVar v #t))) params bounds)
julia-syntax.scm:       (toplevel-only abstract_type)
julia-syntax.scm:(define (primitive-type-def-expr n name params super)
julia-syntax.scm:   (params bounds) (sparam-name-bounds params)
julia-syntax.scm:     (scope-block
julia-syntax.scm:       (local-def ,name)
julia-syntax.scm:       ,@(map (lambda (n v) (make-assignment n (bounds-to-TypeVar v #t))) params bounds)
julia-syntax.scm:       (toplevel-only primitive_type)
julia-syntax.scm:(define (analyze-type-sig ex)
julia-syntax.scm:  (or ((pattern-lambda (-- name (-s))
julia-syntax.scm:      ((pattern-lambda (curly (-- name (-s)) . params)
julia-syntax.scm:      ((pattern-lambda (|<:| (-- name (-s)) super)
julia-syntax.scm:      ((pattern-lambda (|<:| (curly (-- name (-s)) . params) super)
julia-syntax.scm:(define (lower-ccall name RT atypes args cconv)
julia-syntax.scm:                         ,(if isseq (- (length atypes) 1) 0) ; 0 or number of arguments before ... in definition
julia-syntax.scm:                (let* ((g (make-ssavalue))
julia-syntax.scm:(define (expand-function-def e)   ;; handle function definitions
julia-syntax.scm:  (define (just-arglist? ex)
julia-syntax.scm:                  (just-arglist? (cadr ex))))))
julia-syntax.scm:    (if (just-arglist? name)
julia-syntax.scm:        (expand-forms (cons '-> (cdr e)))
julia-syntax.scm:        (expand-function-def- e))))
julia-syntax.scm:(define (flatten-where-expr e)
julia-syntax.scm:(define (lower-destructuring-args argl)
julia-syntax.scm:  (define (check-lhs a)
julia-syntax.scm:    (if (expr-contains-p (lambda (e) (or (decl? e) (assignment? e) (kwarg? e)))
julia-syntax.scm:  (define (transform-arg a)
julia-syntax.scm:             (cons a2 `(local (= ,(check-lhs a) ,a2)))))
julia-syntax.scm:           (let ((x (transform-arg (cadr a))))
julia-syntax.scm:           (let ((x (transform-arg (cadr a))))
julia-syntax.scm:        (let ((a (transform-arg (car argl))))
julia-syntax.scm:(define (expand-function-def- e)
julia-syntax.scm:                    (let ((w (flatten-where-expr name)))
julia-syntax.scm:           (if (not (valid-name? name))
julia-syntax.scm:           (let* ((raw-typevars (or where '()))
julia-syntax.scm:                  (sparams (map analyze-typevar raw-typevars))
julia-syntax.scm:                  (annotations (map (lambda (a) `(meta ,(cadr a) ,(arg-name (caddr a))))
julia-syntax.scm:                                    (filter nospecialize-meta? argl)))
julia-syntax.scm:                  (body (insert-after-meta (caddr e) annotations))
julia-syntax.scm:                               (if (nospecialize-meta? a) (caddr a) a))
julia-syntax.scm:                  (argl-stmts (lower-destructuring-args argl))
julia-syntax.scm:                  (argl       (car argl-stmts))
julia-syntax.scm:                  (name       (check-dotop (car argl)))
julia-syntax.scm:                  (adj-decl (lambda (n) (if (and (decl? n) (length= n 2))
julia-syntax.scm:                               (adj-decl argname)
julia-syntax.scm:                  (body       (insert-after-meta body (cdr argl-stmts)))
julia-syntax.scm:                  (argl    (fix-arglist
julia-syntax.scm:                            (arglist-unshift argl farg)
julia-syntax.scm:             (expand-forms
julia-syntax.scm:              (method-def-expr name sparams argl body rett))))
julia-syntax.scm:;; handle ( )->( ) function expressions. blocks `(a;b=1)` on the left need to be
julia-syntax.scm:(define (expand-arrow e)
julia-syntax.scm:                    (let ((w (flatten-where-expr a)))
julia-syntax.scm:                   (tuple-to-arglist (filter (lambda (x) (not (linenum? x))) a))
julia-syntax.scm:         (name (symbol (string "#" (current-julia-module-counter)))))
julia-syntax.scm:    (expand-forms
julia-syntax.scm:(define (let-binds e)
julia-syntax.scm:(define (expand-let e (hard? #t))
julia-syntax.scm:        (binds (let-binds e))
julia-syntax.scm:    (expand-forms
julia-syntax.scm:      `(scope-block (block ,@hs ,ex))
julia-syntax.scm:              ;; just symbol -> add local
julia-syntax.scm:                    `(scope-block
julia-syntax.scm:               ((eventually-call? (cadar binds))
julia-syntax.scm:                (let ((name (assigned-name (cadar binds))))
julia-syntax.scm:                        `(scope-block
julia-syntax.scm:                           ,(if (expr-contains-eq name (caddar binds))
julia-syntax.scm:                                `(local-def ,name))
julia-syntax.scm:                (let ((vname (decl-var (cadar binds))))
julia-syntax.scm:                        (let ((tmp (make-ssavalue)))
julia-syntax.scm:                                  (scope-block
julia-syntax.scm:                                          (local-def ,(cadar binds))
julia-syntax.scm:                (let ((vars (lhs-vars (cadar binds))))
julia-syntax.scm:                        (let ((tmp (make-ssavalue)))
julia-syntax.scm:                                  (scope-block
julia-syntax.scm:                                          ,@(map (lambda (v) `(local-def ,v)) vars)
julia-syntax.scm:(define (expand-macro-def e)
julia-syntax.scm:         (let ((anames (remove-empty-parameters (cddr (cadr e)))))
julia-syntax.scm:           (if (has-parameters? anames)
julia-syntax.scm:           (expand-forms
julia-syntax.scm:         (expand-forms `(function ,(symbol (string #\@ (cadr e))))))
julia-syntax.scm:(define (expand-struct-def e)
julia-syntax.scm:    (expand-forms
julia-syntax.scm:     (receive (name params super) (analyze-type-sig sig)
julia-syntax.scm:              (struct-def-expr name params super fields mut)))))
julia-syntax.scm:(define (find-symbolic-label-defs e tbl)
julia-syntax.scm:          (for-each (lambda (x) (find-symbolic-label-defs x tbl)) e))))
julia-syntax.scm:(define (find-symbolic-label-refs e tbl)
julia-syntax.scm:          (for-each (lambda (x) (find-symbolic-label-refs x tbl)) e))))
julia-syntax.scm:(define (has-unmatched-symbolic-goto? e)
julia-syntax.scm:  (let ((label-refs (table))
julia-syntax.scm:        (label-defs (table)))
julia-syntax.scm:    (find-symbolic-label-refs e label-refs)
julia-syntax.scm:    (find-symbolic-label-defs e label-defs)
julia-syntax.scm:    (any not (map (lambda (k) (get label-defs k #f))
julia-syntax.scm:                  (table.keys label-refs)))))
julia-syntax.scm:(define (expand-try e)
julia-syntax.scm:           (if (has-unmatched-symbolic-goto? tryb)
julia-syntax.scm:             (expand-forms
julia-syntax.scm:                     `(scope-block ,tryb))
julia-syntax.scm:                (scope-block ,finalb)))))
julia-syntax.scm:           (expand-forms
julia-syntax.scm:            (if (symbol-like? var)
julia-syntax.scm:                `(trycatch (scope-block ,tryb)
julia-syntax.scm:                           (scope-block
julia-syntax.scm:                `(trycatch (scope-block ,tryb)
julia-syntax.scm:                           (scope-block ,catchb)))))
julia-syntax.scm:(define (expand-unionall-def name type-ex)
julia-syntax.scm:            (error (string "empty type parameter list in \"" (deparse `(= (curly ,name) ,type-ex)) "\"")))
julia-syntax.scm:          (const-if-global ,name)
julia-syntax.scm:          ,(expand-forms
julia-syntax.scm:            `(= ,name (where ,type-ex ,@params)))))
julia-syntax.scm:      (expand-forms
julia-syntax.scm:       `(const (= ,name ,type-ex)))))
julia-syntax.scm:(define (expand-const-decl e)
julia-syntax.scm:          ((global local local-def)
julia-syntax.scm:           (for-each (lambda (b) (if (not (assignment? b))
julia-syntax.scm:           (expand-forms (expand-decls (car arg) (cdr arg) #t)))
julia-syntax.scm:           (expand-forms (expand-decls 'const (cdr e) #f)))
julia-syntax.scm:(define (expand-atomic-decl e)
julia-syntax.scm:(define (expand-local-or-global-decl e)
julia-syntax.scm:      (expand-forms (expand-decls (car e) (cdr e) #f))))
julia-syntax.scm:(define (assigned-name e)
julia-syntax.scm:             (and (eq? (car e) '|::|) (eventually-call? e)))
julia-syntax.scm:         (assigned-name (cadr e)))
julia-syntax.scm:(define (expand-decls what binds const?)
julia-syntax.scm:          (cond ((or (assignment-like? x) (function-def? x))
julia-syntax.scm:                       (append (lhs-decls (assigned-name (cadr x))) vars)
julia-syntax.scm:                       (cons `(,(car x) ,(all-decl-vars (cadr x)) ,(caddr x))
julia-syntax.scm:                       (cons (decl-var x) vars)
julia-syntax.scm:(define (tuple-to-assignments lhss0 x)
julia-syntax.scm:          (cond ((and (symbol-like? L)
julia-syntax.scm:                      (not (contains (lambda (e) (eq-sym? e L)) (cdr rhss)))
julia-syntax.scm:                      (not (contains (lambda (e) (eq-sym? e R)) assigned)))
julia-syntax.scm:                       (cons (make-assignment L R) stmts)
julia-syntax.scm:                     (let ((temp (if (eventually-call? (cadr L)) (gensy) (make-ssavalue))))
julia-syntax.scm:                     (error (string "invalid \"...\" on non-final assignment location \""
julia-syntax.scm:                 (let ((temp (make-ssavalue)))
julia-syntax.scm:                           ,(make-assignment temp (cadr R))
julia-syntax.scm:                 (let ((temp (if (eventually-call? L) (gensy) (make-ssavalue))))
julia-syntax.scm:                             (list* (make-assignment temp R) `(local-def ,temp) stmts)
julia-syntax.scm:                             (cons  (make-assignment temp R) stmts))
julia-syntax.scm:                         (cons (make-assignment L temp) after)
julia-syntax.scm:(define (lower-tuple-assignment lhss x)
julia-syntax.scm:  (let ((t (make-ssavalue)))
julia-syntax.scm:              (cons (if (eventually-call? (car lhs))
julia-syntax.scm:                        ;; inside the function and instead create a capture-able variable.
julia-syntax.scm:                            (local-def ,temp)
julia-syntax.scm:(define (remove-argument-side-effects e (tup #f))
julia-syntax.scm:        (define (arg-to-temp x)
julia-syntax.scm:          (cond ((effect-free? x)  x)
julia-syntax.scm:                 `(,(car x) ,(arg-to-temp (cadr x))))
julia-syntax.scm:                 `(,(car x) ,(cadr x) ,(arg-to-temp (caddr x))))
julia-syntax.scm:                 `(parameters ,@(map arg-to-temp (cdr x))))
julia-syntax.scm:                 (let ((tmp (remove-argument-side-effects x #t)))
julia-syntax.scm:                 (let ((g (make-ssavalue)))
julia-syntax.scm:        (cons (cons (car e) (map arg-to-temp (cdr e)))
julia-syntax.scm:(define (lower-kw-call f args)
julia-syntax.scm:  (let* ((para (if (has-parameters? args) (cdar args) '()))
julia-syntax.scm:         (args (if (has-parameters? args) (cdr args) args)))
julia-syntax.scm:    (let* ((parg-stmts (remove-argument-side-effects `(call ,f ,@args)))
julia-syntax.scm:           (call-ex    (car parg-stmts))
julia-syntax.scm:           (fexpr      (cadr call-ex))
julia-syntax.scm:           (cargs      (cddr call-ex)))
julia-syntax.scm:        ,.(cdr parg-stmts)
julia-syntax.scm:          (lower-kw-call- fexpr (append! kws para) pargs))))))
julia-syntax.scm:(define (lower-kw-call- fexpr kw pa)
julia-syntax.scm:  (define (kwcall-unless-empty f pa kw-container-test kw-container)
julia-syntax.scm:    `(if (call (top isempty) ,kw-container-test)
julia-syntax.scm:         (call (call (core kwfunc) ,f) ,kw-container ,f ,@pa)))
julia-syntax.scm:  (let ((f            (if (sym-ref? fexpr) fexpr (make-ssavalue)))
julia-syntax.scm:        (kw-container (make-ssavalue)))
julia-syntax.scm:      (= ,kw-container ,(lower-named-tuple kw
julia-syntax.scm:           (kwcall-unless-empty f pa kw-container kw-container)
julia-syntax.scm:           `(call (call (core kwfunc) ,f) ,kw-container ,f ,@pa)))))
julia-syntax.scm:(define (expand-update-operator- op op= lhs rhs declT)
julia-syntax.scm:  (let* ((e      (remove-argument-side-effects lhs))
julia-syntax.scm:                      (make-ssavalue)))
julia-syntax.scm:              ;; if remove-argument-side-effects needed to replace an expression with
julia-syntax.scm:(define (partially-expand-ref e)
julia-syntax.scm:           (arr   (if reuse (make-ssavalue) a))
julia-syntax.scm:       (new-idxs stuff) (process-indices arr idxs)
julia-syntax.scm:         (call (top getindex) ,arr ,@new-idxs))))))
julia-syntax.scm:(define (expand-update-operator op op= lhs rhs . declT)
julia-syntax.scm:         (let* ((ex (partially-expand-ref lhs))
julia-syntax.scm:                   ,(expand-update-operator- op op= nuref rhs declT))))
julia-syntax.scm:         (let ((e (remove-argument-side-effects (cadr lhs)))
julia-syntax.scm:                   ,(expand-update-operator op op= (car e) rhs T))))
julia-syntax.scm:         (expand-update-operator- op op= lhs rhs declT))))
julia-syntax.scm:(define (lower-update-op e)
julia-syntax.scm:  (expand-forms
julia-syntax.scm:     (expand-update-operator
julia-syntax.scm:      (symbol (string.sub str 0 (- (length str) 1)))
julia-syntax.scm:(define (expand-and e)
julia-syntax.scm:  (let ((e (cdr (flatten-ex '&& e))))
julia-syntax.scm:(define (expand-or e)
julia-syntax.scm:  (let ((e (cdr (flatten-ex '|\|\|| e))))
julia-syntax.scm:              (if (symbol-like? (car tail))
julia-syntax.scm:                  (let ((g (make-ssavalue)))
julia-syntax.scm:(define (expand-for lhss itrs body)
julia-syntax.scm:  (let ((copied-vars  ;; variables not declared `outer` are copied in the innermost loop
julia-syntax.scm:         (delete-duplicates
julia-syntax.scm:          (filter (lambda (x) (not (underscore-symbol? x)))
julia-syntax.scm:                         (map lhs-vars
julia-syntax.scm:    `(break-block
julia-syntax.scm:      loop-exit
julia-syntax.scm:             (let* ((coll  (make-ssavalue))
julia-syntax.scm:                    (state (make-ssavalue))
julia-syntax.scm:                             (map (lambda (v) `(local ,v)) (lhs-vars lhs))
julia-syntax.scm:                       ,(lower-tuple-assignment (list lhs state) next)
julia-syntax.scm:                         `(break-block
julia-syntax.scm:                           loop-cont
julia-syntax.scm:                           (soft-let (block ,@(map (lambda (v) `(= ,v ,v)) copied-vars))
julia-syntax.scm:                         `(scope-block ,body))))
julia-syntax.scm:                       ,@(if outer `((require-existing-local ,lhs)) '())
julia-syntax.scm:(define (func-for-generator-ranges expr range-exprs flat outervars)
julia-syntax.scm:  (let* ((vars    (map cadr range-exprs))
julia-syntax.scm:         (myvars  (lhs-vars `(tuple ,@vars)))
julia-syntax.scm:      ;; use `identity` for x->x
julia-syntax.scm:           (underscore-symbol? argname)
julia-syntax.scm:           (not (dotop-named? (cadr expr)))
julia-syntax.scm:           (not (expr-contains-eq argname (cadr expr))))
julia-syntax.scm:      ;; eta reduce `_->f(_)` => `f`
julia-syntax.scm:                         (expand-generator expr #f (delete-duplicates (append outervars myvars))))
julia-syntax.scm:                         (expand-generator (cadr expr) #t (delete-duplicates (append outervars myvars))))
julia-syntax.scm:                         `(let (block ,@(map (lambda (v) `(= ,v ,v)) (filter (lambda (x) (not (underscore-symbol? x)))
julia-syntax.scm:        `(-> ,argname (block ,@splat ,expr)))))))
julia-syntax.scm:(define (expand-generator e flat outervars)
julia-syntax.scm:         (range-exprs (if filt? (cddr (caddr e)) (cddr e)))
julia-syntax.scm:         (ranges (map caddr range-exprs))
julia-syntax.scm:                          ,(func-for-generator-ranges (cadr (caddr e)) range-exprs #f '())
julia-syntax.scm:                      ,(func-for-generator-ranges expr range-exprs flat outervars)
julia-syntax.scm:    (expand-forms
julia-syntax.scm:(define (ref-to-view expr)
julia-syntax.scm:         (let* ((ex (partially-expand-ref expr))
julia-syntax.scm:; or a broadcast! call if lhs is non-null.
julia-syntax.scm:(define (expand-fuse-broadcast lhs rhs)
julia-syntax.scm:  (define (dot-to-fuse e (top #f)) ; convert e == (. f (tuple args)) to (fuse f args)
julia-syntax.scm:    (define (make-fuse f args) ; check for nested (fuse f args) exprs and combine
julia-syntax.scm:      (define (split-kwargs args) ; return (cons keyword-args positional-args) extracted from args
julia-syntax.scm:        (if (has-parameters? args)
julia-syntax.scm:      (let* ((kws+args (split-kwargs args)) ; fusing occurs on positional args only
julia-syntax.scm:             (args (map dot-to-fuse (cdr kws+args)))
julia-syntax.scm:                    (if (and (eq? (identifier-name f) '^) (length= x 3) (integer? (caddr x)))
julia-syntax.scm:                        (make-fuse '(top literal_pow)
julia-syntax.scm:                                   (list f (cadr x) (expand-forms `(call (call (core apply_type) (top Val) ,(caddr x))))))
julia-syntax.scm:                        (make-fuse f (cdr x))))
julia-syntax.scm:           (define (make-fuse- f x)
julia-syntax.scm:             (if (and (eq? (identifier-name f) '^) (length= x 2) (integer? (cadr x)))
julia-syntax.scm:                 (make-fuse '(top literal_pow)
julia-syntax.scm:                            (list f (car x) (expand-forms `(call (call (core apply_type) (top Val) ,(cadr x))))))
julia-syntax.scm:                 (make-fuse f x)))
julia-syntax.scm:             (cond ((dotop-named? f)
julia-syntax.scm:                    (make-fuse- (undotop f) (cddr e)))
julia-syntax.scm:                    (make-fuse- (cadr f) (cddr e)))
julia-syntax.scm:           (dot-to-fuse (expand-compare-chain (cdr e)) top))
julia-syntax.scm:           (make-fuse '(top andand) (cdr e)))
julia-syntax.scm:           (make-fuse '(top oror) (cdr e)))
julia-syntax.scm:  (let ((e (dot-to-fuse rhs #t)) ; an expression '(fuse func args) if expr is a dot call
julia-syntax.scm:        (lhs-view (ref-to-view lhs))) ; x[...] expressions on lhs turn in to view(x, ...) to update x in-place
julia-syntax.scm:            (expand-forms `(call (top materialize) ,(cdr e)))
julia-syntax.scm:            (expand-forms `(call (top materialize!) ,lhs-view ,(cdr e))))
julia-syntax.scm:            (expand-forms e)
julia-syntax.scm:            (expand-forms `(call (top materialize!) ,lhs-view
julia-syntax.scm:(define (expand-where body var)
julia-syntax.scm:  (let* ((bounds (analyze-typevar var))
julia-syntax.scm:    `(let (= ,v ,(bounds-to-TypeVar bounds))
julia-syntax.scm:(define (expand-wheres body vars)
julia-syntax.scm:      (expand-where (expand-wheres body (cdr vars)) (car vars))))
julia-syntax.scm:; (This implements the syntactic sugar Foo{<:Bar} --> Foo{T} where T<:Bar.)
julia-syntax.scm:(define (extract-implicit-whereparams e)
julia-syntax.scm:(define (named-tuple-expr names values)
julia-syntax.scm:(define (lower-named-tuple lst
julia-syntax.scm:                           (dup-error-fn (lambda (name) (string "field name \"" name "\" repeated in named tuple")))
julia-syntax.scm:                           (name-str     "named tuple field")
julia-syntax.scm:                           (syntax-str   "named tuple element")
julia-syntax.scm:                           (call-with-keyword-arguments? #f))
julia-syntax.scm:         (dups (has-dups names)))
julia-syntax.scm:        (error (dup-error-fn (car dups)))))
julia-syntax.scm:  (define (not-vararg x)
julia-syntax.scm:        (error (string "\"...\" expression cannot be used as " name-str " value"))
julia-syntax.scm:  (define (to-nt n v)
julia-syntax.scm:        (named-tuple-expr (reverse! (map quotify n)) (reverse v))))
julia-syntax.scm:             (current-names '())
julia-syntax.scm:             (current-vals  '())
julia-syntax.scm:        (or (merge expr (to-nt current-names current-vals))
julia-syntax.scm:                     (error (string "invalid " name-str " name \"" (deparse (cadr el)) "\"")))
julia-syntax.scm:                 (not-vararg (caddr el))
julia-syntax.scm:                       (cons (cadr el) current-names)
julia-syntax.scm:                       (cons (caddr el) current-vals)
julia-syntax.scm:                       (cons el current-names)
julia-syntax.scm:                       (cons el current-vals)
julia-syntax.scm:                      (quoted-sym? (caddr el)))
julia-syntax.scm:                       (cons (cadr (caddr el)) current-names)
julia-syntax.scm:                       (cons el current-vals)
julia-syntax.scm:                       (merge (merge expr (to-nt current-names current-vals))
julia-syntax.scm:                              (named-tuple-expr (list (caddr el)) (list (not-vararg (cadddr el)))))))
julia-syntax.scm:                       (let ((current (merge expr (to-nt current-names current-vals))))
julia-syntax.scm:                ((and call-with-keyword-arguments? (has-parameters? L))
julia-syntax.scm:                 (error (string "invalid " syntax-str " \"" (deparse el) "\""))))))))
julia-syntax.scm:(define (expand-condition cnd)
julia-syntax.scm:        (let* ((clauses `(,(car test) ,@(map expand-forms (cdr (flatten-ex (car test) test)))))
julia-syntax.scm:              `(block ,@(map expand-forms stmts) ,clauses)
julia-syntax.scm:        (expand-forms cnd))))
julia-syntax.scm:(define (expand-if e)
julia-syntax.scm:  (list* (car e) (expand-condition (cadr e)) (map expand-forms (cddr e))))
julia-syntax.scm:(define (expand-while e)
julia-syntax.scm:  `(break-block loop-exit
julia-syntax.scm:                (_while ,(expand-condition (cadr e))
julia-syntax.scm:                        (break-block loop-cont
julia-syntax.scm:                                     (scope-block ,(blockify (expand-forms (caddr e))))))))
julia-syntax.scm:(define (expand-vcat e
julia-syntax.scm:    (if (has-parameters? a)
julia-syntax.scm:        (expand-forms
julia-syntax.scm:(define (expand-ncat e (hvncat '((top hvncat))))
julia-syntax.scm:  (define (is-row a) (and (pair? a)
julia-syntax.scm:  (define (is-1d a) (not (any is-row a)))
julia-syntax.scm:  (define (get-shape a is-row-first d)
julia-syntax.scm:    (define (get-next x)
julia-syntax.scm:      (cond ((or (not (is-row x))
julia-syntax.scm:               (and (not is-row-first) (= d 1)))
julia-syntax.scm:          ((and is-row-first (= d 3))
julia-syntax.scm:           (get-shape a is-row-first (1- d)))
julia-syntax.scm:                        (get-shape (get-next x) is-row-first (1- d)))
julia-syntax.scm:  (define (get-dims a is-row-first d)
julia-syntax.scm:    (cond ((and (< d 2) (not (is-row (car a))))
julia-syntax.scm:           (list (car (get-dims (cdar a) is-row-first 0)) (length a)))
julia-syntax.scm:          ((and (= d 3) is-row-first)
julia-syntax.scm:           (get-dims a is-row-first 2))
julia-syntax.scm:             (cons (length a) (get-dims anext is-row-first (1- d)))))))
julia-syntax.scm:  (define (is-balanced s)
julia-syntax.scm:                                 (- z y))
julia-syntax.scm:  (define (hasrows-flatten a)
julia-syntax.scm:               (if (is-row x)
julia-syntax.scm:                       (let* ((raflat (append (hasrows-flatten (cddr x))))
julia-syntax.scm:         (raflat (hasrows-flatten a))
julia-syntax.scm:         (is-row-first (if (null? r) #f r))
julia-syntax.scm:    (if (has-parameters? aflat)
julia-syntax.scm:    (expand-forms
julia-syntax.scm:      (if (is-1d a)
julia-syntax.scm:              (let ((shape (get-shape a is-row-first d)))
julia-syntax.scm:                (if (is-balanced shape)
julia-syntax.scm:                    (let ((dims `(tuple ,@(reverse (get-dims a is-row-first d)))))
julia-syntax.scm:                     `(call ,@hvncat ,dims ,(tf is-row-first) ,@aflat))
julia-syntax.scm:                    `(call ,@hvncat ,(tuplize shape) ,(tf is-row-first) ,@aflat))))))))
julia-syntax.scm:(define (expand-property-destruct lhss x)
julia-syntax.scm:  (let* ((xx (if (symbol-like? x) x (make-ssavalue)))
julia-syntax.scm:         (ini (if (eq? x xx) '() (list (sink-assignment xx (expand-forms x))))))
julia-syntax.scm:               (expand-forms `(= ,field (call (top getproperty) ,xx (quote ,prop))))))
julia-syntax.scm:(define (expand-tuple-destruct lhss x)
julia-syntax.scm:  (define (sides-match? l r)
julia-syntax.scm:          (else               (sides-match? (cdr l) (cdr r)))))
julia-syntax.scm:           (not (has-parameters? (cdr x)))
julia-syntax.scm:           (sides-match? lhss (cdr x)))
julia-syntax.scm:      (expand-forms
julia-syntax.scm:       (tuple-to-assignments lhss x))
julia-syntax.scm:        (define (in-lhs? x lhss)
julia-syntax.scm:                           (error (string "invalid \"...\" on non-final assignment location \""
julia-syntax.scm:                      (else (in-lhs? x (cdr lhss)))))))
julia-syntax.scm:        ;; in-lhs? also checks for invalid syntax, so always call it first
julia-syntax.scm:        (let* ((xx  (cond ((or (and (not (in-lhs? x lhss)) (symbol? x))
julia-syntax.scm:                                (eventually-call? (cadr (last lhss))))
julia-syntax.scm:                          (else (make-ssavalue))))
julia-syntax.scm:               (ini (if (eq? x xx) '() (list (sink-assignment xx (expand-forms x)))))
julia-syntax.scm:               ;; skip last assignment if it is an all-underscore vararg
julia-syntax.scm:                          (if (and (vararg? l) (underscore-symbol? (cadr l)))
julia-syntax.scm:                              (- n 1)
julia-syntax.scm:                     (let ((lhs- (cond ((or (symbol? lhs) (ssavalue? lhs))
julia-syntax.scm:                                        (let ((lhs- (cadr lhs)))
julia-syntax.scm:                                          (if (or (symbol? lhs-) (ssavalue? lhs-))
julia-syntax.scm:                                              `(|...| ,(if (eventually-call? lhs-)
julia-syntax.scm:                                                           (make-ssavalue))))))
julia-syntax.scm:                                       ((eventually-call? lhs) (gensy))
julia-syntax.scm:                                       (else (make-ssavalue)))))
julia-syntax.scm:                       (if (not (eq? lhs lhs-))
julia-syntax.scm:                               (set! end (cons (expand-forms `(= ,(cadr lhs) ,(cadr lhs-))) end))
julia-syntax.scm:                               (set! end (cons (expand-forms `(= ,lhs ,lhs-)) end))))
julia-syntax.scm:                       (expand-forms
julia-syntax.scm:                         (if (vararg? lhs-)
julia-syntax.scm:                             `(= ,(cadr lhs-) (call (top rest) ,xx ,@(if (eq? i 0) '() `(,st))))
julia-syntax.scm:                             (lower-tuple-assignment
julia-syntax.scm:                               (if (= i (- n 1))
julia-syntax.scm:                                   (list lhs-)
julia-syntax.scm:                                   (list lhs- st))
julia-syntax.scm:(define (sink-assignment lhs rhs)
julia-syntax.scm:(define (expand-forms e)
julia-syntax.scm:  (if (or (atom? e) (memq (car e) '(quote inert top core globalref outerref module toplevel ssavalue null true false meta using import export thismodule toplevel-only)))
julia-syntax.scm:      (let ((ex (get expand-table (car e) #f)))
julia-syntax.scm:                  (map expand-forms (cdr e)))))))
julia-syntax.scm:(define expand-table
julia-syntax.scm:   'function       expand-function-def
julia-syntax.scm:   '->             expand-arrow
julia-syntax.scm:   'let            expand-let
julia-syntax.scm:   'soft-let       (lambda (e) (expand-let e #f))
julia-syntax.scm:   'macro          expand-macro-def
julia-syntax.scm:   'struct         expand-struct-def
julia-syntax.scm:   'try            expand-try
julia-syntax.scm:     `(lambda ,(map expand-forms (cadr e))
julia-syntax.scm:        ,@(map expand-forms (cddr e))))
julia-syntax.scm:     (let* ((meth (caddr (caddr (expand-forms (cadr e))))) ;; `method` expr
julia-syntax.scm:            (sig-block (caddr meth))
julia-syntax.scm:            (sig-block (if (and (pair? sig-block) (eq? (car sig-block) 'block))
julia-syntax.scm:                           sig-block
julia-syntax.scm:                           `(block ,sig-block)))
julia-syntax.scm:            (stmts     (cdr (butlast sig-block)))
julia-syntax.scm:            (sig-svec  (last sig-block))
julia-syntax.scm:            (typ-svec  (caddr sig-svec))
julia-syntax.scm:            (tvars     (cddr (cadddr sig-svec)))
julia-syntax.scm:            (argtypes  (cdddr typ-svec))
julia-syntax.scm:            (functionloc (cadr (caddddr sig-svec))))
julia-syntax.scm:        `(_opaque_closure ,(expand-forms `(curly (core Tuple))) (false) 0 ,functionloc ,lam)
julia-syntax.scm:         (let* ((vssa (make-ssavalue))
julia-syntax.scm:                (vval (expand-forms (last argtypes)))
julia-syntax.scm:                                  (expand-forms `(curly (core Tuple) ,@argtypes))
julia-syntax.scm:            (expand-forms (cadr e)))
julia-syntax.scm:                  (map expand-forms (cdr e))))))
julia-syntax.scm:         (expand-fuse-broadcast '() e)))
julia-syntax.scm:   (lambda (e) (expand-fuse-broadcast '() e))
julia-syntax.scm:   (lambda (e) (expand-fuse-broadcast '() e))
julia-syntax.scm:     (expand-fuse-broadcast (cadr e) (caddr e)))
julia-syntax.scm:   (lambda (e) (expand-forms `(call |<:| ,@(cdr e))))
julia-syntax.scm:   (lambda (e) (expand-forms `(call |>:| ,@(cdr e))))
julia-syntax.scm:   '-->
julia-syntax.scm:   (lambda (e) (expand-forms `(call --> ,@(cdr e))))
julia-syntax.scm:   (lambda (e) (expand-forms (expand-wheres (cadr e) (cddr e))))
julia-syntax.scm:   'const  expand-const-decl
julia-syntax.scm:   'atomic expand-atomic-decl
julia-syntax.scm:   'local  expand-local-or-global-decl
julia-syntax.scm:   'global expand-local-or-global-decl
julia-syntax.scm:   'local-def expand-local-or-global-decl
julia-syntax.scm:     (define (function-lhs? lhs)
julia-syntax.scm:     (define (assignment-to-function lhs e)  ;; convert '= expr to 'function expr
julia-syntax.scm:      ((function-lhs? lhs)
julia-syntax.scm:       (expand-forms (assignment-to-function lhs e)))
julia-syntax.scm:       (expand-unionall-def (cadr e) (caddr e)))
julia-syntax.scm:       ;; chain of assignments - convert a=b=c to `b=c; a=c`
julia-syntax.scm:         (if (and (assignment? rhs) (not (function-lhs? (cadr rhs))))
julia-syntax.scm:             (let ((rr (if (symbol-like? rhs) rhs (make-ssavalue))))
julia-syntax.scm:               (expand-forms
julia-syntax.scm:                                                             (assignment-to-function (cadr rhs) rhs)
julia-syntax.scm:      ((or (and (symbol-like? lhs) (valid-name? lhs))
julia-syntax.scm:       (sink-assignment lhs (expand-forms (caddr e))))
julia-syntax.scm:            (let ((aa (if (symbol-like? a) a (make-ssavalue)))
julia-syntax.scm:                  (bb (if (or (atom? b) (symbol-like? b) (and (pair? b) (quoted? b)))
julia-syntax.scm:                          b (make-ssavalue)))
julia-syntax.scm:                  (rr (if (or (symbol-like? rhs) (atom? rhs)) rhs (make-ssavalue))))
julia-syntax.scm:                ,.(if (eq? aa a)   '() (list (sink-assignment aa (expand-forms a))))
julia-syntax.scm:                ,.(if (eq? bb b)   '() (list (sink-assignment bb (expand-forms b))))
julia-syntax.scm:                ,.(if (eq? rr rhs) '() (list (sink-assignment rr (expand-forms rhs))))
julia-syntax.scm:            (if (has-parameters? lhss)
julia-syntax.scm:                (expand-property-destruct lhss x)
julia-syntax.scm:                (expand-tuple-destruct lhss x))))
julia-syntax.scm:                   (arr   (if reuse (make-ssavalue) a))
julia-syntax.scm:                   (stmts (if reuse `((= ,arr ,(expand-forms a))) '()))
julia-syntax.scm:                   (r    (if rrhs (make-ssavalue) rhs))
julia-syntax.scm:                   (rini (if rrhs (list (sink-assignment r (expand-forms rhs))) '())))
julia-syntax.scm:               (new-idxs stuff) (process-indices arr idxs)
julia-syntax.scm:                 ,.(map expand-forms stuff)
julia-syntax.scm:                 ,(expand-forms
julia-syntax.scm:                   `(call (top setindex!) ,arr ,r ,@new-idxs))
julia-syntax.scm:            (let ((e (remove-argument-side-effects x)))
julia-syntax.scm:              (expand-forms
julia-syntax.scm:       (expand-forms
julia-syntax.scm:        (receive (name params super) (analyze-type-sig sig)
julia-syntax.scm:                 (abstract-type-def-expr name params super)))))
julia-syntax.scm:       (expand-forms
julia-syntax.scm:        (receive (name params super) (analyze-type-sig sig)
julia-syntax.scm:                 (primitive-type-def-expr n name params super)))))
julia-syntax.scm:   (lambda (e) (expand-forms (expand-compare-chain (cdr e))))
julia-syntax.scm:       (if (has-parameters? args)
julia-syntax.scm:           (expand-forms (partially-expand-ref e)))))
julia-syntax.scm:     (if (has-parameters? (cddr e))
julia-syntax.scm:     (let* ((p (extract-implicit-whereparams e))
julia-syntax.scm:           (expand-forms `(call (core apply_type) ,@(cdr e)))
julia-syntax.scm:           (expand-forms `(where (curly ,(cadr e) ,@curlyparams) ,@whereparams)))))
julia-syntax.scm:           (cond ((dotop-named? f)
julia-syntax.scm:                  (expand-fuse-broadcast '() `(|.| ,(undotop f) (tuple ,@(cddr e)))))
julia-syntax.scm:                  (expand-fuse-broadcast '() `(|.| ,(cadr f) (tuple ,@(cddr e)))))
julia-syntax.scm:                         (have-cconv (memq cconv '(cdecl stdcall fastcall thiscall llvmcall)))
julia-syntax.scm:                         (after-cconv (if have-cconv (cddddr e) (cdddr e)))
julia-syntax.scm:                         (RT   (car after-cconv))
julia-syntax.scm:                         (argtypes (cadr after-cconv))
julia-syntax.scm:                         (args (cddr after-cconv)))
julia-syntax.scm:                          (expand-forms
julia-syntax.scm:                           (lower-ccall name RT (cdr argtypes) args
julia-syntax.scm:                                        (if have-cconv cconv 'ccall))))))
julia-syntax.scm:                  (expand-forms (lower-kw-call f (cddr e))))
julia-syntax.scm:                 ((has-parameters? (cddr e))  ;; f(...; ...)
julia-syntax.scm:                  (expand-forms
julia-syntax.scm:                       (lower-kw-call f (cddr e)))))
julia-syntax.scm:                    ;; wrap sequences of non-... arguments in tuple()
julia-syntax.scm:                    (define (tuple-wrap a run)
julia-syntax.scm:                                           (tuple-wrap (cdr a) '()))
julia-syntax.scm:                                           (tuple-wrap (cdr a) '())))
julia-syntax.scm:                                (tuple-wrap (cdr a) (cons x run))))))
julia-syntax.scm:                    (expand-forms
julia-syntax.scm:                     `(call (core _apply_iterate) (top iterate) ,f ,@(tuple-wrap argl '())))))
julia-syntax.scm:                 ((and (eq? (identifier-name f) '^) (length= e 4) (integer? (cadddr e)))
julia-syntax.scm:                  (expand-forms
julia-syntax.scm:                  (map expand-forms e))))
julia-syntax.scm:         (map expand-forms e)))
julia-syntax.scm:       (expand-forms
julia-syntax.scm:        (if (has-parameters? argl)
julia-syntax.scm:                (expand-forms (lower-named-tuple (cdr (cadr e))))
julia-syntax.scm:            (expand-forms (lower-named-tuple (cdr e))))
julia-syntax.scm:            (expand-forms `(call (core tuple) ,@(cdr e))))))
julia-syntax.scm:     (expand-forms
julia-syntax.scm:     (if (not (symbol-like? (cadr e)))
julia-syntax.scm:                ,(expand-forms (cadr e)) ,(expand-forms (caddr e)))
julia-syntax.scm:         (map expand-forms e)))
julia-syntax.scm:   'if expand-if
julia-syntax.scm:   'elseif expand-if
julia-syntax.scm:   'while expand-while
julia-syntax.scm:         '(break loop-exit)))
julia-syntax.scm:   'continue (lambda (e) '(break loop-cont))
julia-syntax.scm:       (expand-forms (expand-for (map cadr ranges) (map caddr ranges) (caddr e)))))
julia-syntax.scm:   '&&     (lambda (e) (expand-forms (expand-and e)))
julia-syntax.scm:   '|\|\|| (lambda (e) (expand-forms (expand-or  e)))
julia-syntax.scm:   '+=     lower-update-op
julia-syntax.scm:   '-=     lower-update-op
julia-syntax.scm:   '*=     lower-update-op
julia-syntax.scm:   '.*=    lower-update-op
julia-syntax.scm:   '/=     lower-update-op
julia-syntax.scm:   './=    lower-update-op
julia-syntax.scm:   '//=    lower-update-op
julia-syntax.scm:   './/=   lower-update-op
julia-syntax.scm:   '|\\=|  lower-update-op
julia-syntax.scm:   '|.\\=| lower-update-op
julia-syntax.scm:   '|.+=|  lower-update-op
julia-syntax.scm:   '|.-=|  lower-update-op
julia-syntax.scm:   '^=     lower-update-op
julia-syntax.scm:   '.^=    lower-update-op
julia-syntax.scm:   '=     lower-update-op
julia-syntax.scm:   '.=    lower-update-op
julia-syntax.scm:   '%=     lower-update-op
julia-syntax.scm:   '.%=    lower-update-op
julia-syntax.scm:   '|\|=|  lower-update-op
julia-syntax.scm:   '|.\|=|  lower-update-op
julia-syntax.scm:   '&=     lower-update-op
julia-syntax.scm:   '.&=     lower-update-op
julia-syntax.scm:   '$=     lower-update-op
julia-syntax.scm:   '=     lower-update-op
julia-syntax.scm:   '.=     lower-update-op
julia-syntax.scm:   '<<=    lower-update-op
julia-syntax.scm:   '.<<=    lower-update-op
julia-syntax.scm:   '>>=    lower-update-op
julia-syntax.scm:   '.>>=    lower-update-op
julia-syntax.scm:   '>>>=   lower-update-op
julia-syntax.scm:   '.>>>=   lower-update-op
julia-syntax.scm:     (if (has-parameters? (cdr e))
julia-syntax.scm:     (expand-forms `(call (top vect) ,@(cdr e))))
julia-syntax.scm:     (expand-forms `(call (top hcat) ,@(cdr e))))
julia-syntax.scm:   'vcat expand-vcat
julia-syntax.scm:   'ncat expand-ncat
julia-syntax.scm:     (expand-forms `(call (top typed_hcat) ,@(cdr e))))
julia-syntax.scm:       (expand-vcat e `((top typed_vcat) ,t) `((top typed_hvcat) ,t) `((top typed_hvcat_rows) ,t))))
julia-syntax.scm:       (expand-ncat e `((top typed_hvncat) ,t))))
julia-syntax.scm:   '|'|  (lambda (e) (expand-forms `(call |'| ,(cadr e))))
julia-syntax.scm:     (check-no-return e)
julia-syntax.scm:     (expand-generator e #f '()))
julia-syntax.scm:   (lambda (e) (expand-generator (cadr e) #t '()))
julia-syntax.scm:         (expand-forms `(comprehension (generator ,@(cdr e))))
julia-syntax.scm:                (expand-forms `(call (top collect) ,(cadr e))))))
julia-syntax.scm:     (expand-forms
julia-syntax.scm:                      (lower-comprehension (cadr e) (cadr (caddr e)) ranges))))
julia-syntax.scm:      (let* ((s (make-ssavalue))
julia-syntax.scm:             (r (make-ssavalue)))
julia-syntax.scm:          (= ,r ,(expand-forms (cadr e)))
julia-syntax.scm:      (set! *current-desugar-loc* e)
julia-syntax.scm:(define (has-return? e)
julia-syntax.scm:  (expr-contains-p return? e (lambda (x) (not (function-def? x)))))
julia-syntax.scm:(define (check-no-return e)
julia-syntax.scm:  (if (has-return? e)
julia-syntax.scm:(define (has-break-or-continue? e)
julia-syntax.scm:  (expr-contains-p (lambda (x) (and (pair? x) (memq (car x) '(break continue))))
julia-syntax.scm:(define (lower-comprehension ty expr itrs)
julia-syntax.scm:  (check-no-return expr)
julia-syntax.scm:  (if (has-break-or-continue? expr)
julia-syntax.scm:  (let ((result    (make-ssavalue))
julia-syntax.scm:        (oneresult (make-ssavalue))
julia-syntax.scm:        (prod      (make-ssavalue))
julia-syntax.scm:        (isz       (make-ssavalue))
julia-syntax.scm:        (szunk     (make-ssavalue))
julia-syntax.scm:        (iv        (map (lambda (x) (make-ssavalue)) itrs)))
julia-syntax.scm:    (define (construct-loops itrs iv)
julia-syntax.scm:                ,(construct-loops (cdr itrs) (cdr iv)))))
julia-syntax.scm:    (let ((overall-itr (if (length= itrs 1) (car iv) prod)))
julia-syntax.scm:      `(scope-block
julia-syntax.scm:         (= ,isz (call (top IteratorSize) ,overall-itr))
julia-syntax.scm:         (= ,result (call (top _array_for) ,ty ,overall-itr ,isz))
julia-syntax.scm:         ,(construct-loops (reverse itrs) (reverse iv))
julia-syntax.scm:(define (lhs-vars e)
julia-syntax.scm:  (cond ((symdecl? e)   (list (decl-var e)))
julia-syntax.scm:         (apply append (map lhs-vars (cdr e))))
julia-syntax.scm:(define (lhs-decls e)
julia-syntax.scm:         (apply append (map lhs-decls (cdr e))))
julia-syntax.scm:(define (all-decl-vars e)  ;; map decl-var over every level of an assignment LHS
julia-syntax.scm:  (cond ((eventually-call? e) e)
julia-syntax.scm:        ((decl? e)   (decl-var e))
julia-syntax.scm:         (cons 'tuple (map all-decl-vars (cdr e))))
julia-syntax.scm:(define (find-assigned-vars e)
julia-syntax.scm:  (define (find-assigned-vars- e)
julia-syntax.scm:          ((lambda scope-block module toplevel)  '())
julia-syntax.scm:           (let ((v (decl-var (method-expr-name e))))
julia-syntax.scm:                 (find-assigned-vars- (caddr e)))))
julia-syntax.scm:           (let ((v (decl-var (cadr e))))
julia-syntax.scm:             (find-assigned-vars- (caddr e))
julia-syntax.scm:             (if (or (ssavalue? v) (globalref? v) (outerref? v) (underscore-symbol? v))
julia-syntax.scm:           (for-each find-assigned-vars- (cdr e))))))
julia-syntax.scm:  (find-assigned-vars- e)
julia-syntax.scm:  (delete-duplicates vars))
julia-syntax.scm:(define (find-decls kind e)
julia-syntax.scm:  (define (find-decls- e)
julia-syntax.scm:          ((memq (car e) '(lambda scope-block module toplevel))
julia-syntax.scm:           (if (underscore-symbol? (cadr e))
julia-syntax.scm:               (set! vars (cons (decl-var (cadr e)) vars))))
julia-syntax.scm:           (for-each find-decls- (cdr e)))))
julia-syntax.scm:  (find-decls- e)
julia-syntax.scm:(define (find-local-decls e) (find-decls 'local e))
julia-syntax.scm:(define (find-local-def-decls e) (find-decls 'local-def e))
julia-syntax.scm:(define (find-global-decls e) (find-decls 'global e))
julia-syntax.scm:(define (find-scope-decl e kind)
julia-syntax.scm:  (expr-contains-p
julia-syntax.scm:                         (memq (car x) '(lambda scope-block module toplevel)))))))
julia-syntax.scm:(define (check-valid-name e)
julia-syntax.scm:  (or (valid-name? e)
julia-syntax.scm:(define (make-scope (lam #f) (args '()) (locals '()) (globals '()) (sp '()) (renames '()) (prev #f)
julia-syntax.scm:                    (soft? #f) (hard? #f) (implicit-globals '()) (warn-vars #f))
julia-syntax.scm:  (vector lam args locals globals sp renames prev soft? hard? implicit-globals warn-vars))
julia-syntax.scm:(define (scope:implicit-globals s) (aref s 9))
julia-syntax.scm:(define (scope:warn-vars s) (aref s 10))
julia-syntax.scm:(define (var-kind var scope (exclude-top-level-globals #f))
julia-syntax.scm:               (if (and exclude-top-level-globals
julia-syntax.scm:                        ;; in a top-level expression.
julia-syntax.scm:          (and (memq var (scope:sp scope))      'static-parameter)
julia-syntax.scm:          (var-kind var (scope:prev scope) exclude-top-level-globals))
julia-syntax.scm:(define (in-scope? var scope) (not (eq? (var-kind var scope) 'none)))
julia-syntax.scm:(define (warn-var?! v scope)
julia-syntax.scm:       (let ((w (scope:warn-vars scope)))
julia-syntax.scm:             (warn-var?! v (scope:prev scope))))))
julia-syntax.scm:(define (all-local-names scope)
julia-syntax.scm:  (define (all-lists s)
julia-syntax.scm:        (list* (scope:args s) (scope:sp s) (scope:locals s) (all-lists (scope:prev s)))
julia-syntax.scm:  (apply append (all-lists scope)))
julia-syntax.scm:(define (resolve-scopes- e scope (sp '()) (loc #f))
julia-syntax.scm:               (if (underscore-symbol? e)
julia-syntax.scm:        ((or (not (pair? e)) (quoted? e) (memq (car e) '(toplevel symbolicgoto symboliclabel toplevel-only)))
julia-syntax.scm:         (check-valid-name (cadr e))
julia-syntax.scm:        ((memq (car e) '(local local-def))
julia-syntax.scm:         (check-valid-name (cadr e))
julia-syntax.scm:        ((eq? (car e) 'require-existing-local)
julia-syntax.scm:         (if (not (in-scope? (cadr e) scope))
julia-syntax.scm:                                      (not (length= (string-split (string v) "#") 2))))
julia-syntax.scm:                               (all-local-names scope)))
julia-syntax.scm:                (names (delete-duplicates
julia-syntax.scm:                                (map unmangled-name names))))
julia-syntax.scm:                (d (make-ssavalue)))
julia-syntax.scm:                            (let ((var (resolve-scopes- v scope)))
julia-syntax.scm:         (if (memq (var-kind (cadr e) scope) '(global none))
julia-syntax.scm:                (body (resolve-scopes- (lam:body e) (make-scope e args '() '() sp '() scope))))
julia-syntax.scm:        ((eq? (car e) 'scope-block)
julia-syntax.scm:         (let* ((blok            (cadr e)) ;; body of scope-block expression
julia-syntax.scm:                (current-locals  (caddr lam)) ;; locals created so far in our lambda
julia-syntax.scm:                (globals         (find-global-decls blok))
julia-syntax.scm:                (assigned        (find-assigned-vars blok))
julia-syntax.scm:                (locals-def      (find-local-def-decls blok))
julia-syntax.scm:                (local-decls     (find-local-decls blok))
julia-syntax.scm:                                                           (find-scope-decl blok 'hardscope))))
julia-syntax.scm:                                      (let ((ss (find-scope-decl blok 'softscope)))
julia-syntax.scm:                (nonloc-assigned (filter (lambda (v) (and (not (memq v locals-def))
julia-syntax.scm:                                                          (not (memq v local-decls))))
julia-syntax.scm:                (implicit-globals (if toplevel? nonloc-assigned '()))
julia-syntax.scm:                (implicit-locals
julia-syntax.scm:                             (lambda (v) (and (memq (var-kind v scope #t) '(none static-parameter))
julia-syntax.scm:                                                        (or (memq v (scope:implicit-globals scope))
julia-syntax.scm:                                                            (defined-julia-global v))))
julia-syntax.scm:                         nonloc-assigned))
julia-syntax.scm:                (locals-nondef   (delete-duplicates (append local-decls implicit-locals)))
julia-syntax.scm:                (need-rename?    (lambda (vars)
julia-syntax.scm:                                   (filter (lambda (v) (or (memq v current-locals) (in-scope? v scope)))
julia-syntax.scm:                (need-rename     (need-rename? locals-nondef))
julia-syntax.scm:                (need-rename-def (need-rename? locals-def))
julia-syntax.scm:                (renamed         (map named-gensy need-rename))
julia-syntax.scm:                (renamed-def     (map named-gensy need-rename-def))
julia-syntax.scm:                (newnames        (append (diff locals-nondef need-rename) renamed))
julia-syntax.scm:                (newnames-def    (append (diff locals-def need-rename-def) renamed-def))
julia-syntax.scm:                (warn-vars
julia-syntax.scm:                                            (and (or (memq v (scope:implicit-globals scope))
julia-syntax.scm:                                                     (defined-julia-global v))
julia-syntax.scm:                                                 (eq? (var-kind v scope) 'none)
julia-syntax.scm:                                          nonloc-assigned)))
julia-syntax.scm:                              (for-each (lambda (v) (put! t v #t))
julia-syntax.scm:           (for-each (lambda (v)
julia-syntax.scm:                       (if (or (memq v locals-def) (memq v local-decls))
julia-syntax.scm:                       (if (and (null? argnames) (memq (var-kind v scope) '(argument local)))
julia-syntax.scm:               (for-each (lambda (v)
julia-syntax.scm:                         local-decls))
julia-syntax.scm:           (for-each (lambda (lst)
julia-syntax.scm:                       (for-each (lambda (v)
julia-syntax.scm:                                   (if (eq? (var-kind v scope) 'static-parameter)
julia-syntax.scm:                     (list local-decls implicit-locals))
julia-syntax.scm:               (set-car! (cddr lam)
julia-syntax.scm:                         (append (caddr lam) newnames newnames-def)))
julia-syntax.scm:           (insert-after-meta ;; return the new, expanded scope-block
julia-syntax.scm:             (resolve-scopes- blok
julia-syntax.scm:                              (make-scope lam
julia-syntax.scm:                                          (append locals-nondef locals-def)
julia-syntax.scm:                                          (append (map cons need-rename renamed)
julia-syntax.scm:                                                  (map cons need-rename-def renamed-def))
julia-syntax.scm:                                              implicit-globals
julia-syntax.scm:                                              (scope:implicit-globals scope))
julia-syntax.scm:                                          warn-vars)
julia-syntax.scm:                     (map (lambda (v) `(local-def ,v)) newnames-def)))
julia-syntax.scm:        ((eq? (car e) 'break-block)
julia-syntax.scm:         `(break-block ,(cadr e) ;; ignore type symbol of break-block expression
julia-syntax.scm:                       ,(resolve-scopes- (caddr e) scope '() loc))) ;; body of break-block expression
julia-syntax.scm:        ((eq? (car e) 'with-static-parameters)
julia-syntax.scm:         `(with-static-parameters
julia-syntax.scm:           ,(resolve-scopes- (cadr e) scope (cddr e) loc)
julia-syntax.scm:           ,(resolve-scopes- (cadr   e) scope)
julia-syntax.scm:           ,(resolve-scopes- (caddr  e) scope)
julia-syntax.scm:           ,(resolve-scopes- (cadddr e) scope (method-expr-static-parameters e))))
julia-syntax.scm:                  (warn-var?! (cadr e) scope)
julia-syntax.scm:                  (= *scopewarn-opt* 1))
julia-syntax.scm:                    (loc  (extract-line-file loc))
julia-syntax.scm:                    (line (if (= (car loc) 0) (julia-current-line) (car loc)))
julia-syntax.scm:                    (file (if (eq? (cadr loc) 'none) (julia-current-file) (cadr loc))))
julia-syntax.scm:               (lowering-warning
julia-syntax.scm:                      (resolve-scopes- x scope '() loc))
julia-syntax.scm:(define (resolve-scopes e) (resolve-scopes- e #f))
julia-syntax.scm:(define (lambda-all-vars e)
julia-syntax.scm:(define (free-vars- e tab)
julia-syntax.scm:  (cond ((or (eq? e UNUSED) (underscore-symbol? e)) tab)
julia-syntax.scm:        ((and (pair? e) (eq? (car e) 'break-block)) (free-vars- (caddr e) tab))
julia-syntax.scm:        ((and (pair? e) (eq? (car e) 'with-static-parameters)) (free-vars- (cadr e) tab))
julia-syntax.scm:         (let ((bound (lambda-all-vars e)))
julia-syntax.scm:           (for-each (lambda (v) (if (not (memq v bound)) (put! tab v #t)))
julia-syntax.scm:                     (free-vars (lam:body e))))
julia-syntax.scm:         (for-each (lambda (x) (free-vars- x tab))
julia-syntax.scm:(define (free-vars e)
julia-syntax.scm:  (table.keys (free-vars- e (table))))
julia-syntax.scm:(define (analyze-vars-lambda e env captvars sp new-sp (methsig #f))
julia-syntax.scm:         (allv (nconc (map arg-name args) locl))
julia-syntax.scm:         (fv   (let* ((fv (diff (free-vars (lam:body e)) allv))
julia-syntax.scm:                                              (let ((vi (var-info-for v env)))
julia-syntax.scm:                                                (if vi (free-vars (vinfo:type vi)) '())))
julia-syntax.scm:         (sig-fv (if methsig (free-vars methsig) '()))
julia-syntax.scm:         (glo  (find-global-decls (lam:body e)))
julia-syntax.scm:         ;; make var-info records for vars introduced by this lambda
julia-syntax.scm:                (map (lambda (decl) (make-var-info (decl-var decl)))
julia-syntax.scm:                (map make-var-info locl)))
julia-syntax.scm:         (capt-sp (filter (lambda (v) (or (and (memq v fv) (not (memq v glo)) (not (memq v new-sp)))
julia-syntax.scm:                                          (memq v sig-fv)))
julia-syntax.scm:                                                 (not (memq (vinfo:name v) new-sp))
julia-syntax.scm:                        (map make-var-info capt-sp))))
julia-syntax.scm:    (analyze-vars (lam:body e)
julia-syntax.scm:                  cv (delete-duplicates (append new-sp sp)))
julia-syntax.scm:    (for-each (lambda (v) (vinfo:set-capt! v #t))
julia-syntax.scm:    (set-car! (cddr e)
julia-syntax.scm:              `(,vi ,cv 0 ,(delete-duplicates (append new-sp capt-sp))))
julia-syntax.scm:;; in-place to
julia-syntax.scm:;;   (var-info-lst captured-var-infos ssavalues static_params)
julia-syntax.scm:;; where var-info-lst is a list of var-info records
julia-syntax.scm:(define (analyze-vars e env captvars sp)
julia-syntax.scm:            (let ((vi (var-info-for e env)))
julia-syntax.scm:                  (vinfo:set-read! vi #t))))
julia-syntax.scm:        ((local-def) ;; a local that we know has an assignment that dominates all usages
julia-syntax.scm:         (let ((vi (var-info-for (cadr e) env)))
julia-syntax.scm:              (vinfo:set-never-undef! vi #t)))
julia-syntax.scm:         (let ((vi (and (symbol? (cadr e)) (var-info-for (cadr e) env))))
julia-syntax.scm:                          (vinfo:set-sa! vi #f)
julia-syntax.scm:                          (vinfo:set-sa! vi #t))
julia-syntax.scm:                      (vinfo:set-asgn! vi #t))))
julia-syntax.scm:         (analyze-vars (caddr e) env captvars sp))
julia-syntax.scm:         (let ((vi (var-info-for (cadr e) env)))
julia-syntax.scm:               (vinfo:set-called! vi #t))
julia-syntax.scm:           (for-each (lambda (x) (analyze-vars x env captvars sp))
julia-syntax.scm:         ;; handle var::T declaration by storing the type in the var-info
julia-syntax.scm:         ;; record. for non-symbols or globals, emit a type assertion.
julia-syntax.scm:         (let ((vi (var-info-for (cadr e) env)))
julia-syntax.scm:                      (vinfo:set-type! vi (caddr e))))))
julia-syntax.scm:         (analyze-vars-lambda e env captvars sp '()))
julia-syntax.scm:        ((with-static-parameters)
julia-syntax.scm:         ;; (with-static-parameters func_expr sp_1 sp_2 ...)
julia-syntax.scm:         (analyze-vars-lambda (cadr e) env captvars sp
julia-syntax.scm:             (let ((vi (var-info-for (method-expr-name e) env)))
julia-syntax.scm:                              (vinfo:set-sa! vi #f)
julia-syntax.scm:                              (vinfo:set-sa! vi #t))
julia-syntax.scm:                          (vinfo:set-asgn! vi #t)))
julia-syntax.scm:             (begin (analyze-vars (caddr e) env captvars sp)
julia-syntax.scm:                    (analyze-vars-lambda (cadddr e) env captvars sp
julia-syntax.scm:                                         (method-expr-static-parameters e)
julia-syntax.scm:        (else (for-each (lambda (x) (analyze-vars x env captvars sp))
julia-syntax.scm:(define (analyze-variables! e) (analyze-vars e '() '() '()) e)
julia-syntax.scm:;; a type for them. for example `f(x) = y->(y+x)` is converted to
julia-syntax.scm:(define (type-for-closure-parameterized name P names fields types super)
julia-syntax.scm:        (s (make-ssavalue)))
julia-syntax.scm:(define (type-for-closure name fields super)
julia-syntax.scm:  (let ((s (make-ssavalue)))
julia-syntax.scm:;(define (type-for-closure-parameterized name P names fields types super)
julia-syntax.scm:;(define (type-for-closure name fields super)
julia-syntax.scm:(define (vinfo:not-capt vi)
julia-syntax.scm:(define (clear-capture-bits vinfos)
julia-syntax.scm:  (map vinfo:not-capt vinfos))
julia-syntax.scm:(define (convert-lambda lam fname interp capt-sp opaq)
julia-syntax.scm:  (let ((body (add-box-inits-to-body
julia-syntax.scm:               lam (cl-convert (cadddr lam) fname lam (table) (table) #f interp opaq))))
julia-syntax.scm:       (,(clear-capture-bits (car (lam:vinfo lam)))
julia-syntax.scm:        ,(delete-duplicates (append (lam:sp lam) capt-sp)))
julia-syntax.scm:(define (renumber-assigned-ssavalues e)
julia-syntax.scm:  (let ((vals (expr-find-all (lambda (x) (and (assignment? x) (ssavalue? (cadr x))))
julia-syntax.scm:          (for-each (lambda (id) (put! repl id (make-ssavalue)))
julia-syntax.scm:          (let do-replace ((x e))
julia-syntax.scm:                          (map do-replace (cdr x))))))))))
julia-syntax.scm:(define (convert-for-type-decl rhs t)
julia-syntax.scm:                       (make-ssavalue)))
julia-syntax.scm:            `(block (= ,temp ,(renumber-assigned-ssavalues t)) ,ex)
julia-syntax.scm:(define (capt-var-access var fname opaq)
julia-syntax.scm:(define (convert-assignment var rhs0 fname lam interp opaq)
julia-syntax.scm:           (let* ((rhs1 (if (or (simple-atom? rhs0)
julia-syntax.scm:                            (make-ssavalue)))
julia-syntax.scm:                            (convert-for-type-decl rhs1 (cl-convert vt fname lam #f #f #f interp opaq))))
julia-syntax.scm:                                                (capt-var-access var fname opaq))
julia-syntax.scm:(define (rename-sig-types ex namemap)
julia-syntax.scm:  (pattern-replace
julia-syntax.scm:   (pattern-set
julia-syntax.scm:    (pattern-lambda (call (core (-/ Typeof)) name)
julia-syntax.scm:(define (fix-function-arg-type te typ iskw namemap type-sp)
julia-syntax.scm:         (types  (rename-sig-types (cddr typapp) namemap))
julia-syntax.scm:         (closure-type (if (null? type-sp)
julia-syntax.scm:                           `(call (core apply_type) ,typ ,@type-sp)))
julia-syntax.scm:              `(,(car types) ,(cadr types) ,closure-type ,@(cdddr types))
julia-syntax.scm:              `(,closure-type ,@(cdr types))))
julia-syntax.scm:           (call (core svec) ,@(append (cddr (cadddr te)) type-sp))
julia-syntax.scm:;; collect all toplevel-butfirst expressions inside `e`, and return
julia-syntax.scm:(define (lift-toplevel e)
julia-syntax.scm:    (define (lift- e)
julia-syntax.scm:          (let ((e (cons (car e) (map lift- (cdr e)))))
julia-syntax.scm:            (if (eq? (car e) 'toplevel-butfirst)
julia-syntax.scm:    (let ((e2 (lift- e)))
julia-syntax.scm:(define (first-non-meta blk)
julia-syntax.scm:(define (insert-after-meta body stmts)
julia-syntax.scm:      (let ((meta (take-while (lambda (x) (and (pair? x)
julia-syntax.scm:          ,@(list-tail body (+ 1 (length meta)))))))
julia-syntax.scm:(define (add-box-inits-to-body lam body)
julia-syntax.scm:  (let ((args (map arg-name (lam:args lam)))
julia-syntax.scm:    (insert-after-meta
julia-syntax.scm:(define (all-methods-for ex body)
julia-syntax.scm:  (let ((mname (method-expr-name ex)))
julia-syntax.scm:    (expr-find-all (lambda (s)
julia-syntax.scm:                          (eq? (method-expr-name s) mname)))
julia-syntax.scm:(define lambda-opt-ignored-exprs
julia-syntax.scm:  (Set '(quote top core line inert local-def unnecessary copyast
julia-syntax.scm:         thunk with-static-parameters toplevel-only
julia-syntax.scm:         global globalref outerref const-if-global thismodule
julia-syntax.scm:(define (local-in? s lam)
julia-syntax.scm:;; Try to identify never-undef variables, and then clear the `captured` flag for single-assigned,
julia-syntax.scm:;; never-undef variables to avoid allocating unnecessary `Box`es.
julia-syntax.scm:(define (lambda-optimize-vars! lam)
julia-syntax.scm:  ;; memoize all-methods-for to avoid O(n^2) behavior
julia-syntax.scm:  (define allmethods-table (table))
julia-syntax.scm:  (define (get-methods ex stmts)
julia-syntax.scm:    (let ((mn (method-expr-name ex)))
julia-syntax.scm:      (if (has? allmethods-table mn)
julia-syntax.scm:          (get allmethods-table mn)
julia-syntax.scm:          (let ((am (all-methods-for ex stmts)))
julia-syntax.scm:            (put! allmethods-table mn am)
julia-syntax.scm:  ;; This does a basic-block-local dominance analysis to find variables that
julia-syntax.scm:    (for-each (lambda (v)
julia-syntax.scm:    (define (mark-used var)
julia-syntax.scm:    (define (mark-captured var)
julia-syntax.scm:    (define (leave-loop! old-decls)
julia-syntax.scm:      (for-each (lambda (k)
julia-syntax.scm:                  (if (has? old-decls k)
julia-syntax.scm:      (set! decl old-decls))
julia-syntax.scm:      (cond ((atom? e) (if (symbol? e) (mark-used e))
julia-syntax.scm:            ((lambda-opt-ignored-exprs (car e))
julia-syntax.scm:            ((eq? (car e) 'scope-block)
julia-syntax.scm:             (eager-any visit (cdr e)))
julia-syntax.scm:            ((eq? (car e) 'break-block)
julia-syntax.scm:               (if (eager-any (lambda (e) (begin0 (visit e)
julia-syntax.scm:                   (decl- (table.clone decl)))
julia-syntax.scm:               (let ((result (eager-any visit (cdr e))))
julia-syntax.scm:                 (leave-loop! decl-)
julia-syntax.scm:                 (let* ((mn          (method-expr-name e))
julia-syntax.scm:                        (all-methods (if (local-in? mn lam)
julia-syntax.scm:                                         (get-methods e (lam:body lam))
julia-syntax.scm:                   (for-each (lambda (ex)
julia-syntax.scm:                               (for-each mark-captured
julia-syntax.scm:                             all-methods)
julia-syntax.scm:             (eager-any visit (cdr e))
julia-syntax.scm:    ;; Finally, variables can be marked never-undef if they were set in the first block,
julia-syntax.scm:    (for-each (lambda (v)
julia-syntax.scm:                      (vinfo:set-never-undef! vv #t))))
julia-syntax.scm:    (for-each (lambda (v)
julia-syntax.scm:                (if (and (vinfo:sa v) (vinfo:never-undef v))
julia-syntax.scm:                    (set-car! (cddr v) (logand (caddr v) (lognot 5)))))
julia-syntax.scm:(define (is-var-boxed? v lam)
julia-syntax.scm:(define (toplevel-preserving? e)
julia-syntax.scm:(define (map-cl-convert exprs fname lam namemap defined toplevel interp opaq)
julia-syntax.scm:             (let ((tl (lift-toplevel (cl-convert x fname lam namemap defined
julia-syntax.scm:                                                  (and toplevel (toplevel-preserving? x))
julia-syntax.scm:      (map (lambda (x) (cl-convert x fname lam namemap defined #f interp opaq)) exprs)))
julia-syntax.scm:(define (prepare-lambda! lam)
julia-syntax.scm:  ;; mark all non-arguments as assigned, since locals that are never assigned
julia-syntax.scm:  (for-each (lambda (vi) (vinfo:set-asgn! vi #t))
julia-syntax.scm:            (list-tail (car (lam:vinfo lam)) (length (lam:args lam))))
julia-syntax.scm:  (lambda-optimize-vars! lam))
julia-syntax.scm:(define (cl-convert e fname lam namemap defined toplevel interp opaq)
julia-syntax.scm:          (cons (car e) (map-cl-convert (cdr e) fname lam namemap defined toplevel interp opaq)))
julia-syntax.scm:        (define (new-undef-var name)
julia-syntax.scm:          (let ((g (named-gensy name)))
julia-syntax.scm:            (set-car! (lam:vinfo lam) (append (car (lam:vinfo lam)) `((,g Any 32))))
julia-syntax.scm:        (define (get-box-contents box typ)
julia-syntax.scm:          (let* ((access (if (symbol? box) box (make-ssavalue)))
julia-syntax.scm:                 (undefvar (new-undef-var e))
julia-syntax.scm:                                 ,(cl-convert typ fname lam namemap defined toplevel interp opaq)))))
julia-syntax.scm:                                   (capt-var-access e fname opaq))))
julia-syntax.scm:                       (get-box-contents access (vinfo:type cv))
julia-syntax.scm:                     (get-box-contents e (vinfo:type vi))
julia-syntax.scm:          ((toplevel-only)
julia-syntax.scm:                 (rhs (cl-convert (caddr e) fname lam namemap defined toplevel interp opaq)))
julia-syntax.scm:             (convert-assignment var rhs fname lam interp opaq)))
julia-syntax.scm:          ((local-def) ;; make new Box for local declaration of defined variable
julia-syntax.scm:                 (if (vinfo:never-undef vi)
julia-syntax.scm:          ((const-if-global)
julia-syntax.scm:           (if (local-in? (cadr e) lam)
julia-syntax.scm:                                          (capt-var-access sym fname opaq))))
julia-syntax.scm:             (prepare-lambda! lam2)
julia-syntax.scm:             (let ((var-exprs (map (lambda (v)
julia-syntax.scm:                                           (capt-var-access v fname opaq)
julia-syntax.scm:                      (opaque_closure_method (null) ,nargs ,functionloc ,(convert-lambda lam2 (car (lam:args lam2)) #f '() (symbol-to-idx-map cvs)))
julia-syntax.scm:                      ,@var-exprs))))
julia-syntax.scm:           (let* ((name  (method-expr-name e))
julia-syntax.scm:                  (local? (lambda (s) (and lam (symbol? s) (local-in? s lam))))
julia-syntax.scm:                  (sp-inits (if (or short (not (eq? (car sig) 'block)))
julia-syntax.scm:                                (map-cl-convert (butlast (cdr sig))
julia-syntax.scm:             (if lam2 (prepare-lambda! lam2))
julia-syntax.scm:                                    `(toplevel-butfirst
julia-syntax.scm:                                      ;; wrap in toplevel-butfirst so it gets moved higher along with
julia-syntax.scm:                          ,@sp-inits
julia-syntax.scm:                          (method ,(cadr e) ,(cl-convert
julia-syntax.scm:                                          (rename-sig-types sig namemap)
julia-syntax.scm:                                  ,(let ((body (add-box-inits-to-body
julia-syntax.scm:                                                (cl-convert (cadddr lam2) 'anon lam2 (table) (table) #f interp opaq))))
julia-syntax.scm:                                        (,(clear-capture-bits (car vis))
julia-syntax.scm:                        (let* ((exprs     (lift-toplevel (convert-lambda lam2 '|#anon| #t '() #f)))
julia-syntax.scm:                               (top-stmts (cdr exprs))
julia-syntax.scm:                               (newlam    (compact-and-renumber (linearize (car exprs)) 'none 0)))
julia-syntax.scm:                          `(toplevel-butfirst
julia-syntax.scm:                            (block ,@sp-inits
julia-syntax.scm:                                   (method ,name ,(cl-convert sig fname lam namemap defined toplevel interp opaq)
julia-syntax.scm:                                           ,(julia-bq-macro newlam)))
julia-syntax.scm:                            ,@top-stmts))))
julia-syntax.scm:                 ;; local case - lift to a new type at top level
julia-syntax.scm:                        (type-name  (or (get namemap name #f)
julia-syntax.scm:                                                             name "#" (current-julia-module-counter))))))
julia-syntax.scm:                        (alldefs (expr-find-all
julia-syntax.scm:                                                    (eq? (method-expr-name ex) name)))
julia-syntax.scm:                 (and name (put! namemap name type-name))
julia-syntax.scm:                 (let* ((all-capt-vars   (delete-duplicates
julia-syntax.scm:                        (all-sparams   (delete-duplicates  ;; static params from all definitions
julia-syntax.scm:                        (capt-sp (simple-sort (intersect all-capt-vars all-sparams))) ; the intersection is the list of sparams that need to be captured
julia-syntax.scm:                        (capt-vars (diff all-capt-vars capt-sp)) ; remove capt-sp from capt-vars
julia-syntax.scm:                        (moved-vars  ;; signature-local vars that should be moved to the top-level
julia-syntax.scm:                             (delete-duplicates
julia-syntax.scm:                              (expr-find-all
julia-syntax.scm:                                                (not (memq s capt-sp))
julia-syntax.scm:                                                    (if (or (expr-contains-p (lambda (v) (eq? v s))
julia-syntax.scm:                                                             (expr-contains-p (lambda (e)
julia-syntax.scm:                        (find-locals-in-method-sig (lambda (methdef)
julia-syntax.scm:                                                     (expr-find-all
julia-syntax.scm:                                                                       (not (memq s capt-sp))
julia-syntax.scm:                        (sig-locals (simple-sort
julia-syntax.scm:                                     (delete-duplicates  ;; locals used in sig from all definitions
julia-syntax.scm:                                             (if lam2 (find-locals-in-method-sig e) '())
julia-syntax.scm:                                             (map find-locals-in-method-sig alldefs)))))
julia-syntax.scm:                        (closure-param-names (append capt-sp sig-locals)) ; sparams for the closure method declaration
julia-syntax.scm:                        (closure-param-syms (map (lambda (s) (make-ssavalue)) closure-param-names))
julia-syntax.scm:                                                   (if (is-var-boxed? v lam)
julia-syntax.scm:                                                       (make-ssavalue)))
julia-syntax.scm:                                                 capt-vars))
julia-syntax.scm:                                (para (append closure-param-syms
julia-syntax.scm:                                (fieldnames (append closure-param-names (filter (lambda (v) (not (is-var-boxed? v lam))) capt-vars))))
julia-syntax.scm:                               (type-for-closure type-name capt-vars '(core Function))
julia-syntax.scm:                               (type-for-closure-parameterized type-name para fieldnames capt-vars fieldtypes '(core Function)))))
julia-syntax.scm:                        (mk-method ;; expression to make the method
julia-syntax.scm:                                    (renamemap (map cons closure-param-names closure-param-syms))
julia-syntax.scm:                                    (arg-defs (replace-vars
julia-syntax.scm:                                               (fix-function-arg-type sig type-name iskw namemap closure-param-syms)
julia-syntax.scm:                                              (make-assignment gs `(call (core TypeVar) ',tvar (core Any))))
julia-syntax.scm:                                            closure-param-syms closure-param-names)
julia-syntax.scm:                                       `((method #f ,(cl-convert arg-defs fname lam namemap defined toplevel interp opaq)
julia-syntax.scm:                                                 ,(convert-lambda lam2
julia-syntax.scm:                                                                  #f closure-param-names #f)))))))
julia-syntax.scm:                        (mk-closure  ;; expression to make the closure
julia-syntax.scm:                         (let* ((var-exprs (map (lambda (v)
julia-syntax.scm:                                                            (capt-var-access v fname opaq))
julia-syntax.scm:                                                capt-vars))
julia-syntax.scm:                                    closure-param-names
julia-syntax.scm:                                                            (if (is-var-boxed? v lam)
julia-syntax.scm:                                                          capt-vars var-exprs)))))
julia-syntax.scm:                                      type-name
julia-syntax.scm:                                      `(call (core apply_type) ,type-name ,@P))
julia-syntax.scm:                                 ,@var-exprs))))
julia-syntax.scm:                   (if (pair? moved-vars)
julia-syntax.scm:                       (set-car! (lam:vinfo lam)
julia-syntax.scm:                                           (not (memq (car vi) moved-vars)))
julia-syntax.scm:                       `(toplevel-butfirst
julia-syntax.scm:                         ,@sp-inits
julia-syntax.scm:                         ,@mk-method)
julia-syntax.scm:                         `(toplevel-butfirst
julia-syntax.scm:                           ,(convert-assignment name mk-closure fname lam interp opaq)
julia-syntax.scm:                           ,@(map (lambda (v) `(moved-local ,v)) moved-vars)
julia-syntax.scm:                           ,@sp-inits
julia-syntax.scm:                           ,@mk-method))))))))
julia-syntax.scm:           (for-each (lambda (vi) (vinfo:set-asgn! vi #t))
julia-syntax.scm:                     (list-tail (car (lam:vinfo e)) (length (lam:args e))))
julia-syntax.scm:           (let ((body (map-cl-convert (cdr (lam:body e)) 'anon
julia-syntax.scm:                                       (lambda-optimize-vars! e)
julia-syntax.scm:                (,(clear-capture-bits (car (lam:vinfo e)))
julia-syntax.scm:           (cl-convert `(call (core typeassert) ,@(cdr e)) fname lam namemap defined toplevel interp opaq))
julia-syntax.scm:          ;; argument is global or a non-symbol.
julia-syntax.scm:                       (local-in? (cadr e) lam))
julia-syntax.scm:                  (cl-convert `(call (core typeassert) ,@(cdr e)) fname lam namemap defined toplevel interp opaq))))
julia-syntax.scm:          ;; `with-static-parameters` expressions can be removed now; used only by analyze-vars
julia-syntax.scm:          ((with-static-parameters)
julia-syntax.scm:           (cl-convert (cadr e) fname lam namemap defined toplevel interp opaq))
julia-syntax.scm:                 (map-cl-convert (cdr e) fname lam namemap defined toplevel interp opaq))))))))
julia-syntax.scm:(define (closure-convert e) (cl-convert e #f #f #f #f #f #f #f))
julia-syntax.scm:         (set-car! (cdddr e) (compile-body (cadddr e) (append (car (caddr e))
julia-syntax.scm:        (else (for-each linearize (cdr e))))
julia-syntax.scm:(define (valid-ir-argument? e)
julia-syntax.scm:  (or (simple-atom? e) (symbol? e)
julia-syntax.scm:(define (valid-ir-rvalue? lhs e)
julia-syntax.scm:      (valid-ir-argument? e)
julia-syntax.scm:(define (valid-ir-return? e)
julia-syntax.scm:  (or (valid-ir-argument? e) (and (pair? e) (memq (car e) '(lambda)))))
julia-syntax.scm:(define (compile-body e vi lam)
julia-syntax.scm:        (first-line #t)
julia-syntax.scm:        (current-loc #f)
julia-syntax.scm:        (global-const-error #f)
julia-syntax.scm:        (arg-map #f)          ;; map arguments to new names if they are assigned
julia-syntax.scm:        (label-counter 0)     ;; counter for generating label addresses
julia-syntax.scm:        (label-map (table))   ;; maps label names to generated addresses
julia-syntax.scm:        (label-nesting (table)) ;; exception handler and catch block nesting of each label
julia-syntax.scm:        (finally-handler #f)  ;; Current finally block info: `(var label map level tokens)`
julia-syntax.scm:                              ;; should enter the finally block via `enter-finally-block`.
julia-syntax.scm:        (handler-goto-fixups '())  ;; `goto`s that might need `leave` exprs added
julia-syntax.scm:        (handler-level 0)     ;; exception handler nesting depth
julia-syntax.scm:        (catch-token-stack '())) ;; tokens identifying handler enter for current catch blocks
julia-syntax.scm:    (define (make-label)
julia-syntax.scm:      (begin0 label-counter
julia-syntax.scm:              (set! label-counter (+ 1 label-counter))))
julia-syntax.scm:    (define (mark-label l) (emit `(label ,l)))
julia-syntax.scm:    (define (make&mark-label)
julia-syntax.scm:          (let ((l (make-label)))
julia-syntax.scm:            (mark-label l)
julia-syntax.scm:    ;; `need-goto` is true. Before entering, the current code path is identified
julia-syntax.scm:    (define (enter-finally-block action (need-goto #t))
julia-syntax.scm:      (let* ((tags (caddr finally-handler))
julia-syntax.scm:        (set-car! (cddr finally-handler) (cons (cons tag action) tags))
julia-syntax.scm:        (emit `(= ,(car finally-handler) ,tag))
julia-syntax.scm:        (if need-goto
julia-syntax.scm:            (let ((label (cadr finally-handler))
julia-syntax.scm:                  (dest-handler-level (cadddr finally-handler))
julia-syntax.scm:                  (dest-tokens        (caddddr finally-handler)))
julia-syntax.scm:              (let ((pexc (pop-exc-expr catch-token-stack dest-tokens)))
julia-syntax.scm:              (emit `(leave ,(+ 1 (- handler-level dest-handler-level))))
julia-syntax.scm:    (define (pop-exc-expr src-tokens dest-tokens)
julia-syntax.scm:      (if (eq? src-tokens dest-tokens)
julia-syntax.scm:          (let ((restore-token (let loop ((s src-tokens))
julia-syntax.scm:                                 (if (eq? (cdr s) dest-tokens)
julia-syntax.scm:            `(pop_exception ,restore-token))))
julia-syntax.scm:    (define (emit-return x)
julia-syntax.scm:      (define (actually-return x)
julia-syntax.scm:                        (compile (convert-for-type-decl x rett) '() #t #f)
julia-syntax.scm:               (tmp (if ((if (null? catch-token-stack) valid-ir-return? simple-atom?) x)
julia-syntax.scm:                        (make-ssavalue))))
julia-syntax.scm:          (let ((pexc (pop-exc-expr catch-token-stack '())))
julia-syntax.scm:          (if (> handler-level 0)
julia-syntax.scm:              (let ((tmp (cond ((and (simple-atom? x) (or (not (ssavalue? x)) (not finally-handler))) #f)
julia-syntax.scm:                               (finally-handler  (new-mutable-var))
julia-syntax.scm:                               (else             (make-ssavalue)))))
julia-syntax.scm:                (if finally-handler
julia-syntax.scm:                    (enter-finally-block `(return ,(or tmp x)))
julia-syntax.scm:                    (begin (emit `(leave ,handler-level))
julia-syntax.scm:                           (actually-return (or tmp x))))
julia-syntax.scm:              (actually-return x))))
julia-syntax.scm:    (define (emit-break labl)
julia-syntax.scm:            (dest-tokens (cadddr labl)))
julia-syntax.scm:        (if (and finally-handler (> (cadddr finally-handler) lvl))
julia-syntax.scm:            (enter-finally-block `(break ,labl))
julia-syntax.scm:              (let ((pexc (pop-exc-expr catch-token-stack dest-tokens)))
julia-syntax.scm:              (if (> handler-level lvl)
julia-syntax.scm:                  (emit `(leave ,(- handler-level lvl))))
julia-syntax.scm:    (define (new-mutable-var . name)
julia-syntax.scm:      (let ((g (if (null? name) (gensy) (named-gensy (car name)))))
julia-syntax.scm:        (set-car! (lam:vinfo lam) (append (car (lam:vinfo lam)) `((,g Any 2))))
julia-syntax.scm:    ;; give an error for misplaced top-level-only expressions
julia-syntax.scm:    (define (check-top-level e)
julia-syntax.scm:      (define (head-to-text h)
julia-syntax.scm:          (error (string (head-to-text (car e)) " expression not at top level"))))
julia-syntax.scm:    (define (compile-args lst break-labels)
julia-syntax.scm:          (let ((simple? (every (lambda (x) (or (simple-atom? x) (symbol? x)
julia-syntax.scm:                         (aval (or (compile arg break-labels #t #f)
julia-syntax.scm:                                         (not (simple-atom? arg))
julia-syntax.scm:                                         (not (simple-atom? aval))
julia-syntax.scm:                                    (let ((tmp (make-ssavalue)))
julia-syntax.scm:    (define (compile-cond ex break-labels)
julia-syntax.scm:      (let ((cnd (or (compile ex break-labels #t #f)
julia-syntax.scm:        (if (not (valid-ir-argument? cnd))
julia-syntax.scm:            (let ((tmp (make-ssavalue)))
julia-syntax.scm:    (define (emit-cond cnd break-labels endl)
julia-syntax.scm:                       (begin (if (length> cnd 2) (compile (butlast cnd) break-labels #f #f))
julia-syntax.scm:                        (let ((short-circuit `(goto _)))
julia-syntax.scm:                          (for-each
julia-syntax.scm:                              (let ((jmp (emit `(gotoifnot ,(compile-cond clause break-labels) ,endl))))
julia-syntax.scm:                                (emit short-circuit)
julia-syntax.scm:                                (set-car! (cddr jmp) (make&mark-label))))
julia-syntax.scm:                          (let ((last-jmp (emit `(gotoifnot ,(compile-cond (last (cdr cnd)) break-labels) ,endl))))
julia-syntax.scm:                            (set-car! (cdr short-circuit) (make&mark-label))
julia-syntax.scm:                            (list last-jmp)))
julia-syntax.scm:                               (emit `(gotoifnot ,(compile-cond clause break-labels) ,endl)))
julia-syntax.scm:    (define (emit-assignment lhs rhs)
julia-syntax.scm:          (if (valid-ir-rvalue? lhs rhs)
julia-syntax.scm:              (let ((rr (make-ssavalue)))
julia-syntax.scm:    ;; the interpreter loop. `break-labels` keeps track of the labels to jump to
julia-syntax.scm:    ;; for all currently closing break-blocks.
julia-syntax.scm:    (define (compile e break-labels value tail)
julia-syntax.scm:          (let ((e1 (if (and arg-map (symbol? e))
julia-syntax.scm:                        (get arg-map e e)
julia-syntax.scm:            (if (and value (or (underscore-symbol? e)
julia-syntax.scm:                                    (underscore-symbol? (cadr e)))))
julia-syntax.scm:                (error (string "all-underscore identifier used as rvalue" (format-loc current-loc))))
julia-syntax.scm:            (cond (tail  (emit-return e1))
julia-syntax.scm:                  ((symbol? e1) (emit e1) #f)  ;; keep symbols for undefined-var checking
julia-syntax.scm:                  ((and (pair? e1) (eq? (car e1) 'outerref)) (emit e1) #f)  ;; keep globals for undefined-var checking
julia-syntax.scm:                  ((and (pair? e1) (eq? (car e1) 'globalref)) (emit e1) #f) ;; keep globals for undefined-var checking
julia-syntax.scm:             (define (atom-or-not-tuple-call? fptr)
julia-syntax.scm:                   (not (tuple-call? fptr))))
julia-syntax.scm:                            (append (if (atom-or-not-tuple-call? (cadr e))
julia-syntax.scm:                                        (compile-args (list (cadr e)) break-labels)
julia-syntax.scm:                                    (list-head (cddr e) 4)
julia-syntax.scm:                                    (compile-args (list-tail e 6) break-labels)))
julia-syntax.scm:                            (let ((fptr (car (compile-args (list (caddr e)) break-labels))))
julia-syntax.scm:                             (let* ((oc_method (car (list-tail (cdr e) 4))) ;; opaque_closure_method
julia-syntax.scm:                                  (compile-args (list-head (cdr e) 4) break-labels)
julia-syntax.scm:                                  (compile-args (list-tail (cdr e) 5) break-labels))))
julia-syntax.scm:                                    (if (atom-or-not-tuple-call? (caddr e))
julia-syntax.scm:                                        (compile-args (list (caddr e)) break-labels)
julia-syntax.scm:                                    (compile-args (cdddr e) break-labels)))
julia-syntax.scm:                            (compile-args (cdr e) break-labels))))
julia-syntax.scm:               (cond (tail (emit-return callex))
julia-syntax.scm:               (if (and (symbol? lhs) (underscore-symbol? lhs))
julia-syntax.scm:                   (compile (caddr e) break-labels value tail)
julia-syntax.scm:                   (let* ((rhs (compile (caddr e) break-labels #t #f))
julia-syntax.scm:                          (lhs (if (and arg-map (symbol? lhs))
julia-syntax.scm:                                   (get arg-map lhs lhs)
julia-syntax.scm:                                       rhs (make-ssavalue))))
julia-syntax.scm:                           (if tail (emit-return rr))
julia-syntax.scm:                         (emit-assignment lhs rhs))))))
julia-syntax.scm:             (let* ((last-fname filename)
julia-syntax.scm:                    (fnm        (first-non-meta e))
julia-syntax.scm:                    (file-diff  (not (eq? fname last-fname)))
julia-syntax.scm:                    (need-meta  (and file-diff last-fname
julia-syntax.scm:               (if file-diff (set! filename fname))
julia-syntax.scm:               (if need-meta (emit `(meta push_loc ,fname)))
julia-syntax.scm:                      (compile (car xs) break-labels value tail)
julia-syntax.scm:                      (begin (compile (car xs) break-labels #f #f)
julia-syntax.scm:                (if need-meta
julia-syntax.scm:                        ;; If we need to return the last non-meta expression
julia-syntax.scm:                          (if (complex-return? retv)
julia-syntax.scm:                              (let ((tmp (make-ssavalue)))
julia-syntax.scm:                (if file-diff (set! filename last-fname)))))
julia-syntax.scm:             (compile (cadr e) break-labels #t #t)
julia-syntax.scm:                 (compile (cadr e) break-labels value tail)
julia-syntax.scm:             (let* ((tests (emit-cond (cadr e) break-labels '_))
julia-syntax.scm:                    (end-jump `(goto _))
julia-syntax.scm:                    (val (if (and value (not tail)) (new-mutable-var) #f)))
julia-syntax.scm:               (let ((v1 (compile (caddr e) break-labels value tail)))
julia-syntax.scm:                 (if val (emit-assignment val v1))
julia-syntax.scm:                     (emit end-jump))
julia-syntax.scm:                 (let ((elselabel (make&mark-label)))
julia-syntax.scm:                   (for-each (lambda (test)
julia-syntax.scm:                               (set-car! (cddr test) elselabel))
julia-syntax.scm:                               (compile (cadddr e) break-labels value tail)
julia-syntax.scm:                   (if val (emit-assignment val v2))
julia-syntax.scm:                       (set-car! (cdr end-jump) (make&mark-label))
julia-syntax.scm:                           (emit-return v2)))
julia-syntax.scm:             (let* ((endl (make-label))
julia-syntax.scm:                    (topl (make&mark-label)))
julia-syntax.scm:               (emit-cond (cadr e) break-labels endl)
julia-syntax.scm:               (compile (caddr e) break-labels #f #f)
julia-syntax.scm:               (mark-label endl))
julia-syntax.scm:             (if value (compile '(null) break-labels value tail)))
julia-syntax.scm:             (let* ((endl (make-label))
julia-syntax.scm:                    (topl (make&mark-label)))
julia-syntax.scm:               (compile (cadr e) break-labels #f #f)
julia-syntax.scm:               (let ((test (compile-cond (caddr e) break-labels)))
julia-syntax.scm:               (mark-label endl))
julia-syntax.scm:             (if value (compile '(null) break-labels value tail)))
julia-syntax.scm:            ((break-block)
julia-syntax.scm:             (let ((endl (make-label)))
julia-syntax.scm:                        (cons (list (cadr e) endl handler-level catch-token-stack)
julia-syntax.scm:                              break-labels)
julia-syntax.scm:               (mark-label endl))
julia-syntax.scm:             (if value (compile '(null) break-labels value tail)))
julia-syntax.scm:             (let ((labl (assq (cadr e) break-labels)))
julia-syntax.scm:                   (emit-break labl))))
julia-syntax.scm:                 (if (has? label-nesting (cadr e))
julia-syntax.scm:                     (put! label-nesting (cadr e) (list handler-level catch-token-stack))))
julia-syntax.scm:             (let ((m (get label-map (cadr e) #f)))
julia-syntax.scm:                   (put! label-map (cadr e) (make&mark-label)))
julia-syntax.scm:                   (emit-return '(null))
julia-syntax.scm:             (let* ((m (get label-map (cadr e) #f))
julia-syntax.scm:                    (m (or m (let ((l (make-label)))
julia-syntax.scm:                               (put! label-map (cadr e) l)
julia-syntax.scm:               (set! handler-goto-fixups
julia-syntax.scm:                     (cons (list code handler-level catch-token-stack (cadr e)) handler-goto-fixups))
julia-syntax.scm:            ;; (= tok (enter L)) - push handler with catch block at label L, yielding token
julia-syntax.scm:            ;; (leave n) - pop N exception handlers
julia-syntax.scm:            ;; (pop_exception tok) - pop exception stack back to state of associated enter
julia-syntax.scm:             (let ((handler-token (make-ssavalue))
julia-syntax.scm:                   (catch (make-label))
julia-syntax.scm:                   (endl  (make-label))
julia-syntax.scm:                   (last-finally-handler finally-handler)
julia-syntax.scm:                   (finally           (if (eq? (car e) 'tryfinally) (new-mutable-var) #f))
julia-syntax.scm:                   (my-finally-handler #f))
julia-syntax.scm:               (emit `(= ,handler-token (enter ,catch)))
julia-syntax.scm:               (set! handler-level (+ handler-level 1))
julia-syntax.scm:               (if finally (begin (set! my-finally-handler (list finally endl '() handler-level catch-token-stack))
julia-syntax.scm:                                  (set! finally-handler my-finally-handler)
julia-syntax.scm:                                  (emit `(= ,finally -1))))
julia-syntax.scm:               (let* ((v1  (compile (cadr e) break-labels value #f)) ;; emit try block code
julia-syntax.scm:                               (new-mutable-var) #f)))
julia-syntax.scm:                 (if (and val v1) (emit-assignment val v1))
julia-syntax.scm:                     (begin (if v1 (emit-return v1))
julia-syntax.scm:                 (set! handler-level (- handler-level 1))
julia-syntax.scm:                 (mark-label catch)
julia-syntax.scm:                     (begin (enter-finally-block '(call (top rethrow)) #f) ;; enter block via exception
julia-syntax.scm:                            (mark-label endl) ;; non-exceptional control flow enters here
julia-syntax.scm:                            (set! finally-handler last-finally-handler)
julia-syntax.scm:                            (compile (caddr e) break-labels #f #f)
julia-syntax.scm:                            (let loop ((actions (caddr my-finally-handler)))
julia-syntax.scm:                                                  (make-label))))
julia-syntax.scm:                                        (let ((tmp (make-ssavalue)))
julia-syntax.scm:                                      (cond ((eq? (car ac) 'return) (emit-return (cadr ac)))
julia-syntax.scm:                                            ((eq? (car ac) 'break)  (emit-break (cadr ac)))
julia-syntax.scm:                                    (if skip (mark-label skip))
julia-syntax.scm:                     (begin (set! catch-token-stack (cons handler-token catch-token-stack))
julia-syntax.scm:                            (let ((v2 (compile (caddr e) break-labels value tail)))
julia-syntax.scm:                              (if val (emit-assignment val v2))
julia-syntax.scm:                              (if (not tail) (emit `(pop_exception ,handler-token)))
julia-syntax.scm:                                             ;; else done in emit-return from compile
julia-syntax.scm:                              (if endl (mark-label endl)))
julia-syntax.scm:                            (set! catch-token-stack (cdr catch-token-stack))))
julia-syntax.scm:            ((local-def) #f)
julia-syntax.scm:            ((moved-local)
julia-syntax.scm:             (set-car! (lam:vinfo lam) (append (car (lam:vinfo lam)) `((,(cadr e) Any 2))))
julia-syntax.scm:             (if (local-in? (cadr e) lam)
julia-syntax.scm:                 (error (string "unsupported `const` declaration on local variable" (format-loc current-loc)))
julia-syntax.scm:                     (if (not global-const-error)
julia-syntax.scm:                         (set! global-const-error current-loc))
julia-syntax.scm:            ((isdefined) (if tail (emit-return e) e))
julia-syntax.scm:            ((boundscheck) (if tail (emit-return e) e))
julia-syntax.scm:                 (error (string "Global method definition" (linenode-string current-loc)
julia-syntax.scm:                 (let* ((sig (let ((sig (compile (caddr e) break-labels #t #f)))
julia-syntax.scm:                               (if (valid-ir-argument? sig)
julia-syntax.scm:                                   (let ((l (make-ssavalue)))
julia-syntax.scm:                                 (let ((l  (make-ssavalue)))
julia-syntax.scm:                                   (emit `(= ,l ,(compile lam break-labels #t #f)))
julia-syntax.scm:                   (if value (compile '(null) break-labels value tail)))
julia-syntax.scm:                 (cond (tail  (emit-return e))
julia-syntax.scm:               (cond (tail  (emit-return temp))
julia-syntax.scm:             (check-top-level e)
julia-syntax.scm:             (if tail (emit-return '(null)))
julia-syntax.scm:            ((toplevel-only)
julia-syntax.scm:             (check-top-level (cdr e))
julia-syntax.scm:             (check-top-level e)
julia-syntax.scm:             (let ((val (make-ssavalue)))
julia-syntax.scm:               (if tail (emit-return val))
julia-syntax.scm:             (check-top-level e)
julia-syntax.scm:             (let ((have-ret? (and (pair? code) (pair? (car code)) (eq? (caar code) 'return))))
julia-syntax.scm:               (if (and tail (not have-ret?))
julia-syntax.scm:                   (emit-return '(null))))
julia-syntax.scm:             (let ((args (compile-args (cdr e) break-labels)))
julia-syntax.scm:             (let ((have-ret? (and (pair? code) (pair? (car code)) (eq? (caar code) 'return))))
julia-syntax.scm:                      (set! current-loc e)
julia-syntax.scm:                      (if first-line
julia-syntax.scm:                          (begin (set! first-line #f)
julia-syntax.scm:                          ;; strip filenames out of non-initial line nodes
julia-syntax.scm:                     ((and (eq? (car e) 'meta) (length> e 2) (eq? (cadr e) 'ret-type))
julia-syntax.scm:               (if (and tail (not have-ret?))
julia-syntax.scm:                   (emit-return '(null)))
julia-syntax.scm:    (for-each (lambda (v)
julia-syntax.scm:                      (if (not arg-map)
julia-syntax.scm:                          (set! arg-map (table)))
julia-syntax.scm:                      (put! arg-map (car v) (new-mutable-var (car v))))))
julia-syntax.scm:              (list-head vi (length (lam:args lam))))
julia-syntax.scm:    (for-each (lambda (x)
julia-syntax.scm:                      (src-tokens (caddr x))
julia-syntax.scm:                  (let ((target-nesting (get label-nesting lab #f)))
julia-syntax.scm:                    (if (not target-nesting)
julia-syntax.scm:                    (let ((target-level (car target-nesting)))
julia-syntax.scm:                      (cond ((> target-level hl)
julia-syntax.scm:                            ((= target-level hl)
julia-syntax.scm:                             (set-cdr! point (cddr point))) ;; remove empty slot
julia-syntax.scm:                             (set-car! (cdr point) `(leave ,(- hl target-level))))))
julia-syntax.scm:                    (let ((pexc (pop-exc-expr src-tokens (cadr target-nesting))))
julia-syntax.scm:                      (if pexc (set-cdr! point (cons pexc (cdr point))))))))
julia-syntax.scm:              handler-goto-fixups)
julia-syntax.scm:    (if global-const-error
julia-syntax.scm:        (error (string "`global const` declaration not allowed inside function" (format-loc global-const-error))))
julia-syntax.scm:           (di    (definitely-initialized-vars stmts vi))
julia-syntax.scm:      (if arg-map
julia-syntax.scm:          (insert-after-meta
julia-syntax.scm:                        '() arg-map))
julia-syntax.scm:(define (for-each-isdefined f e)
julia-syntax.scm:         (for-each (lambda (x) (for-each-isdefined f x))
julia-syntax.scm:;; This is used to remove newvar nodes that are not needed for re-initializing
julia-syntax.scm:;; It doesn't look for variable *uses*, because any variables used-before-def
julia-syntax.scm:;; to be *re*-initialized.
julia-syntax.scm:(define (definitely-initialized-vars stmts vi)
julia-syntax.scm:              (for-each-isdefined (lambda (x) (if (has? vars x) (del! vars x)))
julia-syntax.scm:                     (let ((vinf (var-info-for (cadr e) vi)))
julia-syntax.scm:(define (listify-lambda lam)
julia-syntax.scm:(define (make-lineinfo name file line (inlined-at #f))
julia-syntax.scm:  `(lineinfo (thismodule) ,(if inlined-at '|macro expansion| name) ,file ,line ,(or inlined-at 0)))
julia-syntax.scm:(define (set-lineno! lineinfo num)
julia-syntax.scm:  (set-car! (cddddr lineinfo) num))
julia-syntax.scm:(define (compact-ir body name file line)
julia-syntax.scm:        (current-loc  0)
julia-syntax.scm:        (current-file file)
julia-syntax.scm:        (current-line line)
julia-syntax.scm:          (begin (set! linetable (cons (make-lineinfo name file line) linetable))
julia-syntax.scm:                 (set! current-loc 1)))
julia-syntax.scm:                 (set! locs (cons current-loc locs)))))
julia-syntax.scm:                   (if (and (= current-line 0) (length= e 2) (pair? linetable))
julia-syntax.scm:                       (begin (set-lineno! (car linetable) (cadr e))
julia-syntax.scm:                              (set! current-line (cadr e)))
julia-syntax.scm:                         (set! current-line (cadr e))
julia-syntax.scm:                             (set! current-file (caddr e)))
julia-syntax.scm:                                                   (make-lineinfo name current-file current-line)
julia-syntax.scm:                                                   (make-lineinfo name current-file current-line (caar locstack)))
julia-syntax.scm:                         (set! current-loc (- (length linetable) 1)))))
julia-syntax.scm:                   (set! locstack (cons (list current-loc current-line current-file) locstack))
julia-syntax.scm:                   (set! current-file (caddr e))
julia-syntax.scm:                   (set! current-line 0)
julia-syntax.scm:                   (set! linetable (cons (make-lineinfo name current-file current-line current-loc) linetable))
julia-syntax.scm:                   (set! current-loc (- (length linetable) 1)))
julia-syntax.scm:                     (set! current-loc (car l))
julia-syntax.scm:                     (set! current-line (cadr l))
julia-syntax.scm:                     (set! current-file (caddr l))))
julia-syntax.scm:(define (renumber-lambda lam file line)
julia-syntax.scm:  (let* ((stuff (compact-ir (lam:body lam)
julia-syntax.scm:                            (if (null? (cadr lam)) '|top-level scope| 'none)
julia-syntax.scm:         (ssavalue-table (aref stuff 3))
julia-syntax.scm:         (label-table (aref stuff 4)))
julia-syntax.scm:    (set-car! (cdddr lam) code)
julia-syntax.scm:    (define slot-table (symbol-to-idx-map (map car (car (lam:vinfo lam)))))
julia-syntax.scm:    (define sp-table (symbol-to-idx-map (lam:sp lam)))
julia-syntax.scm:    (define (renumber-stuff e)
julia-syntax.scm:             (let ((idx (get slot-table e #f)))
julia-syntax.scm:                   (let ((idx (get sp-table e #f)))
julia-syntax.scm:            ((nospecialize-meta? e)
julia-syntax.scm:             `(meta ,(cadr e) ,@(map renumber-stuff (cddr e))))
julia-syntax.scm:             (let ((idx (or (get ssavalue-table (cadr e) #f)
julia-syntax.scm:             (list* (car e) (get label-table (cadr e)) (cddr e)))
julia-syntax.scm:             `(gotoifnot ,(renumber-stuff (cadr e)) ,(get label-table (caddr e))))
julia-syntax.scm:             (renumber-lambda e 'none 0))
julia-syntax.scm:                            (map renumber-stuff (cdr e)))))
julia-syntax.scm:                        (tuple-call? (cadr e))
julia-syntax.scm:                        (expr-contains-p (lambda (x) (or (ssavalue? x) (slot? x))) (cadr e)))
julia-syntax.scm:    (let ((body (renumber-stuff (lam:body lam)))
julia-syntax.scm:      (listify-lambda
julia-syntax.scm:(define (compact-and-renumber ex file line)
julia-syntax.scm:          (renumber-lambda ex
julia-syntax.scm:                (map (lambda (e) (compact-and-renumber e file line))
julia-syntax.scm:(define (julia-expand1 ex file line)
julia-syntax.scm:  (compact-and-renumber
julia-syntax.scm:    (closure-convert
julia-syntax.scm:     (analyze-variables!
julia-syntax.scm:      (resolve-scopes ex)))) file line))
julia-syntax.scm:(define *current-desugar-loc* #f)
julia-syntax.scm:(define (julia-expand0 ex file line)
julia-syntax.scm:  (with-bindings ((*current-desugar-loc* `(line ,line ,file)))
julia-syntax.scm:   (trycatch (expand-forms ex)
julia-syntax.scm:                   ; - Line number nodes are sparse in the AST
julia-syntax.scm:                   ; - Line number nodes apply to the next statement, so
julia-syntax.scm:                   ;   tracking by `set!`ing *current-desugar-loc* relies on
julia-syntax.scm:                   (error (string (cadr e) (format-loc *current-desugar-loc*))))
julia-syntax.scm:(define (julia-expand ex (file 'none) (line 0))
julia-syntax.scm:  (julia-expand1
julia-syntax.scm:   (julia-expand0
julia-syntax.scm:    (julia-expand-macroscope ex) file line) file line))
signal-handling.c:// Note: these "static" variables are also used in "signals-*.c"
signal-handling.c:    uint64_t dt = cur_time - jl_last_sigint_trigger;
signal-handling.c:    double new_weight = accum_weight * exp(-(dt / 1e9)) + 0.3;
signal-handling.c:    // hard to interrupt a running process in the debugger with `Ctrl-C`.
signal-handling.c:    // Force sigint requires pressing `Ctrl-C` repeatedly.
signal-handling.c:#include "signals-win.c"
signal-handling.c:#include "signals-unix.c"
signal-handling.c:    return ((ucontext_t*)_ctx)->uc_mcontext.gregs[REG_RIP];
signal-handling.c:    return ((ucontext_t*)_ctx)->uc_mcontext.mc_rip;
signal-handling.c:    return ((ucontext_t*)_ctx)->uc_mcontext.gregs[REG_EIP];
signal-handling.c:    return ((ucontext_t*)_ctx)->uc_mcontext.mc_eip;
signal-handling.c:    return ((ucontext64_t*)_ctx)->uc_mcontext64->__ss.__rip;
signal-handling.c:    return ((ucontext64_t*)_ctx)->uc_mcontext64->__ss.__pc;
signal-handling.c:    return ((CONTEXT*)_ctx)->Eip;
signal-handling.c:    return ((CONTEXT*)_ctx)->Rip;
signal-handling.c:    return ((ucontext_t*)_ctx)->uc_mcontext.pc;
signal-handling.c:    return ((ucontext_t*)_ctx)->uc_mcontext.arm_pc;
signal-handling.c:    if (ctx->uc_mcontext.arm_cpsr & (1 << 5)) {
signal-handling.c:    jl_bt_element_t *bt_data = ct->ptls->bt_data;
signal-handling.c:    size_t *bt_size = &ct->ptls->bt_size;
signal-handling.c:        ct->gcstack = NULL;
signal-handling.c:        ct->eh = NULL;
signal-handling.c:        ct->excstack = NULL;
signal-handling.c:        return -1;
signal-handling.c:    // The "modern FisherYates shuffle" - O(n) algorithm
signal-handling.c:    for (size_t i = size - 1; i >= 1; --i) {
staticdata.c:    // Lazyily-initialize this list
staticdata.c:        assert(i >= (NUM_TAGS-2) && i < NUM_TAGS);
staticdata.c:// this is used to set the method-instance->invoke field
staticdata.c:// this supports up to 8 RefTags, 512MB of pointer data, and 4/2 (64/32-bit) GB of constant data.
staticdata.c:// --- Static Compile ---
staticdata.c:    // in --build mode only use sysimg data, not precompiled native code
staticdata.c:        *tls_offset_idx = (uintptr_t)(jl_tls_offset == -1 ? 0 : jl_tls_offset);
staticdata.c:// --- serializer ---
staticdata.c:    jl_serialize_value(s, m->name);
staticdata.c:    jl_serialize_value(s, m->parent);
staticdata.c:    void **table = m->bindings.table;
staticdata.c:    for (i = 0; i < m->bindings.size; i += 2) {
staticdata.c:            jl_serialize_value(s, b->name);
staticdata.c:            jl_serialize_value(s, jl_atomic_load_relaxed(&b->value));
staticdata.c:            jl_serialize_value(s, jl_atomic_load_relaxed(&b->globalref));
staticdata.c:            jl_serialize_value(s, b->owner);
staticdata.c:    for (i = 0; i < m->usings.len; i++) {
staticdata.c:        jl_serialize_value(s, (jl_value_t*)m->usings.items[i]);
staticdata.c:        if (v == (jl_value_t*)s->ptls->root_task) {
staticdata.c:            jl_serialize_value(s, ((jl_task_t*)v)->tls);
staticdata.c:    if (t->layout->npointers == 0) {
staticdata.c:        if (ar->flags.ptrarray) {
staticdata.c:        else if (ar->flags.hasptr) {
staticdata.c:            uint16_t elsz = ar->elsize;
staticdata.c:            size_t j, np = et->layout->npointers;
staticdata.c:        jl_serialize_value(s, tn->name);
staticdata.c:        jl_serialize_value(s, tn->module);
staticdata.c:        jl_serialize_value(s, tn->names);
staticdata.c:        jl_serialize_value(s, tn->wrapper);
staticdata.c:        jl_serialize_value_(s, (jl_value_t*)tn->cache, 0);
staticdata.c:        jl_serialize_value_(s, (jl_value_t*)tn->linearcache, 0);
staticdata.c:        jl_serialize_value(s, tn->mt);
staticdata.c:        jl_serialize_value(s, tn->partial);
staticdata.c:    else if (t->layout->nfields > 0) {
staticdata.c:        size_t i, np = t->layout->npointers;
staticdata.c:    size_t prevsize = s->size;
staticdata.c:        assert(s->size == newsize);
staticdata.c:        memset(&s->buf[prevsize], 0, newsize - prevsize);
staticdata.c:    ios_ensureroom(s->gvar_record, gid * sizeof(uint32_t));
staticdata.c:    ios_seek(s->gvar_record, (gid - 1) * sizeof(uint32_t));
staticdata.c:    write_uint32(s->gvar_record, reloc_id);
staticdata.c:        nb -= 16;
staticdata.c:    assert((ios_pos(s) & (sizeof(void*) - 1)) == 0 && "stream misaligned for writing a word-sized value");
staticdata.c:            write_uint32(s->symbols, l);
staticdata.c:            ios_write(s->symbols, jl_symbol_name((jl_sym_t*)v), l + 1);
staticdata.c:    else if (v == (jl_value_t*)s->ptls->root_task) {
staticdata.c:    return (char*)idx - 1 - (char*)HT_NOTFOUND;
staticdata.c:        arraylist_push(&s->relocs_list, (void*)(uintptr_t)ios_pos(s->s));
staticdata.c:        arraylist_push(&s->relocs_list, (void*)backref_id(s, fld));
staticdata.c:    write_pointer(s->s);
staticdata.c:    arraylist_push(&s->gctags_list, (void*)(uintptr_t)ios_pos(s->s));
staticdata.c:    arraylist_push(&s->gctags_list, (void*)ref);
staticdata.c:    write_pointer(s->s);
staticdata.c:    size_t reloc_offset = ios_pos(s->s);
staticdata.c:    ios_write(s->s, (char*)m, tot);
staticdata.c:    jl_module_t *newm = (jl_module_t*)&s->s->buf[reloc_offset];
staticdata.c:    newm->name = NULL;
staticdata.c:    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, name)));
staticdata.c:    arraylist_push(&s->relocs_list, (void*)backref_id(s, m->name));
staticdata.c:    newm->parent = NULL;
staticdata.c:    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, parent)));
staticdata.c:    arraylist_push(&s->relocs_list, (void*)backref_id(s, m->parent));
staticdata.c:    newm->primary_world = jl_world_counter;
staticdata.c:    void **table = m->bindings.table;
staticdata.c:    for (i = 0; i < m->bindings.size; i += 2) {
staticdata.c:            size_t binding_reloc_offset = ios_pos(s->s);
staticdata.c:            write_pointerfield(s, (jl_value_t*)b->name);
staticdata.c:            write_pointerfield(s, jl_atomic_load_relaxed(&b->value));
staticdata.c:            write_pointerfield(s, jl_atomic_load_relaxed(&b->globalref));
staticdata.c:            write_pointerfield(s, (jl_value_t*)b->owner);
staticdata.c:            size_t flag_offset = offsetof(jl_binding_t, owner) + sizeof(b->owner);
staticdata.c:            ios_write(s->s, (char*)b + flag_offset, sizeof(*b) - flag_offset);
staticdata.c:    assert(ios_pos(s->s) - reloc_offset == tot);
staticdata.c:    newm = (jl_module_t*)&s->s->buf[reloc_offset]; // buf might have been reallocated
staticdata.c:    newm->bindings.size = count; // stash the count in newm->size
staticdata.c:    newm->bindings.table = NULL;
staticdata.c:    memset(&newm->bindings._space, 0, sizeof(newm->bindings._space));
staticdata.c:    memset(&newm->usings._space, 0, sizeof(newm->usings._space));
staticdata.c:    if (m->usings.items == &m->usings._space[0]) {
staticdata.c:        newm->usings.items = (void**)offsetof(jl_module_t, usings._space);
staticdata.c:        arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, usings.items)));
staticdata.c:        arraylist_push(&s->relocs_list, (void*)(((uintptr_t)DataRef << RELOC_TAG_OFFSET) + item));
staticdata.c:        for (i = 0; i < m->usings.len; i++) {
staticdata.c:            arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, usings._space[i])));
staticdata.c:            arraylist_push(&s->relocs_list, (void*)backref_id(s, m->usings._space[i]));
staticdata.c:        newm->usings.items = (void**)tot;
staticdata.c:        arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, usings.items)));
staticdata.c:        arraylist_push(&s->relocs_list, (void*)(((uintptr_t)DataRef << RELOC_TAG_OFFSET) + item));
staticdata.c:        for (i = 0; i < m->usings.len; i++) {
staticdata.c:            write_pointerfield(s, (jl_value_t*)m->usings.items[i]);
staticdata.c:        for (; i < m->usings.max; i++) {
staticdata.c:            write_pointer(s->s);
staticdata.c:        return SIZE_MAX - 5;
staticdata.c:        return SIZE_MAX - 4;
staticdata.c:    if (dt->name == jl_array_typename)
staticdata.c:        return SIZE_MAX - 3;
staticdata.c:        return SIZE_MAX - 2;
staticdata.c:        return SIZE_MAX - 1;
staticdata.c:    return (sa > sb ? 1 : (sa < sb ? -1 : 0));
staticdata.c:        sa = tya->uid;
staticdata.c:        sb = tyb->uid;
staticdata.c:    return (sa > sb ? 1 : (sa < sb ? -1 : 0));
staticdata.c:            uintptr_t item = reloc_id - 1 - (char*)HT_NOTFOUND;
staticdata.c:        assert((t->instance == NULL || t->instance == v) && "detected singleton construction corruption");
staticdata.c:        uintptr_t skip_header_pos = ios_pos(s->s) + sizeof(jl_taggedvalue_t);
staticdata.c:        write_padding(s->s, LLT_ALIGN(skip_header_pos, 16) - skip_header_pos);
staticdata.c:        size_t reloc_offset = ios_pos(s->s);
staticdata.c:            write_pointer(s->s);
staticdata.c:            size_t datasize = alen * ar->elsize;
staticdata.c:            else if (ar->elsize == 1)
staticdata.c:            int ndimwords = jl_array_ndimwords(ar->flags.ndims);
staticdata.c:            ios_write(s->s, (char*)v, headersize);
staticdata.c:            // make some header modifications in-place
staticdata.c:            jl_array_t *newa = (jl_array_t*)&s->s->buf[reloc_offset];
staticdata.c:            if (newa->flags.ndims == 1)
staticdata.c:                newa->maxsize = alen;
staticdata.c:            newa->offset = 0;
staticdata.c:            newa->flags.how = 0;
staticdata.c:            newa->flags.pooled = 0;
staticdata.c:            newa->flags.isshared = 0;
staticdata.c:            if (!ar->flags.ptrarray && !ar->flags.hasptr) {
staticdata.c:                uintptr_t data = LLT_ALIGN(ios_pos(s->const_data), alignment_amt);
staticdata.c:                write_padding(s->const_data, data - ios_pos(s->const_data));
staticdata.c:                newa->data = NULL; // relocation offset
staticdata.c:                arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_array_t, data))); // relocation location
staticdata.c:                arraylist_push(&s->relocs_list, (void*)(((uintptr_t)ConstDataRef << RELOC_TAG_OFFSET) + data)); // relocation target
staticdata.c:                        write_pointer(s->const_data);
staticdata.c:                        ios_write(s->const_data, (char*)jl_array_data(ar), datasize);
staticdata.c:                        ios_write(s->const_data, jl_array_typetagdata(ar), alen);
staticdata.c:                        ios_write(s->const_data, (char*)jl_array_data(ar), tot);
staticdata.c:                size_t data = LLT_ALIGN(ios_pos(s->s), alignment_amt);
staticdata.c:                size_t padding_amt = data - ios_pos(s->s);
staticdata.c:                write_padding(s->s, padding_amt);
staticdata.c:                newa->data = (void*)headersize; // relocation offset
staticdata.c:                arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_array_t, data))); // relocation location
staticdata.c:                arraylist_push(&s->relocs_list, (void*)(((uintptr_t)DataRef << RELOC_TAG_OFFSET) + item)); // relocation target
staticdata.c:                if (ar->flags.hasptr) {
staticdata.c:                    ios_write(s->s, data, datasize);
staticdata.c:                    uint16_t elsz = ar->elsize;
staticdata.c:                    size_t j, np = ((jl_datatype_t*)et)->layout->npointers;
staticdata.c:                                arraylist_push(&s->relocs_list, (void*)(uintptr_t)(reloc_offset + headersize + offset)); // relocation location
staticdata.c:                                arraylist_push(&s->relocs_list, (void*)backref_id(s, fld)); // relocation target
staticdata.c:                                memset(&s->s->buf[reloc_offset + headersize + offset], 0, sizeof(fld)); // relocation offset (none)
staticdata.c:                                assert(*(jl_value_t**)&s->s->buf[reloc_offset + headersize + offset] == NULL);
staticdata.c:            ios_write(s->s, (char*)v, sizeof(void*));
staticdata.c:            ios_write(s->s, (char*)v, sizeof(void*) + jl_string_len(v));
staticdata.c:            write_uint8(s->s, '\0'); // null-terminated strings for easier C-compatibility
staticdata.c:            assert(t->layout->npointers == 0);
staticdata.c:            if (t->size > 0)
staticdata.c:                ios_write(s->s, (char*)v, t->size);
staticdata.c:            int32_t nw = (sz == 0 ? 1 : (sz < 0 ? -sz : sz));
staticdata.c:            ios_write(s->s, (char*)&nw, sizeof(int32_t));
staticdata.c:            ios_write(s->s, (char*)&sz, sizeof(int32_t));
staticdata.c:            uintptr_t data = LLT_ALIGN(ios_pos(s->const_data), 8);
staticdata.c:            write_padding(s->const_data, data - ios_pos(s->const_data));
staticdata.c:            arraylist_push(&s->relocs_list, (void*)(reloc_offset + 8)); // relocation location
staticdata.c:            arraylist_push(&s->relocs_list, (void*)(((uintptr_t)ConstDataRef << RELOC_TAG_OFFSET) + data)); // relocation target
staticdata.c:            ios_write(s->const_data, (char*)pdata, nb);
staticdata.c:            write_pointer(s->s);
staticdata.c:                write_padding(s->s, offset - tot);
staticdata.c:                if (t->name->mutabl && jl_is_cpointer_type(jl_field_type(t, i))) {
staticdata.c:                    write_pointer(s->s);
staticdata.c:                    ios_write(s->s, slot, fsz);
staticdata.c:            size_t np = t->layout->npointers;
staticdata.c:                    arraylist_push(&s->relocs_list, (void*)(uintptr_t)(offset + reloc_offset)); // relocation location
staticdata.c:                    arraylist_push(&s->relocs_list, (void*)backref_id(s, fld)); // relocation target
staticdata.c:                    memset(&s->s->buf[offset + reloc_offset], 0, sizeof(fld)); // relocation offset (none)
staticdata.c:                write_padding(s->s, sizeof(jl_method_t) - tot);
staticdata.c:                if (((jl_method_t*)v)->ccallable) {
staticdata.c:                jl_code_instance_t *newm = (jl_code_instance_t*)&s->s->buf[reloc_offset];
staticdata.c:                newm->invoke = NULL;
staticdata.c:                newm->isspecsig = 0;
staticdata.c:                newm->specptr.fptr = NULL;
staticdata.c:                if (m->invoke == jl_fptr_const_return) {
staticdata.c:                    if (jl_is_method(m->def->def.method)) {
staticdata.c:                        builtin_id = jl_fptr_id(m->specptr.fptr);
staticdata.c:                                if (invokeptr_id == -1) {
staticdata.c:                                else if (invokeptr_id == -2) {
staticdata.c:                                    ios_ensureroom(s->fptr_record, invokeptr_id * sizeof(void*));
staticdata.c:                                    ios_seek(s->fptr_record, (invokeptr_id - 1) * sizeof(void*));
staticdata.c:                                    write_uint32(s->fptr_record, ~reloc_offset);
staticdata.c:                                    write_padding(s->fptr_record, 4);
staticdata.c:                                    ios_ensureroom(s->fptr_record, specfptr_id * sizeof(void*));
staticdata.c:                                    ios_seek(s->fptr_record, (specfptr_id - 1) * sizeof(void*));
staticdata.c:                                    write_uint32(s->fptr_record, reloc_offset);
staticdata.c:                                    write_padding(s->fptr_record, 4);
staticdata.c:                newm->invoke = NULL; // relocation offset
staticdata.c:                    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_code_instance_t, invoke))); // relocation location
staticdata.c:                    arraylist_push(&s->relocs_list, (void*)(((uintptr_t)FunctionRef << RELOC_TAG_OFFSET) + fptr_id)); // relocation target
staticdata.c:                    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_code_instance_t, specptr.fptr))); // relocation location
staticdata.c:                    arraylist_push(&s->relocs_list, (void*)(((uintptr_t)BuiltinFunctionRef << RELOC_TAG_OFFSET) + builtin_id - 2)); // relocation target
staticdata.c:                jl_datatype_t *newdt = (jl_datatype_t*)&s->s->buf[reloc_offset];
staticdata.c:                if (dt->layout != NULL) {
staticdata.c:                    size_t nf = dt->layout->nfields;
staticdata.c:                    size_t np = dt->layout->npointers;
staticdata.c:                    size_t fieldsize = jl_fielddesc_size(dt->layout->fielddesc_type);
staticdata.c:                    char *flddesc = (char*)dt->layout;
staticdata.c:                    if (dt->layout->first_ptr != -1)
staticdata.c:                        fldsize += np << dt->layout->fielddesc_type;
staticdata.c:                    uintptr_t layout = LLT_ALIGN(ios_pos(s->const_data), sizeof(void*));
staticdata.c:                    write_padding(s->const_data, layout - ios_pos(s->const_data)); // realign stream
staticdata.c:                    newdt->layout = NULL; // relocation offset
staticdata.c:                    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_datatype_t, layout))); // relocation location
staticdata.c:                    arraylist_push(&s->relocs_list, (void*)(((uintptr_t)ConstDataRef << RELOC_TAG_OFFSET) + layout)); // relocation target
staticdata.c:                    ios_write(s->const_data, flddesc, fldsize);
staticdata.c:                jl_typename_t *newtn = (jl_typename_t*)&s->s->buf[reloc_offset];
staticdata.c:                if (tn->atomicfields != NULL) {
staticdata.c:                    size_t nb = (jl_svec_len(tn->names) + 31) / 32 * sizeof(uint32_t);
staticdata.c:                    uintptr_t layout = LLT_ALIGN(ios_pos(s->const_data), sizeof(void*));
staticdata.c:                    write_padding(s->const_data, layout - ios_pos(s->const_data)); // realign stream
staticdata.c:                    newtn->atomicfields = NULL; // relocation offset
staticdata.c:                    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_typename_t, atomicfields))); // relocation location
staticdata.c:                    arraylist_push(&s->relocs_list, (void*)(((uintptr_t)ConstDataRef << RELOC_TAG_OFFSET) + layout)); // relocation target
staticdata.c:                    ios_write(s->const_data, (char*)tn->atomicfields, nb);
staticdata.c:            else if (((jl_datatype_t*)(jl_typeof(v)))->name == jl_idtable_typename) {
staticdata.c:                write_padding(s->s, t->size - tot);
staticdata.c:    if (v->left)
staticdata.c:        jl_write_gv_syms(s, v->left);
staticdata.c:    if (v->right)
staticdata.c:        jl_write_gv_syms(s, v->right);
staticdata.c:    jl_write_gv_tagref(s, (jl_value_t*)s->ptls->root_task);
staticdata.c:    jl_write_gv_tagref(s, s->ptls->root_task->tls);
staticdata.c:        jl_write_gv_tagref(s, jl_box_int32((int32_t)i - NBOX_C / 2));
staticdata.c:        jl_write_gv_tagref(s, jl_box_int64((int64_t)i - NBOX_C / 2));
staticdata.c:    uintptr_t base = (uintptr_t)&s->symbols->buf[0];
staticdata.c:    uintptr_t end = base + s->symbols->size;
staticdata.c:        // write reloc_offset into s->s at pos
staticdata.c:        size_t offset = (reloc_item & (((uintptr_t)1 << RELOC_TAG_OFFSET) - 1));
staticdata.c:        return reloc_item; // pre-composed relocation + offset
staticdata.c:    size_t offset = (reloc_id & (((uintptr_t)1 << RELOC_TAG_OFFSET) - 1));
staticdata.c:        return (uintptr_t)s->const_data->buf + (offset * sizeof(void*));
staticdata.c:            return (uintptr_t)s->ptls->root_task;
staticdata.c:        offset -= 2;
staticdata.c:            return (uintptr_t)jl_box_int64((int64_t)offset - NBOX_C / 2);
staticdata.c:        offset -= NBOX_C;
staticdata.c:            return (uintptr_t)jl_box_int32((int32_t)offset - NBOX_C / 2);
staticdata.c:        offset -= NBOX_C;
staticdata.c:        // offset -= 256;
staticdata.c:    for (i = 0; i < list->len; i += 2) {
staticdata.c:        size_t pos = (size_t)list->items[i];
staticdata.c:        size_t item = (size_t)list->items[i + 1];
staticdata.c:        // TODO: save space by using delta-compression
staticdata.c:    char *base = &s->s->buf[0];
staticdata.c:    jl_write_skiplist(s->relocs, base, s->s->size, &s->gctags_list);
staticdata.c:    jl_write_skiplist(s->relocs, base, s->s->size, &s->relocs_list);
staticdata.c:    uintptr_t base = (uintptr_t)&s->s->buf[0];
staticdata.c:    size_t size = s->s->size;
staticdata.c:        uintptr_t val = (uintptr_t)&s->relocs->buf[s->relocs->bpos];
staticdata.c:        s->relocs->bpos += sizeof(uint32_t);
staticdata.c:        o->bits.gc = GC_OLD;
staticdata.c:        write_uint32(s->s, 0);
staticdata.c:    write_uint32(s->s, reloc);
staticdata.c:    uintptr_t base = (uintptr_t)&s->s->buf[0];
staticdata.c:    size_t size = s->s->size;
staticdata.c:    uintptr_t val = base + s->s->bpos;
staticdata.c:    s->s->bpos += sizeof(uint32_t);
staticdata.c:    int sysimg_fvars_max = s->fptr_record->size / sizeof(void*);
staticdata.c:    uintptr_t base = (uintptr_t)&s->s->buf[0];
staticdata.c:    jl_method_instance_t **linfos = (jl_method_instance_t**)&s->fptr_record->buf[0];
staticdata.c:            if (offset & ((uintptr_t)1 << (8 * sizeof(uint32_t) - 1))) {
staticdata.c:            assert(jl_is_method(codeinst->def->def.method) && codeinst->invoke != jl_fptr_const_return);
staticdata.c:            assert(specfunc ? codeinst->invoke != NULL : codeinst->invoke == NULL);
staticdata.c:            linfos[i] = codeinst->def;
staticdata.c:                codeinst->specptr.fptr = fptr;
staticdata.c:                codeinst->isspecsig = 1; // TODO: set only if confirmed to be true
staticdata.c:                codeinst->invoke = (jl_callptr_t)fptr;
staticdata.c:    uintptr_t base = (uintptr_t)&s->s->buf[0];
staticdata.c:    size_t size = s->s->size;
staticdata.c:    uintptr_t gvars = (uintptr_t)&s->gvar_record->buf[0];
staticdata.c:    uintptr_t end = gvars + s->gvar_record->size;
staticdata.c:    l = list->len;
staticdata.c:        size_t item = (size_t)list->items[i];
staticdata.c:        write_uint32(s->s, (uint32_t)reloc_offset);
staticdata.c:        write_uint32(s->s, (uint32_t)((uintptr_t)list->items[i + 1]));
staticdata.c:    write_uint32(s->s, 0);
staticdata.c:            size_t nbindings = mod->bindings.size;
staticdata.c:            htable_new(&mod->bindings, nbindings);
staticdata.c:                ptrhash_put(&mod->bindings, b->asname, &b->b);
staticdata.c:                nbindings -= 1;
staticdata.c:            if (mod->usings.items != &mod->usings._space[0]) {
staticdata.c:                void **newitems = (void**)malloc_s(mod->usings.max * sizeof(void*));
staticdata.c:                memcpy(newitems, mod->usings.items, mod->usings.len * sizeof(void*));
staticdata.c:                mod->usings.items = newitems;
staticdata.c:            jl_svec_t *sv = ((jl_method_t*)v)->ccallable;
staticdata.c:    uintptr_t base = (uintptr_t)&s->s->buf[0];
staticdata.c:        size_t offset = read_uint32(s->s);
staticdata.c:        jl_reinit_item(v, read_uint32(s->s));
staticdata.c:            jl_value_t *singleton = ((jl_datatype_t*)ti)->instance;
staticdata.c:        memset(&jl_svec_data(cache)[ins], 0, (i - ins) * sizeof(jl_value_t*));
staticdata.c:// --- entry points ---
staticdata.c:    s.ptls = jl_current_task->ptls;
staticdata.c:    jl_idtable_typename = jl_base_module ? ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_idtable_type))->name : NULL;
staticdata.c:            jl_scan_type_cache_gv(&s, tn->cache);
staticdata.c:            jl_scan_type_cache_gv(&s, tn->linearcache);
staticdata.c:        // built-in type caches
staticdata.c:            jl_prune_type_cache_hash(tn->cache);
staticdata.c:            jl_prune_type_cache_linear(tn->linearcache);
staticdata.c:    write_uint32(f, sysimg.size - sizeof(uint32_t));
staticdata.c:    // realign stream to max-alignment for data
staticdata.c:    write_padding(f, LLT_ALIGN(ios_pos(f), 16) - ios_pos(f));
staticdata.c:        jl_write_value(&s, s.ptls->root_task->tls);
staticdata.c:    s.ptls = jl_current_task->ptls;
staticdata.c:    assert(ios_pos(f) == 0 && f->bm == bm_mem);
staticdata.c:    ios_static_buffer(&sysimg, f->buf, sizeof_sysimg + sizeof(uint32_t));
staticdata.c:    // realign stream to max-alignment for data
staticdata.c:    ios_static_buffer(&const_data, f->buf + f->bpos, sizeof_constdata);
staticdata.c:    ios_static_buffer(&symbols, f->buf + f->bpos, sizeof_symbols);
staticdata.c:    ios_static_buffer(&relocs, f->buf + f->bpos, sizeof_relocations);
staticdata.c:    ios_static_buffer(&gvar_record, f->buf + f->bpos, sizeof_gvar_record);
staticdata.c:    ios_static_buffer(&fptr_record, f->buf + f->bpos, sizeof_fptr_record);
staticdata.c:    // set typeof extra-special values now that we have the type set by tags above
staticdata.c:    jl_astaggedvalue(jl_current_task)->header = (uintptr_t)jl_task_type | jl_astaggedvalue(jl_current_task)->header;
staticdata.c:    jl_astaggedvalue(jl_nothing)->header = (uintptr_t)jl_nothing_type | jl_astaggedvalue(jl_nothing)->header;
staticdata.c:    s.ptls->root_task->tls = jl_read_value(&s);
staticdata.c:    jl_gc_wb(s.ptls->root_task, s.ptls->root_task->tls);
staticdata.c:            (unsigned)(sizeof_relocations - sizeof_tags),
staticdata.c:        // load the pre-compiled sysimage from jl_sysimg_handle
staticdata.c:// --- init ---
llvm-gc-invariant-verifier.cpp:#include "llvm-version.h"
llvm-gc-invariant-verifier.cpp:#include <llvm-c/Core.h>
llvm-gc-invariant-verifier.cpp:#include <llvm-c/Types.h>
llvm-gc-invariant-verifier.cpp:    unsigned FromAS = cast<PointerType>(I.getSrcTy())->getAddressSpace();
llvm-gc-invariant-verifier.cpp:    unsigned ToAS = cast<PointerType>(I.getDestTy())->getAddressSpace();
llvm-gc-invariant-verifier.cpp:    if (VTy->isPointerTy()) {
llvm-gc-invariant-verifier.cpp:        /* We currently don't obey this for arguments. That's ok - they're
llvm-gc-invariant-verifier.cpp:        unsigned AS = cast<PointerType>(VTy)->getAddressSpace();
llvm-gc-invariant-verifier.cpp:    Type *VTy = SI.getValueOperand()->getType();
llvm-gc-invariant-verifier.cpp:    Type *VTy = SI.getValOperand()->getType();
llvm-gc-invariant-verifier.cpp:    Type *VTy = SI.getNewValOperand()->getType();
llvm-gc-invariant-verifier.cpp:    if (Ty->isPointerTy()) {
llvm-gc-invariant-verifier.cpp:        unsigned AS = cast<PointerType>(Ty)->getAddressSpace();
llvm-gc-invariant-verifier.cpp:    Ty = LI.getPointerOperand()->getType();
llvm-gc-invariant-verifier.cpp:    if (Ty->isPointerTy()) {
llvm-gc-invariant-verifier.cpp:        unsigned AS = cast<PointerType>(Ty)->getAddressSpace();
llvm-gc-invariant-verifier.cpp:    Type *RTy = RI.getReturnValue()->getType();
llvm-gc-invariant-verifier.cpp:    if (!RTy->isPointerTy())
llvm-gc-invariant-verifier.cpp:    unsigned AS = cast<PointerType>(RTy)->getAddressSpace();
llvm-gc-invariant-verifier.cpp:    if (!Ty->isPointerTy())
llvm-gc-invariant-verifier.cpp:    unsigned AS = cast<PointerType>(Ty)->getAddressSpace();
llvm-gc-invariant-verifier.cpp:            Type *Ty = Arg->getType();
llvm-gc-invariant-verifier.cpp:            Check(Ty->isPointerTy() && cast<PointerType>(Ty)->getAddressSpace() == AddressSpace::Tracked,
llvm-gc-invariant-verifier.cpp:    unwrap(PM)->add(createGCInvariantVerifierPass(Strong));
llvm-alloc-opt.cpp:#include "llvm-version.h"
llvm-alloc-opt.cpp:#include <llvm-c/Core.h>
llvm-alloc-opt.cpp:#include <llvm-c/Types.h>
llvm-alloc-opt.cpp:#include "llvm-pass-helpers.h"
llvm-alloc-opt.cpp:    auto replace = Constant::getNullValue(val->getType());
llvm-alloc-opt.cpp:    call->replaceUsesOfWith(val, replace);
llvm-alloc-opt.cpp:    for (auto &arg: call->arg_operands()) {
llvm-alloc-opt.cpp:    while (!call->use_empty()) {
llvm-alloc-opt.cpp:        auto end = cast<Instruction>(*call->user_begin());
llvm-alloc-opt.cpp:        assert(end->use_empty());
llvm-alloc-opt.cpp:        end->eraseFromParent();
llvm-alloc-opt.cpp:    call->eraseFromParent();
llvm-alloc-opt.cpp:        return ptrty->getAddressSpace() == AddressSpace::Tracked;
llvm-alloc-opt.cpp:        for (auto elty: structty->elements()) {
llvm-alloc-opt.cpp:                return --it;
llvm-alloc-opt.cpp:    if (sz != -1) {
llvm-alloc-opt.cpp:        inst->eraseFromParent();
llvm-alloc-opt.cpp:    if (auto callee = call->getCalledFunction()) {
llvm-alloc-opt.cpp:        if (callee == pass.pointer_from_objref_func || callee->getName() == "memcmp") {
llvm-alloc-opt.cpp:        Value *Val = it->second;
llvm-alloc-opt.cpp:        return -1;
llvm-alloc-opt.cpp:    if (call->getCalledOperand() != pass.alloc_obj_func)
llvm-alloc-opt.cpp:        return -1;
llvm-alloc-opt.cpp:    assert(call->getNumArgOperands() == 3);
llvm-alloc-opt.cpp:    size_t sz = (size_t)cast<ConstantInt>(call->getArgOperand(1))->getZExtValue();
llvm-alloc-opt.cpp:    return -1;
llvm-alloc-opt.cpp:        if (it->first + it->second.size >= offset + size) {
llvm-alloc-opt.cpp:            if (it->second.elty != elty)
llvm-alloc-opt.cpp:                it->second.elty = nullptr;
llvm-alloc-opt.cpp:            assert(it->second.elty == nullptr || (it->first == offset && it->second.size == size));
llvm-alloc-opt.cpp:        if (it->first + it->second.size > offset) {
llvm-alloc-opt.cpp:    for (; it != end && it->first < offset + size; ++it) {
llvm-alloc-opt.cpp:    uint32_t new_offset = std::min(offset, lb->first);
llvm-alloc-opt.cpp:    uint32_t new_addrub = std::max(offset + uint32_t(size), ub->first + ub->second.size);
llvm-alloc-opt.cpp:    uint32_t new_size = new_addrub - new_offset;
llvm-alloc-opt.cpp:        field.hasobjref |= it->second.hasobjref;
llvm-alloc-opt.cpp:        field.hasload |= it->second.hasload;
llvm-alloc-opt.cpp:        field.hasaggr |= it->second.hasaggr;
llvm-alloc-opt.cpp:        field.accesses.append(it->second.accesses.begin(), it->second.accesses.end());
llvm-alloc-opt.cpp:    if (size >= UINT32_MAX - offset)
llvm-alloc-opt.cpp:    if (I->use_empty())
llvm-alloc-opt.cpp:    CheckInst::Frame cur{I, 0, I->use_begin(), I->use_end()};
llvm-alloc-opt.cpp:        cur.use_it = inst->use_begin();
llvm-alloc-opt.cpp:        cur.use_end = inst->use_end();
llvm-alloc-opt.cpp:                                                               inst->getType(),
llvm-alloc-opt.cpp:            auto callee = call->getCalledOperand();
llvm-alloc-opt.cpp:                if (auto id = II->getIntrinsicID()) {
llvm-alloc-opt.cpp:                        assert(call->getNumArgOperands() == 4);
llvm-alloc-opt.cpp:                            !isa<ConstantInt>(call->getArgOperand(2)) ||
llvm-alloc-opt.cpp:                            !isa<ConstantInt>(call->getArgOperand(1)) ||
llvm-alloc-opt.cpp:                            (cast<ConstantInt>(call->getArgOperand(2))->getLimitedValue() >=
llvm-alloc-opt.cpp:                             UINT32_MAX - cur.offset))
llvm-alloc-opt.cpp:                    for (auto user: call->users())
llvm-alloc-opt.cpp:                assert(use->get() == I);
llvm-alloc-opt.cpp:            auto opno = use->getOperandNo();
llvm-alloc-opt.cpp:            if (!call->isBundleOperand(opno) ||
llvm-alloc-opt.cpp:                call->getOperandBundleForOperand(opno).getTagName() != "jl_roots") {
llvm-alloc-opt.cpp:            if (use->getOperandNo() != StoreInst::getPointerOperandIndex()) {
llvm-alloc-opt.cpp:            auto storev = store->getValueOperand();
llvm-alloc-opt.cpp:            if (cur.offset == UINT32_MAX || !use_info.addMemOp(inst, use->getOperandNo(),
llvm-alloc-opt.cpp:                                                               cur.offset, storev->getType(),
llvm-alloc-opt.cpp:            if (use->getOperandNo() != isa<AtomicCmpXchgInst>(inst) ? AtomicCmpXchgInst::getPointerOperandIndex() : AtomicRMWInst::getPointerOperandIndex()) {
llvm-alloc-opt.cpp:            auto storev = isa<AtomicCmpXchgInst>(inst) ? cast<AtomicCmpXchgInst>(inst)->getNewValOperand() : cast<AtomicRMWInst>(inst)->getValOperand();
llvm-alloc-opt.cpp:            if (cur.offset == UINT32_MAX || !use_info.addMemOp(inst, use->getOperandNo(),
llvm-alloc-opt.cpp:                                                               cur.offset, storev->getType(),
llvm-alloc-opt.cpp:                if (!gep->accumulateConstantOffset(*pass.DL, apoffset) || apoffset.isNegative()) {
llvm-alloc-opt.cpp:        auto inst = dyn_cast<Instruction>(use->getUser());
llvm-alloc-opt.cpp:    BasicBlock::iterator begin(insert->getParent()->begin());
llvm-alloc-opt.cpp:        --it;
llvm-alloc-opt.cpp:            if (II->getIntrinsicID() == Intrinsic::lifetime_start ||
llvm-alloc-opt.cpp:                II->getIntrinsicID() == Intrinsic::lifetime_end) {
llvm-alloc-opt.cpp:    BasicBlock *def_bb = orig->getParent();
llvm-alloc-opt.cpp:        auto bb = use->getParent();
llvm-alloc-opt.cpp:        auto F = bb->getParent();
llvm-alloc-opt.cpp:        for (auto RN = DT.getNode(preserve->getParent()); RN;
llvm-alloc-opt.cpp:                auto bb = N->getBlock();
llvm-alloc-opt.cpp:                for (auto end: preserve->users()) {
llvm-alloc-opt.cpp:                    auto end_bb = cast<Instruction>(end)->getParent();
llvm-alloc-opt.cpp:                    first_dead.push_back(&*succ->begin());
llvm-alloc-opt.cpp:            first_dead.push_back(bb->getTerminator());
llvm-alloc-opt.cpp:            for (auto it = bb->rbegin(), end = bb->rend(); it != end; ++it) {
llvm-alloc-opt.cpp:                    --it;
llvm-alloc-opt.cpp:        auto bb = I->getParent();
llvm-alloc-opt.cpp:        if (I == &*bb->begin()) {
llvm-alloc-opt.cpp:                insertLifetimeEnd(ptr, sz, &*bb->getFirstInsertionPt());
llvm-alloc-opt.cpp:            BasicBlock::iterator end = bb->end();
llvm-alloc-opt.cpp:            first_dead.push_back(&*succ->begin());
llvm-alloc-opt.cpp:    auto nargs = call->getNumArgOperands();
llvm-alloc-opt.cpp:        auto arg = call->getArgOperand(i);
llvm-alloc-opt.cpp:        argTys[i] = args[i]->getType();
llvm-alloc-opt.cpp:    auto oldfType = call->getFunctionType();
llvm-alloc-opt.cpp:            oldfType->getReturnType(),
llvm-alloc-opt.cpp:            makeArrayRef(argTys).slice(0, oldfType->getNumParams()),
llvm-alloc-opt.cpp:            oldfType->isVarArg());
llvm-alloc-opt.cpp:        bool matchvararg = Intrinsic::matchIntrinsicVarArg(newfType->isVarArg(), TableRef);
llvm-alloc-opt.cpp:    auto newF = Intrinsic::getDeclaration(call->getModule(), ID, overloadTys);
llvm-alloc-opt.cpp:    assert(newF->getFunctionType() == newfType);
llvm-alloc-opt.cpp:    newF->setCallingConv(call->getCallingConv());
llvm-alloc-opt.cpp:    newCall->setTailCallKind(call->getTailCallKind());
llvm-alloc-opt.cpp:    auto old_attrs = call->getAttributes();
llvm-alloc-opt.cpp:    newCall->setAttributes(AttributeList::get(pass.getLLVMContext(), old_attrs.getFnAttributes(),
llvm-alloc-opt.cpp:    newCall->setDebugLoc(call->getDebugLoc());
llvm-alloc-opt.cpp:    call->replaceAllUsesWith(newCall);
llvm-alloc-opt.cpp:    call->eraseFromParent();
llvm-alloc-opt.cpp:    auto tag = orig_inst->getArgOperand(2);
llvm-alloc-opt.cpp:        // treat this as a non-mem2reg'd alloca
llvm-alloc-opt.cpp:        buff->setAlignment(Align(align));
llvm-alloc-opt.cpp:        if (pass.DL->isLegalInteger(sz * 8))
llvm-alloc-opt.cpp:        buff->setAlignment(Align(align));
llvm-alloc-opt.cpp:    new_inst->takeName(orig_inst);
llvm-alloc-opt.cpp:        if (orig_i->user_empty()) {
llvm-alloc-opt.cpp:                orig_i->eraseFromParent();
llvm-alloc-opt.cpp:        Type *orig_t = orig_i->getType();
llvm-alloc-opt.cpp:        Type *new_t = new_i->getType();
llvm-alloc-opt.cpp:            orig_i->replaceAllUsesWith(new_i);
llvm-alloc-opt.cpp:                orig_i->eraseFromParent();
llvm-alloc-opt.cpp:        assert(cur.orig_i->user_empty());
llvm-alloc-opt.cpp:            cur.orig_i->eraseFromParent();
llvm-alloc-opt.cpp:            user->replaceUsesOfWith(orig_i, new_i);
llvm-alloc-opt.cpp:            auto callee = call->getCalledOperand();
llvm-alloc-opt.cpp:                call->replaceAllUsesWith(new_i);
llvm-alloc-opt.cpp:                call->eraseFromParent();
llvm-alloc-opt.cpp:                call->replaceAllUsesWith(tag);
llvm-alloc-opt.cpp:                call->eraseFromParent();
llvm-alloc-opt.cpp:                    call->replaceUsesOfWith(orig_i, buff);
llvm-alloc-opt.cpp:                call->eraseFromParent();
llvm-alloc-opt.cpp:                if (Intrinsic::ID ID = intrinsic->getIntrinsicID()) {
llvm-alloc-opt.cpp:            Value *replace = has_ref ? (Value*)buff : Constant::getNullValue(orig_i->getType());
llvm-alloc-opt.cpp:            user->replaceUsesOfWith(orig_i, replace);
llvm-alloc-opt.cpp:            auto cast_t = PointerType::get(cast<PointerType>(user->getType())->getElementType(),
llvm-alloc-opt.cpp:            Type *new_t = new_i->getType();
llvm-alloc-opt.cpp:                replace_i->setDebugLoc(user->getDebugLoc());
llvm-alloc-opt.cpp:                replace_i->takeName(user);
llvm-alloc-opt.cpp:            SmallVector<Value *, 4> IdxOperands(gep->idx_begin(), gep->idx_end());
llvm-alloc-opt.cpp:            auto new_gep = GetElementPtrInst::Create(gep->getSourceElementType(),
llvm-alloc-opt.cpp:                                                     gep->getName(), gep);
llvm-alloc-opt.cpp:            new_gep->setIsInBounds(gep->isInBounds());
llvm-alloc-opt.cpp:            new_gep->takeName(gep);
llvm-alloc-opt.cpp:            new_gep->copyMetadata(*gep);
llvm-alloc-opt.cpp:        replace_inst(cast<Instruction>(*cur.orig_i->user_begin()));
llvm-alloc-opt.cpp:        while (cur.orig_i->use_empty()) {
llvm-alloc-opt.cpp:    auto tag = orig_inst->getArgOperand(2);
llvm-alloc-opt.cpp:        if (orig_i->user_empty()) {
llvm-alloc-opt.cpp:                orig_i->eraseFromParent();
llvm-alloc-opt.cpp:        assert(cur.orig_i->user_empty());
llvm-alloc-opt.cpp:            cur.orig_i->eraseFromParent();
llvm-alloc-opt.cpp:            if (auto stored_inst = dyn_cast<Instruction>(store->getValueOperand()))
llvm-alloc-opt.cpp:            user->eraseFromParent();
llvm-alloc-opt.cpp:            auto callee = call->getCalledOperand();
llvm-alloc-opt.cpp:                call->replaceAllUsesWith(tag);
llvm-alloc-opt.cpp:                call->eraseFromParent();
llvm-alloc-opt.cpp:                call->eraseFromParent();
llvm-alloc-opt.cpp:                auto id = II->getIntrinsicID();
llvm-alloc-opt.cpp:                    call->eraseFromParent();
llvm-alloc-opt.cpp:            user->replaceUsesOfWith(orig_i, Constant::getNullValue(orig_i->getType()));
llvm-alloc-opt.cpp:        remove_inst(cast<Instruction>(*cur.orig_i->user_begin()));
llvm-alloc-opt.cpp:        while (cur.orig_i->use_empty()) {
llvm-alloc-opt.cpp:    auto tag = orig_inst->getArgOperand(2);
llvm-alloc-opt.cpp:    for (auto user: orig_inst->users()) {
llvm-alloc-opt.cpp:            auto callee = call->getCalledOperand();
llvm-alloc-opt.cpp:                call->replaceAllUsesWith(tag);
llvm-alloc-opt.cpp:        removed[last_deleted++]->replaceUsesOfWith(orig_inst, UndefValue::get(orig_inst->getType()));
llvm-alloc-opt.cpp:    auto tag = orig_inst->getArgOperand(2);
llvm-alloc-opt.cpp:        else if (pass.DL->isLegalInteger(field.size * 8)) {
llvm-alloc-opt.cpp:        if (orig_i->user_empty()) {
llvm-alloc-opt.cpp:                orig_i->eraseFromParent();
llvm-alloc-opt.cpp:        assert(cur.orig_i->user_empty());
llvm-alloc-opt.cpp:            cur.orig_i->eraseFromParent();
llvm-alloc-opt.cpp:        offset -= slot.offset;
llvm-alloc-opt.cpp:        auto size = pass.DL->getTypeAllocSize(elty);
llvm-alloc-opt.cpp:            addr = builder.CreateBitCast(slot.slot, elty->getPointerTo());
llvm-alloc-opt.cpp:            addr = builder.CreateBitCast(addr, elty->getPointerTo());
llvm-alloc-opt.cpp:        Instruction *user = cast<Instruction>(use->getUser());
llvm-alloc-opt.cpp:            Type *load_ty = load->getType();
llvm-alloc-opt.cpp:            // TODO: should we use `load->clone()`, or manually copy any other metadata?
llvm-alloc-opt.cpp:            newload->setAlignment(load->getAlign());
llvm-alloc-opt.cpp:            // since we're moving heap-to-stack, it is safe to downgrade the atomic level to NotAtomic
llvm-alloc-opt.cpp:            newload->setOrdering(AtomicOrdering::NotAtomic);
llvm-alloc-opt.cpp:            load->replaceAllUsesWith(val);
llvm-alloc-opt.cpp:            load->eraseFromParent();
llvm-alloc-opt.cpp:            if (auto stored_inst = dyn_cast<Instruction>(store->getValueOperand()))
llvm-alloc-opt.cpp:                store->eraseFromParent();
llvm-alloc-opt.cpp:            auto store_val = store->getValueOperand();
llvm-alloc-opt.cpp:            auto store_ty = store_val->getType();
llvm-alloc-opt.cpp:                    store_ty = cast<PointerType>(pass.T_pjlvalue)->getElementType()
llvm-alloc-opt.cpp:                        ->getPointerTo(cast<PointerType>(store_ty)->getAddressSpace());
llvm-alloc-opt.cpp:                if (cast<PointerType>(store_ty)->getAddressSpace() != AddressSpace::Tracked)
llvm-alloc-opt.cpp:            // TODO: should we use `store->clone()`, or manually copy any other metadata?
llvm-alloc-opt.cpp:            newstore->setAlignment(store->getAlign());
llvm-alloc-opt.cpp:            // since we're moving heap-to-stack, it is safe to downgrade the atomic level to NotAtomic
llvm-alloc-opt.cpp:            newstore->setOrdering(AtomicOrdering::NotAtomic);
llvm-alloc-opt.cpp:            store->eraseFromParent();
llvm-alloc-opt.cpp:                Value *Val = isa<AtomicCmpXchgInst>(user) ? cast<AtomicCmpXchgInst>(user)->getNewValOperand() : cast<AtomicRMWInst>(user)->getValOperand();
llvm-alloc-opt.cpp:                newptr = slot_gep(slot, offset, Val->getType(), builder);
llvm-alloc-opt.cpp:            auto callee = call->getCalledOperand();
llvm-alloc-opt.cpp:                if (Intrinsic::ID id = intrinsic->getIntrinsicID()) {
llvm-alloc-opt.cpp:                        auto val_arg = cast<ConstantInt>(call->getArgOperand(1));
llvm-alloc-opt.cpp:                        auto size_arg = cast<ConstantInt>(call->getArgOperand(2));
llvm-alloc-opt.cpp:                        uint8_t val = val_arg->getLimitedValue();
llvm-alloc-opt.cpp:                        uint32_t size = size_arg->getLimitedValue();
llvm-alloc-opt.cpp:                                store->setOrdering(AtomicOrdering::NotAtomic);
llvm-alloc-opt.cpp:                                                                          offset - slot.offset);
llvm-alloc-opt.cpp:                            auto sub_size = std::min(slot.offset + slot.size, offset + size) -
llvm-alloc-opt.cpp:                        call->eraseFromParent();
llvm-alloc-opt.cpp:                    call->eraseFromParent();
llvm-alloc-opt.cpp:                call->replaceAllUsesWith(tag);
llvm-alloc-opt.cpp:                call->eraseFromParent();
llvm-alloc-opt.cpp:                call->eraseFromParent();
llvm-alloc-opt.cpp:                for (auto &arg: call->arg_operands()) {
llvm-alloc-opt.cpp:                    // since we're moving heap-to-stack, it is safe to downgrade the atomic level to NotAtomic
llvm-alloc-opt.cpp:                    ref->setOrdering(AtomicOrdering::NotAtomic);
llvm-alloc-opt.cpp:                new_call->takeName(call);
llvm-alloc-opt.cpp:                new_call->setAttributes(call->getAttributes());
llvm-alloc-opt.cpp:                call->replaceAllUsesWith(new_call);
llvm-alloc-opt.cpp:                call->eraseFromParent();
llvm-alloc-opt.cpp:            assert(call->isBundleOperand(use->getOperandNo()));
llvm-alloc-opt.cpp:            assert(call->getOperandBundleForOperand(use->getOperandNo()).getTagName() ==
llvm-alloc-opt.cpp:            call->getOperandBundlesAsDefs(bundles);
llvm-alloc-opt.cpp:                    // since we're moving heap-to-stack, it is safe to downgrade the atomic level to NotAtomic
llvm-alloc-opt.cpp:                    ref->setOrdering(AtomicOrdering::NotAtomic);
llvm-alloc-opt.cpp:            new_call->takeName(call);
llvm-alloc-opt.cpp:            call->replaceAllUsesWith(new_call);
llvm-alloc-opt.cpp:            call->eraseFromParent();
llvm-alloc-opt.cpp:            gep->accumulateConstantOffset(*pass.DL, apoffset);
llvm-alloc-opt.cpp:        replace_inst(&*cur.orig_i->use_begin());
llvm-alloc-opt.cpp:        while (cur.orig_i->use_empty()) {
llvm-alloc-opt.cpp:    unwrap(PM)->add(createAllocOptPass());
gf.c:    return jl_current_task->world_age;
gf.c:/// ----- Handling for Julia callbacks ----- ///
gf.c:    return ct->ptls->in_pure_callback;
gf.c:    int last_in = ct->ptls->in_pure_callback;
gf.c:        ct->ptls->in_pure_callback = 1;
gf.c:        ct->ptls->in_pure_callback = last_in;
gf.c:        ct->ptls->in_pure_callback = last_in;
gf.c:/// ----- Definitions for various internal TypeMaps ----- ///
gf.c:    return mt->offs;
gf.c:/// ----- Insertion logic for special entries ----- ///
gf.c:    jl_value_t *sig = ml->specTypes;
gf.c:    return ((jl_datatype_t*)sig)->hash;
gf.c:    jl_value_t *sig = ml->specTypes;
gf.c:    uint_t h2 = ((jl_datatype_t*)(jl_is_unionall(sig) ? jl_unwrap_unionall(sig) : sig))->hash;
gf.c:    uint_t hv = ((jl_datatype_t*)ut)->hash;
gf.c:        jl_array_t *speckeyset = jl_atomic_load_acquire(&m->speckeyset);
gf.c:        jl_svec_t *specializations = jl_atomic_load_acquire(&m->specializations);
gf.c:            if (idx != -1) {
gf.c:                    JL_UNLOCK(&m->writelock);
gf.c:            JL_GC_PUSH1(&specializations); // clang-sa doesn't realize this loop uses specializations
gf.c:            for (i = cl; i > 0; i--) {
gf.c:                jl_method_instance_t *mi = jl_atomic_load_relaxed(&data[i - 1]);
gf.c:                if (jl_types_equal(mi->specTypes, type)) {
gf.c:                        JL_UNLOCK(&m->writelock);
gf.c:            JL_LOCK(&m->writelock);
gf.c:                    assert(!jl_types_equal(mi->specTypes, type));
gf.c:            if (hv ? (i + 1 >= cl || jl_svecref(specializations, i + 1) != jl_nothing) : (i <= 1 || jl_svecref(specializations, i - 2) != jl_nothing)) {
gf.c:                for (int j = 0; j < ncl - cl; j++)
gf.c:                    memcpy((char*)jl_svec_data(nc) + sizeof(void*) * (i + ncl - cl),
gf.c:                           sizeof(void*) * (cl - i));
gf.c:                jl_atomic_store_release(&m->specializations, nc);
gf.c:                    i += ncl - cl;
gf.c:                i -= 1;
gf.c:                jl_smallintset_insert(&m->speckeyset, (jl_value_t*)m, speccache_hash, i, specializations);
gf.c:            JL_UNLOCK(&m->writelock);
gf.c:    jl_typemap_entry_t *sf = jl_typemap_assoc_by_type(mt->defs, &search, /*offs*/0, /*subtype*/0);
gf.c:    return sf->func.value;
gf.c:// ----- MethodInstance specialization instantiation ----- //
gf.c:    m->name = sname;
gf.c:    m->module = jl_core_module;
gf.c:    m->isva = 1;
gf.c:    m->nargs = 2;
gf.c:    m->sig = (jl_value_t*)jl_anytuple_type;
gf.c:    m->slot_syms = jl_an_empty_string;
gf.c:    m->unspecialized = mi;
gf.c:    codeinst->specptr.fptr1 = fptr;
gf.c:    codeinst->invoke = jl_fptr_args;
gf.c:    jl_methtable_t *mt = dt->name->mt;
gf.c:    jl_typemap_insert(&mt->cache, (jl_value_t*)mt, newentry, 0);
gf.c:    mt->frozen = 1;
gf.c:    if (jl_is_method(mi->def.method) && mi->def.method->unspecialized == mi)
gf.c:    if (mi->inInference && !force)
gf.c:    if (jl_is_method(mi->def.method) && mi->def.method->unspecialized == mi)
gf.c:    if (mi->specTypes != (jl_value_t*)jl_emptytuple_type) {
gf.c:        jl_static_show_func_sig(JL_STDERR, (jl_value_t*)mi->specTypes);
gf.c:    size_t last_age = ct->world_age;
gf.c:    ct->world_age = jl_typeinf_world;
gf.c:    mi->inInference = 1;
gf.c:    ct->world_age = last_age;
gf.c:    in_inference--;
gf.c:    mi->inInference = 0;
gf.c:    size_t last_age = ct->world_age;
gf.c:    ct->world_age = jl_typeinf_world;
gf.c:    ct->world_age = last_age;
gf.c:    jl_code_instance_t *codeinst = jl_atomic_load_relaxed(&mi->cache);
gf.c:        if (codeinst->min_world <= min_world && max_world <= codeinst->max_world) {
gf.c:            jl_value_t *code = codeinst->inferred;
gf.c:        codeinst = jl_atomic_load_relaxed(&codeinst->next);
gf.c:    jl_code_instance_t *codeinst = jl_atomic_load_relaxed(&mi->cache);
gf.c:        if (codeinst->min_world == min_world &&
gf.c:            codeinst->max_world == max_world &&
gf.c:            jl_egal(codeinst->rettype, rettype)) {
gf.c:        codeinst = jl_atomic_load_relaxed(&codeinst->next);
gf.c:    jl_code_instance_t *codeinst = (jl_code_instance_t*)jl_gc_alloc(ct->ptls, sizeof(jl_code_instance_t),
gf.c:    codeinst->def = mi;
gf.c:    codeinst->min_world = min_world;
gf.c:    codeinst->max_world = max_world;
gf.c:    codeinst->rettype = rettype;
gf.c:    codeinst->inferred = inferred;
gf.c:    //codeinst->edges = NULL;
gf.c:    codeinst->rettype_const = inferred_const;
gf.c:    codeinst->invoke = NULL;
gf.c:    codeinst->specptr.fptr = NULL;
gf.c:        codeinst->invoke = jl_fptr_const_return;
gf.c:    codeinst->isspecsig = 0;
gf.c:    codeinst->precompile = 0;
gf.c:    codeinst->next = NULL;
gf.c:    if (jl_is_method(mi->def.method))
gf.c:        JL_LOCK(&mi->def.method->writelock);
gf.c:    ci->next = mi->cache;
gf.c:    jl_atomic_store_release(&mi->cache, ci);
gf.c:    if (jl_is_method(mi->def.method))
gf.c:        JL_UNLOCK(&mi->def.method->writelock);
gf.c:    jl_svec_t *specializations = def->func.method->specializations;
gf.c:    void **table = m->bindings.table;
gf.c:    for (i = 1; i < m->bindings.size; i += 2) {
gf.c:            if (b->owner == m && b->value && b->constp) {
gf.c:                jl_value_t *v = jl_unwrap_unionall(b->value);
gf.c:                    jl_typename_t *tn = ((jl_datatype_t*)v)->name;
gf.c:                    if (tn->module == m && tn->name == b->name) {
gf.c:                        jl_methtable_t *mt = tn->mt;
gf.c:                    if (child != m && child->parent == m && child->name == b->name &&
gf.c:    if (mt->defs != jl_nothing) { // make sure not to reset builtin functions
gf.c:        mt->leafcache = (jl_array_t*)jl_an_empty_vec_any;
gf.c:        mt->cache = jl_nothing;
gf.c:    jl_typemap_visitor(mt->defs, get_method_unspec_list, env);
gf.c:    ++jl_world_counter; // make type-inference the only thing in this world
gf.c:    if (i < len-1)
gf.c:    if (jl_is_vararg(jl_tparam(sig, len-1)))
gf.c:        return jl_unwrap_vararg(jl_tparam(sig, len-1));
gf.c:    if (i == len-1)
gf.c:    if (definition->generator) {
gf.c:    jl_value_t *decl = definition->sig;
gf.c:    size_t nargs = definition->nargs; // == jl_nparams(jl_unwrap_unionall(decl));
gf.c:        size_t i_arg = (i < nargs - 1 ? i : nargs - 1);
gf.c:            if (!*newparams) *newparams = jl_svec_copy(tt->parameters);
gf.c:                if (!*newparams) *newparams = jl_svec_copy(tt->parameters);
gf.c:                if (!*newparams) *newparams = jl_svec_copy(tt->parameters);
gf.c:        if (i_arg > 0 && i_arg <= sizeof(definition->nospecialize) * 8 &&
gf.c:                (definition->nospecialize & (1 << (i_arg - 1)))) {
gf.c:                    if (!*newparams) *newparams = jl_svec_copy(tt->parameters);
gf.c:            if (!*newparams) *newparams = jl_svec_copy(tt->parameters);
gf.c:                  Type{TC} is type-equal to Type{TC.body}, yet a slot
gf.c:                int iscalled = i_arg > 0 && i_arg <= 8 && (definition->called & (1 << (i_arg - 1)));
gf.c:                    if (!*newparams) *newparams = jl_svec_copy(tt->parameters);
gf.c:                if (!*newparams) *newparams = jl_svec_copy(tt->parameters);
gf.c:                if (i < nargs || !definition->isva) {
gf.c:        int notcalled_func = (i_arg > 0 && i_arg <= 8 && !(definition->called & (1 << (i_arg - 1))) &&
gf.c:                                ((((jl_uniontype_t*)decl_i)->a == (jl_value_t*)jl_function_type &&
gf.c:                                  ((jl_uniontype_t*)decl_i)->b == (jl_value_t*)jl_type_type) ||
gf.c:                                 (((jl_uniontype_t*)decl_i)->b == (jl_value_t*)jl_function_type &&
gf.c:                                  ((jl_uniontype_t*)decl_i)->a == (jl_value_t*)jl_type_type))))) {
gf.c:            if (!*newparams) *newparams = jl_svec_copy(tt->parameters);
gf.c:        if (!*newparams) *newparams = tt->parameters;
gf.c:        for (i = 0; i < nspec - 1; i++) {
gf.c:        jl_value_t *lasttype = jl_svecref(*newparams, i - 1);
gf.c:            jl_value_t *lastdeclt = jl_tparam(unw, jl_nparams(unw) - 1);
gf.c:        // be a call attempted that should throw a no-method error
gf.c:// compute whether this type signature is a possible return value from jl_compilation_sig given a concrete-type for `tt`
gf.c:    jl_value_t *decl = definition->sig;
gf.c:    size_t nargs = definition->nargs; // == jl_nparams(jl_unwrap_unionall(decl));
gf.c:    if (definition->generator) {
gf.c:        return (definition->isva ? np >= nargs - 1 : np == nargs) && type->isdispatchtuple;
gf.c:    if (definition->isva) {
gf.c:        unsigned nspec_min = nargs + 1; // min number of non-vararg values before vararg
gf.c:        unsigned nspec_max = INT32_MAX; // max number of non-vararg values before vararg
gf.c:                nspec_min = mt->max_args + 2;
gf.c:        if (jl_is_vararg(jl_tparam(type, np - 1))) {
gf.c:            if (np < nargs - 1 || (isbound && np >= nspec_max))
gf.c:    else if (np != nargs || jl_is_vararg(jl_tparam(type, np - 1))) {
gf.c:        size_t i_arg = (i < nargs - 1 ? i : nargs - 1);
gf.c:                // TODO: in this case, answer semi-conservatively that these varargs are always compilable
gf.c:        if (i_arg > 0 && i_arg <= sizeof(definition->nospecialize) * 8 &&
gf.c:                (definition->nospecialize & (1 << (i_arg - 1)))) {
gf.c:            int iscalled = i_arg > 0 && i_arg <= 8 && (definition->called & (1 << (i_arg - 1)));
gf.c:                if (i >= nargs && definition->isva)
gf.c:                if (i < nargs || !definition->isva) {
gf.c:        int notcalled_func = (i_arg > 0 && i_arg <= 8 && !(definition->called & (1 << (i_arg - 1))) &&
gf.c:                                ((((jl_uniontype_t*)decl_i)->a == (jl_value_t*)jl_function_type &&
gf.c:                                  ((jl_uniontype_t*)decl_i)->b == (jl_value_t*)jl_type_type) ||
gf.c:                                 (((jl_uniontype_t*)decl_i)->b == (jl_value_t*)jl_function_type &&
gf.c:                                  ((jl_uniontype_t*)decl_i)->a == (jl_value_t*)jl_type_type))))) {
gf.c:    jl_value_t **types = jl_svec_data(((jl_datatype_t*)tt)->parameters);
gf.c:    jl_value_t **sigs = jl_svec_data(((jl_datatype_t*)simplesig)->parameters);
gf.c:    assert(lensig > 0 && !jl_is_vararg(jl_tparam(simplesig, lensig - 1)));
gf.c:            if (entry->min_world <= world && world <= entry->max_world) {
gf.c:                if (entry->simplesig == (void*)jl_nothing || concretesig_equal(tt, (jl_value_t*)entry->simplesig))
gf.c:            entry = entry->next;
gf.c:    // caller must hold the mt->writelock
gf.c:    // short-circuit (now that we hold the lock) if this entry is already present
gf.c:            jl_array_t *leafcache = jl_atomic_load_relaxed(&mt->leafcache);
gf.c:                return entry->func.linfo;
gf.c:        if (entry && entry->func.value)
gf.c:            return entry->func.linfo;
gf.c:    intptr_t nspec = (mt == NULL || mt == jl_type_type_mt || mt == jl_nonfunction_mt ? definition->nargs + 1 : mt->max_args + 2);
gf.c:        cache_with_orig = !jl_subtype((jl_value_t*)compilationsig, definition->sig);
gf.c:                jl_svec_t *env = matc->sparams;
gf.c:                if (matc->method != definition) {
gf.c:                jl_method_t *other = matc->method;
gf.c:                    jl_svecset(guardsigs, guards, matc->spec_types);
gf.c:                    //jl_typemap_insert(cache, parent, (jl_tupletype_t*)matc->spec_types,
gf.c:                    //        NULL, jl_emptysvec, /*guard*/NULL, jl_cachearg_offset(mt), other->min_world, other->max_world);
gf.c:    // by replacing non-simple types with jl_any_type to build a new `type`
gf.c:        jl_value_t *elt = jl_svecref(cachett->parameters, i);
gf.c:            if (!newparams) newparams = jl_svec_copy(cachett->parameters);
gf.c:            if (!newparams) newparams = jl_svec_copy(cachett->parameters);
gf.c:    // short-circuit if an existing entry is already present
gf.c:        if (entry && jl_egal((jl_value_t*)entry->simplesig, simplett ? (jl_value_t*)simplett : jl_nothing) &&
gf.c:                jl_egal((jl_value_t*)guardsigs, (jl_value_t*)entry->guardsigs)) {
gf.c:            return entry->func.linfo;
gf.c:    if (mt && cachett == tt && jl_svec_len(guardsigs) == 0 && tt->hash && !tt->hasfreetypevars) {
gf.c:        // we check `tt->hash` exists, since otherwise the NamedTuple
gf.c:        jl_typemap_entry_t *old = (jl_typemap_entry_t*)jl_eqtable_get(mt->leafcache, (jl_value_t*)tt, jl_nothing);
gf.c:        newentry->next = old;
gf.c:        jl_atomic_store_release(&mt->leafcache, jl_eqtable_put(mt->leafcache, (jl_value_t*)tt, (jl_value_t*)newentry, NULL));
gf.c:        jl_gc_wb(mt, mt->leafcache);
gf.c:    // caller must hold the mt->writelock
gf.c:    assert(tt->isdispatchtuple || tt->hasfreetypevars);
gf.c:    if (tt->isdispatchtuple) {
gf.c:        jl_array_t *leafcache = jl_atomic_load_relaxed(&mt->leafcache);
gf.c:            return entry->func.linfo;
gf.c:    jl_typemap_entry_t *entry = jl_typemap_assoc_by_type(mt->cache, &search, jl_cachearg_offset(mt), /*subtype*/1);
gf.c:        return entry->func.linfo;
gf.c:        jl_method_t *m = matc->method;
gf.c:        jl_svec_t *env = matc->sparams;
gf.c:        nf = cache_method(mt, &mt->cache, (jl_value_t*)mt, tt, m, world, min_valid, max_valid, env);
gf.c:    if (oldentry == closure->newentry)
gf.c:    if (oldentry->max_world < ~(size_t)0 || oldentry->min_world == closure->newentry->min_world)
gf.c:        // also be careful not to try to scan something from the current dump-reload though
gf.c:    jl_method_t *oldmethod = oldentry->func.method;
gf.c:    if (closure->shadowed == NULL)
gf.c:        closure->shadowed = (jl_value_t*)jl_alloc_vec_any(0);
gf.c:    jl_array_ptr_1d_push((jl_array_t*)closure->shadowed, (jl_value_t*)oldmethod);
gf.c:    jl_tupletype_t *type = newentry->sig;
gf.c:        va = jl_tparam(ttypes, l - 1);
gf.c:    long lno = m->line;
gf.c:        char *fname = jl_symbol_name((jl_sym_t*)m->file);
gf.c:    jl_method_t *method = (jl_method_t*)newentry->func.method;
gf.c:    jl_module_t *newmod = method->module;
gf.c:    jl_module_t *oldmod = oldvalue->module;
gf.c:    jl_datatype_t *dt = jl_first_argument_datatype(oldvalue->sig);
gf.c:    int anon = dt && is_anonfn_typename(jl_symbol_name(dt->name->name));
gf.c:        jl_static_show_func_sig(s, (jl_value_t*)newentry->sig);
gf.c:        jl_printf(s, " in module %s", jl_symbol_name(oldmod->name));
gf.c:            jl_printf(s, " in module %s", jl_symbol_name(newmod->name));
gf.c:        if (method->line > 0 && method->line == oldvalue->line && method->file == oldvalue->file)
gf.c:        na--;
gf.c:    if (na > mt->max_args)
gf.c:        mt->max_args = na;
gf.c:    jl_array_t *callbacks = mi->callbacks;
gf.c:        // AbstractInterpreter allows for MethodInstances to be present in non-local caches
gf.c:            size_t last_age = ct->world_age;
gf.c:            ct->world_age = jl_get_world_counter();
gf.c:            ct->world_age = last_age;
gf.c:    if (!jl_is_method(replaced->def.method))
gf.c:    JL_LOCK(&replaced->def.method->writelock);
gf.c:    jl_code_instance_t *codeinst = replaced->cache;
gf.c:        if (codeinst->max_world == ~(size_t)0) {
gf.c:            assert(codeinst->min_world - 1 <= max_world && "attempting to set illogical world constraints (probable race condition)");
gf.c:            codeinst->max_world = max_world;
gf.c:        assert(codeinst->max_world <= max_world);
gf.c:        codeinst = jl_atomic_load_relaxed(&codeinst->next);
gf.c:    jl_array_t *backedges = replaced->backedges;
gf.c:        replaced->backedges = NULL;
gf.c:    JL_UNLOCK(&replaced->def.method->writelock);
gf.c:    JL_LOCK(&replaced_mi->def.method->writelock);
gf.c:    jl_array_t *backedges = replaced_mi->backedges;
gf.c:        replaced_mi->backedges = NULL;
gf.c:    JL_UNLOCK(&replaced_mi->def.method->writelock);
gf.c:    JL_LOCK(&callee->def.method->writelock);
gf.c:    if (!callee->backedges) {
gf.c:        // lazy-init the backedges array
gf.c:        callee->backedges = jl_alloc_vec_any(1);
gf.c:        jl_gc_wb(callee, callee->backedges);
gf.c:        jl_array_ptr_set(callee->backedges, 0, caller);
gf.c:        size_t i, l = jl_array_len(callee->backedges);
gf.c:            if (jl_array_ptr_ref(callee->backedges, i) == (jl_value_t*)caller)
gf.c:            jl_array_ptr_1d_push(callee->backedges, (jl_value_t*)caller);
gf.c:    JL_UNLOCK(&callee->def.method->writelock);
gf.c:// add a backedge from a non-existent signature to caller
gf.c:    JL_LOCK(&mt->writelock);
gf.c:    if (!mt->backedges) {
gf.c:        // lazy-init the backedges array
gf.c:        mt->backedges = jl_alloc_vec_any(2);
gf.c:        jl_gc_wb(mt, mt->backedges);
gf.c:        jl_array_ptr_set(mt->backedges, 0, typ);
gf.c:        jl_array_ptr_set(mt->backedges, 1, caller);
gf.c:        size_t i, l = jl_array_len(mt->backedges);
gf.c:            if (jl_types_equal(jl_array_ptr_ref(mt->backedges, i - 1), typ)) {
gf.c:                if (jl_array_ptr_ref(mt->backedges, i) == caller) {
gf.c:                    JL_UNLOCK(&mt->writelock);
gf.c:                typ = jl_array_ptr_ref(mt->backedges, i - 1);
gf.c:        jl_array_ptr_1d_push(mt->backedges, typ);
gf.c:        jl_array_ptr_1d_push(mt->backedges, caller);
gf.c:    JL_UNLOCK(&mt->writelock);
gf.c:    JL_GC_PROMISE_ROOTED(env->newentry);
gf.c:    if (oldentry->max_world == ~(size_t)0) {
gf.c:        jl_method_instance_t *mi = oldentry->func.linfo;
gf.c:        jl_method_instance_t **d = (jl_method_instance_t**)jl_array_ptr_data(env->shadowed);
gf.c:        size_t i, n = jl_array_len(env->shadowed);
gf.c:            oldentry->max_world = env->max_world;
gf.c:            env->invalidated = 1;
gf.c:    if (oldentry->max_world < ~(size_t)0)
gf.c:    jl_method_t *m = oldentry->func.linfo->def.method;
gf.c:    if (m == env->newentry->func.method)
gf.c:        oldentry->max_world = env->max_world;
gf.c:    if ((void*)(entry->func.method) == *(jl_method_t**)closure) {
gf.c:    if (jl_typemap_visitor(mt->defs, typemap_search, &closure))
gf.c:    assert(!method->is_for_opaque_closure);
gf.c:    method->deleted_world = methodentry->max_world = max_world;
gf.c:    // drop this method from mt->cache
gf.c:    jl_typemap_visitor(mt->cache, disable_mt_cache, (void*)&mt_cache_env);
gf.c:    jl_array_t *leafcache = jl_atomic_load_relaxed(&mt->leafcache);
gf.c:                if (oldentry->max_world == ~(size_t)0)
gf.c:                    oldentry->max_world = mt_cache_env.max_world;
gf.c:                oldentry = oldentry->next;
gf.c:    jl_svec_t *specializations = methodentry->func.method->specializations;
gf.c:            invalidate_external(mi, methodentry->max_world);
gf.c:            invalidate_backedges(mi, methodentry->max_world, "jl_method_table_disable");
gf.c:    JL_LOCK(&mt->writelock);
gf.c:    JL_UNLOCK(&mt->writelock);
gf.c:    // determine if type-intersection can be convinced to give a better, non-bad answer
gf.c:    jl_value_t *type = method->sig;
gf.c:    if (method->primary_world == 1)
gf.c:        method->primary_world = ++jl_world_counter;
gf.c:    size_t max_world = method->primary_world - 1;
gf.c:    JL_LOCK(&mt->writelock);
gf.c:    struct jl_typemap_assoc search = {(jl_value_t*)type, method->primary_world, NULL, 0, ~(size_t)0};
gf.c:    jl_typemap_entry_t *oldentry = jl_typemap_assoc_by_type(mt->defs, &search, /*offs*/0, /*subtype*/0);
gf.c:            (jl_value_t*)method, method->primary_world, method->deleted_world);
gf.c:    jl_typemap_insert(&mt->defs, (jl_value_t*)mt, newentry, 0);
gf.c:        jl_method_t *m = oldentry->func.method;
gf.c:        oldvalue = get_intersect_matches(mt->defs, newentry);
gf.c:        if (mt->backedges) {
gf.c:            jl_value_t **backedges = jl_array_ptr_data(mt->backedges);
gf.c:            size_t i, na = jl_array_len(mt->backedges);
gf.c:                jl_value_t *backedgetyp = backedges[i - 1];
gf.c:                    //  -> no previous method: now there is one, need to update the missing edge
gf.c:                    //  -> one+ previously matching method(s):
gf.c:                    //    -> more specific then all of them: need to update the missing edge
gf.c:                    //      -> some may have been ambiguous: now there is a replacement
gf.c:                    //      -> some may have been called: now there is a replacement (also will be detected in the loop later)
gf.c:                    //    -> less specific or ambiguous with any one of them: can ignore the missing edge (not missing)
gf.c:                    //      -> some may have been ambiguous: still are
gf.c:                    //      -> some may have been called: they may be partly replaced (will be detected in the loop later)
gf.c:                        if (jl_subtype(isect, m->sig) || (isect2 && jl_subtype(isect2, m->sig))) {
gf.c:                            if (!jl_type_morespecific(type, m->sig)) {
gf.c:                    backedges[ins++] = backedges[i - 1];
gf.c:                    backedges[ins++] = backedges[i - 0];
gf.c:                mt->backedges = NULL;
gf.c:                jl_array_del_end(mt->backedges, na - ins);
gf.c:                jl_svec_t *specializations = jl_atomic_load_acquire(&m->specializations);
gf.c:                    isect3 = jl_type_intersection(m->sig, (jl_value_t*)mi->specTypes);
gf.c:                            morespec[j] = (char)(jl_type_morespecific(m->sig, type) ? morespec_is : morespec_isnot);
gf.c:                            // not actually shadowing--the existing method is still better
gf.c:                            ambig = jl_type_morespecific(type, m->sig) ? morespec_is : morespec_isnot;
gf.c:                        // replacing a method--see if this really was the selected method previously
gf.c:                                if (m == m2 || !(jl_subtype(isect, m2->sig) || (isect && jl_subtype(isect, m2->sig))))
gf.c:                                    morespec[k] = (char)(jl_type_morespecific(m2->sig, type) ? morespec_is : morespec_isnot);
gf.c:                                    // not actually shadowing this--m2 will still be better
gf.c:                                if (!jl_type_morespecific(m->sig, m2->sig))
gf.c:                        if (mi->backedges) {
gf.c:                // search mt->cache and leafcache and drop anything that might overlap with the new method
gf.c:                jl_typemap_visitor(mt->cache, invalidate_mt_cache, (void*)&mt_cache_env);
gf.c:                jl_array_t *leafcache = jl_atomic_load_relaxed(&mt->leafcache);
gf.c:                            entry = (jl_value_t*)((jl_typemap_entry_t*)entry)->next;
gf.c:    JL_UNLOCK(&mt->writelock);
gf.c:        jl_ptls_t ptls = jl_current_task->ptls;
gf.c:        ptls->bt_size = rec_backtrace(ptls->bt_data, JL_MAX_BT_SIZE, 0);
gf.c:    jl_value_t *argtup = jl_f_tuple(NULL, args, na - 1);
gf.c:    jl_typemap_t *cache = jl_atomic_load_relaxed(&mt->cache); // XXX: gc root for this?
gf.c:        return entry->func.linfo;
gf.c:    jl_array_t *leafcache = jl_atomic_load_relaxed(&mt->leafcache);
gf.c:        return entry->func.linfo;
gf.c:    JL_LOCK(&mt->writelock);
gf.c:    JL_UNLOCK(&mt->writelock);
gf.c:// -1 for no limit.
gf.c:        return jl_false; // indeterminate - ml_matches can't deal with this case
gf.c:    jl_method_t *def = method->def.method;
gf.c:    if (!jl_is_method(def) || def->source == NULL) {
gf.c:    if (def->unspecialized == NULL) {
gf.c:        JL_LOCK(&def->writelock);
gf.c:        if (def->unspecialized == NULL) {
gf.c:            def->unspecialized = jl_get_specialized(def, def->sig, jl_emptysvec);
gf.c:            jl_gc_wb(def, def->unspecialized);
gf.c:        JL_UNLOCK(&def->writelock);
gf.c:    return def->unspecialized;
gf.c:    jl_code_instance_t *codeinst = jl_atomic_load_relaxed(&mi->cache);
gf.c:        if (codeinst->min_world <= world && world <= codeinst->max_world) {
gf.c:            if (jl_atomic_load_relaxed(&codeinst->invoke) != NULL)
gf.c:        codeinst = jl_atomic_load_relaxed(&codeinst->next);
gf.c:    jl_method_t *def = mi->def.method;
gf.c:    // disabling compilation per-module can override global setting
gf.c:        jl_method_t *def = mi->def.method;
gf.c:        if (jl_is_method(def) && def->unspecialized) {
gf.c:            jl_code_instance_t *unspec = jl_atomic_load_relaxed(&def->unspecialized->cache);
gf.c:            if (unspec && jl_atomic_load_relaxed(&unspec->invoke)) {
gf.c:                codeinst->isspecsig = 0;
gf.c:                codeinst->specptr = unspec->specptr;
gf.c:                codeinst->rettype_const = unspec->rettype_const;
gf.c:                codeinst->invoke = unspec->invoke;
gf.c:            codeinst->invoke = jl_fptr_interpret_call;
gf.c:            jl_printf(JL_STDERR, " : sysimg may not have been built with --compile=all\n");
gf.c:        int mod_setting = jl_get_module_compile(((jl_method_t*)def)->module);
gf.c:            compile_option = ((jl_method_t*)def)->module->compile;
gf.c:        jl_method_t *def = mi->def.method;
gf.c:        if (jl_is_method(def) && def->unspecialized) {
gf.c:            jl_code_instance_t *unspec = jl_atomic_load_relaxed(&def->unspecialized->cache);
gf.c:            if (unspec && jl_atomic_load_relaxed(&unspec->invoke)) {
gf.c:                codeinst->isspecsig = 0;
gf.c:                codeinst->specptr = unspec->specptr;
gf.c:                codeinst->rettype_const = unspec->rettype_const;
gf.c:                codeinst->invoke = unspec->invoke;
gf.c:            codeinst->invoke = jl_fptr_interpret_call;
gf.c:            jl_printf(JL_STDERR, " : sysimg may not have been built with --compile=all\n");
gf.c:        if (jl_atomic_load_relaxed(&ucache->invoke) == NULL)
gf.c:        assert(jl_atomic_load_relaxed(&ucache->invoke) != NULL);
gf.c:        if (jl_atomic_load_relaxed(&ucache->invoke) != jl_fptr_sparam &&
gf.c:            jl_atomic_load_relaxed(&ucache->invoke) != jl_fptr_interpret_call) {
gf.c:        codeinst->isspecsig = 0;
gf.c:        codeinst->specptr = ucache->specptr;
gf.c:        codeinst->rettype_const = ucache->rettype_const;
gf.c:        codeinst->invoke = ucache->invoke;
gf.c:    jl_atomic_store_relaxed(&codeinst->precompile, 1);
gf.c:    return m->rettype_const;
gf.c:        jl_fptr_args_t invoke = jl_atomic_load_relaxed(&m->specptr.fptr1);
gf.c:    jl_svec_t *sparams = m->def->sparam_vals;
gf.c:        jl_fptr_sparam_t invoke = jl_atomic_load_relaxed(&m->specptr.fptr3);
gf.c:    jl_callptr_t f = jl_atomic_load_relaxed(&codeinst->invoke);
gf.c:    return -1;
gf.c:    intptr_t nspec = (mt == jl_type_type_mt || mt == jl_nonfunction_mt ? m->nargs + 1 : mt->max_args + 2);
gf.c:    int is_compileable = ((jl_datatype_t*)ti)->isdispatchtuple ||
gf.c:// compile-time method lookup
gf.c:    jl_method_t *m = match->method;
gf.c:    jl_svec_t *env = match->sparams;
gf.c:    jl_tupletype_t *ti = match->spec_types;
gf.c:            if (mt_cache && ((jl_datatype_t*)ti)->isdispatchtuple) {
gf.c:                JL_LOCK(&mt->writelock);
gf.c:                nf = cache_method(mt, &mt->cache, (jl_value_t*)mt, ti, m, world, min_valid2, max_valid2, env);
gf.c:                JL_UNLOCK(&mt->writelock);
gf.c:        if (jl_atomic_load_relaxed(&((jl_code_instance_t*)codeinst)->invoke) == jl_fptr_const_return)
gf.c:        jl_atomic_store_relaxed(&((jl_code_instance_t*)codeinst)->precompile, 1);
gf.c:    if (jl_typeinf_func && mi->def.method->primary_world <= tworld) {
gf.c:        // In addition to full compilation of the compilation-signature, if `types` is more specific (e.g. due to nospecialize),
gf.c:        //ALT: if (jl_is_datatype(types) && ((jl_datatype_t*)types)->isdispatchtuple && !jl_egal(mi->specTypes, types))
gf.c:        //ALT: if (jl_subtype(types, mi->specTypes))
gf.c:        if (!jl_subtype(mi->specTypes, (jl_value_t*)types)) {
gf.c:            types2 = jl_type_intersection_env((jl_value_t*)types, (jl_value_t*)mi->def.method->sig, &tpenv2);
gf.c:            jl_method_instance_t *li2 = jl_specializations_get_linfo(mi->def.method, (jl_value_t*)types2, tpenv2);
gf.c:            if (jl_typeinf_func && mi->def.method->primary_world <= tworld) {
gf.c:    jl_code_instance_t *codeinst = jl_atomic_load_relaxed(&mfunc->cache);
gf.c:        if (codeinst->min_world <= world && world <= codeinst->max_world) {
gf.c:            jl_callptr_t invoke = jl_atomic_load_relaxed(&codeinst->invoke);
gf.c:        codeinst = jl_atomic_load_relaxed(&codeinst->next);
gf.c:    jl_callptr_t invoke = jl_atomic_load_relaxed(&codeinst->invoke);
gf.c:    size_t world = jl_current_task->world_age;
gf.c:        jl_value_t *a = args[i - 1];
gf.c:              hash-consed, so pointer comparison should work.
gf.c:    int traceen = trace_en; //&& ((char*)&mt < jl_stack_hi-6000000);
gf.c:        (callsite) & (N_CALL_CACHE - 1),
gf.c:        (callsite >> 8) & (N_CALL_CACHE - 1),
gf.c:        (callsite >> 16) & (N_CALL_CACHE - 1),
gf.c:        (callsite >> 24 | callsite << 8) & (N_CALL_CACHE - 1)};
gf.c:            if (entry && nargs == jl_svec_len(entry->sig->parameters) && \
gf.c:                sig_match_fast(FT, args, jl_svec_data(entry->sig->parameters), nargs) && \
gf.c:                world >= entry->min_world && world <= entry->max_world) { \
gf.c:        jl_array_t *leafcache = jl_atomic_load_relaxed(&mt->leafcache);
gf.c:                jl_typeis(jl_atomic_load_relaxed(&mt->cache), jl_typemap_level_type)) {
gf.c:            // hashing args is expensive, but looking at mt->cache is probably even more expensive
gf.c:            jl_typemap_t *cache = jl_atomic_load_relaxed(&mt->cache); // XXX: gc root required?
gf.c:        if (entry != NULL && entry->isleafsig && entry->simplesig == (void*)jl_nothing && entry->guardsigs == jl_emptysvec) {
gf.c:        mfunc = entry->func.linfo;
gf.c:        JL_LOCK(&mt->writelock);
gf.c:        JL_UNLOCK(&mt->writelock);
gf.c:        jl_printf(JL_STDOUT, " at %s:%d\n", jl_symbol_name(mfunc->def.method->file), mfunc->def.method->line);
gf.c:    size_t world = jl_current_task->world_age;
gf.c:    return (jl_value_t*)matc->method;
gf.c:    size_t world = jl_current_task->world_age;
gf.c:    if (method->invokes != NULL)
gf.c:        tm = jl_typemap_assoc_exact(method->invokes, gf, args, nargs, 1, 1);
gf.c:        mfunc = tm->func.linfo;
gf.c:        JL_LOCK(&method->writelock);
gf.c:        if (jl_is_unionall(method->sig)) {
gf.c:            int sub = jl_subtype_matching((jl_value_t*)tt, (jl_value_t*)method->sig, &tpenv);
gf.c:        if (method->invokes == NULL)
gf.c:            method->invokes = jl_nothing;
gf.c:        mfunc = cache_method(NULL, &method->invokes, (jl_value_t*)method, tt, method, 1, 1, ~(size_t)0, tpenv);
gf.c:        JL_UNLOCK(&method->writelock);
gf.c:    size_t world = jl_current_task->world_age;
gf.c:    return _jl_invoke(gf, args, nargs - 1, mfunc, world);
gf.c:    ftype->name->mt->name = name;
gf.c:    jl_gc_wb(ftype->name->mt, name);
gf.c:    ftype->instance = f; jl_gc_wb(ftype, f);
gf.c:    if (!mt->kwsorter) {
gf.c:        JL_LOCK(&mt->writelock);
gf.c:        if (!mt->kwsorter) {
gf.c:                name = jl_symbol_name(mt->name);
gf.c:                name = jl_symbol_name(dt->name->name);
gf.c:            mt->kwsorter = jl_new_generic_function_with_supertype(fname, mt->module, jl_function_type);
gf.c:            jl_gc_wb(mt, mt->kwsorter);
gf.c:        JL_UNLOCK(&mt->writelock);
gf.c:    return mt->kwsorter;
gf.c:    jl_method_match_t *match = (jl_method_match_t*)jl_gc_alloc(ct->ptls, sizeof(jl_method_match_t), jl_method_match_type);
gf.c:    match->spec_types = spec_types;
gf.c:    match->sparams = sparams;
gf.c:    match->method = method;
gf.c:    match->fully_covers = fully_covers;
gf.c:    if (closure->intersections == 0 && !closure0->issubty)
gf.c:    if (closure->world < ml->min_world) {
gf.c:        if (closure->max_valid >= ml->min_world)
gf.c:            closure->max_valid = ml->min_world - 1;
gf.c:    else if (closure->world > ml->max_world) {
gf.c:        if (closure->min_valid <= ml->max_world)
gf.c:            closure->min_valid = ml->max_world + 1;
gf.c:        if (closure->min_valid < ml->min_world)
gf.c:            closure->min_valid = ml->min_world;
gf.c:        if (closure->max_valid > ml->max_world)
gf.c:            closure->max_valid = ml->max_world;
gf.c:    jl_method_t *meth = ml->func.method;
gf.c:    if (closure->lim >= 0 && jl_is_dispatch_tupletype(meth->sig)) {
gf.c:        if (closure->lim == 0)
gf.c:        closure->lim--;
gf.c:    closure->matc = make_method_match((jl_tupletype_t*)closure->match.ti,
gf.c:        closure->match.env, meth,
gf.c:        closure->match.issubty ? FULLY_COVERS : NOT_FULLY_COVERS);
gf.c:    size_t len = jl_array_len(closure->t);
gf.c:        closure->t = (jl_value_t*)jl_alloc_vec_any(1);
gf.c:        jl_array_ptr_set(closure->t, 0, (jl_value_t*)closure->matc);
gf.c:        jl_array_ptr_1d_push((jl_array_t*)closure->t, (jl_value_t*)closure->matc);
gf.c:// Returns a match as an array of svec(argtypes, static_params, Method, fully-covers).
gf.c:// fully-covers is a Bool indicating subtyping, though temporarily it may be
gf.c:// tri-values, with `nothing` indicating a match that is not a subtype, but
gf.c:    jl_typemap_t *defs = mt->defs;
gf.c:    if (defs == jl_nothing) // special-case: ignore builtin functions
gf.c:    size_t l = jl_svec_len(((jl_datatype_t*)unw)->parameters);
gf.c:        va = jl_tparam(unw, l - 1);
gf.c:    if (((jl_datatype_t*)unw)->isdispatchtuple) {
gf.c:        jl_array_t *leafcache = jl_atomic_load_relaxed(&mt->leafcache);
gf.c:            jl_method_instance_t *mi = entry->func.linfo;
gf.c:            jl_method_t *meth = mi->def.method;
gf.c:            if (!jl_is_unionall(meth->sig)) {
gf.c:            else if (jl_egal((jl_value_t*)type, mi->specTypes)) {
gf.c:                env.match.env = mi->sparam_vals;
gf.c:                env.match.ti = mi->specTypes;
gf.c:                // this just calls jl_subtype_env (since we know that `type <: meth->sig` by transitivity)
gf.c:                env.match.ti = jl_type_intersection_env((jl_value_t*)type, (jl_value_t*)meth->sig, &env.match.env);
gf.c:            if (*min_valid < entry->min_world)
gf.c:                *min_valid = entry->min_world;
gf.c:            if (*max_valid > entry->max_world)
gf.c:                *max_valid = entry->max_world;
gf.c:    if (((jl_datatype_t*)unw)->isdispatchtuple) {
gf.c:        jl_typemap_entry_t *entry = jl_typemap_assoc_by_type(jl_atomic_load_relaxed(&mt->cache), &search, jl_cachearg_offset(mt), /*subtype*/1);
gf.c:        if (entry && (((jl_datatype_t*)unw)->isdispatchtuple || entry->guardsigs == jl_emptysvec)) {
gf.c:            jl_method_instance_t *mi = entry->func.linfo;
gf.c:            jl_method_t *meth = mi->def.method;
gf.c:            if (!jl_is_unionall(meth->sig) && ((jl_datatype_t*)unw)->isdispatchtuple) {
gf.c:                // this just calls jl_subtype_env (since we know that `type <: meth->sig` by transitivity)
gf.c:                env.match.ti = jl_type_intersection_env((jl_value_t*)type, (jl_value_t*)meth->sig, &env.match.env);
gf.c:            *min_valid = entry->min_world;
gf.c:            *max_valid = entry->max_world;
gf.c:        // first try to pre-process the results to find the most specific
gf.c:        //   - first find a candidate for the best of these method results
gf.c:            if (matc->fully_covers == FULLY_COVERS) {
gf.c:                jl_method_t *m = matc->method;
gf.c:                    jl_method_t *minmaxm = minmax->method;
gf.c:                    if (jl_type_morespecific((jl_value_t*)minmaxm->sig, (jl_value_t*)m->sig))
gf.c:        //   - then see if it dominated all of the other choices
gf.c:                if (matc->fully_covers == FULLY_COVERS) {
gf.c:                    jl_method_t *m = matc->method;
gf.c:                    jl_method_t *minmaxm = minmax->method;
gf.c:                    if (!jl_type_morespecific((jl_value_t*)minmaxm->sig, (jl_value_t*)m->sig)) {
gf.c:        //   - it may even dominate some choices that are not subtypes!
gf.c:        //   - we could always check here if *any* FULLY_COVERS method is
gf.c:        //     more-specific (instead of just considering minmax), but that may
gf.c:            jl_method_t *minmaxm = minmax->method;
gf.c:                if (matc->fully_covers != FULLY_COVERS) {
gf.c:                    jl_method_t *m = matc->method;
gf.c:                    if (jl_type_morespecific((jl_value_t*)minmaxm->sig, (jl_value_t*)m->sig))
gf.c:                        matc->fully_covers = SENTINEL; // put a sentinel value here for sorting
gf.c:        //    - now we might have a fast-return here, if we see that
gf.c:                jl_array_del_end((jl_array_t*)env.t, len - 1);
gf.c:            jl_method_t *m = env.matc->method;
gf.c:            int subt = env.matc->fully_covers != NOT_FULLY_COVERS;
gf.c:                jl_method_match_t *matc2 = (jl_method_match_t *)jl_array_ptr_ref(env.t, i - j - 1);
gf.c:                jl_method_t *m2 = matc2->method;
gf.c:                int subt2 = matc2->fully_covers != NOT_FULLY_COVERS;
gf.c:                        if (subt || !jl_has_empty_intersection(m->sig, m2->sig))
gf.c:                            if (!jl_type_morespecific((jl_value_t*)m->sig, (jl_value_t*)m2->sig))
gf.c:                        // main downside being that it may be overly-
gf.c:                        if (jl_type_morespecific((jl_value_t*)m2->sig, (jl_value_t*)m->sig))
gf.c:                jl_array_ptr_set(env.t, i - j, matc2);
gf.c:            jl_array_ptr_set(env.t, i - j, env.matc);
gf.c:                if (minmax != matc && matc->fully_covers != NOT_FULLY_COVERS) {
gf.c:        if (include_ambiguous && lim == -1 && ambig == NULL && !minmax_ambig) {
gf.c:            // by computing the specificity-ambiguity matrix covering this query
gf.c:                    assert(matc->fully_covers != NOT_FULLY_COVERS);
gf.c:                    if (ambig_groupid[len - 1] > i)
gf.c:                        ambig_groupid[len - 1] = i; // ambiguity covering range [i:len)
gf.c:                jl_method_t *m = matc->method;
gf.c:                int subt = matc->fully_covers == FULLY_COVERS; // jl_subtype((jl_value_t*)type, (jl_value_t*)m->sig)
gf.c:                int rsubt = jl_egal((jl_value_t*)matc->spec_types, m->sig);
gf.c:                for (j = len; j > i; j--) {
gf.c:                    if (ambig_groupid[j - 1] < i) {
gf.c:                    jl_method_match_t *matc2 = (jl_method_match_t*)jl_array_ptr_ref(env.t, j - 1);
gf.c:                    // can't use skip[j - 1] here, since we still need to make sure the minmax dominates
gf.c:                    jl_method_t *m2 = matc2->method;
gf.c:                    int subt2 = matc2->fully_covers == FULLY_COVERS; // jl_subtype((jl_value_t*)type, (jl_value_t*)m2->sig)
gf.c:                    int rsubt2 = jl_egal((jl_value_t*)matc2->spec_types, m2->sig);
gf.c:                    if (!subt && !subt2 && rsubt && rsubt2 && lim == -1 && ambig == NULL)
gf.c:                        // ambiguous if they are also type-equal, as we
gf.c:                    if (jl_type_morespecific((jl_value_t*)m->sig, (jl_value_t*)m2->sig))
gf.c:                        ti = (jl_value_t*)matc2->spec_types;
gf.c:                        ti = (jl_value_t*)matc->spec_types;
gf.c:                        jl_type_intersection2((jl_value_t*)matc->spec_types, (jl_value_t*)matc2->spec_types, &env.match.ti, &isect2);
gf.c:                        for (k = i; k > 0; k--) {
gf.c:                            jl_method_match_t *matc3 = (jl_method_match_t*)jl_array_ptr_ref(env.t, k - 1);
gf.c:                            jl_method_t *m3 = matc3->method;
gf.c:                            if ((jl_subtype(ti, m3->sig) || (isect2 && jl_subtype(isect2, m3->sig)))
gf.c:                                    && jl_type_morespecific((jl_value_t*)m3->sig, (jl_value_t*)m->sig)
gf.c:                                    && jl_type_morespecific((jl_value_t*)m3->sig, (jl_value_t*)m2->sig))
gf.c:                            ambig_groupid[j - 1] = i; // ambiguity covering range [i:j)
gf.c:                j = len - i - 1;
gf.c:                        ambig_groupid[grouphi--] = groupid;
gf.c:                if (matc->fully_covers == FULLY_COVERS) { // jl_subtype((jl_value_t*)type, (jl_value_t*)m->sig)
gf.c:                    jl_method_t *m = matc->method;
gf.c:                    jl_tupletype_t *ti = matc->spec_types;
gf.c:                    if (matc->fully_covers == FULLY_COVERS)
gf.c:                        jl_method_t *m2 = matc2->method;
gf.c:                        if (jl_subtype((jl_value_t*)ti, m2->sig)) {
gf.c:                                if (!jl_type_morespecific((jl_value_t*)m->sig, (jl_value_t*)m2->sig)) {
gf.c:                    jl_method_t *m = matc->method;
gf.c:                    jl_tupletype_t *ti = matc->spec_types;
gf.c:                    int subt = matc->fully_covers == FULLY_COVERS; // jl_subtype((jl_value_t*)type, (jl_value_t*)m->sig)
gf.c:                        jl_method_t *m2 = matc2->method;
gf.c:                        int subt2 = matc2->fully_covers == FULLY_COVERS; // jl_subtype((jl_value_t*)type, (jl_value_t*)m2->sig)
gf.c:                        if (subt || subt2 || !jl_has_empty_intersection((jl_value_t*)ti, m2->sig)) {
gf.c:                            if (subt2 || jl_subtype((jl_value_t*)ti, m2->sig)) {
gf.c:                                if (!jl_type_morespecific((jl_value_t*)m->sig, (jl_value_t*)m2->sig) &&
gf.c:                                    !jl_type_morespecific((jl_value_t*)m2->sig, (jl_value_t*)m->sig)) {
gf.c:                if (matc->fully_covers == SENTINEL)
gf.c:                    matc->fully_covers = NOT_FULLY_COVERS;
gf.c:            jl_array_del_end((jl_array_t*)env.t, len - j);
gf.c:    if (cache_result && ((jl_datatype_t*)unw)->isdispatchtuple) { // cache_result parameter keeps this from being recursive
gf.c:            jl_method_t *meth = env.matc->method;
gf.c:            jl_svec_t *tpenv = env.matc->sparams;
gf.c:            JL_LOCK(&mt->writelock);
gf.c:            cache_method(mt, &mt->cache, (jl_value_t*)mt, type, meth, world, env.min_valid, env.max_valid, tpenv);
gf.c:            JL_UNLOCK(&mt->writelock);
gf.c:    return ((jl_datatype_t*)typ)->has_concrete_subtype;
gf.c:        jl_atomic_fetch_add_relaxed(&jl_cumulative_compile_time, (jl_hrtime() - inference_start_time));
gc.c:                cb = cb->next) \
gc.c:            ((ty)(cb->func)) args; \
gc.c:        if ((*list)->func == func)
gc.c:        list = &((*list)->next);
gc.c:    (*list)->next = NULL;
gc.c:    (*list)->func = func;
gc.c:        if ((*list)->func == func) {
gc.c:            (*list) = (*list)->next;
gc.c:        list = &((*list)->next);
gc.c:// Save/restore local mark stack to/from thread-local storage.
gc.c:    ptls->gc_mark_sp = *sp;
gc.c:    *sp = ptls->gc_mark_sp;
gc.c:// For accessing `ptls->finalizers`, the lock is needed if a thread
gc.c:// List of marked big objects.  Not per-thread.  Accessed only by master thread.
gc.c:// `ptls->finalizers` and `finalizer_list_marked` might have tagged pointers.
gc.c:        while (!jl_atomic_load_relaxed(&ptls2->gc_state) || !jl_atomic_load_acquire(&ptls2->gc_state))
gc.c:        size_t last_age = ct->world_age;
gc.c:        ct->world_age = jl_world_counter;
gc.c:        ct->world_age = last_age;
gc.c:    size_t len = need_sync ? jl_atomic_load_acquire((_Atomic(size_t)*)&list->len) : list->len;
gc.c:    void **items = list->items;
gc.c:        memset(&items[len], 0, (oldlen - len) * sizeof(void*));
gc.c:        jl_atomic_cmpswap((_Atomic(size_t)*)&list->len, &oldlen, len);
gc.c:        list->len = len;
gc.c:    void **items = list->items;
gc.c:    items[0] = (void*)JL_GC_ENCODE_PUSHARGS(list->len - 2);
gc.c:    items[1] = ct->gcstack;
gc.c:    ct->gcstack = (jl_gcframe_t*)items;
gc.c:    arraylist_push(list, list->items[0]);
gc.c:    arraylist_push(list, list->items[1]);
gc.c:    jl_value_t **items = (jl_value_t**)list->items;
gc.c:    size_t len = list->len;
gc.c:    // run finalizers in reverse order they were added, so lower-level finalizers run last
gc.c:    for (size_t i = len-4; i >= 2; i -= 2)
gc.c:    run_finalizer(ct, items[len-2], items[len-1]);
gc.c:    jl_ptls_t ptls = ct->ptls;
gc.c:    if (!ptls->in_finalizer && ptls->locks.len == 0 && ptls->finalizers_inhibited == 0) {
gc.c:        ptls->in_finalizer = 1;
gc.c:        ptls->in_finalizer = 0;
gc.c:        ptls = jl_current_task->ptls;
gc.c:    return ptls->finalizers_inhibited;
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    ptls->finalizers_inhibited++;
gc.c:    ct->ptls->finalizers_inhibited--;
gc.c:    jl_ptls_t ptls = ct->ptls;
gc.c:    int old_val = ptls->finalizers_inhibited;
gc.c:    int new_val = old_val + (on ? -1 : 1);
gc.c:    ptls->finalizers_inhibited = new_val;
gc.c:    void **items = flist->items;
gc.c:    size_t len = flist->len;
gc.c:    flist->len = 0;
gc.c:        schedule_all_finalizers(&ptls2->finalizers);
gc.c:    assert(jl_atomic_load_relaxed(&ptls->gc_state) == 0);
gc.c:    arraylist_t *a = &ptls->finalizers;
gc.c:    size_t oldlen = jl_atomic_load_acquire((_Atomic(size_t)*)&a->len);
gc.c:    if (__unlikely(oldlen + 2 > a->max)) {
gc.c:        // `a->len` might have been modified.
gc.c:        oldlen = a->len;
gc.c:        a->len = oldlen;
gc.c:    void **items = a->items;
gc.c:    jl_atomic_store_release((_Atomic(size_t)*)&a->len, oldlen + 2);
gc.c:        finalize_object(&ptls2->finalizers, o, &copied_list, jl_atomic_load_relaxed(&ct->tid) != i);
gc.c:    for (size_t i = 0; i < objs->len; i++) {
gc.c:        jl_value_t *v = (jl_value_t *)(objs->items[i]);
gc.c:        const jl_datatype_layout_t *layout = t->layout;
gc.c:            desc->sweepfunc(v);
gc.c:            objs->items[p++] = v;
gc.c:    objs->len = p;
gc.c:        gc_sweep_foreign_objs_in_list(&ptls2->sweep_objs);
gc.c:// GC knobs and self-measurement variables
gc.c: * <-[(quick)sweep]-
gc.c: *     ---->  GC_OLD  <--[(quick)sweep && age>promotion]--
gc.c: *     ----- GC_OLD_MARKED <----                         |
gc.c: *              --[quicksweep]---                        |
gc.c: *  ----[new]------> GC_CLEAN ------[mark]-----------> GC_MARKED
gc.c: *  <-[(quick)sweep]---    |                                   |
gc.c: *                         --[(quick)sweep && age<=promotion]---
gc.c:// - sweep_page which is specialized for 1bit age
gc.c:// - the size of the age storage in jl_gc_pagemeta_t
gc.c:    const int nbig = gc_cache->nbig_obj;
gc.c:        void *ptr = gc_cache->big_obj[i];
gc.c:            gc_big_object_link(hdr, &ptls->heap.big_objects);
gc.c:    gc_cache->nbig_obj = 0;
gc.c:    perm_scanned_bytes += gc_cache->perm_scanned_bytes;
gc.c:    scanned_bytes += gc_cache->scanned_bytes;
gc.c:    gc_cache->perm_scanned_bytes = 0;
gc.c:    gc_cache->scanned_bytes = 0;
gc.c:    gc_sync_cache_nolock(ptls, &ptls->gc_cache);
gc.c:        gc_sync_cache_nolock(ptls, &ptls2->gc_cache);
gc.c:    const int nentry = sizeof(ptls->gc_cache.big_obj) / sizeof(void*);
gc.c:    size_t nobj = ptls->gc_cache.nbig_obj;
gc.c:    ptls->gc_cache.big_obj[nobj] = (void*)(toyoung ? (v | 1) : v);
gc.c:    ptls->gc_cache.nbig_obj = nobj + 1;
gc.c:    tag = jl_atomic_exchange_relaxed((_Atomic(uintptr_t)*)&o->header, tag);
gc.c:        ptls->gc_cache.perm_scanned_bytes += hdr->sz & ~3;
gc.c:        ptls->gc_cache.scanned_bytes += hdr->sz & ~3;
gc.c:        if (mark_reset_age && hdr->age) {
gc.c:            hdr->age = 0;
gc.c:                     mark_mode == GC_OLD_MARKED, hdr->sz & ~3);
gc.c:        ptls->gc_cache.perm_scanned_bytes += page->osize;
gc.c:        static_assert(sizeof(_Atomic(uint16_t)) == sizeof(page->nold), "");
gc.c:        jl_atomic_fetch_add_relaxed((_Atomic(uint16_t)*)&page->nold, 1);
gc.c:        ptls->gc_cache.scanned_bytes += page->osize;
gc.c:            page->has_young = 1;
gc.c:            int obj_id = (((char*)o) - page_begin) / page->osize;
gc.c:            uint8_t *ages = page->ages + obj_id / 8;
gc.c:                     mark_mode == GC_OLD_MARKED, page->osize);
gc.c:    page->has_marked = 1;
gc.c:    uintptr_t tag = buf->header;
gc.c:    if (o->bits.gc == GC_OLD_MARKED)
gc.c:    o->bits.gc = GC_OLD_MARKED;
gc.c:    else if (dt->name == jl_array_typename) {
gc.c:        if (!a->flags.pooled)
gc.c:    if (dt->layout->npointers != 0)
gc.c:    if (jl_atomic_load_relaxed(&ptls->gc_num.allocd) >= 0 || jl_gc_debug_check_other()) {
gc.c:    wr->value = value;  // NOTE: wb not needed here
gc.c:    arraylist_push(&ptls->heap.weak_refs, wr);
gc.c:        size_t n, l = ptls2->heap.weak_refs.len;
gc.c:        void **lst = ptls2->heap.weak_refs.items;
gc.c:            if (!gc_marked(jl_astaggedvalue(wr->value)->bits.gc))
gc.c:                wr->value = (jl_value_t*)jl_nothing;
gc.c:        size_t l = ptls2->heap.weak_refs.len;
gc.c:        void **lst = ptls2->heap.weak_refs.items;
gc.c:            if (gc_marked(jl_astaggedvalue(wr)->bits.gc))
gc.c:            if (n >= l - ndel)
gc.c:        ptls2->heap.weak_refs.len -= ndel;
gc.c:    jl_atomic_store_relaxed(&ptls->gc_num.allocd,
gc.c:        jl_atomic_load_relaxed(&ptls->gc_num.allocd) + allocsz);
gc.c:    jl_atomic_store_relaxed(&ptls->gc_num.bigalloc,
gc.c:        jl_atomic_load_relaxed(&ptls->gc_num.bigalloc) + 1);
gc.c:    v->sz = allocsz;
gc.c:    v->age = 0;
gc.c:    gc_big_object_link(v, &ptls->heap.big_objects);
gc.c:    return jl_valueof(&v->header);
gc.c:        bigval_t *nxt = v->next;
gc.c:        int bits = v->bits.gc;
gc.c:            pv = &v->next;
gc.c:            int age = v->age;
gc.c:                v->age = age;
gc.c:            v->bits.gc = bits;
gc.c:                nxt->prev = pv;
gc.c:            gc_num.freed += v->sz&~3;
gc.c:            memset(v, 0xbb, v->sz&~3);
gc.c:        sweep_big_list(sweep_full, &jl_all_tls_states[i]->heap.big_objects);
gc.c:        if (ptls->heap.big_objects)
gc.c:            ptls->heap.big_objects->prev = last_next;
gc.c:        *last_next = ptls->heap.big_objects;
gc.c:        ptls->heap.big_objects = big_objects_marked;
gc.c:        if (ptls->heap.big_objects)
gc.c:            ptls->heap.big_objects->prev = &ptls->heap.big_objects;
gc.c:    if (ptls->heap.mafreelist == NULL) {
gc.c:        ma = ptls->heap.mafreelist;
gc.c:        ptls->heap.mafreelist = ma->next;
gc.c:    ma->a = a;
gc.c:    ma->next = ptls->heap.mallocarrays;
gc.c:    ptls->heap.mallocarrays = ma;
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    jl_atomic_store_relaxed(&ptls->gc_num.allocd,
gc.c:        jl_atomic_load_relaxed(&ptls->gc_num.allocd) + sz);
gc.c:            dest->allocd += (jl_atomic_load_relaxed(&ptls->gc_num.allocd) + gc_num.interval);
gc.c:            dest->freed += jl_atomic_load_relaxed(&ptls->gc_num.freed);
gc.c:            dest->malloc += jl_atomic_load_relaxed(&ptls->gc_num.malloc);
gc.c:            dest->realloc += jl_atomic_load_relaxed(&ptls->gc_num.realloc);
gc.c:            dest->poolalloc += jl_atomic_load_relaxed(&ptls->gc_num.poolalloc);
gc.c:            dest->bigalloc += jl_atomic_load_relaxed(&ptls->gc_num.bigalloc);
gc.c:            dest->freecall += jl_atomic_load_relaxed(&ptls->gc_num.freecall);
gc.c:            memset(&ptls->gc_num, 0, sizeof(ptls->gc_num));
gc.c:            jl_atomic_store_relaxed(&ptls->gc_num.allocd, -(int64_t)gc_num.interval);
gc.c:        sz = a->elsize * a->maxsize + ((a->elsize == 1 && !isbitsunion) ? 1 : 0);
gc.c:        sz = a->elsize * jl_array_len(a);
gc.c:    if (a->flags.how == 2) {
gc.c:        char *d = (char*)a->data - a->offset*a->elsize;
gc.c:        if (a->flags.isaligned)
gc.c:        mallocarray_t *ma = ptls2->heap.mallocarrays;
gc.c:        mallocarray_t **pma = &ptls2->heap.mallocarrays;
gc.c:            mallocarray_t *nxt = ma->next;
gc.c:            int bits = jl_astaggedvalue(ma->a)->bits.gc;
gc.c:                pma = &ma->next;
gc.c:                assert(ma->a->flags.how == 2);
gc.c:                jl_gc_free_array(ma->a);
gc.c:                ma->next = ptls2->heap.mafreelist;
gc.c:                ptls2->heap.mafreelist = ma;
gc.c:    pg->nfree = (GC_PAGE_SZ - GC_PAGE_OFFSET) / p->osize;
gc.c:    jl_ptls_t ptls2 = jl_all_tls_states[pg->thread_n];
gc.c:    pg->pool_n = p - ptls2->heap.norm_pools;
gc.c:    memset(pg->ages, 0, GC_PAGE_SZ / 8 / p->osize + 1);
gc.c:    jl_taggedvalue_t *beg = (jl_taggedvalue_t*)(pg->data + GC_PAGE_OFFSET);
gc.c:    jl_taggedvalue_t *next = (jl_taggedvalue_t*)pg->data;
gc.c:        next->next = NULL;
gc.c:        next->next = flpage->next;
gc.c:        flpage->next = beg;
gc.c:    pg->has_young = 0;
gc.c:    pg->has_marked = 0;
gc.c:    pg->fl_begin_offset = -1;
gc.c:    pg->fl_end_offset = -1;
gc.c:// Add a new page to the pool. Discards any pages in `p->newpages` before.
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    pg->osize = p->osize;
gc.c:    pg->ages = (uint8_t*)malloc_s(GC_PAGE_SZ / 8 / p->osize + 1);
gc.c:    pg->thread_n = ptls->tid;
gc.c:    p->newpages = fl;
gc.c:    assert(jl_atomic_load_relaxed(&ptls->gc_state) == 0);
gc.c:    jl_atomic_store_relaxed(&ptls->gc_num.allocd,
gc.c:        jl_atomic_load_relaxed(&ptls->gc_num.allocd) + osize);
gc.c:    jl_atomic_store_relaxed(&ptls->gc_num.poolalloc,
gc.c:        jl_atomic_load_relaxed(&ptls->gc_num.poolalloc) + 1);
gc.c:    jl_taggedvalue_t *v = p->freelist;
gc.c:        jl_taggedvalue_t *next = v->next;
gc.c:        p->freelist = next;
gc.c:            assert(pg->osize == p->osize);
gc.c:            pg->nfree = 0;
gc.c:            pg->has_young = 1;
gc.c:    v = p->newpages;
gc.c:    char *cur_page = gc_page_data((char*)v - 1);
gc.c:            jl_gc_pagemeta_t *pg = jl_assume(page_metadata((char*)v - 1));
gc.c:            assert(pg->osize == p->osize);
gc.c:            pg->nfree = 0;
gc.c:            pg->has_young = 1;
gc.c:    p->newpages = next;
gc.c:        return -1;
gc.c:    return (int)(intptr_t)(&((jl_ptls_t)0)->heap.norm_pools[klass]);
gc.c:    char *data = pg->data;
gc.c:    uint8_t *ages = pg->ages;
gc.c:    char *lim = (char*)v + GC_PAGE_SZ - GC_PAGE_OFFSET - osize;
gc.c:    size_t old_nfree = pg->nfree;
gc.c:    if (!pg->has_marked) {
gc.c:        // FIXME - need to do accounting on a per-thread basis
gc.c:            jl_taggedvalue_t *begin = reset_page(p, pg, p->newpages);
gc.c:            p->newpages = begin;
gc.c:            begin->next = (jl_taggedvalue_t*)0;
gc.c:        nfree = (GC_PAGE_SZ - GC_PAGE_OFFSET) / osize;
gc.c:    if (!sweep_full && !pg->has_young) {
gc.c:        assert(!prev_sweep_full || pg->prev_nold >= pg->nold);
gc.c:        if (!prev_sweep_full || pg->prev_nold == pg->nold) {
gc.c:            if (pg->fl_begin_offset != (uint16_t)-1) {
gc.c:            nfree = pg->nfree;
gc.c:            int bits = v->bits.gc;
gc.c:                pfl = &v->next;
gc.c:                    // non-first-class objects like `jl_binding_t`
gc.c:                        bits = v->bits.gc = GC_OLD; // promote
gc.c:                    bits = v->bits.gc = GC_CLEAN; // unmark
gc.c:        pg->has_marked = has_marked;
gc.c:        pg->has_young = has_young;
gc.c:            pg->fl_begin_offset = (char*)pfl_begin - data;
gc.c:            pg->fl_end_offset = (char*)pfl - data;
gc.c:            pg->fl_begin_offset = -1;
gc.c:            pg->fl_end_offset = -1;
gc.c:        pg->nfree = pg_nfree;
gc.c:            pg->nold = 0;
gc.c:            pg->prev_nold = prev_nold;
gc.c:    nfree = pg->nfree;
gc.c:    gc_num.freed += (nfree - old_nfree) * osize;
gc.c:    int p_n = pg->pool_n;
gc.c:    int t_n = pg->thread_n;
gc.c:    jl_gc_pool_t *p = &ptls2->heap.norm_pools[p_n];
gc.c:    int osize = pg->osize;
gc.c:    for (unsigned pg_i = 0; pg_i <= pagetable0->ub; pg_i++) {
gc.c:        uint32_t line = pagetable0->allocmap[pg_i];
gc.c:            jl_gc_pagemeta_t *pg = pagetable0->meta[pg_i * 32 + j];
gc.c:    pagetable0->ub = ub;
gc.c:    for (unsigned pg_i = 0; pg_i <= pagetable1->ub; pg_i++) {
gc.c:        uint32_t line = pagetable1->allocmap0[pg_i];
gc.c:            pagetable0_t *pagetable0 = pagetable1->meta0[pg_i * 32 + j];
gc.c:                pagetable1->allocmap0[pg_i] &= ~(1 << j); // no allocations found, remember that for next time
gc.c:        if (pagetable1->allocmap0[pg_i]) {
gc.c:    pagetable1->ub = ub;
gc.c:    if (REGION2_PG_COUNT == 1) { // compile-time optimization
gc.c:    assert(pg->fl_begin_offset != (uint16_t)-1);
gc.c:    jl_taggedvalue_t *fl_beg = (jl_taggedvalue_t*)(cur_pg + pg->fl_begin_offset);
gc.c:        last = last->next;
gc.c:    pg->nfree = nfree;
gc.c:// setup the data-structures for a sweep over all memory pools
gc.c:            jl_gc_pool_t *p = &ptls2->heap.norm_pools[i];
gc.c:            jl_taggedvalue_t *last = p->freelist;
gc.c:                pg->has_young = 1;
gc.c:            p->freelist =  NULL;
gc.c:            pfl[t_i * JL_GC_N_POOLS + i] = &p->freelist;
gc.c:            last = p->newpages;
gc.c:                jl_gc_pagemeta_t *pg = jl_assume(page_metadata(last_p - 1));
gc.c:                assert(last_p - gc_page_data(last_p - 1) >= GC_PAGE_OFFSET);
gc.c:                pg->nfree = (GC_PAGE_SZ - (last_p - gc_page_data(last_p - 1))) / p->osize;
gc.c:                pg->has_young = 1;
gc.c:            p->newpages = NULL;
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    o->bits.gc = GC_MARKED;
gc.c:    arraylist_push(ptls->heap.remset, (jl_value_t*)ptr);
gc.c:    ptls->heap.remset_nptr++; // conservative
gc.c:    const jl_datatype_layout_t *ly = dt->layout;
gc.c:    uint32_t npointers = ly->npointers;
gc.c:    jl_value_t *ptrf = ((jl_value_t**)ptr)[ly->first_ptr];
gc.c:    if (ptrf && (jl_astaggedvalue(ptrf)->bits.gc & 1) == 0) {
gc.c:        if (ly->fielddesc_type == 0) {
gc.c:        else if (ly->fielddesc_type == 1) {
gc.c:            assert(ly->fielddesc_type == 2);
gc.c:        if (ptrf && (jl_astaggedvalue(ptrf)->bits.gc & 1) == 0) {
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    buf->bits.gc = GC_MARKED;
gc.c:    arraylist_push(&ptls->heap.rem_bindings, bnd);
gc.c:static void *volatile gc_findval; // for usage from gdb, for finding the gc-root for a value
gc.c:    jl_gc_mark_data_t *old_data = gc_cache->data_stack;
gc.c:    void **pc_stack = sp->pc_start;
gc.c:    size_t stack_size = (char*)sp->pc_end - (char*)pc_stack;
gc.c:    JL_LOCK_NOGC(&gc_cache->stack_lock);
gc.c:    gc_cache->data_stack = (jl_gc_mark_data_t *)realloc_s(old_data, stack_size * 2 * sizeof(jl_gc_mark_data_t));
gc.c:    sp->data = (jl_gc_mark_data_t *)(((char*)sp->data) + (((char*)gc_cache->data_stack) - ((char*)old_data)));
gc.c:    sp->pc_start = gc_cache->pc_stack = (void**)realloc_s(pc_stack, stack_size * 2 * sizeof(void*));
gc.c:    gc_cache->pc_stack_end = sp->pc_end = sp->pc_start + stack_size * 2;
gc.c:    sp->pc = sp->pc_start + (sp->pc - pc_stack);
gc.c:    JL_UNLOCK_NOGC(&gc_cache->stack_lock);
gc.c:    if (__unlikely(sp->pc == sp->pc_end))
gc.c:    *sp->pc = pc;
gc.c:    memcpy(sp->data, data, data_size);
gc.c:        sp->data = (jl_gc_mark_data_t *)(((char*)sp->data) + data_size);
gc.c:        sp->pc++;
gc.c:// Check if the reference is non-NULL and atomically set the mark bit.
gc.c:    uintptr_t tag = o->header;
gc.c:    size_t len = list->len;
gc.c:    jl_value_t **items = (jl_value_t**)list->items;
gc.c:    uintptr_t tag = o->header;
gc.c:    return gc_mark_queue_obj(&ptls->gc_cache, &ptls->gc_mark_sp, obj);
gc.c:                                jl_astaggedvalue(parent)->bits.gc & 2 };
gc.c:    gc_mark_stack_push(&ptls->gc_cache, &ptls->gc_mark_sp,
gc.c:        ptls->heap.remset_nptr += nptr >> 2;
gc.c:        arraylist_t *remset = ptls->heap.remset;
gc.c:        size_t len = remset->len;
gc.c:        if (__unlikely(len >= remset->max)) {
gc.c:            remset->len = len + 1;
gc.c:            remset->items[len] = obj;
gc.c:    (void)jl_assume(objary == (gc_mark_objarray_t*)sp->data);
gc.c:    for (; begin < end; begin += objary->step) {
gc.c:            verify_parent2("obj array", objary->parent, begin, "elem(%d)",
gc.c:                           gc_slot_to_arrayidx(objary->parent, begin));
gc.c:        if (!gc_try_setmark(*pnew_obj, &objary->nptr, ptag, pbits))
gc.c:        begin += objary->step;
gc.c:            objary->begin = begin;
gc.c:            gc_mark_push_remset(ptls, objary->parent, objary->nptr);
gc.c:    gc_mark_push_remset(ptls, objary->parent, objary->nptr);
gc.c:    (void)jl_assume(ary8 == (gc_mark_array8_t*)sp->data);
gc.c:    size_t elsize = ((jl_array_t*)ary8->elem.parent)->elsize / sizeof(jl_value_t*);
gc.c:                verify_parent2("array", ary8->elem.parent, slot, "elem(%d)",
gc.c:                               gc_slot_to_arrayidx(ary8->elem.parent, begin));
gc.c:            if (!gc_try_setmark(*pnew_obj, &ary8->elem.nptr, ptag, pbits))
gc.c:                ary8->elem.begin = elem_begin;
gc.c:                ary8->begin = begin;
gc.c:                    ary8->elem.begin = ary8->rebegin;
gc.c:                    ary8->begin = begin;
gc.c:                    gc_mark_push_remset(ptls, ary8->elem.parent, ary8->elem.nptr);
gc.c:        elem_begin = ary8->rebegin;
gc.c:    gc_mark_push_remset(ptls, ary8->elem.parent, ary8->elem.nptr);
gc.c:    (void)jl_assume(ary16 == (gc_mark_array16_t*)sp->data);
gc.c:    size_t elsize = ((jl_array_t*)ary16->elem.parent)->elsize / sizeof(jl_value_t*);
gc.c:                verify_parent2("array", ary16->elem.parent, slot, "elem(%d)",
gc.c:                               gc_slot_to_arrayidx(ary16->elem.parent, begin));
gc.c:            if (!gc_try_setmark(*pnew_obj, &ary16->elem.nptr, ptag, pbits))
gc.c:                ary16->elem.begin = elem_begin;
gc.c:                ary16->begin = begin;
gc.c:                    ary16->elem.begin = ary16->rebegin;
gc.c:                    ary16->begin = begin;
gc.c:                    gc_mark_push_remset(ptls, ary16->elem.parent, ary16->elem.nptr);
gc.c:        elem_begin = ary16->rebegin;
gc.c:    gc_mark_push_remset(ptls, ary16->elem.parent, ary16->elem.nptr);
gc.c:    (void)jl_assume(obj8 == (gc_mark_obj8_t*)sp->data);
gc.c:        if (!gc_try_setmark(*pnew_obj, &obj8->nptr, ptag, pbits))
gc.c:            obj8->begin = begin;
gc.c:            gc_mark_push_remset(ptls, obj8->parent, obj8->nptr);
gc.c:    gc_mark_push_remset(ptls, obj8->parent, obj8->nptr);
gc.c:    (void)jl_assume(obj16 == (gc_mark_obj16_t*)sp->data);
gc.c:        if (!gc_try_setmark(*pnew_obj, &obj16->nptr, ptag, pbits))
gc.c:            obj16->begin = begin;
gc.c:            gc_mark_push_remset(ptls, obj16->parent, obj16->nptr);
gc.c:    gc_mark_push_remset(ptls, obj16->parent, obj16->nptr);
gc.c:    (void)jl_assume(obj32 == (gc_mark_obj32_t*)sp->data);
gc.c:        if (!gc_try_setmark(*pnew_obj, &obj32->nptr, ptag, pbits))
gc.c:            obj32->begin = begin;
gc.c:            gc_mark_push_remset(ptls, obj32->parent, obj32->nptr);
gc.c:    gc_mark_push_remset(ptls, obj32->parent, obj32->nptr);
gc.c:// It uses an iterative (mostly) Depth-first search (DFS) to mark all the objects.
gc.c:// one (fixed-size) pc stack which stores the return address and one (variable-size)
gc.c:// 3. We can perform end-of-loop tail-call optimization for common cases.
gc.c://    in a well-defined format already.
gc.c:// The main disadvantages are that we bypass some stack-based CPU optimizations including the
gc.c:// As a general guide we do not want to make non-inlined function calls in this function
gc.c:    sp.pc--;
gc.c:        new_obj = obj->obj;
gc.c:        tag = obj->tag;
gc.c:        bits = obj->bits;
gc.c:        new_obj = obj->obj;
gc.c:        tag = obj->tag;
gc.c:        bits = obj->bits;
gc.c:    objary_begin = objary->begin;
gc.c:    objary_end = objary->end;
gc.c:    objary_begin = ary8->begin;
gc.c:    objary_end = ary8->end;
gc.c:    obj8_begin = ary8->elem.begin;
gc.c:    obj8_end = ary8->elem.end;
gc.c:    objary_begin = ary16->begin;
gc.c:    objary_end = ary16->end;
gc.c:    obj16_begin = ary16->elem.begin;
gc.c:    obj16_end = ary16->elem.end;
gc.c:    obj8_parent = (char*)obj8->parent;
gc.c:    obj8_begin = obj8->begin;
gc.c:    obj8_end = obj8->end;
gc.c:    obj16_parent = (char*)obj16->parent;
gc.c:    obj16_begin = obj16->begin;
gc.c:    obj16_end = obj16->end;
gc.c:        char *parent = (char*)obj32->parent;
gc.c:        uint32_t *begin = obj32->begin;
gc.c:        uint32_t *end = obj32->end;
gc.c:        jl_gcframe_t *s = stack->s;
gc.c:        uint32_t i = stack->i;
gc.c:        uint32_t nroots = stack->nroots;
gc.c:        uintptr_t offset = stack->offset;
gc.c:        uintptr_t lb = stack->lb;
gc.c:        uintptr_t ub = stack->ub;
gc.c:                    stack->i = i;
gc.c:                else if ((s = (jl_gcframe_t*)gc_read_stack(&s->prev, offset, lb, ub))) {
gc.c:                    stack->s = s;
gc.c:                    stack->i = 0;
gc.c:                    uintptr_t new_nroots = gc_read_stack(&s->nroots, offset, lb, ub);
gc.c:                    stack->nroots = (uint32_t)new_nroots;
gc.c:            s = (jl_gcframe_t*)gc_read_stack(&s->prev, offset, lb, ub);
gc.c:                stack->s = s;
gc.c:                uintptr_t new_nroots = gc_read_stack(&s->nroots, offset, lb, ub);
gc.c:                nroots = stack->nroots = (uint32_t)new_nroots;
gc.c:        jl_excstack_t *excstack = stackitr->s;
gc.c:        size_t itr = stackitr->itr;
gc.c:        size_t bt_index = stackitr->bt_index;
gc.c:        size_t jlval_index = stackitr->jlval_index;
gc.c:                // GC-managed values inside.
gc.c:                        stackitr->itr = itr;
gc.c:                        stackitr->bt_index = bt_index;
gc.c:                        stackitr->jlval_index = jlval_index;
gc.c:            // The exception comes last - mark it
gc.c:                stackitr->itr = itr;
gc.c:                stackitr->bt_index = bt_index;
gc.c:                stackitr->jlval_index = jlval_index;
gc.c:        jl_binding_t **begin = binding->begin;
gc.c:        jl_binding_t **end = binding->end;
gc.c:        uint8_t mbits = binding->bits;
gc.c:                uintptr_t tag = buf->header;
gc.c:            verify_parent1("module", binding->parent, &vb, "binding_buff");
gc.c:            jl_value_t *value = jl_atomic_load_relaxed(&b->value);
gc.c:            jl_value_t *globalref = jl_atomic_load_relaxed(&b->globalref);
gc.c:                verify_parent2("module", binding->parent,
gc.c:                               &b->value, "binding(%s)", jl_symbol_name(b->name));
gc.c:                if (gc_try_setmark(value, &binding->nptr, &tag, &bits)) {
gc.c:                    binding->begin = begin;
gc.c:                    if (gc_try_setmark(globalref, &binding->nptr, &gr_tag, &gr_bits)) {
gc.c:                        gc_mark_stack_push(&ptls->gc_cache, &sp, gc_mark_laddr(marked_obj),
gc.c:            if (gc_try_setmark(globalref, &binding->nptr, &tag, &bits)) {
gc.c:                binding->begin = begin;
gc.c:        jl_module_t *m = binding->parent;
gc.c:        int scanparent = gc_try_setmark((jl_value_t*)m->parent, &binding->nptr, &tag, &bits);
gc.c:        size_t nusings = m->usings.len;
gc.c:            objary_begin = (jl_value_t**)m->usings.items;
gc.c:            gc_mark_objarray_t data = {(jl_value_t*)m, objary_begin, objary_end, 1, binding->nptr};
gc.c:            gc_mark_stack_push(&ptls->gc_cache, &sp, gc_mark_laddr(objarray),
gc.c:            gc_mark_push_remset(ptls, (jl_value_t*)m, binding->nptr);
gc.c:            new_obj = (jl_value_t*)m->parent;
gc.c:        jl_value_t **begin = finlist->begin;
gc.c:        jl_value_t **end = finlist->end;
gc.c:                finlist->begin = begin;
gc.c:            gc_mark_stack_push(&ptls->gc_cache, &sp, gc_mark_laddr(objarray),
gc.c:        else if (vt->name == jl_array_typename) {
gc.c:            jl_array_flags_t flags = a->flags;
gc.c:                void *val_buf = jl_astaggedvalue((char*)a->data - a->offset * a->elsize);
gc.c:                gc_setmark_buf_(ptls, (char*)a->data - a->offset * a->elsize,
gc.c:                        ptls->gc_cache.perm_scanned_bytes += jl_array_nbytes(a);
gc.c:                        ptls->gc_cache.scanned_bytes += jl_array_nbytes(a);
gc.c:            if (a->data == NULL || jl_array_len(a) == 0)
gc.c:                objary_begin = (jl_value_t**)a->data;
gc.c:                gc_mark_stack_push(&ptls->gc_cache, &sp, gc_mark_laddr(objarray),
gc.c:                const jl_datatype_layout_t *layout = et->layout;
gc.c:                unsigned npointers = layout->npointers;
gc.c:                unsigned elsize = a->elsize / sizeof(jl_value_t*);
gc.c:                objary_begin = (jl_value_t**)a->data;
gc.c:                    objary_begin += layout->first_ptr;
gc.c:                    gc_mark_stack_push(&ptls->gc_cache, &sp, gc_mark_laddr(objarray),
gc.c:                else if (layout->fielddesc_type == 0) {
gc.c:                    gc_mark_stack_push(&ptls->gc_cache, &sp, gc_mark_laddr(array8),
gc.c:                else if (layout->fielddesc_type == 1) {
gc.c:                    gc_mark_stack_push(&ptls->gc_cache, &sp, gc_mark_laddr(array16),
gc.c:            jl_binding_t **table = (jl_binding_t**)m->bindings.table;
gc.c:            size_t bsize = m->bindings.size;
gc.c:            uintptr_t nptr = ((bsize + m->usings.len + 1) << 2) | (bits & GC_OLD);
gc.c:            gc_mark_stack_push(&ptls->gc_cache, &sp, gc_mark_laddr(module_binding),
gc.c:            void *stkbuf = ta->stkbuf;
gc.c:                int16_t tid = jl_atomic_load_relaxed(&ta->tid);
gc.c:                    (ta, tid != -1 && ta == jl_all_tls_states[tid]->root_task));
gc.c:            if (stkbuf && ta->copy_stack)
gc.c:                gc_setmark_buf_(ptls, stkbuf, bits, ta->bufsz);
gc.c:            jl_gcframe_t *s = ta->gcstack;
gc.c:            uintptr_t ub = (uintptr_t)-1;
gc.c:            if (stkbuf && ta->copy_stack && ta->ptls == NULL) {
gc.c:                int16_t tid = jl_atomic_load_relaxed(&ta->tid);
gc.c:                ub = (uintptr_t)ptls2->stackbase;
gc.c:                lb = ub - ta->copy_stack;
gc.c:                offset = (uintptr_t)stkbuf - lb;
gc.c:                nroots = gc_read_stack(&s->nroots, offset, lb, ub);
gc.c:                gc_mark_stack_push(&ptls->gc_cache, &sp, gc_mark_laddr(stack),
gc.c:            if (ta->excstack) {
gc.c:                gc_setmark_buf_(ptls, ta->excstack, bits, sizeof(jl_excstack_t) +
gc.c:                                sizeof(uintptr_t)*ta->excstack->reserved_size);
gc.c:                gc_mark_excstack_t stackdata = {ta->excstack, ta->excstack->top, 0, 0};
gc.c:                gc_mark_stack_push(&ptls->gc_cache, &sp, gc_mark_laddr(excstack),
gc.c:            const jl_datatype_layout_t *layout = jl_task_type->layout;
gc.c:            assert(layout->fielddesc_type == 0);
gc.c:            assert(layout->nfields > 0);
gc.c:            uint32_t npointers = layout->npointers;
gc.c:            gc_mark_stack_push(&ptls->gc_cache, &sp, gc_mark_laddr(obj8),
gc.c:            const jl_datatype_layout_t *layout = vt->layout;
gc.c:            uint32_t npointers = layout->npointers;
gc.c:            assert((layout->nfields > 0 || layout->fielddesc_type == 3) && "opaque types should have been handled specially");
gc.c:            if (layout->fielddesc_type == 0) {
gc.c:                gc_mark_stack_push(&ptls->gc_cache, &sp, gc_mark_laddr(obj8),
gc.c:            else if (layout->fielddesc_type == 1) {
gc.c:                gc_mark_stack_push(&ptls->gc_cache, &sp, gc_mark_laddr(obj16),
gc.c:            else if (layout->fielddesc_type == 2) {
gc.c:                gc_mark_stack_push(&ptls->gc_cache, &sp, gc_mark_laddr(obj32),
gc.c:                assert(layout->fielddesc_type == 3);
gc.c:                int old = jl_astaggedvalue(new_obj)->bits.gc & 2;
gc.c:                uintptr_t young = desc->markfunc(ptls, new_obj);
gc.c:    gc_mark_queue_obj(gc_cache, sp, ptls2->current_task);
gc.c:    gc_mark_queue_obj(gc_cache, sp, ptls2->root_task);
gc.c:    if (ptls2->next_task)
gc.c:        gc_mark_queue_obj(gc_cache, sp, ptls2->next_task);
gc.c:    if (ptls2->previous_task) // shouldn't be necessary, but no reason not to
gc.c:        gc_mark_queue_obj(gc_cache, sp, ptls2->previous_task);
gc.c:    if (ptls2->previous_exception)
gc.c:        gc_mark_queue_obj(gc_cache, sp, ptls2->previous_exception);
gc.c:    void **items = list->items;
gc.c:    size_t len = list->len;
gc.c:        int isfreed = !gc_marked(jl_astaggedvalue(v)->bits.gc);
gc.c:                     jl_astaggedvalue(v)->bits.gc == GC_OLD_MARKED &&
gc.c:                     jl_astaggedvalue(fin)->bits.gc == GC_OLD_MARKED);
gc.c:    list->len = j;
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    int prev = !ptls->disable_gc;
gc.c:    ptls->disable_gc = (on == 0);
gc.c:        // disable -> enable
gc.c:        if (jl_atomic_fetch_add(&jl_gc_disable_counter, -1) == 1) {
gc.c:        // enable -> disable
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    return !ptls->disable_gc;
gc.c:    return newtb - oldtb;
gc.c:    last_gc_total_bytes = newtb - offset;
gc.c:    return newtb - oldtb;
gc.c:    arraylist_t *remset = ptls2->heap.remset;
gc.c:    ptls2->heap.remset = ptls2->heap.last_remset;
gc.c:    ptls2->heap.last_remset = remset;
gc.c:    ptls2->heap.remset->len = 0;
gc.c:    ptls2->heap.remset_nptr = 0;
gc.c:    size_t len = remset->len;
gc.c:    void **items = remset->items;
gc.c:        jl_astaggedvalue(item)->bits.gc = GC_OLD_MARKED;
gc.c:    len = ptls2->heap.rem_bindings.len;
gc.c:    items = ptls2->heap.rem_bindings.items;
gc.c:        jl_astaggedvalue(ptr)->bits.gc = GC_OLD_MARKED;
gc.c:    size_t len = ptls2->heap.last_remset->len;
gc.c:    void **items = ptls2->heap.last_remset->items;
gc.c:    len = ptls2->heap.rem_bindings.len;
gc.c:    items = ptls2->heap.rem_bindings.items;
gc.c:        jl_value_t *v = jl_atomic_load_relaxed(&ptr->value);
gc.c:    ptls2->heap.rem_bindings.len = n_bnd_refyoung;
gc.c:    jl_bt_element_t *bt_data = ptls2->bt_data;
gc.c:    size_t bt_size = ptls2->bt_size;
gc.c:    jl_gc_mark_cache_t *gc_cache = &ptls->gc_cache;
gc.c:        sweep_finalizer_list(&ptls2->finalizers);
gc.c:        gc_mark_queue_finlist(gc_cache, &sp, &ptls2->finalizers, 0);
gc.c:    int64_t estimate_freed = live_sz_ub - live_sz_est;
gc.c:        promoted_bytes += perm_scanned_bytes - last_perm_scanned_bytes;
gc.c:        nptr += jl_all_tls_states[i]->heap.remset_nptr;
gc.c:            for (int i = 0; i < ptls2->heap.remset->len; i++) {
gc.c:                jl_astaggedvalue(ptls2->heap.remset->items[i])->bits.gc = GC_MARKED;
gc.c:            for (int i = 0; i < ptls2->heap.rem_bindings.len; i++) {
gc.c:                void *ptr = ptls2->heap.rem_bindings.items[i];
gc.c:                jl_astaggedvalue(ptr)->bits.gc = GC_MARKED;
gc.c:            ptls2->heap.remset->len = 0;
gc.c:            ptls2->heap.rem_bindings.len = 0;
gc.c:        // of about 20-25%
gc.c:    uint64_t pause = gc_end_t - t0;
gc.c:    live_bytes += -gc_num.freed + gc_num.since_sweep;
gc.c:    jl_ptls_t ptls = ct->ptls;
gc.c:        size_t localbytes = jl_atomic_load_relaxed(&ptls->gc_num.allocd) + gc_num.interval;
gc.c:        jl_atomic_store_relaxed(&ptls->gc_num.allocd, -(int64_t)gc_num.interval);
gc.c:    int8_t old_state = jl_atomic_load_relaxed(&ptls->gc_state);
gc.c:    jl_atomic_store_release(&ptls->gc_state, JL_GC_STATE_WAITING);
gc.c:    // no-op for non-threading
gc.c:    // no-op for non-threading
gc.c:    if (!ptls->finalizers_inhibited && ptls->locks.len == 0) {
gc.c:        int8_t was_in_finalizer = ptls->in_finalizer;
gc.c:        ptls->in_finalizer = 1;
gc.c:        ptls->in_finalizer = was_in_finalizer;
gc.c:    jl_gc_mark_cache_t *gc_cache = &ptls->gc_cache;
gc.c:// Per-thread initialization
gc.c:    if (ptls->tid == 0)
gc.c:        ptls->disable_gc = 1;
gc.c:    jl_thread_heap_t *heap = &ptls->heap;
gc.c:    jl_gc_pool_t *p = heap->norm_pools;
gc.c:    arraylist_new(&heap->weak_refs, 0);
gc.c:    arraylist_new(&heap->live_tasks, 0);
gc.c:    heap->mallocarrays = NULL;
gc.c:    heap->mafreelist = NULL;
gc.c:    heap->big_objects = NULL;
gc.c:    arraylist_new(&heap->rem_bindings, 0);
gc.c:    heap->remset = &heap->_remset[0];
gc.c:    heap->last_remset = &heap->_remset[1];
gc.c:    arraylist_new(heap->remset, 0);
gc.c:    arraylist_new(heap->last_remset, 0);
gc.c:    arraylist_new(&ptls->finalizers, 0);
gc.c:    arraylist_new(&ptls->sweep_objs, 0);
gc.c:    jl_gc_mark_cache_t *gc_cache = &ptls->gc_cache;
gc.c:    gc_cache->perm_scanned_bytes = 0;
gc.c:    gc_cache->scanned_bytes = 0;
gc.c:    gc_cache->nbig_obj = 0;
gc.c:    JL_MUTEX_INIT(&gc_cache->stack_lock);
gc.c:    gc_cache->pc_stack = (void**)malloc_s(init_size * sizeof(void*));
gc.c:    gc_cache->pc_stack_end = gc_cache->pc_stack + init_size;
gc.c:    gc_cache->data_stack = (jl_gc_mark_data_t *)malloc_s(init_size * sizeof(jl_gc_mark_data_t));
gc.c:    memset(&ptls->gc_num, 0, sizeof(ptls->gc_num));
gc.c:    jl_atomic_store_relaxed(&ptls->gc_num.allocd, -(int64_t)gc_num.interval);
gc.c:// System-wide initializations
gc.c:    if (pgcstack && ct->world_age) {
gc.c:        jl_ptls_t ptls = ct->ptls;
gc.c:        jl_atomic_store_relaxed(&ptls->gc_num.allocd,
gc.c:            jl_atomic_load_relaxed(&ptls->gc_num.allocd) + sz);
gc.c:        jl_atomic_store_relaxed(&ptls->gc_num.malloc,
gc.c:            jl_atomic_load_relaxed(&ptls->gc_num.malloc) + 1);
gc.c:    if (pgcstack && ct->world_age) {
gc.c:        jl_ptls_t ptls = ct->ptls;
gc.c:        jl_atomic_store_relaxed(&ptls->gc_num.allocd,
gc.c:            jl_atomic_load_relaxed(&ptls->gc_num.allocd) + nm*sz);
gc.c:        jl_atomic_store_relaxed(&ptls->gc_num.malloc,
gc.c:            jl_atomic_load_relaxed(&ptls->gc_num.malloc) + 1);
gc.c:    if (pgcstack && ct->world_age) {
gc.c:        jl_ptls_t ptls = ct->ptls;
gc.c:        jl_atomic_store_relaxed(&ptls->gc_num.freed,
gc.c:            jl_atomic_load_relaxed(&ptls->gc_num.freed) + sz);
gc.c:        jl_atomic_store_relaxed(&ptls->gc_num.freecall,
gc.c:            jl_atomic_load_relaxed(&ptls->gc_num.freecall) + 1);
gc.c:    if (pgcstack && ct->world_age) {
gc.c:        jl_ptls_t ptls = ct->ptls;
gc.c:            jl_atomic_store_relaxed(&ptls->gc_num.freed,
gc.c:                jl_atomic_load_relaxed(&ptls->gc_num.freed) + (old - sz));
gc.c:            jl_atomic_store_relaxed(&ptls->gc_num.allocd,
gc.c:                jl_atomic_load_relaxed(&ptls->gc_num.allocd) + (sz - old));
gc.c:        jl_atomic_store_relaxed(&ptls->gc_num.realloc,
gc.c:            jl_atomic_load_relaxed(&ptls->gc_num.realloc) + 1);
gc.c:// jl_gc_counted_* functions with a libc-compatible API.
gc.c:        int64_t *pp = (int64_t *)p - 2;
gc.c:        pp = (int64_t *)p - 2;
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    jl_atomic_store_relaxed(&ptls->gc_num.allocd,
gc.c:        jl_atomic_load_relaxed(&ptls->gc_num.allocd) + allocsz);
gc.c:    jl_atomic_store_relaxed(&ptls->gc_num.malloc,
gc.c:        jl_atomic_load_relaxed(&ptls->gc_num.malloc) + 1);
gc.c:    if (jl_astaggedvalue(owner)->bits.gc == GC_OLD_MARKED) {
gc.c:        ptls->gc_cache.perm_scanned_bytes += allocsz - oldsz;
gc.c:        live_bytes += allocsz - oldsz;
gc.c:        jl_atomic_store_relaxed(&ptls->gc_num.freed,
gc.c:            jl_atomic_load_relaxed(&ptls->gc_num.freed) + (oldsz - allocsz));
gc.c:        jl_atomic_store_relaxed(&ptls->gc_num.allocd,
gc.c:            jl_atomic_load_relaxed(&ptls->gc_num.allocd) + (allocsz - oldsz));
gc.c:    jl_atomic_store_relaxed(&ptls->gc_num.realloc,
gc.c:        jl_atomic_load_relaxed(&ptls->gc_num.realloc) + 1);
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:        gc_marked(v->bits.gc)) {
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    newbig->sz = allocsz;
gc.c:    newbig->age = 0;
gc.c:    gc_big_object_link(newbig, &ptls->heap.big_objects);
gc.c:    jl_value_t *snew = jl_valueof(&newbig->header);
gc.c:        sz += align - 1;
gc.c:    unsigned diff = (offset - base) % align;
gc.c:    uintptr_t pool = LLT_ALIGN(gc_perm_pool + offset, (uintptr_t)align) - offset;
gc.c:                      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc.c:    p = (char *) p - 1;
gc.c:    if (meta && meta->ages) {
gc.c:        size_t off = (char *)p - page;
gc.c:        size_t off2 = (off - GC_PAGE_OFFSET);
gc.c:        size_t osize = meta->osize;
gc.c:        if (off - off2 + osize > GC_PAGE_SZ)
gc.c:        jl_taggedvalue_t *cell = (jl_taggedvalue_t *)((char *)p - off2);
gc.c:        // 2. We are on a page where objects are currently bump-allocated
gc.c:        //    from the corresponding pool->newpages list.
gc.c:        if (meta->nfree == 0) {
gc.c:            jl_all_tls_states[meta->thread_n]->heap.norm_pools +
gc.c:            meta->pool_n;
gc.c:        if (meta->fl_begin_offset == (uint16_t) -1) {
gc.c:            jl_taggedvalue_t *newpages = pool->newpages;
gc.c:            if (data != meta->data) {
gc.c:        if (cell->bits.gc)
gc.c:        //   pool->freelist will point to the current page; any cell with
gc.c:        unsigned obj_id = (off - off2) / osize;
gc.c:        if (gc_page_data(cell) == gc_page_data(pool->freelist)
gc.c:            && (char *)cell < (char *)pool->freelist)
gc.c:        if (!(meta->ages[obj_id / 8] & (1 << (obj_id % 8)))) {
gc.c:        if ((cell->header & ~(uintptr_t) 3) == jl_buff_tag)
gc.c:    arraylist_push(&ptls->sweep_objs, obj);
sys.c:#include <mach-o/dyld.h>
sys.c:#include <mach-o/nlist.h>
sys.c:        return -1;
sys.c:JL_DLLEXPORT long jl_ios_fd(ios_t *s) { return s->fd; }
sys.c:    return (int32_t)(s->size - s->bpos);
sys.c:// --- dir/file stuff ---
sys.c:JL_DLLEXPORT char *jl_uv_fs_t_ptr(uv_fs_t *req) { return (char*)req->ptr; }
sys.c:JL_DLLEXPORT char *jl_uv_fs_t_path(uv_fs_t *req) { return (char*)req->path; }
sys.c:// --- stat ---
sys.c:    return ((uv_stat_t*)statbuf)->st_dev;
sys.c:    return ((uv_stat_t*)statbuf)->st_ino;
sys.c:    return ((uv_stat_t*)statbuf)->st_mode;
sys.c:    return ((uv_stat_t*)statbuf)->st_nlink;
sys.c:    return ((uv_stat_t*)statbuf)->st_uid;
sys.c:    return ((uv_stat_t*)statbuf)->st_gid;
sys.c:    return ((uv_stat_t*)statbuf)->st_rdev;
sys.c:    return ((uv_stat_t*)statbuf)->st_size;
sys.c:    return ((uv_stat_t*)statbuf)->st_blksize;
sys.c:    return ((uv_stat_t*)statbuf)->st_blocks;
sys.c:  return (double)s->st_atim.tv_sec + (double)s->st_atim.tv_nsec * 1e-9;
sys.c:    return (double)s->st_mtim.tv_sec + (double)s->st_mtim.tv_nsec * 1e-9;
sys.c:    return (double)s->st_ctim.tv_sec + (double)s->st_ctim.tv_nsec * 1e-9;
sys.c:    return -1;
sys.c:    return -1;
sys.c:    return -r;
sys.c:  pwd->username = (char*)malloc(name_size +
sys.c:  if (pwd->username == NULL) {
sys.c:  memcpy(pwd->username, pw.pw_name, name_size);
sys.c:  pwd->homedir = pwd->username + name_size;
sys.c:  memcpy(pwd->homedir, pw.pw_dir, homedir_size);
sys.c:  pwd->shell = pwd->homedir + homedir_size;
sys.c:  memcpy(pwd->shell, pw.pw_shell, shell_size);
sys.c:  pwd->gecos = NULL;  /* pw_gecos does not exist on zOS. */
sys.c:    pwd->gecos = NULL;
sys.c:    pwd->gecos = pwd->shell + shell_size;
sys.c:    memcpy(pwd->gecos, pw.pw_gecos, gecos_size);
sys.c:  pwd->uid = pw.pw_uid;
sys.c:  pwd->gid = pw.pw_gid;
sys.c:    return -r;
sys.c:  grp->members = (char**) gr_mem;
sys.c:  grp->members[members] = NULL;
sys.c:    grp->members[r] = gr_mem;
sys.c:  assert(gr_mem == (char*)grp->members + mem_size);
sys.c:  grp->groupname = gr_mem;
sys.c:  memcpy(grp->groupname, gp.gr_name, name_size);
sys.c:  grp->gid = gp.gr_gid;
sys.c:    pointer is stored in grp->members, so that is the only field that needs
sys.c:  free(grp->members);
sys.c:  grp->members = NULL;
sys.c:  grp->groupname = NULL;
sys.c:// --- buffer manipulation ---
sys.c:    if (s->buf == &s->local[0]) {
sys.c:        a = jl_pchar_to_array(s->buf, s->size);
sys.c:        a = jl_ptr_to_array_1d(jl_array_uint8_type, b, n-1, 1);
sys.c://   0 - keep delimiter
sys.c://   1 - remove 1 byte delimiter
sys.c://   2 - remove 2 bytes \r\n if present
sys.c:    char *pd = (char*)memchr(s->buf + s->bpos, delim, (size_t)(s->size - s->bpos));
sys.c:        size_t n = pd - (s->buf + s->bpos) + 1;
sys.c:            jl_value_t *str = jl_pchar_to_string(s->buf + s->bpos, n - nchomp);
sys.c:            s->bpos += n;
sys.c:        a = jl_alloc_array_1d(jl_array_uint8_type, n - nchomp);
sys.c:        memcpy(jl_array_data(a), s->buf + s->bpos, n - nchomp);
sys.c:        s->bpos += n;
sys.c:        ios_setbuf(&dest, (char*)a->data, 80, 0);
sys.c:        if (chomp && n > 0 && dest.buf[n - 1] == delim) {
sys.c:            n--;
sys.c:            if (chomp == 2 && n > 0 && dest.buf[n - 1] == '\r') {
sys.c:                n--;
sys.c:        if (dest.buf != a->data) {
sys.c:            a->length = n;
sys.c:            a->nrows = n;
sys.c:            ((char*)a->data)[n] = '\0';
sys.c:        space = (size_t)(s->size - s->bpos);
sys.c:    uint8_t *buf = (uint8_t*)&s->buf[s->bpos];
sys.c:    s->bpos += n;
sys.c:// -- syscall utilities --
sys.c:// -- get the number of CPU threads (logical cores) --
sys.c:            count -= 4;
sys.c:// -- high resolution timers --
sys.c:// -- iterating the environment --
sys.c:// -- child process status --
sys.c:// -- access to std filehandles --
sys.c:// -- processor native alignment information --
sys.c:// -- misc sysconf info --
sys.c:    assert(page_size != -1);
sys.c:    for (int32_t i = _dyld_image_count() - 1; i >= 0 ; i--) {
sys.c:        if (((intptr_t)handle & (-4)) == ((intptr_t)probe_lib & (-4)))
sys.c:    DWORD n8 = WideCharToMultiByte(CP_UTF8, 0, pth16, -1, NULL, 0, NULL, NULL);
sys.c:    if (!WideCharToMultiByte(CP_UTF8, 0, pth16, -1, filepath, n8, NULL, NULL)) {
sys.c:        __msan_unpoison_string(map->l_name);
sys.c:        return map->l_name;
sys.c:        jl_array_ptr_set(list, jl_array_dim0(list) - 1, v);
llvm-muladd.cpp:#include "llvm-version.h"
llvm-muladd.cpp:#include <llvm-c/Core.h>
llvm-muladd.cpp:#include <llvm-c/Types.h>
llvm-muladd.cpp:    if (!mulOp || mulOp->getOpcode() != Instruction::FMul)
llvm-muladd.cpp:    if (!mulOp->hasOneUse())
llvm-muladd.cpp:    auto fmf = mulOp->getFastMathFlags();
llvm-muladd.cpp:    mulOp->copyFastMathFlags(fmf);
llvm-muladd.cpp:    unwrap(PM)->add(createCombineMulAddPass());
getopt.h:/* This file is adapted from musl-libc
getopt.h:----------------------------------------------------------------------
getopt.h:Copyright  2005-2014 Rich Felker, et al.
getopt.h:----------------------------------------------------------------------
jitlayers.cpp:#include "llvm-version.h"
jitlayers.cpp:    Constant *P = literal_static_pointer_val(addr, GV->getValueType());
jitlayers.cpp:    GV->setInitializer(P);
jitlayers.cpp:        llvm::StringRef ref = GV->getName();
jitlayers.cpp:        // emit external non-const symbol to avoid LLVM optimizing the code
jitlayers.cpp:        // similar to non-imaging mode.
jitlayers.cpp:        GV->setLinkage(GlobalValue::ExternalLinkage);
jitlayers.cpp:        GV->setConstant(true);
jitlayers.cpp:        GV->setLinkage(GlobalValue::PrivateLinkage);
jitlayers.cpp:        GV->setUnnamedAddr(GlobalValue::UnnamedAddr::Global);
jitlayers.cpp:    assert(codeinst->min_world <= world && (codeinst->max_world >= world || codeinst->max_world == 0) &&
jitlayers.cpp:        "invalid world for method-instance");
jitlayers.cpp:            NewGlobals[global.second->getName()] = global.first;
jitlayers.cpp:            for (auto &F : M->global_objects()) {
jitlayers.cpp:            for (auto &GV : M->globals()) {
jitlayers.cpp:                    jl_link_global(&GV, InitValue->second);
jitlayers.cpp:        if (this_code->invoke == NULL) {
jitlayers.cpp:            // once set, don't change invoke-ptr, as that leads to race conditions
jitlayers.cpp:                jl_atomic_store_release(&this_code->specptr.fptr, (void*)getAddressForFunction(decls.specFunctionObject));
jitlayers.cpp:                this_code->isspecsig = isspecsig;
jitlayers.cpp:            jl_atomic_store_release(&this_code->invoke, addr);
jitlayers.cpp:        else if (this_code->invoke == jl_fptr_const_return_addr && !decls.specFunctionObject.empty()) {
jitlayers.cpp:            jl_atomic_store_release(&this_code->specptr.fptr, (void*)getAddressForFunction(decls.specFunctionObject));
jitlayers.cpp:    // then dump the method-instance specialization type to the stream
jitlayers.cpp:    jl_method_instance_t *mi = codeinst->def;
jitlayers.cpp:    if (jl_is_method(mi->def.method)) {
jitlayers.cpp:            if (!jl_has_free_typevars(mi->specTypes)) {
jitlayers.cpp:                jl_static_show(s_precompile, mi->specTypes);
jitlayers.cpp:            jl_printf(dump_compiles_stream, "%" PRIu64 "\t\"", end_time - start_time);
jitlayers.cpp:            jl_static_show(dump_compiles_stream, mi->specTypes);
jitlayers.cpp:// compile a C-callable alias
jitlayers.cpp:        if (jl_ExecutionEngine->getGlobalValueAddress(name)) {
jitlayers.cpp:        jl_atomic_fetch_add_relaxed(&jl_cumulative_compile_time, (jl_hrtime() - compiler_start_time));
jitlayers.cpp:// declare a C-callable entry point; called during code loading from the toplevel
jitlayers.cpp:    if (!jl_is_datatype(ft) || ft->instance == NULL)
jitlayers.cpp:    jl_method_t *meth = (jl_method_t*)jl_methtable_lookup(ft->name->mt, (jl_value_t*)sigt, jl_world_counter);
jitlayers.cpp:    meth->ccallable = jl_svec2(declrt, (jl_value_t*)sigt);
jitlayers.cpp:    jl_gc_wb(meth, meth->ccallable);
jitlayers.cpp:        src = (jl_code_info_t*)codeinst->inferred;
jitlayers.cpp:        else if (jl_is_method(mi->def.method))
jitlayers.cpp:            src = jl_uncompress_ir(mi->def.method, codeinst, (jl_array_t*)src);
jitlayers.cpp:    if (src == NULL && jl_is_method(mi->def.method) &&
jitlayers.cpp:             jl_symbol_name(mi->def.method->name)[0] != '@') {
jitlayers.cpp:            codeinst = jl_get_method_inferred(mi, src->rettype, src->min_world, src->max_world);
jitlayers.cpp:            if (src->inferred && !codeinst->inferred)
jitlayers.cpp:                codeinst->inferred = jl_nothing;
jitlayers.cpp:        if (codeinst->invoke == NULL)
jitlayers.cpp:        jl_atomic_fetch_add_relaxed(&jl_cumulative_compile_time, (jl_hrtime() - compiler_start_time));
jitlayers.cpp:    if (jl_atomic_load_relaxed(&unspec->invoke) != NULL) {
jitlayers.cpp:    if (unspec->invoke == NULL) {
jitlayers.cpp:        jl_method_t *def = unspec->def->def.method;
jitlayers.cpp:            src = (jl_code_info_t*)def->source;
jitlayers.cpp:                assert(def->generator);
jitlayers.cpp:                src = jl_code_for_staged(unspec->def);
jitlayers.cpp:            src = (jl_code_info_t*)unspec->def->uninferred;
jitlayers.cpp:        _jl_compile_codeinst(unspec, src, unspec->min_world);
jitlayers.cpp:        if (unspec->invoke == NULL) {
jitlayers.cpp:            jl_atomic_store_release(&unspec->invoke, jl_fptr_interpret_call_addr);
jitlayers.cpp:        jl_atomic_fetch_add_relaxed(&jl_cumulative_compile_time, (jl_hrtime() - compiler_start_time));
jitlayers.cpp:        uintptr_t fptr = (uintptr_t)jl_atomic_load_relaxed(&codeinst->invoke);
jitlayers.cpp:        uintptr_t specfptr = (uintptr_t)jl_atomic_load_relaxed(&codeinst->specptr.fptr);
jitlayers.cpp:            specfptr = (uintptr_t)jl_atomic_load_relaxed(&codeinst->specptr.fptr);
jitlayers.cpp:                jl_method_t *def = mi->def.method;
jitlayers.cpp:                        src = def->generator ? jl_code_for_staged(mi) : (jl_code_info_t*)def->source;
jitlayers.cpp:                        src = jl_uncompress_ir(mi->def.method, codeinst, (jl_array_t*)src);
jitlayers.cpp:                fptr = (uintptr_t)jl_atomic_load_relaxed(&codeinst->invoke);
jitlayers.cpp:                specfptr = (uintptr_t)jl_atomic_load_relaxed(&codeinst->specptr.fptr);
jitlayers.cpp:                        specfptr = (uintptr_t)jl_atomic_load_relaxed(&codeinst->specptr.fptr);
jitlayers.cpp:                jl_atomic_fetch_add_relaxed(&jl_cumulative_compile_time, (jl_hrtime() - compiler_start_time));
jitlayers.cpp:    // whatever, that didn't work - use the assembler output instead
jitlayers.cpp:        return MemMgr->allocateCodeSection(Size, Alignment, SectionID, SectionName);
jitlayers.cpp:        return MemMgr->allocateDataSection(Size, Alignment, SectionID, SectionName, IsReadOnly);
jitlayers.cpp:        return MemMgr->reserveAllocationSpace(CodeSize, CodeAlign, RODataSize, RODataAlign, RWDataSize, RWDataAlign);
jitlayers.cpp:        return MemMgr->needsToReserveAllocationSpace();
jitlayers.cpp:        return MemMgr->registerEHFrames(Addr, LoadAddr, Size);
jitlayers.cpp:        return MemMgr->deregisterEHFrames();
jitlayers.cpp:        return MemMgr->finalizeMemory(ErrMsg);
jitlayers.cpp:        return MemMgr->notifyObjectLoaded(RTDyld, Obj);
jitlayers.cpp:        jl_printf(dump_llvm_opt_stream, "- \n");
jitlayers.cpp:                Attribute attr = F.getFnAttribute("julia-optimization-level");
jitlayers.cpp:                    int ol = (int)val[0] - '0';
jitlayers.cpp:    auto Obj = object::ObjectFile::createObjectFile(ObjBuffer->getMemBufferRef());
jitlayers.cpp:        jl_printf(dump_llvm_opt_stream, "  time_ns: %" PRIu64 "\n", end_time - start_time);
jitlayers.cpp:    // Resolve non-lock free atomic functions in the libatomic1 library.
jitlayers.cpp:        "libatomic-1.dll";
jitlayers.cpp:    for (auto &F : M->global_values()) {
jitlayers.cpp:    for (Module::global_object_iterator I = M->global_objects().begin(), E = M->global_objects().end(); I != E; ) {
jitlayers.cpp:        if (F->isDeclaration()) {
jitlayers.cpp:            if (F->use_empty())
jitlayers.cpp:                F->eraseFromParent();
jitlayers.cpp:                       findUnmangledSymbol(F->getName()) ||
jitlayers.cpp:                           getMangledName(F->getName())))) {
jitlayers.cpp:                             << "Symbol \"" << F->getName().str() << "\""
jitlayers.cpp:    if (fname->empty()) {
jitlayers.cpp:        jl_callptr_t invoke = jl_atomic_load_relaxed(&codeinst->invoke);
jitlayers.cpp:        const char* unadorned_name = jl_symbol_name(codeinst->def->def.method->name);
jitlayers.cpp:    this->ObjectLayer.registerJITEventListener(*L);
jitlayers.cpp:        Listener->notifyObjectLoaded(Key, Obj, LoadedObjectInfo);
jitlayers.cpp:    return getMangledName(GV->getName());
jitlayers.cpp:// and that there is no module-level assembly
jitlayers.cpp:    for (Module::global_iterator I = src->global_begin(), E = src->global_end(); I != E;) {
jitlayers.cpp:        GlobalVariable *dG = cast_or_null<GlobalVariable>(dest->getNamedValue(sG->getName()));
jitlayers.cpp:            if (sG->isDeclaration()) {
jitlayers.cpp:                sG->replaceAllUsesWith(dG);
jitlayers.cpp:                sG->eraseFromParent();
jitlayers.cpp:            //else if (!dG->isDeclaration() && dG->hasAppendingLinkage() && sG->hasAppendingLinkage()) {
jitlayers.cpp:            //    auto *dCA = cast<ConstantArray>(dG->getInitializer());
jitlayers.cpp:            //    auto *sCA = cast<ConstantArray>(sG->getInitializer());
jitlayers.cpp:            //    for (auto &Op : dCA->operands())
jitlayers.cpp:            //    for (auto &Op : sCA->operands())
jitlayers.cpp:            //    GlobalVariable *GV = new GlobalVariable(dest, ATy, dG->isConstant(),
jitlayers.cpp:            //            dG->getThreadLocalMode(), dG->getType()->getAddressSpace());
jitlayers.cpp:            //    GV->copyAttributesFrom(dG);
jitlayers.cpp:            //    sG->replaceAllUsesWith(GV);
jitlayers.cpp:            //    dG->replaceAllUsesWith(GV);
jitlayers.cpp:            //    GV->takeName(sG);
jitlayers.cpp:            //    sG->eraseFromParent();
jitlayers.cpp:            //    dG->eraseFromParent();
jitlayers.cpp:                assert(dG->isDeclaration() || dG->getInitializer() == sG->getInitializer());
jitlayers.cpp:                dG->replaceAllUsesWith(sG);
jitlayers.cpp:                dG->eraseFromParent();
jitlayers.cpp:        sG->removeFromParent();
jitlayers.cpp:        dest->getGlobalList().push_back(sG);
jitlayers.cpp:        sG->setComdat(nullptr);
jitlayers.cpp:    for (Module::iterator I = src->begin(), E = src->end(); I != E;) {
jitlayers.cpp:        Function *dG = cast_or_null<Function>(dest->getNamedValue(sG->getName()));
jitlayers.cpp:            if (sG->isDeclaration()) {
jitlayers.cpp:                sG->replaceAllUsesWith(dG);
jitlayers.cpp:                sG->eraseFromParent();
jitlayers.cpp:                assert(dG->isDeclaration());
jitlayers.cpp:                dG->replaceAllUsesWith(sG);
jitlayers.cpp:                dG->eraseFromParent();
jitlayers.cpp:        sG->removeFromParent();
jitlayers.cpp:        dest->getFunctionList().push_back(sG);
jitlayers.cpp:        sG->setComdat(nullptr);
jitlayers.cpp:    for (Module::alias_iterator I = src->alias_begin(), E = src->alias_end(); I != E;) {
jitlayers.cpp:        GlobalAlias *dG = cast_or_null<GlobalAlias>(dest->getNamedValue(sG->getName()));
jitlayers.cpp:            if (!dG->isDeclaration()) { // aliases are always definitions, so this test is reversed from the above two
jitlayers.cpp:                sG->replaceAllUsesWith(dG);
jitlayers.cpp:                sG->eraseFromParent();
jitlayers.cpp:                dG->replaceAllUsesWith(sG);
jitlayers.cpp:                dG->eraseFromParent();
jitlayers.cpp:        sG->removeFromParent();
jitlayers.cpp:        dest->getAliasList().push_back(sG);
jitlayers.cpp:    NamedMDNode *sNMD = src->getNamedMetadata("llvm.dbg.cu");
jitlayers.cpp:        NamedMDNode *dNMD = dest->getOrInsertNamedMetadata("llvm.dbg.cu");
jitlayers.cpp:        for (NamedMDNode::op_iterator I = sNMD->op_begin(), E = sNMD->op_end(); I != E; ++I) {
jitlayers.cpp:            dNMD->addOperand(*I);
jitlayers.cpp:        StringRef data = CDS->getRawDataValues();
jitlayers.cpp:        GV->eraseFromParent();
jitlayers.cpp:    Type *T_uint32 = Type::getInt32Ty(m->getContext());
jitlayers.cpp:    ArrayType *atype = ArrayType::get(T_uint32, 3); // want 4-byte alignment of 12-bytes of data
jitlayers.cpp:    gvs[0]->setSection(".text");
jitlayers.cpp:    gvs[1]->setSection(".text");
jitlayers.cpp:    jl_ExecutionEngine->addModule(std::move(m));
jitlayers.cpp:    // DAG-sort (post-dominator) the compile to compute the minimum
jitlayers.cpp:    // merge-module sets for linkage
jitlayers.cpp:    // Compute the cycle-id
jitlayers.cpp:    for (auto &F : M->global_objects()) {
jitlayers.cpp:                auto &CM = Callee->second;
jitlayers.cpp:        for (auto &CM : ToMerge.at(depth - 1)) {
jitlayers.cpp:            assert(Queued.find(CM->get())->second == depth);
jitlayers.cpp:            Queued.erase(CM->get());
jitlayers.cpp:        auto &Top = ToMerge.at(MergeUp - 1);
jitlayers.cpp:        for (auto &CM : ToMerge.at(depth - 1)) {
jitlayers.cpp:            assert(Queued.find(CM->get())->second == depth);
jitlayers.cpp:            Queued[CM->get()] = MergeUp;
jitlayers.cpp:    auto addr = jl_ExecutionEngine->getFunctionAddress(fname);
jitlayers.cpp:    jl_ExecutionEngine->addGlobalMapping(name, (uint64_t)(uintptr_t)addr);
jitlayers.cpp:    return jl_ExecutionEngine->getTotalBytes();
support/htable.c:        h->size = size = HT_N_INLINE;
support/htable.c:        h->table = &h->_space[0];
support/htable.c:        h->size = size;
support/htable.c:        h->table = (void**)LLT_ALLOC(size * sizeof(void*));
support/htable.c:    if (h->table == NULL)
support/htable.c:        h->table[i] = HT_NOTFOUND;
support/htable.c:    if (h->table != &h->_space[0])
support/htable.c:        LLT_FREE(h->table);
support/htable.c:    if (h->size > sz * 4 && h->size > HT_N_INLINE) {
support/htable.c:        LLT_FREE(h->table);
support/htable.c:        h->table = NULL;
support/htable.c:        size_t i, hsz = h->size;
support/htable.c:            h->table[i] = HT_NOTFOUND;
support/libsupportinit.c:                    rl.rlim_cur = min + (max - min) / 2;
support/libsupportinit.c:        // but use locale-independent numeric formats (for parsing)
support/libsupportinit.c:        // and try to specify ASCII or UTF-8 (preferred) for our Libc and Cstring functions
support/libsupportinit.c:            size_t codeset = jl_strchrnul(ctype, '.') - ctype;
support/libsupportinit.c:            if (strncmp(ctype + codeset, ".UTF-8", strlen(".UTF-8")) == 0 ||
support/libsupportinit.c:                strncmp(ctype + codeset, ".utf-8", strlen(".utf-8")) == 0 ||
support/libsupportinit.c:                return; // already UTF-8
support/libsupportinit.c:            ctype = (char*)memcpy(malloc_s(codeset + sizeof(".UTF-8")), ctype, codeset);
support/libsupportinit.c:            strcpy(ctype + codeset, ".UTF-8");
support/libsupportinit.c:        if (setlocale(LC_CTYPE, "C.UTF-8") == NULL && // Linux/FreeBSD name
support/libsupportinit.c:            setlocale(LC_CTYPE, "en_US.UTF-8") == NULL && // Common name
support/libsupportinit.c:            setlocale(LC_CTYPE, "UTF-8") == NULL && // Apple name
support/libsupportinit.c:            ios_puts("WARNING: failed to select UTF-8 encoding, using ASCII\n", ios_stderr);
support/dtypes.h:  - supports integer word sizes of 8, 16, 32, and 64 bits
support/dtypes.h:  - uses unsigned and signed 2's complement representations
support/dtypes.h:  - all pointer types are the same size
support/dtypes.h:  - there is an integer type with the same size as a pointer
support/dtypes.h:  - IEEE 754 single- and double-precision floating point
support/dtypes.h:  We assume the LP64 convention for 64-bit platforms.
support/dtypes.h:    val -= 1;
support/dtypes.h:#define LLT_ALIGN(x, sz) (((x) + (sz)-1) & ~((sz)-1))
support/dtypes.h:#define S64_MIN    (-S64_MAX - 1LL)
support/dtypes.h:#define S32_MIN    (-S32_MAX - 1L)
support/dtypes.h:#define D_NNAN ((double)-NAN)
support/dtypes.h:#define D_NINF ((double)-INFINITY)
support/dtypes.h:#define F_NNAN ((float)-NAN)
support/dtypes.h:#define F_NINF ((float)-INFINITY)
support/asprintf.c:        int ret = -1;
support/asprintf.c:        return (-1);
support/strtod.c:// Copyright  2001-2020 Python Software Foundation; All Rights Reserved
support/strtod.c:// - Leading spaces are ignored
support/strtod.c:// - Parsing of hex floats is supported in the derived version
support/strtod.c:// - Python functions for tolower, isdigit and malloc have been replaced by the respective
support/strtod.c:    if (*s == '-') {
support/strtod.c:        retval = negate ? -D_PINF : D_PINF;
support/strtod.c:        retval = negate ? -D_PNAN : D_PNAN;
support/strtod.c:        retval = -1.0;
support/strtod.c:    decimal_point = locale_data->decimal_point;
support/strtod.c:    if (*p == '-') {
support/strtod.c:                if (*p == '+' || *p == '-')
support/strtod.c:                if (*p == '+' || *p == '-')
support/strtod.c:           locale-specific decimal point */
support/strtod.c:        copy = (char *)malloc(end - digits_pos + 1 + decimal_point_len);
support/strtod.c:            return -1.0;
support/strtod.c:        memcpy(c, digits_pos, decimal_point_pos - digits_pos);
support/strtod.c:        c += decimal_point_pos - digits_pos;
support/strtod.c:               end - (decimal_point_pos + 1));
support/strtod.c:        c += end - (decimal_point_pos + 1);
support/strtod.c:                    (fail_pos - copy) -
support/strtod.c:                    (decimal_point_len - 1);
support/strtod.c:                    (fail_pos - copy);
support/strtod.c:        val = -val;
support/strtod.c:    return -1.0;
support/htable.inc://-*- mode:c -*-
support/htable.inc:#define hash_size(h) ((h)->size/2)
support/htable.inc:// compute empirical max-probe for a given size
support/htable.inc:    void **tab = h->table;                                              \
support/htable.inc:        index = (size_t)(hv & (sz-1)) * 2;                              \
support/htable.inc:        empty_slot = -1;                                                \
support/htable.inc:                if (empty_slot == -1)                                   \
support/htable.inc:                if (empty_slot == -1)                                   \
support/htable.inc:            index = (index+2) & (sz-1);                                 \
support/htable.inc:        if (empty_slot != -1) {                                         \
support/htable.inc:        sz = h->size;                                                   \
support/htable.inc:        ol = h->table;                                                  \
support/htable.inc:        h->table = tab;                                                 \
support/htable.inc:        h->size = newsz;                                                \
support/htable.inc:        if (ol != &h->_space[0])                                        \
support/htable.inc:        tab = h->table;                                                 \
support/htable.inc:/* if return is non-NULL and *bp == HT_NOTFOUND then key was deleted */ \
support/htable.inc:    void **tab = h->table;                                              \
support/htable.inc:    size_t index = (size_t)(HFUNC((uintptr_t)key, ctx) & (sz-1)) * 2;   \
support/htable.inc:        index = (index+2) & (sz-1);                                     \
support/END.h:/*-
support/END.h:.size CNAME, . - CNAME
support/hashing.c:    key = (~key) + (key << 21);            // key = (key << 21) - key - 1;
support/hashing.c:    key = (~key) + (key << 18); // key = (key << 18) - key - 1;
support/hashing.c:    // TODO: expose 128-bit hash
support/hashing.c:    // TODO: expose 128-bit hash
support/Makefile:FLAGS := $(HFILEDIRS:%=-I%) -I$(LIBUV_INC) -I$(UTF8PROC_INC) -DLIBRARY_EXPORTS -DUTF8PROC_EXPORTS
support/Makefile:FLAGS += -Wall -Wno-strict-aliasing -fvisibility=hidden -Wpointer-arith -Wundef
support/Makefile:JCFLAGS += -Wold-style-definition -Wstrict-prototypes -Wc++-compat
support/Makefile:	mkdir -p $(BUILDDIR)
support/Makefile:	@$(call PRINT_CC, $(CC) $(JCPPFLAGS) $(JCFLAGS) $(SHIPFLAGS) $(DISABLE_ASSERTIONS) -c $< -o $@)
support/Makefile:	@$(call PRINT_CC, $(CC) $(JCPPFLAGS) $(JCFLAGS) $(DEBUGFLAGS) -c $< -o $@)
support/Makefile:	@$(call PRINT_CC, $(CC) $(JCPPFLAGS) $(SHIPFLAGS) -c $< -o $@)
support/Makefile:	@$(call PRINT_CC, $(CC) $(JCPPFLAGS) $(DEBUGFLAGS) -c $< -o $@)
support/Makefile:	@$(call PRINT_CC, $(CPP) -P $(JCPPFLAGS) $(SHIPFLAGS) $<)
support/Makefile:	@$(call PRINT_CC, $(AS) $(JCPPFLAGS) $(SHIPFLAGS) -Fo $@ -c $*.i)
support/Makefile:	@$(call PRINT_CC, $(CPP) -P $(JCPPFLAGS) $(DEBUGFLAGS) $<)
support/Makefile:	@$(call PRINT_CC, $(AS) $(JCPPFLAGS) $(DEBUGFLAGS) -Fo $@ -c $*.i)
support/Makefile:	mkdir -p $(BUILDDIR)/host
support/Makefile:	@echo '# -- This file is automatically generated in julia/Makefile -- #' > $@
support/Makefile:debug: $(BUILDDIR)/libsupport-debug.a
support/Makefile:	rm -rf $@
support/Makefile:	@$(call PRINT_LINK, $(AR) -rcs $@ $^)
support/Makefile:$(BUILDDIR)/libsupport-debug.a: $(DOBJS) | $(BUILDDIR)
support/Makefile:	rm -rf $@
support/Makefile:	@$(call PRINT_LINK, $(AR) -rcs $@ $^)
support/Makefile:	$(MAKE) -C $(BUILDDIR)/host libsupport.a
support/Makefile:$(BUILDDIR)/host/libsupport-debug.a: $(BUILDDIR)/host/Makefile
support/Makefile:	$(MAKE) -C $(BUILDDIR)/host libsupport-debug.a
support/Makefile:	rm -f $(BUILDDIR)/*.o
support/Makefile:	rm -f $(BUILDDIR)/*.dbg.obj
support/Makefile:	rm -f $(BUILDDIR)/*.a
support/Makefile:	rm -f $(BUILDDIR)/*~ *#
support/Makefile:	rm -f $(BUILDDIR)/core*
support/Makefile:	rm -f $(BUILDDIR)/libsupport.a
support/Makefile:	rm -f $(BUILDDIR)/libsupport-debug.a
support/Makefile:	rm -f $(BUILDDIR)/host/*
support/dirname.c:        /* check again, just to ensure we still have a non-empty path name ... */
support/dirname.c:                do --basename;
support/dirname.c:                if( ((refpath - refcopy) > 2) || (refcopy[1] != refcopy[0]) )
support/dirname.c:                if( (len = wcstombs( path, refcopy, len )) != (size_t)(-1) )
support/operators.c:            d = -d;
support/strptime.c:/*-
support/strptime.c:    ((_TimeLocale *)((loc)->part_impl[(size_t)LC_TIME]))
support/strptime.c:/* RFC-822/RFC-2822 */
support/strptime.c:	/* non-leap year */
support/strptime.c:	return ((2 * (3 - (yr / 100) % 4)) + (yr % 100) + ((yr % 100) /  4) +
support/strptime.c:	for (p = buf, rp = *bp; !delim(*rp) && p < &buf[sizeof(buf) - 1]; rp++)
support/strptime.c:	tm->tm_isdst = 0;	/* XXX */
support/strptime.c:	tm->TM_GMTOFF = tzgetgmtoff(tz, tm->tm_isdst);
support/strptime.c:	tm->TM_ZONE = NULL; /* XXX */
support/strptime.c:	    day_offset = -1, week_offset = 0, offs, mandatory;
support/strptime.c:		/* Eat up white-space. */
support/strptime.c:			new_fmt = _TIME_LOCALE(loc)->d_t_fmt;
support/strptime.c:		case 'F':	/* The date as "%Y-%m-%d". */
support/strptime.c:			new_fmt = "%Y-%m-%d";
support/strptime.c:		case 'r':	/* The time in 12-hour clock representation. */
support/strptime.c:			new_fmt = _TIME_LOCALE(loc)->t_fmt_ampm;
support/strptime.c:			new_fmt = _TIME_LOCALE(loc)->t_fmt;
support/strptime.c:			new_fmt = _TIME_LOCALE(loc)->d_fmt;
support/strptime.c:			bp = find_string(bp, &tm->tm_wday,
support/strptime.c:			    _TIME_LOCALE(loc)->day, _TIME_LOCALE(loc)->abday, 7);
support/strptime.c:			bp = find_string(bp, &tm->tm_mon,
support/strptime.c:			    _TIME_LOCALE(loc)->mon, _TIME_LOCALE(loc)->abmon,
support/strptime.c:			i = i * 100 - TM_YEAR_BASE;
support/strptime.c:				i += tm->tm_year % 100;
support/strptime.c:			tm->tm_year = i;
support/strptime.c:			bp = conv_num(bp, &tm->tm_mday, 1, 31);
support/strptime.c:		case 'k':	/* The hour (24-hour clock representation). */
support/strptime.c:			bp = conv_num(bp, &tm->tm_hour, 0, 23);
support/strptime.c:		case 'l':	/* The hour (12-hour clock representation). */
support/strptime.c:			bp = conv_num(bp, &tm->tm_hour, 1, 12);
support/strptime.c:			if (tm->tm_hour == 12)
support/strptime.c:				tm->tm_hour = 0;
support/strptime.c:			tm->tm_yday = i - 1;
support/strptime.c:			bp = conv_num(bp, &tm->tm_min, 0, 59);
support/strptime.c:			tm->tm_mon = i - 1;
support/strptime.c:			bp = find_string(bp, &i, _TIME_LOCALE(loc)->am_pm,
support/strptime.c:			if (HAVE_HOUR(state) && tm->tm_hour > 11)
support/strptime.c:			tm->tm_hour += i * 12;
support/strptime.c:			bp = conv_num(bp, &tm->tm_sec, 0, 61);
support/strptime.c:					sse += *bp++ - '0';
support/strptime.c:			bp = conv_num(bp, &tm->tm_wday, 0, 6);
support/strptime.c:			tm->tm_wday = i % 7;
support/strptime.c:			tm->tm_year = i - TM_YEAR_BASE;
support/strptime.c:				i += (tm->tm_year / 100) * 100;
support/strptime.c:					i = i + 2000 - TM_YEAR_BASE;
support/strptime.c:					i = i + 1900 - TM_YEAR_BASE;
support/strptime.c:			tm->tm_year = i;
support/strptime.c:			 * [+-]hhmm
support/strptime.c:			 * [+-]hh:mm
support/strptime.c:			 * [+-]hh
support/strptime.c:			 * We recognize all RFC-822/RFC-2822 formats:
support/strptime.c:			 * E[DS]T = Eastern : -4 | -5
support/strptime.c:			 * C[DS]T = Central : -5 | -6
support/strptime.c:			 * M[DS]T = Mountain: -6 | -7
support/strptime.c:			 * P[DS]T = Pacific : -7 | -8
support/strptime.c:			 * [A-IL-M] = -1 ... -9 (J not used)
support/strptime.c:			 * [N-Y]  = +1 ... +12
support/strptime.c:			 * Note: J maybe used to denote non-nautical
support/strptime.c:				tm->tm_isdst = 0;
support/strptime.c:				tm->TM_GMTOFF = 0;
support/strptime.c:				tm->TM_ZONE = utc;
support/strptime.c:			case '-':
support/strptime.c:						tm->TM_GMTOFF =
support/strptime.c:						    ('A' - 1) - (int)*bp;
support/strptime.c:						tm->TM_GMTOFF = 'A' - (int)*bp;
support/strptime.c:						tm->TM_GMTOFF = (int)*bp - 'M';
support/strptime.c:					tm->TM_GMTOFF *= SECSPERHOUR;
support/strptime.c:					tm->TM_ZONE = NULL; /* XXX */
support/strptime.c:					tm->TM_GMTOFF = -timezone;
support/strptime.c:					tm->TM_ZONE = NULL; /* XXX */
support/strptime.c:				 * From our 3 letter hard-coded table
support/strptime.c:					tm->TM_GMTOFF = (-5 - i) * SECSPERHOUR;
support/strptime.c:					tm->TM_ZONE = __UNCONST(nast[i]);
support/strptime.c:					tm->tm_isdst = 1;
support/strptime.c:					tm->TM_GMTOFF = (-4 - i) * SECSPERHOUR;
support/strptime.c:					tm->TM_ZONE = __UNCONST(nadt[i]);
support/strptime.c:					tm->tm_isdst = i;
support/strptime.c:					tm->TM_GMTOFF = -timezone;
support/strptime.c:					tm->TM_ZONE = _tzname[i];
support/strptime.c:					offs = offs * 10 + (*bp++ - '0');
support/strptime.c:				offs = -offs;
support/strptime.c:			tm->tm_isdst = 0;	/* XXX */
support/strptime.c:			tm->TM_GMTOFF = offs;
support/strptime.c:			tm->TM_ZONE = NULL;	/* XXX */
support/strptime.c:		case 'n':	/* Any kind of white-space. */
support/strptime.c:			tm->tm_yday =  start_of_month[isleap_sum(tm->tm_year,
support/strptime.c:			    TM_YEAR_BASE)][tm->tm_mon] + (tm->tm_mday - 1);
support/strptime.c:		} else if (day_offset != -1) {
support/strptime.c:				tm->tm_wday = day_offset;
support/strptime.c:			tm->tm_yday = (7 -
support/strptime.c:			    first_wday_of(tm->tm_year + TM_YEAR_BASE) +
support/strptime.c:			    day_offset) % 7 + (week_offset - 1) * 7 +
support/strptime.c:			    tm->tm_wday  - day_offset;
support/strptime.c:			isleap = isleap_sum(tm->tm_year, TM_YEAR_BASE);
support/strptime.c:			while (tm->tm_yday >= start_of_month[isleap][i])
support/strptime.c:				tm->tm_yday -= start_of_month[isleap][12];
support/strptime.c:				tm->tm_year++;
support/strptime.c:			tm->tm_mon = i - 1;
support/strptime.c:			isleap = isleap_sum(tm->tm_year, TM_YEAR_BASE);
support/strptime.c:			tm->tm_mday = tm->tm_yday -
support/strptime.c:			    start_of_month[isleap][tm->tm_mon] + 1;
support/strptime.c:			week_offset = first_wday_of(tm->tm_year);
support/strptime.c:			while (i++ <= tm->tm_yday) {
support/strptime.c:			tm->tm_wday = week_offset;
support/strptime.c:		result += ch - '0';
support/strptime.c:	/* check full name - then abbreviated ones */
support/htable.h:// Power-of-two hash table with linear probing.
support/htable.h:// elements. (Expect `h->size > size` for efficient occupancy factor.)
support/arraylist.c:    a->len = 0;
support/arraylist.c:        a->items = &a->_space[0];
support/arraylist.c:        a->max = AL_N_INLINE;
support/arraylist.c:        a->items = (void**)LLT_ALLOC(size*sizeof(void*));
support/arraylist.c:        if (a->items == NULL) return NULL;
support/arraylist.c:        a->max = size;
support/arraylist.c:    if (a->items != &a->_space[0])
support/arraylist.c:        LLT_FREE(a->items);
support/arraylist.c:    a->len = 0;
support/arraylist.c:    a->max = AL_N_INLINE;
support/arraylist.c:    a->items = &a->_space[0];
support/arraylist.c:    size_t len = a->len;
support/arraylist.c:    if (newlen > a->max) {
support/arraylist.c:        if (a->items == &a->_space[0]) {
support/arraylist.c:            void **p = (void**)LLT_ALLOC((a->len+n)*sizeof(void*));
support/arraylist.c:            memcpy(p, a->items, len * sizeof(void*));
support/arraylist.c:            a->items = p;
support/arraylist.c:            a->max = newlen;
support/arraylist.c:            size_t nm = a->max * 2;
support/arraylist.c:            void **p = (void**)LLT_REALLOC(a->items, nm * sizeof(void*));
support/arraylist.c:            a->items = p;
support/arraylist.c:            a->max = nm;
support/arraylist.c:    a->len = newlen;
support/arraylist.c:    a->items[a->len - 1] = elt;
support/arraylist.c:    if (a->len == 0) return NULL;
support/arraylist.c:    void *p = a->items[--a->len];
support/arraylist.c:    a->items[a->len] = NULL;
support/arraylist.c:    a->len = 0;
support/arraylist.c:        a->items = &a->_space[0];
support/arraylist.c:        a->max = SMALL_AL_N_INLINE;
support/arraylist.c:        a->items = (void**)LLT_ALLOC(size*sizeof(void*));
support/arraylist.c:        if (a->items == NULL) return NULL;
support/arraylist.c:        a->max = size;
support/arraylist.c:    if (a->items != &a->_space[0])
support/arraylist.c:        LLT_FREE(a->items);
support/arraylist.c:    a->len = 0;
support/arraylist.c:    a->max = SMALL_AL_N_INLINE;
support/arraylist.c:    a->items = &a->_space[0];
support/arraylist.c:    size_t len = a->len;
support/arraylist.c:    if (newlen > a->max) {
support/arraylist.c:        if (a->items == &a->_space[0]) {
support/arraylist.c:            void **p = (void**)LLT_ALLOC((a->len+n)*sizeof(void*));
support/arraylist.c:            memcpy(p, a->items, len * sizeof(void*));
support/arraylist.c:            a->items = p;
support/arraylist.c:            a->max = newlen;
support/arraylist.c:            size_t nm = a->max * 2;
support/arraylist.c:            void **p = (void**)LLT_REALLOC(a->items, nm * sizeof(void*));
support/arraylist.c:            a->items = p;
support/arraylist.c:            a->max = nm;
support/arraylist.c:    a->len = newlen;
support/arraylist.c:    a->items[a->len - 1] = elt;
support/arraylist.c:    if (a->len == 0) return NULL;
support/arraylist.c:    void *p = a->items[--a->len];
support/arraylist.c:    a->items[a->len] = NULL;
support/ENTRY.i387.h:/*-
support/ENTRY.i387.h:.ascii " -export:", XSTR(CNAME)
support/ios.c:#define MOST_OF(x) ((x) - ((x)>>4))
support/ios.c:/* OS-level primitive wrappers */
support/ios.c:    while (--src >= (unsigned char*)s)
support/ios.c:#define MAXSIZE ((1l << 31) - 1)   // OSX cannot handle blocks larger than this
support/ios.c:        if (r > -1) {
support/ios.c:        n -= got;
support/ios.c:        if (r > -1) {
support/ios.c:        n -= wrote;
support/ios.c:    if ((s->buf==NULL || s->buf==&s->local[0]) && (sz <= IOS_INLSIZE)) {
support/ios.c:        s->buf = &s->local[0];
support/ios.c:        s->maxsize = IOS_INLSIZE;
support/ios.c:        s->ownbuf = 1;
support/ios.c:        return s->buf;
support/ios.c:    if (sz <= s->maxsize) return s->buf;
support/ios.c:    if (s->ownbuf && s->buf != &s->local[0]) {
support/ios.c:        temp = (char*)LLT_REALLOC(s->buf, sz);
support/ios.c:        s->ownbuf = 1;
support/ios.c:        if (s->size > 0)
support/ios.c:            memcpy(temp, s->buf, (size_t)s->size);
support/ios.c:    s->buf = temp;
support/ios.c:    s->maxsize = sz;
support/ios.c:    return s->buf;
support/ios.c:    if (s->bpos + n > s->size) {
support/ios.c:        if (s->bpos + n > s->maxsize) {
support/ios.c:            newsize = (size_t)(s->maxsize ? s->maxsize * 2 : 8);
support/ios.c:            while (s->bpos + n > newsize)
support/ios.c:                amt = (size_t)(s->maxsize - s->bpos);
support/ios.c:                    memcpy(&s->buf[s->bpos], data, amt);
support/ios.c:                s->bpos += amt;
support/ios.c:                s->size = s->maxsize;
support/ios.c:        s->size = s->bpos + n;
support/ios.c:    memcpy(s->buf + s->bpos, data, n);
support/ios.c:    s->bpos += n;
support/ios.c:    if (s->state == bst_wr) {
support/ios.c:    s->state = bst_rd;
support/ios.c:        avail = (size_t)(s->size - s->bpos);
support/ios.c:            memcpy(dest, s->buf + s->bpos, ncopy);
support/ios.c:            s->bpos += ncopy;
support/ios.c:        if (s->bm == bm_mem || s->fd == -1) {
support/ios.c:                s->_eof = 1;
support/ios.c:        n -= avail;
support/ios.c:        s->bpos = s->size = 0;
support/ios.c:        s->fpos = -1;
support/ios.c:        if (n > MOST_OF(s->maxsize)) {
support/ios.c:                //result = _os_read_all(s->fd, dest, n, &got);
support/ios.c:                _os_read_all(s->fd, dest, n, &got);
support/ios.c:                //result = _os_read(s->fd, dest, n, &got);
support/ios.c:                _os_read(s->fd, dest, n, &got);
support/ios.c:                s->_eof = 1;
support/ios.c:            if (_os_read(s->fd, s->buf, (size_t)s->maxsize, &got)) {
support/ios.c:                s->_eof = 1;
support/ios.c:                s->_eof = 1;
support/ios.c:            s->size = got;
support/ios.c:    if (s->state == bst_wr && s->bm != bm_mem) {
support/ios.c:        s->bpos = s->size = 0;
support/ios.c:    size_t space = (size_t)(s->size - s->bpos);
support/ios.c:    s->state = bst_rd;
support/ios.c:    if (space >= n || s->bm == bm_mem || s->fd == -1)
support/ios.c:    if (s->maxsize < s->bpos+n) {
support/ios.c:        if (n <= s->maxsize && space <= ((s->maxsize)>>2)) {
support/ios.c:                memmove(s->buf, s->buf+s->bpos, space);
support/ios.c:            s->size -= s->bpos;
support/ios.c:            s->bpos = 0;
support/ios.c:            if (_buf_realloc(s, (size_t)(s->bpos + n))==NULL)
support/ios.c:    s->fpos = -1;
support/ios.c:    int result = _os_read(s->fd, s->buf+s->size, (size_t)(s->maxsize - s->size), &got);
support/ios.c:    s->size += got;
support/ios.c:    return (size_t)(s->size - s->bpos);
support/ios.c:// have read the whole file, or -1 if there might be more data.
support/ios.c:    size_t nb = s->maxsize - s->bpos;
support/ios.c:    return -1;
support/ios.c:    if (s->bpos > s->ndirty) s->ndirty = s->bpos;
support/ios.c:    if (s->bpos > s->size)   s->size = s->bpos;
support/ios.c:    char *data = src->buf;
support/ios.c:    size_t n = (size_t)src->size;
support/ios.c:    dest->fpos = -1;
support/ios.c:    _os_write_all(dest->fd, data, n, &nwr);
support/ios.c:    if (!s->writable) return 0;
support/ios.c:    if (s->state == bst_rd) {
support/ios.c:    s->state = bst_wr;
support/ios.c:    space = (size_t)(s->maxsize - s->bpos);
support/ios.c:    if (s->bm == bm_mem) {
support/ios.c:    else if (s->bm == bm_none) {
support/ios.c:        s->fpos = -1;
support/ios.c:        _os_write_all(s->fd, data, n, &wrote);
support/ios.c:        if (s->bm == bm_line) {
support/ios.c:                size_t linesz = nl-data+1;
support/ios.c:                s->bm = bm_block;
support/ios.c:                s->bm = bm_line;
support/ios.c:                n -= linesz;
support/ios.c:        memcpy(s->buf + s->bpos, data, n);
support/ios.c:        s->bpos += n;
support/ios.c:        if (n > MOST_OF(s->maxsize)) {
support/ios.c:            s->fpos = -1;
support/ios.c:            _os_write_all(s->fd, data, n, &wrote);
support/ios.c://        -1 on error which set errno, and
support/ios.c://        -2 on error which doesn't set errno.
support/ios.c:    s->_eof = 0;
support/ios.c:    if (s->bm == bm_mem) {
support/ios.c:        if (pos < 0 || pos > s->size)
support/ios.c:            return -2;
support/ios.c:        s->bpos = pos;
support/ios.c:        int64_t fdpos = lseek(s->fd, (off_t)pos, SEEK_SET);
support/ios.c:        if (fdpos == (int64_t)-1)
support/ios.c:        s->fpos = fdpos;
support/ios.c:        s->bpos = s->size = 0;
support/ios.c:    s->_eof = 1;
support/ios.c:    if (s->bm == bm_mem) {
support/ios.c:        s->bpos = s->size;
support/ios.c:        int64_t fdpos = lseek(s->fd, 0, SEEK_END);
support/ios.c:        if (fdpos == (int64_t)-1)
support/ios.c:        s->fpos = fdpos;
support/ios.c:        s->bpos = s->size = 0;
support/ios.c://        -1 on error which set errno, and
support/ios.c://        -2 on error which doesn't set errno.
support/ios.c:            if (offs <= (s->size - s->bpos)) {
support/ios.c:                s->bpos += offs;
support/ios.c:            else if (s->bm == bm_mem) {
support/ios.c:                return -2;
support/ios.c:            if (-offs <= (int64_t)s->bpos) {
support/ios.c:                s->bpos += offs;
support/ios.c:                s->_eof = 0;
support/ios.c:            else if (s->bm == bm_mem) {
support/ios.c:                return -2;
support/ios.c:        if (s->state == bst_wr)
support/ios.c:            offs += s->bpos;
support/ios.c:        else if (s->state == bst_rd)
support/ios.c:            offs -= (s->size - s->bpos);
support/ios.c:        int64_t fdpos = lseek(s->fd, (off_t)offs, SEEK_CUR);
support/ios.c:        if (fdpos == (int64_t)-1)
support/ios.c:        s->fpos = fdpos;
support/ios.c:        s->bpos = s->size = 0;
support/ios.c:        s->_eof = 0;
support/ios.c:    if (s->bm == bm_mem)
support/ios.c:        return s->bpos;
support/ios.c:    int64_t fdpos = s->fpos;
support/ios.c:    if (fdpos == (int64_t)-1) {
support/ios.c:        fdpos = lseek(s->fd, 0, SEEK_CUR);
support/ios.c:        if (fdpos == (int64_t)-1)
support/ios.c:        s->fpos = fdpos;
support/ios.c:    if (s->state == bst_wr)
support/ios.c:        fdpos += s->bpos;
support/ios.c:    else if (s->state == bst_rd)
support/ios.c:        fdpos -= (s->size - s->bpos);
support/ios.c:    int64_t fdpos = s->fpos;
support/ios.c:    if (fdpos == (int64_t)-1) {
support/ios.c:        fdpos = lseek(s->fd, 0, SEEK_CUR);
support/ios.c:        if (fdpos == (int64_t)-1)
support/ios.c:        s->fpos = fdpos;
support/ios.c:    off_t sz = lseek(s->fd, 0, SEEK_END);
support/ios.c:    lseek(s->fd, (off_t)fdpos, SEEK_SET);
support/ios.c:    if (s->bm == bm_mem) {
support/ios.c:        if (size == s->size)
support/ios.c:        if (size < s->size) {
support/ios.c:            if (s->bpos > size)
support/ios.c:                s->bpos = size;
support/ios.c:        s->size = size;
support/ios.c:        if (s->state == bst_rd) {
support/ios.c:            if (size < p + (s->size - s->bpos))
support/ios.c:                s->size -= (p + (s->size - s->bpos) - size);
support/ios.c:        if (ftruncate(s->fd, size) == 0)
support/ios.c:        if (_chsize_s(s->fd, size) == 0)
support/ios.c:    if (s->state == bst_rd && s->bpos < s->size)
support/ios.c:    if (s->bm == bm_mem)
support/ios.c:        return (s->_eof ? 1 : 0);
support/ios.c:    if (s->fd == -1)
support/ios.c:    if (s->_eof)
support/ios.c:    if (_fd_available(s->fd))
support/ios.c:    s->_eof = 1;
support/ios.c:    if (s->state == bst_rd && s->bpos < s->size)
support/ios.c:    if (s->bm == bm_mem)
support/ios.c:        return (s->_eof ? 1 : 0);
support/ios.c:    if (s->fd == -1)
support/ios.c:    if (s->ndirty == 0 || s->bm == bm_mem || s->buf == NULL)
support/ios.c:    if (s->fd == -1)
support/ios.c:        return -1;
support/ios.c:    if (s->state == bst_rd) {
support/ios.c:        if (lseek(s->fd, -(off_t)s->size, SEEK_CUR) == (off_t)-1) {
support/ios.c:    size_t nw, ntowrite=s->ndirty;
support/ios.c:    s->fpos = -1;
support/ios.c:    int err = _os_write_all(s->fd, s->buf, ntowrite, &nw);
support/ios.c:    if (s->state == bst_rd) {
support/ios.c:        if (lseek(s->fd, (off_t)(s->size - nw), SEEK_CUR) == (off_t)-1) {
support/ios.c:    else if (s->state == bst_wr) {
support/ios.c:        if (s->bpos != nw &&
support/ios.c:            lseek(s->fd, (off_t)(s->bpos - nw), SEEK_CUR) == (off_t)-1) {
support/ios.c:        // begins at the beginning of the buffer, and s->size refers
support/ios.c:        if (s->size > s->ndirty) {
support/ios.c:            size_t delta = (size_t)(s->size - s->ndirty);
support/ios.c:            memmove(s->buf, s->buf + s->ndirty, delta);
support/ios.c:        s->size -= s->ndirty;
support/ios.c:        s->bpos = 0;
support/ios.c:    s->ndirty = 0;
support/ios.c:        return -1;
support/ios.c:    if (s->fd != -1 && s->ownfd) {
support/ios.c:        int err2 = close(s->fd);
support/ios.c:    s->fd = -1;
support/ios.c:    if (s->buf!=NULL && s->ownbuf && s->buf!=&s->local[0]) {
support/ios.c:        LLT_FREE(s->buf);
support/ios.c:    s->buf = NULL;
support/ios.c:    s->size = s->maxsize = s->bpos = 0;
support/ios.c:    return s->fd != -1;
support/ios.c:    s->bm = bm;
support/ios.c:    if (s->bm == bm_mem || s->bm == bm_none) {
support/ios.c:        s->buf = &s->local[0];
support/ios.c:        s->maxsize = IOS_INLSIZE;
support/ios.c:        s->buf = NULL;
support/ios.c:        s->maxsize = 0;
support/ios.c:    s->size = s->bpos = 0;
support/ios.c:    if (s->buf == &s->local[0] || s->buf == NULL || (!s->ownbuf && s->size == s->maxsize)) {
support/ios.c:        buf = (char*)LLT_ALLOC((size_t)s->size + 1);
support/ios.c:        if (s->size)
support/ios.c:            memcpy(buf, s->buf, (size_t)s->size);
support/ios.c:    else if (s->size == s->maxsize) {
support/ios.c:        buf = (char*)LLT_REALLOC(s->buf, (size_t)s->size + 1);
support/ios.c:        buf = s->buf;
support/ios.c:    buf[s->size] = '\0';
support/ios.c:    *psize = s->size + 1;
support/ios.c:    _buf_init(s, s->bm);
support/ios.c:    nvalid = (size_t)((size < s->size) ? size : s->size);
support/ios.c:        memcpy(buf, s->buf, nvalid);
support/ios.c:    if (s->bpos > nvalid) {
support/ios.c:        s->bpos = nvalid;
support/ios.c:    s->size = nvalid;
support/ios.c:    if (s->buf!=NULL && s->ownbuf && s->buf!=&s->local[0]) {
support/ios.c:        LLT_FREE(s->buf);
support/ios.c:    s->buf = buf;
support/ios.c:    s->maxsize = size;
support/ios.c:    s->ownbuf = own;
support/ios.c:    // no fd; can only do mem-only buffering
support/ios.c:    if (s->fd == -1 && mode != bm_mem)
support/ios.c:        return -1;
support/ios.c:    s->bm = mode;
support/ios.c:    return s->readable;
support/ios.c:    return s->writable;
support/ios.c:    if (!s->writable) return;
support/ios.c:    s->state = bst_none;
support/ios.c:    s->writable = 0;
support/ios.c:                from->_eof = 1;
support/ios.c:            written = ios_write(to, from->buf+from->bpos, ntowrite);
support/ios.c:            from->bpos += ntowrite;
support/ios.c:                nbytes -= written;
support/ios.c:    size_t total = 0, avail = (size_t)(from->size - from->bpos);
support/ios.c:        char *pd = (char*)memchr(from->buf+from->bpos, delim, avail);
support/ios.c:            written = ios_write(to, from->buf+from->bpos, avail);
support/ios.c:            from->bpos += avail;
support/ios.c:            size_t ntowrite = pd - (from->buf+from->bpos) + 1;
support/ios.c:            written = ios_write(to, from->buf+from->bpos, ntowrite);
support/ios.c:            from->bpos += ntowrite;
support/ios.c:    from->_eof = 1;
support/ios.c:    if (ntowrite > 1 && from->buf[from->bpos+ntowrite - 2] == '\r') {
support/ios.c:    s->bm = bm_block;
support/ios.c:    s->state = bst_none;
support/ios.c:    s->errcode = 0;
support/ios.c:    s->buf = NULL;
support/ios.c:    s->maxsize = 0;
support/ios.c:    s->size = 0;
support/ios.c:    s->bpos = 0;
support/ios.c:    s->ndirty = 0;
support/ios.c:    s->fpos = -1;
support/ios.c:    s->lineno = 1;
support/ios.c:    s->u_colno = 0;
support/ios.c:    s->fd = -1;
support/ios.c:    s->ownbuf = 1;
support/ios.c:    s->ownfd = 0;
support/ios.c:    s->_eof = 0;
support/ios.c:    s->readable = 1;
support/ios.c:    s->writable = 1;
support/ios.c:    s->rereadable = 0;
support/ios.c: *  while (-1 == fd && _enonfatal(errno))
support/ios.c:        if (fd != -1)
support/ios.c:            return -1;
support/ios.c:    size_t wlen = MultiByteToWideChar(CP_UTF8, 0, fname, -1, NULL, 0);
support/ios.c:    if (!MultiByteToWideChar(CP_UTF8, 0, fname, -1, fname_w, wlen)) goto open_file_err;
support/ios.c:    while (-1 == fd && _enonfatal(errno));
support/ios.c:    if (fd == -1)
support/ios.c:    s->fpos = 0;
support/ios.c:        s->readable = 0;
support/ios.c:        s->writable = 0;
support/ios.c:    s->fd = -1;
support/ios.c:    size_t wlen = MultiByteToWideChar(CP_UTF8, 0, fname, -1, NULL, 0);
support/ios.c:    if (!MultiByteToWideChar(CP_UTF8, 0, fname, -1, fname_w, wlen) ||
support/ios.c:        !WideCharToMultiByte(CP_UTF8, 0, fname_w, -1, fname, strlen(fname)+1,
support/ios.c:    if (fd == -1)
support/ios.c:    s->fd = -1;
support/ios.c:    s->bm = bm_mem;
support/ios.c:    s->rereadable = 1;
support/ios.c:    s->size = sz;
support/ios.c:    s->fd = fd;
support/ios.c:    if (isfile) s->rereadable = 1;
support/ios.c:    s->ownfd = own;
support/ios.c:        s->bm = bm_none;
support/ios.c:        s->bm = bm_line;
support/ios.c:    ios_stdout->bm = bm_line;
support/ios.c:    ios_stderr->bm = bm_none;
support/ios.c:    if (s->state == bst_wr && s->bpos < s->maxsize && s->bm != bm_none) {
support/ios.c:        s->buf[s->bpos++] = ch;
support/ios.c:        if (s->bm == bm_line && ch == '\n')
support/ios.c:    if (s->state == bst_rd && s->bpos < s->size) {
support/ios.c:        ch = s->buf[s->bpos++];
support/ios.c:        if (s->_eof) return IOS_EOF;
support/ios.c:    if (ch == '\n') s->lineno++;
support/ios.c:    if (s->bpos < s->size)
support/ios.c:        return (unsigned char)s->buf[s->bpos];
support/ios.c:    if (s->_eof) return IOS_EOF;
support/ios.c:    return (unsigned char)s->buf[s->bpos];
support/ios.c:    if (s->state == bst_wr)
support/ios.c:    if (s->bpos > 0) {
support/ios.c:        s->bpos--;
support/ios.c:        s->buf[s->bpos] = (char)c;
support/ios.c:        s->_eof = 0;
support/ios.c:    if (s->size == s->maxsize) {
support/ios.c:        if (_buf_realloc(s, s->maxsize*2) == NULL)
support/ios.c:    memmove(s->buf + 1, s->buf, s->size);
support/ios.c:    s->buf[0] = (char)c;
support/ios.c:    s->size++;
support/ios.c:    s->_eof = 0;
support/ios.c:            s->u_colno = 0;
support/ios.c:            s->u_colno += utf8proc_charwidth(*pwc);
support/ios.c:    int valid = u8_isvalid(&s->buf[s->bpos], sz);
support/ios.c:        size_t i = s->bpos;
support/ios.c:        *pwc = u8_nextchar(s->buf, &i);
support/ios.c:        s->u_colno += utf8proc_charwidth(*pwc);
support/ios.c:    int valid = u8_isvalid(&s->buf[s->bpos], sz);
support/ios.c:        size_t i = s->bpos;
support/ios.c:        *pwc = u8_nextchar(s->buf, &i);
support/ios.c:    if (s->state == bst_rd) {
support/ios.c:        s->bpos = s->size;
support/ios.c:    if (s->state == bst_wr && s->bpos < s->maxsize && s->bm != bm_none) {
support/ios.c:        size_t avail = (size_t)(s->maxsize - s->bpos);
support/ios.c:        char *start = s->buf + s->bpos;
support/ios.c:            s->bpos += (size_t)c;
support/ios.c:            if (s->bm == bm_line && memrchr(start, '\n', (size_t)c))
support/utf8.h:#define UEOF ((uint32_t)-1)
support/utf8.h:/* convert UTF-8 data to wide character */
support/utf8.h:/* single character to UTF-8, returns # bytes written */
support/utf8.h:/* returns length of next utf-8 sequence */
support/utf8.h:/* convert UTF-8 "src" to escape sequences.
support/utf8.h:   if ascii is nonzero, the output is 7-bit ASCII, no UTF-8 survives.
support/utf8.h:   a NUL-terminated string. */
support/utf8.h:/* printf where the format string and arguments may be in UTF-8.
support/utf8.h:   locale is UTF-8. */
support/utf8.h:/* determine whether a sequence of bytes is valid UTF-8. length is in bytes */
support/MurmurHash3.h://-----------------------------------------------------------------------------
support/MurmurHash3.h://-----------------------------------------------------------------------------
support/MurmurHash3.h:// Platform-specific functions and macros
support/MurmurHash3.h://-----------------------------------------------------------------------------
support/MurmurHash3.h://-----------------------------------------------------------------------------
support/.gitignore:/libsupport-debug.a
support/platform.h: * based of compiler-specific pre-defined macros. It is based on the
support/timefuncs.c:    jtv->sec = tb.time;
support/timefuncs.c:    jtv->usec = tb.millitm * 1000;
support/timefuncs.c:    jtv->sec = tv.tv_sec;
support/timefuncs.c:    jtv->usec = tv.tv_usec;
support/timefuncs.c:    return now.sec + now.usec * 1e-6;
support/MurmurHash3.c://-----------------------------------------------------------------------------
support/MurmurHash3.c:// Note - The x86 and x64 versions do _not_ produce the same results, as the
support/MurmurHash3.c:// non-native version will be less than optimal.
support/MurmurHash3.c://-----------------------------------------------------------------------------
support/MurmurHash3.c:// Platform-specific functions and macros
support/MurmurHash3.c:  return (x << r) | (x >> (32 - r));
support/MurmurHash3.c:  return (x << r) | (x >> (64 - r));
support/MurmurHash3.c://-----------------------------------------------------------------------------
support/MurmurHash3.c:// Finalization mix - force all bits of a hash block to avalanche
support/MurmurHash3.c://----------
support/MurmurHash3.c://-----------------------------------------------------------------------------
support/MurmurHash3.c:  //----------
support/MurmurHash3.c:  for(int i = -nblocks; i; i++)
support/MurmurHash3.c:  //----------
support/MurmurHash3.c:  //----------
support/MurmurHash3.c://-----------------------------------------------------------------------------
support/MurmurHash3.c:  //----------
support/MurmurHash3.c:  for(int i = -nblocks; i; i++)
support/MurmurHash3.c:  //----------
support/MurmurHash3.c:  //----------
support/MurmurHash3.c://-----------------------------------------------------------------------------
support/MurmurHash3.c:  //----------
support/MurmurHash3.c:  //----------
support/MurmurHash3.c:  //----------
support/MurmurHash3.c://-----------------------------------------------------------------------------
support/bitvector.c:        memset(&p[osz/sizeof(uint32_t)], 0, sz-osz);
support/ios.h:    // pointer-size integer to support platforms where it might have
support/ios.h:    // seek without flushing in between. this performs read-before-write
support/ios.h:/* low-level interface functions */
support/ios.h:/* high-level functions - output */
support/ios.h:/* high-level stream functions - input */
support/ios.h:/* stdio-style functions */
support/ios.h:#define IOS_EOF (-1)
support/ios.h:  Single-bit I/O is able to write partial bytes ONLY IF the stream supports
support/ios.h:  seeking. Also, line buffering is not well-defined in the context of
support/ios.h:  single-bit I/O, so it might not do what you expect.
support/ios.h:  when writing: buf starts at curr. physical stream pos, p - buf is how
support/ios.h:  to write a bit: if !dirty, read up to maxsize-(p-buf) into buffer, then
support/ios.h:  the dirty bit. in this state, we can bit-read up to the end of the byte,
support/ios.h:  - data-source independence, including memory streams
support/ios.h:  - expose buffer to user, allow user-owned buffers
support/ios.h:  - allow direct I/O, don't always go through buffer
support/ios.h:  - buffer-internal seeking. makes seeking back 1-2 bytes very fast,
support/ios.h:  - tries to allow switching between reading and writing
support/ios.h:  - support 64-bit and large files
support/ios.h:  - efficient, low-latency buffering
support/ios.h:  - special support for utf8
support/ios.h:  - type-aware functions with byte-order swapping service
support/ios.h:  - position counter for meaningful data offsets with sockets
support/_setjmp.win32.S:/*-
support/_setjmp.win32.S: * C library -- _setjmp, _longjmp
support/int2str.c:    int i = len-1;
support/int2str.c:    dest[i--] = '\0';
support/int2str.c:            ch = ch-10+'a';
support/int2str.c:        dest[i--] = ch;
support/int2str.c:            (c >= 'a' && c < 'a'+base-10) ||
support/int2str.c:            (c >= 'A' && c < 'A'+base-10));
support/int2str.c:    for(i=len-1; i>=0; i--) {
support/int2str.c:            digit -= '0';
support/int2str.c:            digit = digit-'a'+10;
support/int2str.c:            digit = digit-'A'+10;
support/ENTRY.amd64.h:/*-
support/ENTRY.amd64.h:.ascii " -export:"
support/utf8.c:  Basic UTF-8 manipulation routines
support/utf8.c:  UTF-8 as an internal string encoding. These functions do not perform the
support/utf8.c:  error checking normally needed when handling UTF-8 data, so if you happen
support/utf8.c:  A UTF-8 validation routine is included.
support/utf8.c:/* returns length of next utf-8 sequence */
support/utf8.c:   only works for valid UTF-8, i.e. no 5- or 6-byte sequences
support/utf8.c:        ch -= offsetsFromUTF8[nb];
support/utf8.c:            if (dest >= dest_end-1)
support/utf8.c:            if (dest >= dest_end-2)
support/utf8.c:            if (dest >= dest_end-3)
support/utf8.c:            if (dest >= dest_end-2)
support/utf8.c:    return (dest-dest0);
support/utf8.c:        charnum--;
support/utf8.c:          // assume this is a valid UTF-8 string
support/utf8.c:       } while (--offset);
support/utf8.c:            ch -= offsetsFromUTF8[nb];
support/utf8.c:/* reads the next utf-8 sequence out of a string, updating an index */
support/utf8.c:    for (j = sz; j > 0; j--) {
support/utf8.c:    ch -= offsetsFromUTF8[sz-1];
support/utf8.c:    (void)(isutf(s[--(*i)]) || isutf(s[--(*i)]) || isutf(s[--(*i)]) || --(*i));
support/utf8.c:    char *blim = start + sz-11;
support/utf8.c:        // sz-11: leaves room for longest escape sequence
support/utf8.c:                buf += u8_escape_wchar(buf, sz - (buf-start), ch);
support/utf8.c:    return (buf-start);
support/utf8.c:        c -= offsetsFromUTF8[csz-1];
support/utf8.c:    size_t i = sz-1, tempi=0;
support/utf8.c:    while (i && !isutf(s[i])) i--;
support/utf8.c:    // First scan for non-ASCII characters as fast as possible
support/utf8.c:    // Check validity of UTF-8 sequences
support/utf8.c:    byt = pnt[-1];
support/utf8.c:    if (((uint32_t)byt - 0xc2) > (0xf4-0xc2)) return 0;
support/utf8.c:    if (byt < 0xe0) {               // 2-byte sequence
support/utf8.c:    } else if (byt < 0xf0) {        // 3-byte sequence
support/utf8.c:    } else {                        // 4-byte sequence
support/utf8.c:        // Make sure in correct range (0x10000 - 0x10ffff)
support/utf8.c:    // Find next non-ASCII characters as fast as possible
support/utf8.c:    return 2;   // Valid UTF-8
support/tzfile.h:** 1996-06-05 by Arthur David Olson.
support/tzfile.h:**	tzh_charcnt (char)s		'\0'-terminated zone abbreviations
support/tzfile.h:** then a POSIX-TZ-environment-variable-style string for use in handling
support/tzfile.h:** First, the POSIX TZ string's hour offset may range from -167
support/tzfile.h:** through 167 as compared to the POSIX-required 0 through 24.
smallintset.c:// compute empirical max-probe for a given size
smallintset.c:#define h2index(hv, sz) (size_t)((hv) & ((sz)-1))
smallintset.c:    memset(a->data, 0, len * a->elsize);
smallintset.c:        return -1;
smallintset.c:            return -1;
smallintset.c:        if (eq(val1 - 1, key, data, hv)) {
smallintset.c:            return val1 - 1;
smallintset.c:        index = (index + 1) & (sz - 1);
smallintset.c:    return -1;
smallintset.c:        index = (index + 1) & (sz - 1);
smallintset.c:                if (!smallintset_insert_(newa, hash(val1 - 1, data), val1)) {
utils.scm:  (with-output-to *stderr*
utils.scm:(define (has-dups lst)
utils.scm:          (has-dups (cdr lst)))))
utils.scm:(define (expr-contains-eq x expr)
utils.scm:           (any (lambda (y) (expr-contains-eq x y))
utils.scm:(define (expr-contains-p p expr (filt (lambda (x) #t)))
utils.scm:                (any (lambda (y) (expr-contains-p p y filt))
utils.scm:(define (expr-find-all p expr key (filt (lambda (x) #t)))
utils.scm:                   (map (lambda (x) (expr-find-all p x key filt))
utils.scm:(define (take-while f xs)
utils.scm:        ((f (car xs)) (cons (car xs) (take-while f (cdr xs))))
utils.scm:(define (eager-any pred lst)
utils.scm:;; construct a table mapping each element of `lst` to its index (1-indexed)
utils.scm:(define (symbol-to-idx-map lst)
match.scm:; (head <p1> <p2> etc)   match an s-expr with 'head' matched literally,
match.scm:; (-/ <ex>)  match <ex> literally
match.scm:; (-^ <p>)   complement of pattern <p>
match.scm:; (-- <var> <p>)  match <p> and capture as <var> if match succeeds
match.scm:; (-s)       match any symbol
match.scm:; (-$ <p1> <p2> etc)  match any of subpatterns <p1>, <p2>, etc
match.scm:; (-* <p>)            match any number of <p>
match.scm:; (-? <p>)            match 0 or 1 of <p>
match.scm:; (-+ <p>)            match at least 1 of <p>
match.scm:; all of these can be wrapped in (-- var   ) for capturing purposes
match.scm:; This is NP-complete. Be careful.
match.scm:(define (match- p expr state)
match.scm:         (cond ((eq? (car p) '-/)
match.scm:               ((eq? (car p) '-^)
match.scm:                (and (not (match- (cadr p) expr state)) state))
match.scm:               ((eq? (car p) '--)
match.scm:                (and (match- (caddr p) expr state)
match.scm:               ((eq? (car p) '-$)  ; greedy alternation for toplevel pattern
match.scm:                (match-alt (cdr p) '() (list expr) state #f 1))
match.scm:               ((eq? (car p) '-s)
match.scm:                     (match-seq (cdr p) (cdr expr) state (length
match.scm:(define (match-alt alt prest expr state var L)
match.scm:      (let ((subma (match- (car alt) (car expr) state)))
match.scm:                 (match-seq prest (cdr expr)
match.scm:                            (- L 1)))
match.scm:            (match-alt (cdr alt) prest expr state var L)))))
match.scm:(define (match-star- p prest expr state var min max L sofar)
match.scm:   ((= max 0) (match-seq prest expr
match.scm:    (let ((subma (match- p (car expr) state)))
match.scm:           (match-star- p prest (cdr expr) subma var (- min 1) (- max 1) (- L 1)
match.scm:    (or (match-star- p prest expr state var 0 0   L sofar)
match.scm:        (match-star- p prest expr state var 1 max L sofar)))))
match.scm:(define (match-star p prest expr state var min max L)
match.scm:  (match-star- p prest expr state var min max L '()))
match.scm:(define (match-seq p expr state L)
match.scm:                           (eq? (car (car p)) '--))))
match.scm:                      (match-star '_ (cdr p) expr state var 0 L L))
match.scm:                     ((eq? head '-*)
match.scm:                      (match-star (cadr subp) (cdr p) expr state var 0 L L))
match.scm:                     ((eq? head '-+)
match.scm:                      (match-star (cadr subp) (cdr p) expr state var 1 L L))
match.scm:                     ((eq? head '-?)
match.scm:                      (match-star (cadr subp) (cdr p) expr state var 0 1 L))
match.scm:                     ((eq? head '-$)
match.scm:                      (match-alt (cdr subp) (cdr p) expr state var L))
match.scm:                           (match-seq (cdr p) (cdr expr)
match.scm:                                      (match- (car p) (car expr) state)
match.scm:                                      (- L 1)))))))))))
match.scm:(define (match p expr) (match- p expr (list (cons '__ expr))))
match.scm:; try to transform expr using a pattern-lambda from plist
match.scm:(define (apply-patterns plist expr)
match.scm:             (let* ((relevant (table-ref (vector-ref plist 1) (car expr) '()))
match.scm:                    (enew     (apply-patterns relevant expr)))
match.scm:                   (apply-patterns (vector-ref plist 2) expr)
match.scm:             (apply-patterns (vector-ref plist 2) expr)))
match.scm:               (apply-patterns (cdr plist) expr)
match.scm:; top-down fixed-point macroexpansion. this is a typical algorithm,
match.scm:; the advantage is that non-terminating cases cannot arise as a result
match.scm:; (pattern-lambda (/ 2 3) '(/ 3 2)), (pattern-lambda (/ 3 2) '(/ 2 3))
match.scm:(define (pattern-expand plist expr)
match.scm:      (let ((enew (apply-patterns plist expr)))
match.scm:                             (pattern-expand plist subex)))))
match.scm:            (pattern-expand plist enew)))))
match.scm:(define (pattern-expand1 plist expr)
match.scm:      (let ((enew (apply-patterns plist expr)))
match.scm:            (pattern-expand plist enew)))))
match.scm:(define (pattern-replace plist expr)
match.scm:      (let ((enew (apply-patterns plist expr)))
match.scm:                       (pattern-replace plist subex)))
match.scm:(define-macro (pattern-set . pats)
match.scm:  ; (pattern-lambda (x ...) ...) => x
match.scm:  (define (pl-head p) (car (cadr p)))
match.scm:                                 (eq? (car x) 'pattern-lambda)
match.scm:   (let ((heads (delete-duplicates (map pl-head pls)))
match.scm:     `(let ((,ht (make-table)))
match.scm:                 `(table-set! ,ht ',h (list
match.scm:                                                   (eq? (pl-head p) h))
match.scm:        (vector 'pattern-set ,ht (list ,@others))))))
match.scm:(define (plambda-expansion pat expr expander args)
match.scm:(define-macro (pattern-lambda pat body)
match.scm:  (define (patargs- p)
match.scm:           (if (eq? (car p) '-/)
match.scm:               (delete-duplicates (apply append (map patargs- (to-proper (cdr p)))))))
match.scm:    (cons '__ (patargs- p)))
match.scm:       (plambda-expansion ',pat __ex__ ,expander ',args))))
disasm.cpp://===------------- Disassembler for in-memory function --------------------===//
disasm.cpp:// Modified for use in The Julia Language from code in the  llvm-mc project:
disasm.cpp://      llvm-mc.cpp and Disassembler.cpp
disasm.cpp:// Copyright (c) 2003-2016 University of Illinois at Urbana-Champaign.
disasm.cpp://    University of Illinois at Urbana-Champaign
disasm.cpp://      Urbana-Champaign, nor the names of its contributors may be used to
disasm.cpp://===----------------------------------------------------------------------===//
disasm.cpp://===----------------------------------------------------------------------===//
disasm.cpp:#include "llvm-version.h"
disasm.cpp:            std::max(inline_depth + bracket_outer, (uint32_t)1) - 1,
disasm.cpp:    while (i.times-- > 0)
disasm.cpp:    this->inline_depth = 0;
disasm.cpp:        const DILineInfo &FrameLine = DI.at(nframes - 1 - nctx);
disasm.cpp:            StringRef method = StringRef(context.at(nctx - 1).FunctionName).rtrim(';'); // last matching frame
disasm.cpp:            if ((nctx < nframes && StringRef(DI.at(nframes - nctx - 1).FunctionName).rtrim(';') == method) ||
disasm.cpp:                while (nctx > 0 && StringRef(context.at(nctx - 1).FunctionName).rtrim(';') == method)
disasm.cpp:                    nctx -= 1;
disasm.cpp:            // look at the first non-matching element to see if we are only changing the line number
disasm.cpp:            const DILineInfo &FrameLine = DI.at(nframes - 1 - nctx);
disasm.cpp:        // look at the first non-matching element to see if we are only changing the line number
disasm.cpp:        const DILineInfo &FrameLine = DI.at(nframes - 1 - nctx);
disasm.cpp:            npops = context.size() - nctx;
disasm.cpp:        update_line_only && (npops -= 1);
disasm.cpp:            this->inline_depth -= npops;
disasm.cpp:        const DILineInfo &frame = DI.at(nframes - 1 - nctx);
disasm.cpp:            this->inline_depth += 1;
disasm.cpp:                const DILineInfo &frame = DI.at(nframes - 1 - nctx);
disasm.cpp:    assert(this->inline_depth == depth2);
disasm.cpp:    DISubprogram *FuncLoc = F->getSubprogram();
disasm.cpp:            FuncLoc = SP->second;
disasm.cpp:        DI.FunctionName = FuncLoc->getName().str();
disasm.cpp:        DI.FileName = FuncLoc->getFilename().str();
disasm.cpp:        DI.Line = FuncLoc->getLine();
disasm.cpp:    const DILocation *NewInstrLoc = I->getDebugLoc();
disasm.cpp:            NewInstrLoc = Loc->second;
disasm.cpp:            DIScope *scope = NewInstrLoc->getScope();
disasm.cpp:                DI.FunctionName = scope->getName().str();
disasm.cpp:            DI.FileName = NewInstrLoc->getFilename().str();
disasm.cpp:            DI.Line = NewInstrLoc->getLine();
disasm.cpp:            NewInstrLoc = NewInstrLoc->getInlinedAt();
disasm.cpp:    if (BB == &BB->getParent()->back())
disasm.cpp:    for (Function &f : m->functions()) {
disasm.cpp:            AAW->addSubprogram(&f, f.getSubprogram());
disasm.cpp:                    deletelast->eraseFromParent();
disasm.cpp:                    AAW->addDebugLoc(&inst, inst.getDebugLoc());
disasm.cpp:                deletelast->eraseFromParent();
disasm.cpp:        for (GlobalObject &g : m->global_objects()) {
disasm.cpp:    if (NamedMDNode *md = m->getNamedMetadata("llvm.dbg.cu"))
disasm.cpp:        m->eraseNamedMetadata(md);
disasm.cpp:    //if (NamedMDNode *md = m->getNamedMetadata("llvm.module.flags"))
disasm.cpp:    //    m->eraseNamedMetadata(md);
disasm.cpp:// warning: this takes ownership of, and destroys, f->getParent()
disasm.cpp:        if (!llvmf || (!llvmf->isDeclaration() && !llvmf->getParent()))
disasm.cpp:        if (!llvmf->getParent()) {
disasm.cpp:            // print the function declaration as-is
disasm.cpp:            llvmf->print(stream, &AAW);
disasm.cpp:            Module *m = llvmf->getParent();
disasm.cpp:                std::string llvmfn(llvmf->getName());
disasm.cpp:                llvmf = m->getFunction(llvmfn);
disasm.cpp:                m->print(stream, &AAW);
disasm.cpp:                llvmf->print(stream, &AAW);
disasm.cpp:    for (const object::SymbolRef &Sym : Section.getObject()->symbols()) {
disasm.cpp:        return hi - lo;
disasm.cpp:    jl_ptls_t ptls = jl_current_task->ptls;
disasm.cpp:    void setPass(int Pass) { this->Pass = Pass; }
disasm.cpp:    char *name = frame->func_name; // TODO: free me
disasm.cpp:    free(frame->file_name);
disasm.cpp:    object::section_iterator ESection = object->section_end();
disasm.cpp:    for (const object::SymbolRef &Sym : object->symbols()) {
disasm.cpp:        if (Sect->getAddress() == 0)
disasm.cpp:        uintptr_t rel = isymb->first - ip;
disasm.cpp:        uintptr_t addr = isymb->first;
disasm.cpp:            isymb->second = name;
disasm.cpp:                isymb->second = global;
disasm.cpp:                //Sym->second = name.str();
disasm.cpp:                Sym->second = global;
disasm.cpp:            Sym->second = local_name.str();
disasm.cpp:    return Sym->second.empty() ? NULL : Sym->second.c_str();
disasm.cpp:    if (Sym == Table.end() || Sym->second.empty())
disasm.cpp:    MCSymbol *symb = Ctx.getOrCreateSymbol(Sym->second);
disasm.cpp:    assert(symb->isUndefined());
disasm.cpp:    if (SymTab->getPass() != 0) {
disasm.cpp:            uint64_t addr = ReferenceValue + SymTab->getIP(); // probably pc-rel
disasm.cpp:            const char *symbolName = SymTab->lookupSymbolName(addr);
disasm.cpp:            uint64_t addr = ReferenceValue + SymTab->getIP();
disasm.cpp:            const char *symbolName = SymTab->lookupSymbolName(addr);
disasm.cpp:            uint64_t addr = ReferenceValue; // probably not pc-rel
disasm.cpp:            const char *symbolName = SymTab->lookupSymbolName(addr);
disasm.cpp:    PC += SymTab->getIP() - (uint64_t)(uintptr_t)SymTab->getMemoryObject().data(); // add offset from MemoryObject base
disasm.cpp:    // info->AddSymbol.Present = 1;
disasm.cpp:    // info->AddSymbol.Name = name;
disasm.cpp:    // info->AddSymbol.Value = pointer; // unused by LLVM
disasm.cpp:    // info->Value = 0;                 // offset
disasm.cpp:        // variable-length or (fixed-length) big-endian format
disasm.cpp:        TheTarget->createMCAsmInfo(*TheTarget->createMCRegInfo(TheTriple.str()), TheTriple.str(), Options));
disasm.cpp:    std::unique_ptr<MCRegisterInfo> MRI(TheTarget->createMCRegInfo(TheTriple.str()));
disasm.cpp:    MCSubtargetInfo *MSTI = TheTarget->createMCSubtargetInfo(TheTriple.str(), cpu, features);
disasm.cpp:    MOFI->initMCObjectFileInfo(Ctx, /* PIC */ false, /* LargeCodeModel */ false);
disasm.cpp:    MOFI->InitMCObjectFileInfo(TheTriple, /* PIC */ false, Ctx);
disasm.cpp:        STI(TheTarget->createMCSubtargetInfo(TheTriple.str(), cpu, features));
disasm.cpp:    std::unique_ptr<MCDisassembler> DisAsm(TheTarget->createMCDisassembler(*STI, Ctx));
disasm.cpp:    unsigned OutputAsmVariant = 0; // ATT or Intel-style assembly
disasm.cpp:            TheTarget->createMCInstrInfo());
disasm.cpp:            TheTarget->createMCInstrAnalysis(MCII.get()));
disasm.cpp:            TheTarget->createMCInstPrinter(TheTriple, OutputAsmVariant, *MAI, *MCII, *MRI));
disasm.cpp:    //IP->setPrintImmHex(true); // prefer hex or decimal immediates
disasm.cpp:        CE.reset(TheTarget->createMCCodeEmitter(*MCII, *MRI, Ctx));
disasm.cpp:        MAB.reset(TheTarget->createMCAsmBackend(*STI, *MRI, Options));
disasm.cpp:            TheTarget->createAsmStreamer(Ctx, std::move(ustream), /*asmverbose*/true,
disasm.cpp:    Streamer->InitSections(true);
disasm.cpp:        di_lineinfo = di_ctx->getLineInfoForAddressRange(makeAddress(Section, Fptr + slide), Fsize);
disasm.cpp:        Streamer->emitRawText(Stream.str());
disasm.cpp:            // MCIA->evaluateBranch. (It should be possible to rewrite
disasm.cpp:            DisAsm->setSymbolizer(std::unique_ptr<MCSymbolizer>(new MCExternalSymbolizer(
disasm.cpp:        uint64_t nextLineAddr = -1;
disasm.cpp:                nextLineAddr = di_lineIter->first;
disasm.cpp:                    dbgctx.emit_lineinfo(buf, di_lineIter->second);
disasm.cpp:                        Streamer->emitRawText(buf);
disasm.cpp:            if (pass != 0 && nextLineAddr != (uint64_t)-1 && Index + Fptr + slide == nextLineAddr) {
disasm.cpp:                    DIInliningInfo dbg = di_ctx->getInliningInfoForAddress(makeAddress(Section, Index + Fptr + slide), infoSpec);
disasm.cpp:                        dbgctx.emit_lineinfo(buf, di_lineIter->second);
disasm.cpp:                        Streamer->emitRawText(buf);
disasm.cpp:                    nextLineAddr = (++di_lineIter)->first;
disasm.cpp:                    Streamer->emitLabel(symbol);
disasm.cpp:            S = DisAsm->getInstruction(Inst, insSize, view, 0,
disasm.cpp:                                      /*CStream*/ pass != 0 ? Streamer->GetCommentOS() : nulls());
disasm.cpp:            if (pass != 0 && Streamer->GetCommentOS().tell() > 0)
disasm.cpp:                Streamer->GetCommentOS() << '\n';
disasm.cpp:                    Streamer->emitRawText(StringRef(buf.str()));
disasm.cpp:                    Streamer->emitRawText(StringRef("potentially undefined instruction encoding:"));
disasm.cpp:                        const MCInstrDesc &opcode = MCII->get(Inst.getOpcode());
disasm.cpp:                            if (MCIA->evaluateBranch(Inst, Fptr + Index, insSize, addr))
disasm.cpp:                        const MCInstrDesc &opinfo = MCII->get(Inst.getOpcode());
disasm.cpp:                                    Streamer->AddComment(name);
disasm.cpp:                        Streamer->emitRawText(rawCodeComment(memoryObject.slice(Index, insSize), TheTriple));
disasm.cpp:                    Streamer->emitInstruction(Inst, *STI);
disasm.cpp:                Streamer->emitRawText(buf);
disasm.cpp:    TargetPassConfig *PassConfig = TM->createPassConfig(PM);
disasm.cpp:    PassConfig->setDisableVerify(false);
disasm.cpp:    if (PassConfig->addISelPasses())
disasm.cpp:    PassConfig->addMachinePasses();
disasm.cpp:    PassConfig->setInitialized();
disasm.cpp:    return &MMIWP->getMMI().getContext();
disasm.cpp:        LinePrinter.emitFunctionAnnot(&MF->getFunction(), Stream);
disasm.cpp:        LinePrinter.emitInstructionAnnot(MI->getDebugLoc(), Stream);
disasm.cpp:        assert(!f->isDeclaration());
disasm.cpp:        std::unique_ptr<Module> m(f->getParent());
disasm.cpp:        for (auto &f2 : m->functions()) {
disasm.cpp:            if (f != &f2 && !f->isDeclaration())
disasm.cpp:            if (TM->addPassesToEmitFile(PM, obj_OS, nullptr, CGFT_ObjectFile, false, nullptr))
disasm.cpp:            Context->setGenDwarfForAssembly(false);
disasm.cpp:            const MCSubtargetInfo &STI = *TM->getMCSubtargetInfo();
disasm.cpp:            const MCAsmInfo &MAI = *TM->getMCAsmInfo();
disasm.cpp:            const MCRegisterInfo &MRI = *TM->getMCRegisterInfo();
disasm.cpp:            const MCInstrInfo &MII = *TM->getMCInstrInfo();
disasm.cpp:            MCInstPrinter *InstPrinter = TM->getTarget().createMCInstPrinter(
disasm.cpp:                TM->getTargetTriple(), OutputAsmDialect, MAI, MII, MRI);
disasm.cpp:             std::unique_ptr<MCAsmBackend> MAB(TM->getTarget().createMCAsmBackend(
disasm.cpp:                STI, MRI, TM->Options.MCOptions));
disasm.cpp:                MCE.reset(TM->getTarget().createMCCodeEmitter(MII, MRI, *Context));
disasm.cpp:            std::unique_ptr<MCStreamer> S(TM->getTarget().createAsmStreamer(
disasm.cpp:                TM->getTarget().createAsmPrinter(*TM, std::move(S)));
disasm.cpp:            Printer->addAsmPrinterHandler(AsmPrinter::HandlerInfo(
abi_x86_64.cpp://===-- abi_x86_64.cpp - x86_64 ABI description -----------------*- C++ -*-===//
abi_x86_64.cpp:// This file is distributed under the BSD-style LDC license:
abi_x86_64.cpp:// Copyright (c) 2007-2012 LDC Team.
abi_x86_64.cpp://===----------------------------------------------------------------------===//
abi_x86_64.cpp://===----------------------------------------------------------------------===//
abi_x86_64.cpp:        // is special-cased in classifyType()
abi_x86_64.cpp:                classes[1-idx] = Memory;
abi_x86_64.cpp:    } else if (ty->ty == jl_complex80_type) {
abi_x86_64.cpp:    else if (jl_datatype_size(dt) <= 16 && dt->layout) {
abi_x86_64.cpp:        assert(this->int_regs > 0 && "No int regs available when determining sret-ness?");
abi_x86_64.cpp:        this->int_regs--;
abi_x86_64.cpp:    if (wanted.int_regs <= this->int_regs && wanted.sse_regs <= this->sse_regs) {
abi_x86_64.cpp:        this->int_regs -= wanted.int_regs;
abi_x86_64.cpp:        this->sse_regs -= wanted.sse_regs;
abi_x86_64.cpp:            types[1] = Type::getIntNTy(ctx, (nbits-64));
gc.h:  . non-moving, precise mark and sweep collector
gc.h:  . pool-allocates small objects, keeps big objects on a simple list
gc.h:#define GC_PAGE_OFFSET (JL_HEAP_ALIGNMENT - (sizeof(jl_taggedvalue_t) % JL_HEAP_ALIGNMENT))
gc.h:    jl_gc_mark_data_t *data = (jl_gc_mark_data_t *)(((char*)sp->data) - size);
gc.h:    sp->data = data;
gc.h:// Re-push a frame to the mark stack (both data and pc)
gc.h:    jl_gc_mark_data_t *data = sp->data;
gc.h:    sp->pc++;
gc.h:    sp->data = (jl_gc_mark_data_t *)(((char*)sp->data) + size);
gc.h:#ifdef _P64 // Add padding so that the value is 64-byte aligned
gc.h:    // (8 pointers of 8 bytes each) - (4 other pointers in struct)
gc.h:    void *_padding[8 - 4];
gc.h:    // (16 pointers of 4 bytes each) - (4 other pointers in struct)
gc.h:    void *_padding[16 - 4];
gc.h:    // must be 64-byte aligned here, in 32 & 64 bit modes
gc.h://  Padding: GC_PAGE_OFFSET - sizeof(void*)
gc.h://    Data: <= osize - sizeof(jl_taggedvalue_t)
gc.h://  The complete address space is divided up into a multi-level page table.
gc.h://    - pagetable0_t: the bottom/leaf level (covers the contiguous addresses)
gc.h://    - pagetable1_t: the middle level
gc.h://    - pagetable2_t: the top/leaf level (covers the entire virtual address space)
gc.h:// define the representation of the levels of the page-table (0 to 2)
gc.h:    // an upper bound of the last non-free page
gc.h:    // an upper bound of the last non-free page
gc.h:    // an upper bound of the last non-free page
gc.h:    return __builtin_ffs(bitvec) - 1;
gc.h:    return (jl_taggedvalue_t*)(p->data + p->fl_begin_offset);
gc.h:    return (jl_taggedvalue_t*)(p->data + p->fl_end_offset);
gc.h:    pagetable0_t *r0 = r1->meta0[i];
gc.h:    return r0->meta[i];
gc.h:    info.pagetable0 = info.pagetable1->meta0[i];
gc.h:    info.meta = info.pagetable0->meta[i];
gc.h:    *hdr->prev = hdr->next;
gc.h:    if (hdr->next) {
gc.h:        hdr->next->prev = hdr->prev;
gc.h:    hdr->next = *list;
gc.h:    hdr->prev = list;
gc.h:        (*list)->prev = &hdr->next;
gc.h:    sp->pc = gc_cache->pc_stack;
gc.h:    sp->data = gc_cache->data_stack;
gc.h:    sp->pc_start = gc_cache->pc_stack;
gc.h:    sp->pc_end = gc_cache->pc_stack_end;
gen_sysimg_symtab.jl:#   3. cd src && ../julia --depwarn=no gen_sysimg_symtab.jl
gen_sysimg_symtab.jl:    sort!(Any[x.first for x in rts], by = x->rts[x], rev=true)
gen_sysimg_symtab.jl:filter!(s -> let str = string(s)
gen_sysimg_symtab.jl:open(f->foreach(l->outputline(f,l), take(syms, 100)), "common_symbols1.inc", "w")
gen_sysimg_symtab.jl:open(f->foreach(l->outputline(f,l), take(drop(syms, 100), 254)), "common_symbols2.inc", "w")
features_x86.h:JL_FEATURE_DEF_NAME(amx_bf16, 32 * 4 + 22, 110000, "amx-bf16")
features_x86.h:JL_FEATURE_DEF_NAME(amx_tile, 32 * 4 + 24, 110000, "amx-tile")
features_x86.h:JL_FEATURE_DEF_NAME(amx_int8, 32 * 4 + 25, 110000, "amx-int8")
llvm-pass-helpers.cpp:#include "llvm-version.h"
llvm-pass-helpers.cpp:#include "llvm-pass-helpers.h"
llvm-pass-helpers.cpp:            if (callInst->getCalledOperand() == pgcstack_getter) {
llvm-pass-helpers.cpp:    return module->getFunction(desc.name);
llvm-pass-helpers.cpp:        module->getFunctionList().push_back(func);
llvm-pass-helpers.cpp:        target->addAttribute(AttributeList::ReturnIndex, Attribute::NoAlias);
llvm-pass-helpers.cpp:        target->addAttribute(AttributeList::ReturnIndex, Attribute::NonNull);
llvm-pass-helpers.cpp:        target->addFnAttr(Attribute::getWithAllocSizeArgs(context, 1, None)); // returns %1 bytes
llvm-pass-helpers.cpp:            intrinsic->addAttribute(AttributeList::ReturnIndex, Attribute::NoAlias);
llvm-pass-helpers.cpp:            intrinsic->addAttribute(AttributeList::ReturnIndex, Attribute::NonNull);
llvm-pass-helpers.cpp:            intrinsic->addFnAttr(Attribute::InaccessibleMemOrArgMemOnly);
llvm-pass-helpers.cpp:            func->addFnAttr(Attribute::InaccessibleMemOrArgMemOnly);
intrinsics.cpp:  low-level intrinsics design:
intrinsics.cpp:   of a value. At the user-level, it is perhaps better known as reinterpret.
intrinsics.cpp:  all intrinsics have a non-compiled implementation, this file contains
intrinsics.cpp:// convert an llvm type to same-size float type
intrinsics.cpp:    if (t->isFloatingPointTy())
intrinsics.cpp:    unsigned nb = (t->isPointerTy() ? sizeof(void*) * 8 : t->getPrimitiveSizeInBits());
intrinsics.cpp:// convert an llvm type to same-size int type
intrinsics.cpp:    if (t->isIntegerTy())
intrinsics.cpp:    if (t->isPointerTy())
intrinsics.cpp:    unsigned nb = t->getPrimitiveSizeInBits();
intrinsics.cpp:    Type *t = x->getType();
intrinsics.cpp:    if (to->getPrimitiveSizeInBits() < x->getType()->getPrimitiveSizeInBits())
intrinsics.cpp:    if (lt->isFloatTy()) {
intrinsics.cpp:                APFloat(lt->getFltSemantics(), APInt(32, data32)));
intrinsics.cpp:    if (lt->isDoubleTy()) {
intrinsics.cpp:                APFloat(lt->getFltSemantics(), APInt(64, data64)));
intrinsics.cpp:    if (lt->isFloatingPointTy() || lt->isIntegerTy() || lt->isPointerTy()) {
intrinsics.cpp:        if (lt->isFloatingPointTy()) {
intrinsics.cpp:                    APFloat(lt->getFltSemantics(), val));
intrinsics.cpp:        if (lt->isPointerTy()) {
intrinsics.cpp:        assert(cast<IntegerType>(lt)->getBitWidth() == 8u * nb);
intrinsics.cpp:            uint8_t sel = ((const uint8_t*)ptr)[offs + fsz - 1];
intrinsics.cpp:            unsigned NumATy = (fsz - 1) / al;
intrinsics.cpp:            unsigned remainder = (fsz - 1) % al;
intrinsics.cpp:            while (NumATy--) {
intrinsics.cpp:                        active_sz -= al;
intrinsics.cpp:            while (remainder--) {
intrinsics.cpp:                    active_sz -= 1;
intrinsics.cpp:    if (lt->isVectorTy())
intrinsics.cpp:    Type *ty = unboxed->getType();
intrinsics.cpp:    bool frompointer = ty->isPointerTy();
intrinsics.cpp:    bool topointer = to->isPointerTy();
intrinsics.cpp:    else if (!ty->isIntOrPtrTy() && !ty->isFloatingPointTy()) {
intrinsics.cpp:        unboxed = ctx.builder.CreateLoad(to, ctx.builder.CreateBitCast(cast, to->getPointerTo()));
intrinsics.cpp:        Type *dest_ty = unboxed->getType()->getPointerTo();
intrinsics.cpp:        if (dest->getType() != dest_ty)
intrinsics.cpp:            unbox_load->setMetadata(LLVMContext::MD_range, MDNode::get(jl_LLVMContext, {
intrinsics.cpp:        Type *dest_ty = unboxed->getType()->getPointerTo();
intrinsics.cpp:        if (dest->getType() != dest_ty)
intrinsics.cpp:    Type *ptype = to->getPointerTo();
intrinsics.cpp:        if (p->getType() != ptype && isa<AllocaInst>(p)) {
intrinsics.cpp:            Type *AllocType = AI->getAllocatedType();
intrinsics.cpp:            if (!AI->isArrayAllocation() &&
intrinsics.cpp:                    (AllocType->isFloatingPointTy() || AllocType->isIntegerTy() || AllocType->isPointerTy()) &&
intrinsics.cpp:                    (to->isFloatingPointTy() || to->isIntegerTy() || to->isPointerTy()) &&
intrinsics.cpp:                        vxt == T_int1 ? T_pint8 : vxt->getPointerTo())));
intrinsics.cpp:    vxt = vx->getType();
intrinsics.cpp:        else if (vxt->isPointerTy() && !llvmt->isPointerTy())
intrinsics.cpp:        else if (!vxt->isPointerTy() && llvmt->isPointerTy())
intrinsics.cpp:        Value *jlfloattemp_var = emit_static_alloca(ctx, from->getType());
intrinsics.cpp:            Value *thePtr = emit_unbox(ctx, ptrty->getPointerTo(), e, e.typ);
intrinsics.cpp:            thePtr = emit_unbox(ctx, ptrty->getPointerTo(), e, e.typ);
intrinsics.cpp:        load->setOrdering(llvm_order);
intrinsics.cpp:    if ((nb & (nb - 1)) != 0 || nb > MAX_POINTERATOMIC_SIZE) {
intrinsics.cpp:        thePtr = emit_bitcast(ctx, thePtr, loadT->getPointerTo());
intrinsics.cpp:        load->setOrdering(llvm_order);
intrinsics.cpp:        thePtr = emit_bitcast(ctx, strct, thePtr->getType());
intrinsics.cpp:            Value *thePtr = emit_unbox(ctx, ptrty->getPointerTo(), e, e.typ);
intrinsics.cpp:    if ((nb & (nb - 1)) != 0 || nb > MAX_POINTERATOMIC_SIZE) {
intrinsics.cpp:        Value *thePtr = emit_unbox(ctx, ptrty->getPointerTo(), e, e.typ);
intrinsics.cpp:    Type *t = den->getType();
intrinsics.cpp:    ctx.builder.CreateCondBr(ctx.builder.CreateICmpEQ(den ,ConstantInt::get(t, -1, true)),
intrinsics.cpp:    ret->addIncoming(// rem(typemin, -1) is undefined
intrinsics.cpp:    ret->addIncoming(sremval, okBB);
intrinsics.cpp:// Temporarily switch the ctx.builder to fast-math mode if requested
intrinsics.cpp:        // to instantiate a union-split optimization
intrinsics.cpp:                if (x_ptr->getType() != y_ptr->getType())
intrinsics.cpp:                    y_ptr = ctx.builder.CreateBitCast(y_ptr, x_ptr->getType());
intrinsics.cpp:                // compute tindex if we select the previously-boxed value
intrinsics.cpp:                    ret->addIncoming(x_tindex, ctx.builder.GetInsertBlock());
intrinsics.cpp:                    ret->addIncoming(y_tindex, ctx.builder.GetInsertBlock());
intrinsics.cpp:                ret->addIncoming(tindex, compute);
intrinsics.cpp:                    x_vboxed = ConstantPointerNull::get(cast<PointerType>(y_vboxed->getType()));
intrinsics.cpp:                    y_vboxed = ConstantPointerNull::get(cast<PointerType>(x_vboxed->getType()));
intrinsics.cpp:                assert(ret.Vboxed->getType() == T_prjlvalue);
intrinsics.cpp:    // this forces everything to use runtime-intrinsics (e.g. for testing)
intrinsics.cpp:        if (!jl_is_datatype(typ) || ((jl_datatype_t*)typ)->name != jl_array_typename)
intrinsics.cpp:            ans = ctx.builder.CreateXor(from, ConstantInt::get(xt, -1, true));
intrinsics.cpp:        if (newtyp == (jl_value_t*)jl_bool_type && r->getType() != T_int1)
intrinsics.cpp:    Type *t = x->getType();
intrinsics.cpp:        assert(y->getType() == x->getType());
intrinsics.cpp:        assert(z->getType() == y->getType());
intrinsics.cpp:        assert(x->getType() == y->getType());
intrinsics.cpp:        Value *typemin = ctx.builder.CreateShl(ConstantInt::get(t, 1), t->getPrimitiveSizeInBits() - 1);
intrinsics.cpp:                        ctx.builder.CreateICmpNE(y, ConstantInt::get(t, -1, true)),
intrinsics.cpp:        if (ConstantInt::isValueValidForType(y->getType(), t->getPrimitiveSizeInBits())) {
intrinsics.cpp:                    ctx.builder.CreateICmpUGE(y, ConstantInt::get(y->getType(),
intrinsics.cpp:                                                                  t->getPrimitiveSizeInBits())),
intrinsics.cpp:        if (ConstantInt::isValueValidForType(y->getType(), t->getPrimitiveSizeInBits())) {
intrinsics.cpp:                    ctx.builder.CreateICmpUGE(y, ConstantInt::get(y->getType(),
intrinsics.cpp:                                                                  t->getPrimitiveSizeInBits())),
intrinsics.cpp:        if (ConstantInt::isValueValidForType(y->getType(), t->getPrimitiveSizeInBits())) {
intrinsics.cpp:                    ctx.builder.CreateICmpUGE(y, ConstantInt::get(y->getType(),
intrinsics.cpp:                                                                  t->getPrimitiveSizeInBits())),
intrinsics.cpp:                    ctx.builder.CreateAShr(x, ConstantInt::get(t, t->getPrimitiveSizeInBits() - 1)),
intrinsics.cpp:            APInt ix = cx->getValue();
intrinsics.cpp:            APInt iy = cy->getValue();
intrinsics.cpp:            return ConstantInt::get(t, iy.isNonNegative() ? ix : -ix);
intrinsics.cpp:            APInt iy = cy->getValue();
intrinsics.cpp:        Value *tmp = ctx.builder.CreateAShr(y, ConstantInt::get(t, cast<IntegerType>(t)->getBitWidth() - 1));
uv_constants.h:# define UV__ERR(x) (-(x))
uv_constants.h:        @eval const $(handles[i]) = $(i - 1)
uv_constants.h:        @eval const $(reqs[i]) = $(i - 1)
processor_arm.cpp:    -1);
processor_arm.cpp:    feature_masks & FeatureList<feature_sz>{{(uint32_t)-1, (uint32_t)-1, 0}};
processor_arm.cpp://     .AES: sve2-aes, sve2-pmull
processor_arm.cpp://     .BitPerm: sve2-bitperm
processor_arm.cpp://     .SHA3: sve2-sha3
processor_arm.cpp://     .SM4: sve2-sm4
processor_arm.cpp:    {"armv8.1-a", CPU::armv8_1_a, CPU::generic, 0, Feature::armv8_1a},
processor_arm.cpp:    {"armv8.2-a", CPU::armv8_2_a, CPU::generic, 0, Feature::armv8_2a},
processor_arm.cpp:    {"armv8.4-a", CPU::armv8_4_a, CPU::generic, 0, Feature::armv8_4a},
processor_arm.cpp:    {"armv8.5-a", CPU::armv8_5_a, CPU::generic, 0, Feature::armv8_5a},
processor_arm.cpp:    {"cortex-a34", CPU::arm_cortex_a34, CPU::arm_cortex_a35, 110000, Feature::arm_cortex_a34},
processor_arm.cpp:    {"cortex-a35", CPU::arm_cortex_a35, CPU::generic, 0, Feature::arm_cortex_a35},
processor_arm.cpp:    {"cortex-a53", CPU::arm_cortex_a53, CPU::generic, 0, Feature::arm_cortex_a53},
processor_arm.cpp:    {"cortex-a55", CPU::arm_cortex_a55, CPU::generic, 0, Feature::arm_cortex_a55},
processor_arm.cpp:    {"cortex-a57", CPU::arm_cortex_a57, CPU::generic, 0, Feature::arm_cortex_a57},
processor_arm.cpp:    {"cortex-a65", CPU::arm_cortex_a65, CPU::arm_cortex_a75, 100000, Feature::arm_cortex_a65},
processor_arm.cpp:    {"cortex-a65ae", CPU::arm_cortex_a65ae, CPU::arm_cortex_a75, 100000, Feature::arm_cortex_a65},
processor_arm.cpp:    {"cortex-a72", CPU::arm_cortex_a72, CPU::generic, 0, Feature::arm_cortex_a72},
processor_arm.cpp:    {"cortex-a73", CPU::arm_cortex_a73, CPU::generic, 0, Feature::arm_cortex_a73},
processor_arm.cpp:    {"cortex-a75", CPU::arm_cortex_a75, CPU::generic, 0, Feature::arm_cortex_a75},
processor_arm.cpp:    {"cortex-a76", CPU::arm_cortex_a76, CPU::generic, 0, Feature::arm_cortex_a76},
processor_arm.cpp:    {"cortex-a76ae", CPU::arm_cortex_a76ae, CPU::generic, 0, Feature::arm_cortex_a76},
processor_arm.cpp:    {"cortex-a77", CPU::arm_cortex_a77, CPU::arm_cortex_a76, 110000, Feature::arm_cortex_a77},
processor_arm.cpp:    {"cortex-a78", CPU::arm_cortex_a78, CPU::arm_cortex_a77, 110000, Feature::arm_cortex_a78},
processor_arm.cpp:    {"cortex-x1", CPU::arm_cortex_x1, CPU::arm_cortex_a78, 110000, Feature::arm_cortex_x1},
processor_arm.cpp:    {"neoverse-e1", CPU::arm_neoverse_e1, CPU::arm_cortex_a76, 100000, Feature::arm_neoverse_e1},
processor_arm.cpp:    {"neoverse-n1", CPU::arm_neoverse_n1, CPU::arm_cortex_a76, 100000, Feature::arm_neoverse_n1},
processor_arm.cpp:    {"neoverse-v1", CPU::arm_neoverse_v1, CPU::arm_neoverse_n1, UINT32_MAX, Feature::arm_neoverse_v1},
processor_arm.cpp:    {"neoverse-n2", CPU::arm_neoverse_n2, CPU::arm_neoverse_n1, UINT32_MAX, Feature::arm_neoverse_n2},
processor_arm.cpp:    {"exynos-m1", CPU::samsung_exynos_m1, CPU::generic, UINT32_MAX, Feature::samsung_exynos_m1},
processor_arm.cpp:    {"exynos-m2", CPU::samsung_exynos_m2, CPU::generic, UINT32_MAX, Feature::samsung_exynos_m2},
processor_arm.cpp:    {"exynos-m3", CPU::samsung_exynos_m3, CPU::generic, 0, Feature::samsung_exynos_m3},
processor_arm.cpp:    {"exynos-m4", CPU::samsung_exynos_m4, CPU::generic, 0, Feature::samsung_exynos_m4},
processor_arm.cpp:    {"exynos-m5", CPU::samsung_exynos_m5, CPU::samsung_exynos_m4, 110000,
processor_arm.cpp:    {"apple-a7", CPU::apple_a7, CPU::generic, 100000, Feature::apple_a7},
processor_arm.cpp:    {"apple-a8", CPU::apple_a8, CPU::generic, 100000, Feature::apple_a7},
processor_arm.cpp:    {"apple-a9", CPU::apple_a9, CPU::generic, 100000, Feature::apple_a7},
processor_arm.cpp:    {"apple-a10", CPU::apple_a10, CPU::generic, 100000, Feature::apple_a10},
processor_arm.cpp:    {"apple-a11", CPU::apple_a11, CPU::generic, 100000, Feature::apple_a11},
processor_arm.cpp:    {"apple-a12", CPU::apple_a12, CPU::generic, 100000, Feature::apple_a12},
processor_arm.cpp:    {"apple-a13", CPU::apple_a13, CPU::generic, 100000, Feature::apple_a13},
processor_arm.cpp:    {"apple-s4", CPU::apple_s4, CPU::generic, 100000, Feature::apple_s4},
processor_arm.cpp:    {"apple-s5", CPU::apple_s5, CPU::generic, 100000, Feature::apple_s5},
processor_arm.cpp:    -1);
processor_arm.cpp:    feature_masks & FeatureList<feature_sz>{{(uint32_t)-1, (uint32_t)-1, 0}};
processor_arm.cpp:// This makes sure that, for example, the `generic` target on `armv7-a` binary is equivalent
processor_arm.cpp:// to the `armv7-a` target.
processor_arm.cpp:    {"arm1136jf-s", CPU::arm_1136jf_s, CPU::generic, 0, Feature::generic},
processor_arm.cpp:    {"arm1156t2f-s", CPU::arm_1156t2f_s, CPU::generic, 0, Feature::generic},
processor_arm.cpp:    {"arm1176jzf-s", CPU::arm_1176jzf_s, CPU::generic, 0, Feature::generic},
processor_arm.cpp:    {"cortex-m0", CPU::arm_cortex_m0, CPU::generic, 0, Feature::generic},
processor_arm.cpp:    {"cortex-m1", CPU::arm_cortex_m1, CPU::generic, 0, Feature::generic},
processor_arm.cpp:    {"armv7-m", CPU::armv7_m, CPU::generic, 0, Feature::armv7m},
processor_arm.cpp:    {"armv7e-m", CPU::armv7e_m, CPU::generic, 0, Feature::armv7m},
processor_arm.cpp:    {"cortex-m3", CPU::arm_cortex_m3, CPU::generic, 0, Feature::armv7m},
processor_arm.cpp:    {"cortex-m4", CPU::arm_cortex_m4, CPU::generic, 0, Feature::armv7m},
processor_arm.cpp:    {"cortex-m7", CPU::arm_cortex_m7, CPU::generic, 0, Feature::armv7m},
processor_arm.cpp:    {"armv7-a", CPU::armv7_a, CPU::generic, 0, Feature::armv7a},
processor_arm.cpp:    {"armv7-r", CPU::armv7_r, CPU::generic, 0, Feature::armv7r},
processor_arm.cpp:    {"cortex-a5", CPU::arm_cortex_a5, CPU::generic, 0, Feature::arm_cortex_a5},
processor_arm.cpp:    {"cortex-a7", CPU::arm_cortex_a7, CPU::generic, 0, Feature::arm_cortex_a7},
processor_arm.cpp:    {"cortex-a8", CPU::arm_cortex_a8, CPU::generic, 0, Feature::arm_cortex_a8},
processor_arm.cpp:    {"cortex-a9", CPU::arm_cortex_a9, CPU::generic, 0, Feature::arm_cortex_a9},
processor_arm.cpp:    {"cortex-a12", CPU::arm_cortex_a12, CPU::generic, 0, Feature::arm_cortex_a12},
processor_arm.cpp:    {"cortex-a15", CPU::arm_cortex_a15, CPU::generic, 0, Feature::arm_cortex_a15},
processor_arm.cpp:    {"cortex-a17", CPU::arm_cortex_a17, CPU::generic, 0, Feature::arm_cortex_a17},
processor_arm.cpp:    {"cortex-r4", CPU::arm_cortex_r4, CPU::generic, 0, Feature::arm_cortex_r4},
processor_arm.cpp:    {"cortex-r5", CPU::arm_cortex_r5, CPU::generic, 0, Feature::arm_cortex_r5},
processor_arm.cpp:    {"cortex-r7", CPU::arm_cortex_r7, CPU::generic, 0, Feature::arm_cortex_r7},
processor_arm.cpp:    {"cortex-r8", CPU::arm_cortex_r8, CPU::generic, 0, Feature::arm_cortex_r8},
processor_arm.cpp:    {"armv8-m.base", CPU::armv8_m_base, CPU::generic, 0, Feature::armv8m},
processor_arm.cpp:    {"armv8-m.main", CPU::armv8_m_main, CPU::generic, 0, Feature::armv8m},
processor_arm.cpp:    {"cortex-m23", CPU::arm_cortex_m23, CPU::armv8_m_base, 0, Feature::arm_cortex_m23},
processor_arm.cpp:    {"cortex-m33", CPU::arm_cortex_m33, CPU::armv8_m_main, 0, Feature::arm_cortex_m33},
processor_arm.cpp:    {"armv8-a", CPU::armv8_a, CPU::generic, 0, Feature::armv8a},
processor_arm.cpp:    {"armv8-r", CPU::armv8_r, CPU::generic, 0, Feature::armv8r},
processor_arm.cpp:    {"armv8.1-a", CPU::armv8_1_a, CPU::generic, 0, Feature::armv8_1a},
processor_arm.cpp:    {"armv8.2-a", CPU::armv8_2_a, CPU::generic, 0, Feature::armv8_2a},
processor_arm.cpp:    {"armv8.3-a", CPU::armv8_3_a, CPU::generic, 0, Feature::armv8_3a},
processor_arm.cpp:    {"armv8.4-a", CPU::armv8_4_a, CPU::generic, 0, Feature::armv8_4a},
processor_arm.cpp:    {"armv8.5-a", CPU::armv8_5_a, CPU::generic, 0, Feature::armv8_5a},
processor_arm.cpp:    {"cortex-a32", CPU::arm_cortex_a32, CPU::generic, 0, Feature::arm_cortex_a32},
processor_arm.cpp:    {"cortex-r52", CPU::arm_cortex_r52, CPU::generic, 0, Feature::arm_cortex_r52},
processor_arm.cpp:    {"cortex-a35", CPU::arm_cortex_a35, CPU::generic, 0, Feature::arm_cortex_a35},
processor_arm.cpp:    {"cortex-a53", CPU::arm_cortex_a53, CPU::generic, 0, Feature::arm_cortex_a53},
processor_arm.cpp:    {"cortex-a55", CPU::arm_cortex_a55, CPU::generic, 0, Feature::arm_cortex_a55},
processor_arm.cpp:    {"cortex-a57", CPU::arm_cortex_a57, CPU::generic, 0, Feature::arm_cortex_a57},
processor_arm.cpp:    {"cortex-a72", CPU::arm_cortex_a72, CPU::generic, 0, Feature::arm_cortex_a72},
processor_arm.cpp:    {"cortex-a73", CPU::arm_cortex_a73, CPU::generic, 0, Feature::arm_cortex_a73},
processor_arm.cpp:    {"cortex-a75", CPU::arm_cortex_a75, CPU::generic, 0, Feature::arm_cortex_a75},
processor_arm.cpp:    {"cortex-a76", CPU::arm_cortex_a76, CPU::generic, 0, Feature::arm_cortex_a76},
processor_arm.cpp:    {"cortex-a76ae", CPU::arm_cortex_a76ae, CPU::generic, 0, Feature::arm_cortex_a76},
processor_arm.cpp:    {"cortex-a77", CPU::arm_cortex_a77, CPU::arm_cortex_a76, 110000, Feature::arm_cortex_a77},
processor_arm.cpp:    {"cortex-a78", CPU::arm_cortex_a78, CPU::arm_cortex_a77, 110000, Feature::arm_cortex_a78},
processor_arm.cpp:    {"cortex-x1", CPU::arm_cortex_x1, CPU::arm_cortex_a78, 110000, Feature::arm_cortex_x1},
processor_arm.cpp:    {"neoverse-n1", CPU::arm_neoverse_n1, CPU::arm_cortex_a76, 100000, Feature::arm_neoverse_n1},
processor_arm.cpp:    {"neoverse-v1", CPU::arm_neoverse_v1, CPU::arm_neoverse_n1, UINT32_MAX, Feature::arm_neoverse_v1},
processor_arm.cpp:    {"neoverse-n2", CPU::arm_neoverse_n2, CPU::arm_neoverse_n1, UINT32_MAX, Feature::arm_neoverse_n2},
processor_arm.cpp:    {"exynos-m1", CPU::samsung_exynos_m1, CPU::generic, UINT32_MAX, Feature::samsung_exynos_m1},
processor_arm.cpp:    {"exynos-m2", CPU::samsung_exynos_m2, CPU::generic, UINT32_MAX, Feature::samsung_exynos_m2},
processor_arm.cpp:    {"exynos-m3", CPU::samsung_exynos_m3, CPU::generic, 0, Feature::samsung_exynos_m3},
processor_arm.cpp:    {"exynos-m4", CPU::samsung_exynos_m4, CPU::generic, 0, Feature::samsung_exynos_m4},
processor_arm.cpp:    {"exynos-m5", CPU::samsung_exynos_m5, CPU::samsung_exynos_m4, 110000,
processor_arm.cpp:    {"apple-a7", CPU::apple_a7, CPU::generic, 0, Feature::apple_a7},
processor_arm.cpp:    if (fd == -1)
processor_arm.cpp:        if (entry->d_type != DT_DIR)
processor_arm.cpp:        if (strncmp(entry->d_name, "cpu", 3) != 0)
processor_arm.cpp:        llvm::raw_string_ostream(stm) << "/sys/devices/system/cpu/" << entry->d_name << "/regs/identification/midr_el1";
processor_arm.cpp:        // x-gene 2
processor_arm.cpp:        // x-gene 3
processor_arm.cpp:            // kryo 5xx seems to be using ID for cortex-a77 directly
processor_arm.cpp:        // https://opensource.apple.com/source/xnu/xnu-6153.81.5/osfmk/arm/cpuid.h.auto.html
processor_arm.cpp:    auto feature_arch = feature_arch_version(spec->features);
processor_arm.cpp:        return -1;
processor_arm.cpp:    int maxidx = -1;
processor_arm.cpp:                    return idx != -1 && idx < maxidx;
processor_arm.cpp:    // (Observed for exynos 9810 with exynos-m3 + cortex-a55) we'll compute
processor_arm.cpp:                extra_features = extra_features & find_cpu(name)->features;
processor_arm.cpp:                extra_features = find_cpu(name)->features;
processor_arm.cpp:        return "neoverse-n1";
processor_arm.cpp:        return "neoverse-v1";
processor_arm.cpp:        return "apple-a7";
processor_arm.cpp:        return "apple-a8";
processor_arm.cpp:        return "apple-a9";
processor_arm.cpp:        return "apple-a10";
processor_arm.cpp:        if (fbit == (uint32_t)-1)
processor_arm.cpp:        cpu_features = &spec->features;
processor_arm.cpp:        if (spec->llvmver <= JL_LLVM_VERSION)
processor_arm.cpp:        spec = find_cpu((uint32_t)spec->fallback);
processor_arm.cpp:        name = spec->name;
processor_arm.cpp:        if (is_generic_cpu_name((uint32_t)spec->cpu)) {
processor_arm.cpp:            features = features | spec->features;
processor_arm.cpp:    if (name == "apple-a7")
processor_arm.cpp:            feature_strs.push_back(std::string("-") + fename_str);
processor_arm.cpp:        feature_strs.push_back("+armv8-m.main");
processor_arm.cpp:            feature_strs.push_back("+armv8-a");
processor_arm.cpp:            feature_strs.push_back("+armv8-r");
processor_arm.cpp:            feature_strs.push_back("+armv8-m.base");
processor_arm.cpp:            feature_strs.push_back("+armv7-a");
processor_arm.cpp:            feature_strs.push_back("+armv7-r");
processor_arm.cpp:            feature_strs.push_back("+armv7-m");
processor_arm.cpp:    feature_strs.push_back("+fp-armv8");
jsvm-emscripten/asyncify_setup.js:    next_ctx = -1;
jsvm-emscripten/asyncify_setup.js:    assert(next_ctx != -1);
ast.c:  components of the front-end, for obtaining and translating syntax trees
ast.c:        next->prev = &node->next;
ast.c:    node->next = next;
ast.c:    node->prev = head;
ast.c:    if (node->next)
ast.c:        node->next->prev = node->prev;
ast.c:    *node->prev = node->next;
ast.c:    jl_module_t *module; // context module for `current-julia-module-counter`
ast.c:    jl_module_t *(old) = ctx->module;           \
ast.c:    ctx->module = (inmodule)
ast.c:    ctx->module = (old)
ast.c:    argcount(fl_ctx, "defined-julia-global", nargs, 1);
ast.c:    (void)tosymbol(fl_ctx, args[0], "defined-julia-global");
ast.c:    jl_binding_t *b = jl_get_module_binding(ctx->module, var);
ast.c:    return (b != NULL && b->owner == ctx->module) ? fl_ctx->T : fl_ctx->F;
ast.c:    assert(ctx->module);
ast.c:    return fixnum(jl_module_next_counter(ctx->module));
ast.c:// Check whether v is a scalar for purposes of inlining fused-broadcast
ast.c:    argcount(fl_ctx, "julia-scalar?", nargs, 1);
ast.c:        return fl_ctx->T;
ast.c:    else if (iscvalue(args[0]) && fl_ctx->jl_sym == cv_type((cvalue_t*)ptr(args[0]))) {
ast.c:            return fl_ctx->T;
ast.c:    return fl_ctx->F;
ast.c:    int kwargs_len = (int)nargs - 6;
ast.c:        lerror(fl_ctx, fl_ctx->ArgError, "julia-logmsg: bad argument list - expected "
ast.c:        lerror(fl_ctx, fl_ctx->ArgError,
ast.c:               "julia-logmsg: Unexpected type in argument list");
ast.c:    return fl_ctx->T;
ast.c:    { "defined-julia-global", fl_defined_julia_global },
ast.c:    { "current-julia-module-counter", fl_current_module_counter },
ast.c:    { "julia-scalar?", fl_julia_scalar },
ast.c:    { "julia-logmsg", fl_julia_logmsg },
ast.c:    { "julia-current-file", fl_julia_current_file },
ast.c:    { "julia-current-line", fl_julia_current_line },
ast.c:    fl_context_t *fl_ctx = &ast_ctx->fl;
ast.c:    ctx->jvtype = define_opaque_type(fl_ctx->jl_sym, sizeof(void*), NULL, NULL);
ast.c:    ctx->true_sym = symbol(fl_ctx, "true");
ast.c:    ctx->false_sym = symbol(fl_ctx, "false");
ast.c:    ctx->error_sym = symbol(fl_ctx, "error");
ast.c:    ctx->null_sym = symbol(fl_ctx, "null");
ast.c:    ctx->ssavalue_sym = symbol(fl_ctx, "ssavalue");
ast.c:    ctx->slot_sym = symbol(fl_ctx, "slot");
ast.c:    ctx->task = NULL;
ast.c:    ctx->module = NULL;
ast.c:    set(symbol(fl_ctx, "*depwarn-opt*"), fixnum(jl_options.depwarn));
ast.c:    set(symbol(fl_ctx, "*scopewarn-opt*"), fixnum(jl_options.warn_scope));
ast.c:    for (node = jl_ast_ctx_using;node;(node = node->next)) {
ast.c:        if (ctx->task == ct) {
ast.c:            ctx->ref++;
ast.c:        ctx->ref = 1;
ast.c:        ctx->task = ct;
ast.c:        ctx->module = NULL;
ast.c:    ctx->ref = 1;
ast.c:    ctx->task = ct;
ast.c:    node = &ctx->list;
ast.c:    if (--ctx->ref)
ast.c:    ctx->task = NULL;
ast.c:    jl_ast_context_list_t *node = &ctx->list;
ast.c:    jl_hygienicscope_sym = jl_symbol("hygienic-scope");
ast.c:    // Make `--lisp` sigatomic in order to avoid triggering the sigint safepoint.
ast.c:    fl_context_t *fl_ctx = &ctx->fl;
ast.c:    fl_applyn(fl_ctx, 1, symbol_value(symbol(fl_ctx, "__start")), fl_cons(fl_ctx, fl_ctx->NIL,fl_ctx->NIL));
ast.c:    fl_context_t *fl_ctx = &ctx->fl;
ast.c:    fl_applyn(fl_ctx, 0, symbol_value(symbol(fl_ctx, "show-profiles")));
ast.c:    fl_context_t *fl_ctx = &ctx->fl;
ast.c:    fl_applyn(fl_ctx, 0, symbol_value(symbol(fl_ctx, "clear-profiles")));
ast.c:    fl_context_t *fl_ctx = &ctx->fl;
ast.c:    fl_applyn(fl_ctx, 1, symbol_value(symbol(fl_ctx, "profile-e")), symbol(fl_ctx, fname));
ast.c:        char *n = uint2str(&gsname[1], sizeof(gsname)-1,
ast.c:                           ((gensym_t*)ptr(s))->id, 10);
ast.c:        *(--n) = '#';
ast.c:        jl_array_ptr_set(ex->args, 0, jl_cstr_to_string("invalid AST"));
ast.c:    if (iscons(e) || e == fl_ctx->NIL) {
ast.c:        if (e == fl_ctx->NIL) {
ast.c:            if (hd == jl_ast_ctx(fl_ctx)->ssavalue_sym)
ast.c:            else if (hd == jl_ast_ctx(fl_ctx)->slot_sym)
ast.c:            else if (hd == jl_ast_ctx(fl_ctx)->null_sym && llength(e) == 1)
ast.c:            else if (hd == jl_ast_ctx(fl_ctx)->true_sym && llength(e) == 1)
ast.c:            else if (hd == jl_ast_ctx(fl_ctx)->false_sym && llength(e) == 1)
ast.c:        size_t n = llength(e)-1;
ast.c:            jl_array_ptr_set(((jl_expr_t*)ex)->args, i, scm_to_julia_(fl_ctx, car_(e), mod));
ast.c:            return (jl_value_t*)((jl_expr_t*)ex)->args;
ast.c:    if (iscprim(e) && cp_class((cprim_t*)ptr(e)) == fl_ctx->wchartype) {
ast.c:    if (iscvalue(e) && cv_class((cvalue_t*)ptr(e)) == jl_ast_ctx(fl_ctx)->jvtype) {
ast.c:        temp = fl_ctx->lasterror;
ast.c:    for(long i=jl_array_len(a)-1; i >= 0; i--) {
ast.c:        *pv = fl_cons(fl_ctx, fl_ctx->NIL, *pv);
ast.c:        *retval = fl_cons(fl_ctx, jl_ast_ctx(fl_ctx)->true_sym, fl_ctx->NIL);
ast.c:        *retval = fl_cons(fl_ctx, jl_ast_ctx(fl_ctx)->false_sym, fl_ctx->NIL);
ast.c:        *retval = fl_cons(fl_ctx, jl_ast_ctx(fl_ctx)->null_sym, fl_ctx->NIL);
ast.c:    value_t opaque = cvalue(fl_ctx, jl_ast_ctx(fl_ctx)->jvtype, sizeof(void*));
ast.c:        value_t args = fl_ctx->NIL;
ast.c:        if (jl_expr_nargs(ex) > 520000 && ex->head != jl_block_sym)
ast.c:        array_to_list(fl_ctx, ex->args, &args, check_valid);
ast.c:        value_t hd = julia_to_scm_(fl_ctx, (jl_value_t*)ex->head, check_valid);
ast.c:        if (ex->head == jl_lambda_sym && jl_expr_nargs(ex)>0 && jl_is_array(jl_exprarg(ex,0))) {
ast.c:            value_t llist = fl_ctx->NIL;
ast.c:// Parse `text` starting at 0-based `offset` and attributing the content to
ast.c:    fl_context_t *fl_ctx = &ctx->fl;
ast.c:        value_t e = fl_applyn(fl_ctx, 2, symbol_value(symbol(fl_ctx, "jl-parse-all")),
ast.c:        offset1 = e == fl_ctx->FL_EOF ? text_len : 0;
ast.c:        value_t greedy = rule == jl_statement_sym ? fl_ctx->T : fl_ctx->F;
ast.c:        value_t p = fl_applyn(fl_ctx, 4, symbol_value(symbol(fl_ctx, "jl-parse-one")),
ast.c:    expr = fl_expr == fl_ctx->FL_EOF ? jl_nothing : scm_to_julia(fl_ctx, fl_expr, NULL);
ast.c:    fl_context_t *fl_ctx = &ctx->fl;
ast.c:    fl_context_t *fl_ctx = &ctx->fl;
ast.c:        new_code = jl_array_copy(new_ci->code);
ast.c:        new_ci->code = new_code;
ast.c:        new_ci->slotnames = jl_array_copy(new_ci->slotnames);
ast.c:        jl_gc_wb(new_ci, new_ci->slotnames);
ast.c:        new_ci->slotflags = jl_array_copy(new_ci->slotflags);
ast.c:        jl_gc_wb(new_ci, new_ci->slotflags);
ast.c:        new_ci->codelocs = (jl_value_t*)jl_array_copy((jl_array_t*)new_ci->codelocs);
ast.c:        jl_gc_wb(new_ci, new_ci->codelocs);
ast.c:        new_ci->linetable = (jl_value_t*)jl_array_copy((jl_array_t*)new_ci->linetable);
ast.c:        jl_gc_wb(new_ci, new_ci->linetable);
ast.c:        new_ci->ssaflags = jl_array_copy(new_ci->ssaflags);
ast.c:        jl_gc_wb(new_ci, new_ci->ssaflags);
ast.c:        if (new_ci->edges != jl_nothing) {
ast.c:            new_ci->edges = (jl_value_t*)jl_array_copy((jl_array_t*)new_ci->edges);
ast.c:            jl_gc_wb(new_ci, new_ci->edges);
ast.c:        if (jl_is_array(new_ci->ssavaluetypes)) {
ast.c:            new_ci->ssavaluetypes = (jl_value_t*)jl_array_copy((jl_array_t*)new_ci->ssavaluetypes);
ast.c:            jl_gc_wb(new_ci, new_ci->ssavaluetypes);
ast.c:        size_t i, l = jl_array_len(e->args);
ast.c:        jl_expr_t *ne = jl_exprn(e->head, l);
ast.c:    fl_context_t *fl_ctx = &ctx->fl;
ast.c:    int res = fl_applyn(fl_ctx, 1, symbol_value(symbol(fl_ctx, "operator?")), symbol(fl_ctx, sym)) == fl_ctx->T;
ast.c:    fl_context_t *fl_ctx = &ctx->fl;
ast.c:    int res = fl_applyn(fl_ctx, 1, symbol_value(symbol(fl_ctx, "unary-op?")), symbol(fl_ctx, sym)) == fl_ctx->T;
ast.c:    fl_context_t *fl_ctx = &ctx->fl;
ast.c:    int res = fl_applyn(fl_ctx, 1, symbol_value(symbol(fl_ctx, "unary-and-binary-op?")), symbol(fl_ctx, sym)) == fl_ctx->T;
ast.c:    fl_context_t *fl_ctx = &ctx->fl;
ast.c:    int res = fl_applyn(fl_ctx, 1, symbol_value(symbol(fl_ctx, "syntactic-op?")), symbol(fl_ctx, sym)) == fl_ctx->T;
ast.c:    fl_context_t *fl_ctx = &ctx->fl;
ast.c:    int res = numval(fl_applyn(fl_ctx, 1, symbol_value(symbol(fl_ctx, "operator-precedence")), symbol(fl_ctx, sym)));
ast.c:        if (jl_is_expr((jl_value_t*)stmt) && stmt->head == jl_meta_sym) {
ast.c:            size_t i, l = jl_array_len(stmt->args);
ast.c:                if (jl_array_ptr_ref(stmt->args, i) == (jl_value_t*)sym)
ast.c:        margs[i] = jl_array_ptr_ref(args, i - 1);
ast.c:    size_t last_age = ct->world_age;
ast.c:    ct->world_age = world < jl_world_counter ? world : jl_world_counter;
ast.c:        *ctx = mfunc->def.method->module;
ast.c:        result = jl_invoke(margs[0], &margs[1], nargs - 1, mfunc);
ast.c:    ct->world_age = last_age;
ast.c:    if (e->head == jl_inert_sym ||
ast.c:        e->head == jl_module_sym ||
ast.c:        //e->head == jl_toplevel_sym || // TODO: enable this once julia-expand-macroscope is fixed / removed
ast.c:        e->head == jl_meta_sym) {
ast.c:    if (e->head == jl_quote_sym && jl_expr_nargs(e) == 1) {
ast.c:        expr = jl_call_scm_on_ast("julia-bq-macro", jl_exprarg(e, 0), inmodule);
ast.c:    if (e->head == jl_hygienicscope_sym && jl_expr_nargs(e) == 2) {
ast.c:        JL_TYPECHK(hygienic-scope, module, (jl_value_t*)newctx.m);
ast.c:            jl_array_ptr_set(e->args, 0, a2);
ast.c:    if (e->head == jl_macrocall_sym) {
ast.c:        newctx.m = macroctx ? macroctx->m : inmodule;
ast.c:        jl_value_t *result = jl_invoke_julia_macro(e->args, inmodule, &newctx.m, world, throw_load_error);
ast.c:        // copy and wrap the result in `(hygienic-scope ,result ,newctx)
ast.c:        if (jl_is_expr(result) && ((jl_expr_t*)result)->head == jl_escape_sym)
ast.c:    if (e->head == jl_do_sym && jl_expr_nargs(e) == 2 && jl_is_expr(jl_exprarg(e, 0)) &&
ast.c:        ((jl_expr_t*)jl_exprarg(e, 0))->head == jl_macrocall_sym) {
ast.c:    if (e->head == jl_escape_sym && macroctx) {
ast.c:        macroctx = macroctx->parent;
ast.c:    for (i = 0; i < jl_array_len(e->args); i++) {
ast.c:        jl_value_t *a = jl_array_ptr_ref(e->args, i);
ast.c:            jl_array_ptr_set(e->args, i, a2);
ast.c:    expr = jl_call_scm_on_ast("jl-expand-macroscope", expr, inmodule);
ast.c:    expr = jl_call_scm_on_ast("jl-expand-macroscope", expr, inmodule);
ast.c:// Lower an expression tree into Julia's intermediate-representation.
ast.c:    expr = jl_call_scm_on_ast_and_loc("jl-expand-to-thunk", expr, inmodule, file, line);
ast.c:    fl_context_t *fl_ctx = &ctx->fl;
ast.c:    value_t e = fl_applyn(fl_ctx, 4, symbol_value(symbol(fl_ctx, "jl-expand-to-thunk-warn")), arg,
ast.c:                          symbol(fl_ctx, file), fixnum(line), fl_ctx->F);
ast.c:    expr = jl_call_scm_on_ast_and_loc("jl-expand-to-thunk-stmt", expr, inmodule, file, line);
ast.c://------------------------------------------------------------------------------
ast.c:// `text` is passed as a pointer to allow raw non-String buffers to be used
ast.c:    size_t last_age = ct->world_age;
ast.c:    ct->world_age = jl_world_counter;
ast.c:    ct->world_age = last_age;
getopt.c:/* This file is adapted from musl-libc
getopt.c:----------------------------------------------------------------------
getopt.c:Copyright  2005-2014 Rich Felker, et al.
getopt.c:----------------------------------------------------------------------
getopt.c:  if (optind >= argc || !argv[optind] || argv[optind][0] != '-' || !argv[optind][1])
getopt.c:    return -1;
getopt.c:  if (argv[optind][1] == '-' && !argv[optind][2])
getopt.c:    return optind++, -1;
getopt.c:  if (optind >= argc || !argv[optind] || argv[optind][0] != '-') return -1;
getopt.c:    (argv[optind][1] == '-' && argv[optind][2]))
getopt.c:      if (*opt == '-') opt++;
getopt.c:    if (argv[optind][1] == '-') {
interpreter.c:    jl_svec_t *sparam_vals; // method static parameters, if eval-ing a method body
interpreter.c:    size_t ip; // Leak the currently-evaluating statement index to backtrace capture
interpreter.c:    int preevaluation; // use special rules for pre-evaluating expressions (deprecated--only for ccall handling)
interpreter.c:  JL_GCC_IGNORE_START("-Wc++-compat")                                               \
interpreter.c:    jl_value_t **args = jl_array_ptr_data(ex->args);
interpreter.c:        jl_value_t **args = jl_array_ptr_data(ex->args);
interpreter.c:        jl_module_t *modu = s->module;
interpreter.c:        _Atomic(jl_value_t*) *bp = &b->value;
interpreter.c:        jl_value_t *gf = jl_generic_function_def(b->name, b->owner, bp, bp_owner, b);
interpreter.c:    jl_method_def((jl_svec_t*)atypes, mt, (jl_code_info_t*)meth, s->module);
interpreter.c:    JL_GC_PUSHARGS(argv, nargs - 1);
interpreter.c:    jl_value_t *result = jl_invoke(argv[1], &argv[2], nargs - 2, meth);
interpreter.c:    return jl_array_len(src->slotflags);
interpreter.c:    return jl_is_long(src->ssavaluetypes) ? jl_unbox_long(src->ssavaluetypes) : jl_array_len(src->ssavaluetypes);
interpreter.c:    s->locals[jl_source_nslots(s->src) + s->ip] = res;
interpreter.c:    jl_code_info_t *src = s->src;
interpreter.c:        ssize_t id = ((jl_ssavalue_t*)e)->id - 1;
interpreter.c:        if (src == NULL || id >= jl_source_nssavalues(src) || id < 0 || s->locals == NULL)
interpreter.c:            return s->locals[jl_source_nslots(src) + id];
interpreter.c:        if (src == NULL || n > jl_source_nslots(src) || n < 1 || s->locals == NULL)
interpreter.c:        jl_value_t *v = s->locals[n - 1];
interpreter.c:            jl_undefined_var_error((jl_sym_t*)jl_array_ptr_ref(src->slotnames, n - 1));
interpreter.c:        return jl_eval_global_var(s->module, (jl_sym_t*)e);
interpreter.c:    jl_value_t **args = jl_array_ptr_data(ex->args);
interpreter.c:    size_t nargs = jl_array_len(ex->args);
interpreter.c:    jl_sym_t *head = ex->head;
interpreter.c:        return do_call(args + 1, nargs - 1, s);
interpreter.c:            if (src == NULL || n > jl_source_nslots(src) || n < 1 || s->locals == NULL)
interpreter.c:            defined = s->locals[n - 1] != NULL;
interpreter.c:            defined = jl_boundp(s->module, (jl_sym_t*)sym);
interpreter.c:        else if (jl_is_expr(sym) && ((jl_expr_t*)sym)->head == jl_static_parameter_sym) {
interpreter.c:            if (s->sparam_vals && n <= jl_svec_len(s->sparam_vals)) {
interpreter.c:                jl_value_t *sp = jl_svecref(s->sparam_vals, n - 1);
interpreter.c:        jl_value_t *v = jl_new_structv((jl_datatype_t*)argv[0], &argv[1], nargs - 1);
interpreter.c:            argv[3], argv[4], argv+5, nargs-5);
interpreter.c:        if (s->sparam_vals && n <= jl_svec_len(s->sparam_vals)) {
interpreter.c:            jl_value_t *sp = jl_svecref(s->sparam_vals, n - 1);
interpreter.c:            if (jl_is_typevar(sp) && !s->preevaluation)
interpreter.c:                jl_undefined_var_error(((jl_tvar_t*)sp)->name);
interpreter.c:        jl_unionall_t *unionall = ((s->mi!=NULL)&&jl_is_method(s->mi->def.method) && jl_is_unionall(s->mi->def.method->sig))
interpreter.c:        ? (jl_unionall_t*)s->mi->def.method->sig
interpreter.c:            argv[1] = jl_instantiate_type_in_env(rt,unionall,jl_svec_data(s->sparam_vals));
interpreter.c:                every_arg_type[i] = jl_instantiate_type_in_env(jl_svec_ref(at,i),unionall,jl_svec_data(s->sparam_vals));
interpreter.c:            jl_value_t* params = jl_svec_ref(((jl_datatype_t*)rt)->parameters,0);
interpreter.c:                r = ((jl_datatype_t*)rt)->instance;
interpreter.c:    size_t from = s->ip;
interpreter.c:        jl_value_t **dest = &s->locals[jl_source_nslots(s->src) + to];
interpreter.c:            ssize_t edge = -1;
interpreter.c:            size_t closest = to; // implicit edge has `to <= edge - 1 < to + i`
interpreter.c:            // this is because we could see the following IR (all 1-indexed):
interpreter.c:            // from = 1, to = closest = 2, i = 1 --> edge = 2, edge_from = 2, from = 2
interpreter.c:                size_t edge_from = ((int32_t*)jl_array_data(edges))[j]; // 1-indexed
interpreter.c:                    if (edge == -1)
interpreter.c:                    // if we found a nearer implicit branch from fall-through,
interpreter.c:            unsigned n_oldphi = closest - to;
interpreter.c:                    phis[j - n_oldphi] = phis[j];
interpreter.c:                from = closest - 1;
interpreter.c:                i -= n_oldphi;
interpreter.c:                nphi -= n_oldphi;
interpreter.c:            if (edge != -1) {
interpreter.c:        s->ip = ip;
interpreter.c:            ct->world_age = jl_world_counter;
interpreter.c:            next_ip = jl_gotonode_label(stmt) - 1;
interpreter.c:                next_ip = jl_gotoifnot_label(stmt) - 1;
interpreter.c:            jl_value_t *phic = s->locals[jl_source_nslots(s->src) + ip];
interpreter.c:            ssize_t id = ((jl_ssavalue_t*)phic)->id - 1;
interpreter.c:            s->locals[jl_source_nslots(s->src) + id] = val;
interpreter.c:            jl_sym_t *head = ((jl_expr_t*)stmt)->head;
interpreter.c:                    assert(n <= jl_source_nslots(s->src) && n > 0);
interpreter.c:                    s->locals[n - 1] = rhs;
interpreter.c:                        modu = s->module;
interpreter.c:                size_t catch_ip = jl_unbox_long(jl_exprarg(stmt, 0)) - 1;
interpreter.c:                        size_t upsilon = ((jl_ssavalue_t*)val)->id - 1;
interpreter.c:                        s->locals[jl_source_nslots(s->src) + upsilon] = jl_box_ssavalue(catch_ip + 1);
interpreter.c:                    s->locals[jl_source_nslots(s->src) + catch_ip] = NULL;
interpreter.c:                s->locals[jl_source_nslots(s->src) + ip] = jl_box_ulong(jl_excstack_state());
interpreter.c:                else if (s->continue_at) { // means we reached a :leave expression
interpreter.c:                    ip = s->continue_at;
interpreter.c:                    s->continue_at = 0;
interpreter.c:                jl_handler_t *eh = ct->eh;
interpreter.c:                while (--hand_n_leave > 0)
interpreter.c:                    eh = eh->prev;
interpreter.c:                s->continue_at = next_ip;
interpreter.c:                jl_longjmp(eh->eh_ctx, 1);
interpreter.c:                    jl_value_t *res = jl_toplevel_eval(s->module, stmt);
interpreter.c:                    s->locals[jl_source_nslots(s->src) + s->ip] = res;
interpreter.c:                    jl_toplevel_eval(s->module, stmt);
interpreter.c:                        jl_set_module_nospecialize(s->module, 1);
interpreter.c:                        jl_set_module_nospecialize(s->module, 0);
interpreter.c:                                jl_set_module_optlevel(s->module, n);
interpreter.c:                                jl_set_module_compile(s->module, jl_unbox_long(jl_exprarg(stmt, 1)));
interpreter.c:                                jl_set_module_infer(s->module, jl_unbox_long(jl_exprarg(stmt, 1)));
interpreter.c:            assert(n <= jl_source_nslots(s->src) && n > 0);
interpreter.c:            s->locals[n - 1] = NULL;
interpreter.c:    jl_code_info_t *src = (jl_code_info_t*)mi->uninferred;
interpreter.c:    if (jl_is_method(mi->def.value)) {
interpreter.c:            if (mi->def.method->source) {
interpreter.c:                src = (jl_code_info_t*)mi->def.method->source;
interpreter.c:                assert(mi->def.method->generator);
interpreter.c:            src = jl_uncompress_ir(mi->def.method, NULL, (jl_array_t*)src);
interpreter.c:            mi->uninferred = (jl_value_t*)src;
interpreter.c:    jl_method_instance_t *mi = codeinst->def;
interpreter.c:    jl_array_t *stmts = src->code;
interpreter.c:    s->locals = locals + 2;
interpreter.c:    s->src = src;
interpreter.c:    if (jl_is_module(mi->def.value)) {
interpreter.c:        s->module = mi->def.module;
interpreter.c:        s->module = mi->def.method->module;
interpreter.c:        size_t defargs = mi->def.method->nargs;
interpreter.c:        int isva = mi->def.method->isva ? 1 : 0;
interpreter.c:        s->locals[0] = f;
interpreter.c:        for (i = 1; i < defargs - isva; i++)
interpreter.c:            s->locals[i] = args[i - 1];
interpreter.c:            s->locals[defargs - 1] = jl_f_tuple(NULL, &args[defargs - 2], nargs + 2 - defargs);
interpreter.c:    s->sparam_vals = mi->sparam_vals;
interpreter.c:    s->preevaluation = 0;
interpreter.c:    s->continue_at = 0;
interpreter.c:    s->mi = mi;
interpreter.c:    jl_method_t *source = oc->source;
interpreter.c:    jl_code_info_t *code = jl_uncompress_ir(source, NULL, (jl_array_t*)source->source);
interpreter.c:    locals[2] = (jl_value_t*)oc->captures;
interpreter.c:    s->locals = locals + 2;
interpreter.c:    s->src = code;
interpreter.c:    s->module = source->module;
interpreter.c:    s->sparam_vals = NULL;
interpreter.c:    s->preevaluation = 0;
interpreter.c:    s->continue_at = 0;
interpreter.c:    s->mi = NULL;
interpreter.c:    size_t defargs = source->nargs;
interpreter.c:    int isva = !!oc->isva;
interpreter.c:    for (size_t i = 1; i < defargs - isva; i++)
interpreter.c:        s->locals[i] = args[i - 1];
interpreter.c:        s->locals[defargs - 1] = jl_f_tuple(NULL, &args[defargs - 2], nargs + 2 - defargs);
interpreter.c:    jl_value_t *r = eval_body(code->code, s, 0, 0);
interpreter.c:    JL_GC_PUSHFRAME(s, s->locals, nroots);
interpreter.c:    jl_array_t *stmts = src->code;
interpreter.c:    s->src = src;
interpreter.c:    s->module = m;
interpreter.c:    s->sparam_vals = jl_emptysvec;
interpreter.c:    s->continue_at = 0;
interpreter.c:    s->mi = NULL;
interpreter.c:    size_t last_age = ct->world_age;
interpreter.c:    ct->world_age = last_age;
interpreter.c:    s->src = src;
interpreter.c:    s->module = m;
interpreter.c:    s->sparam_vals = sparam_vals;
interpreter.c:    s->preevaluation = (sparam_vals != NULL);
interpreter.c:    s->continue_at = 0;
interpreter.c:    s->mi = NULL;
interpreter.c:    interpreter_state *s = &((interpreter_state*)stateend)[-1];
interpreter.c:    int need_module = !s->mi;
interpreter.c:    uintptr_t entry_tags = jl_bt_entry_descriptor(njlvalues, 0, JL_BT_INTERP_FRAME_TAG, s->ip);
interpreter.c:    bt_entry[2].jlvalue = s->mi  ? (jl_value_t*)s->mi  :
interpreter.c:                          s->src ? (jl_value_t*)s->src : (jl_value_t*)jl_nothing;
interpreter.c:        // If we only have a CodeInfo (s->src), we are in a top level thunk and
interpreter.c:        bt_entry[3].jlvalue = (jl_value_t*)s->module;
threading.c:    return jl_current_task->ptls;
threading.c:    // This 2-step initialization is used to detect calling
threading.c:// Also update the suspended_threads list in signals-mach when changing the
threading.c:    return jl_atomic_load_relaxed(&jl_current_task->tid);
threading.c:    ptls->system_id = jl_thread_self();
threading.c:    seed_cong(&ptls->rngseed);
threading.c:    ptls->tid = tid;
threading.c:    jl_atomic_store_relaxed(&ptls->gc_state, 0); // GC unsafe
threading.c:        ptls->safepoint = (size_t*)(jl_safepoint_pages + jl_page_size);
threading.c:        ptls->safepoint = (size_t*)(jl_safepoint_pages + jl_page_size * 2 +
threading.c:    ptls->bt_data = bt_data;
threading.c:    small_arraylist_new(&ptls->locks, 0);
threading.c:JL_DLLEXPORT ssize_t jl_tls_offset = -1;
threading.c:    ssize_t offset = (char*)k0 - (char*)tp;
threading.c:        return -1;
threading.c:    ssize_t offset = (char*)tp - (char*)k0;
threading.c:        return -1;
threading.c:    return -offset;
threading.c:    const ElfW(Phdr) *phdr = info->dlpi_phdr;
threading.c:    unsigned phnum = info->dlpi_phnum;
threading.c:        if (seg->p_type != PT_TLS)
threading.c:        total_size = jl_add_tls_size(total_size, seg->p_memsz, seg->p_align);
threading.c:    data->total_size = total_size;
threading.c:    if (offset == -1)
threading.c:// interface to Julia; sets up to make the runtime thread-safe
threading.c:    if (jl_options.nthreads < 0) { // --threads=auto
threading.c:    else if (jl_options.nthreads > 0) { // --threads=N
threading.c:    // non-exclusive: no affinity settings; let the kernel move threads about
threading.c:        t->tid = i;
threading.c:        t->barrier = &thread_init_done;
threading.c:    _threadedregion -= 1;
toplevel.c:  evaluating top-level expressions, loading source files
toplevel.c:// create a new top-level module
toplevel.c:    jl_main_module->parent = jl_main_module;
toplevel.c:    size_t last_age = ct->world_age;
toplevel.c:        ct->world_age = jl_world_counter;
toplevel.c:        ct->world_age = last_age;
toplevel.c:            jl_rethrow_other(jl_new_struct(jl_initerror_type, m->name,
toplevel.c:    assert(ex->head == jl_module_sym);
toplevel.c:    if (jl_array_len(ex->args) != 3 || !jl_is_expr(jl_exprarg(ex, 2))) {
toplevel.c:    if (((jl_expr_t *)(jl_exprarg(ex, 2)))->head != jl_symbol("block")) {
toplevel.c:    newm->uuid = parent_module->uuid;
toplevel.c:        newm->parent = newm;
toplevel.c:        newm->parent = parent_module;
toplevel.c:        if (!jl_atomic_cmpswap(&b->value, &old, (jl_value_t*)newm)) {
toplevel.c:            old = jl_atomic_exchange(&b->value, (jl_value_t*)newm);
toplevel.c:    size_t last_age = ct->world_age;
toplevel.c:        form = jl_call_scm_on_ast("module-default-defs", (jl_value_t*)ex, newm);
toplevel.c:    jl_array_t *exprs = ((jl_expr_t*)jl_exprarg(ex, 2))->args;
toplevel.c:        ct->world_age = jl_world_counter;
toplevel.c:        ct->world_age = jl_world_counter;
toplevel.c:    newm->primary_world = jl_world_counter;
toplevel.c:    ct->world_age = last_age;
toplevel.c:    // some optional post-processing steps
toplevel.c:    void **table = newm->bindings.table;
toplevel.c:    for(i=1; i < newm->bindings.size; i+=2) {
toplevel.c:            // remove non-exported macros
toplevel.c:            if (jl_symbol_name(b->name)[0]=='@' &&
toplevel.c:                !b->exportp && b->owner == newm)
toplevel.c:                b->value = NULL;
toplevel.c:            if (b->exportp && b->owner==newm && b->value==NULL)
toplevel.c:                          jl_symbol_name(b->name), jl_symbol_name(newm->name));
toplevel.c:    *refcnt -= 1;
toplevel.c:    // then initialize all in definition-finished order
toplevel.c:        if (!ptrhash_has(&jl_current_modules, (void*)newm->parent)) {
toplevel.c:                    jl_array_ptr_set(jl_module_init_order, ns - 1, (jl_value_t*)m);
toplevel.c:                jl_array_del_end(jl_module_init_order, l - ns);
toplevel.c:        size_t last_age = ct->world_age;
toplevel.c:        ct->world_age = jl_world_counter;
toplevel.c:        ct->world_age = last_age;
toplevel.c:// - initially Base doesn't exist and top === Core
toplevel.c:// - later, it refers to either old Base or new Base
toplevel.c:        if (m->istopmod)
toplevel.c:        if (m == m->parent)
toplevel.c:        m = m->parent;
toplevel.c:    jl_sym_t *head = e->head;
toplevel.c:                if (b && b->value && b->constp)
toplevel.c:                    called = b->value;
toplevel.c:    for (i = 0; i < jl_array_len(e->args); i++) {
toplevel.c:    jl_array_t *body = src->code;
toplevel.c:        size_t last_age = ct->world_age;
toplevel.c:        ct->world_age = (build_mode ? jl_base_module->primary_world : jl_world_counter);
toplevel.c:        ct->world_age = last_age;
toplevel.c://   - sets *name and returns the module to import *name from
toplevel.c://   - sets *name to NULL and returns a module to import
toplevel.c:        if (jl_core_module && var == jl_core_module->name) {
toplevel.c:        else if (jl_base_module && var == jl_base_module->name) {
toplevel.c:            m = m->parent;
toplevel.c:        if (i == jl_array_len(args)-1)
toplevel.c:        (((jl_expr_t*)e)->head == jl_module_sym ||
toplevel.c:         ((jl_expr_t*)e)->head == jl_import_sym ||
toplevel.c:         ((jl_expr_t*)e)->head == jl_using_sym ||
toplevel.c:         ((jl_expr_t*)e)->head == jl_export_sym ||
toplevel.c:         ((jl_expr_t*)e)->head == jl_thunk_sym ||
toplevel.c:         ((jl_expr_t*)e)->head == jl_global_sym ||
toplevel.c:         ((jl_expr_t*)e)->head == jl_const_sym ||
toplevel.c:         ((jl_expr_t*)e)->head == jl_toplevel_sym ||
toplevel.c:         ((jl_expr_t*)e)->head == jl_error_sym ||
toplevel.c:         ((jl_expr_t*)e)->head == jl_incomplete_sym);
toplevel.c:    jl_sym_t *head = ex->head;
toplevel.c:        size_t i, l = jl_array_len(ex->args);
toplevel.c:    li->uninferred = (jl_value_t*)src;
toplevel.c:    li->specTypes = (jl_value_t*)jl_emptytuple_type;
toplevel.c:    li->def.module = module;
toplevel.c:    jl_sym_t *name = asname ? asname : import->name;
toplevel.c:        if ((!b->constp && b->owner != m) || (b->value && b->value != (jl_value_t*)import)) {
toplevel.c:                      jl_symbol_name(name), jl_symbol_name(m->name));
toplevel.c:        b->imported = 1;
toplevel.c:    if (!b->constp) {
toplevel.c:        b->value = (jl_value_t*)import;
toplevel.c:        b->constp = 1;
toplevel.c:        if (fr->head == jl_colon_sym) {
toplevel.c:                if (((jl_expr_t*)path)->head == jl_dot_sym) {
toplevel.c:                    jl_module_t *from = eval_import_path(m, NULL, path->args, &name, keyword);
toplevel.c:        jl_errorf("cannot rename macro \"%s\" to non-macro \"%s\" in \"%s\"", n1, n2, keyword);
toplevel.c:        jl_errorf("cannot rename non-macro \"%s\" to macro \"%s\" in \"%s\"", n1, n2, keyword);
toplevel.c:                jl_eval_errorf(m, "all-underscore identifier used as rvalue");
toplevel.c:    if (ex->head == jl_dot_sym && jl_expr_nargs(ex) != 1) {
toplevel.c:    if (ct->ptls->in_pure_callback) {
toplevel.c:    size_t last_age = ct->world_age;
toplevel.c:        ct->world_age = jl_world_counter;
toplevel.c:        ct->world_age = last_age;
toplevel.c:    jl_sym_t *head = jl_is_expr(ex) ? ex->head : NULL;
toplevel.c:            if (jl_is_expr(a) && ((jl_expr_t*)a)->head == jl_dot_sym) {
toplevel.c:                jl_module_t *import = eval_import_path(m, from, ((jl_expr_t*)a)->args, &name, "using");
toplevel.c:            else if (from && jl_is_expr(a) && ((jl_expr_t*)a)->head == jl_as_sym && jl_expr_nargs(a) == 2 &&
toplevel.c:                     jl_is_expr(jl_exprarg(a, 0)) && ((jl_expr_t*)jl_exprarg(a, 0))->head == jl_dot_sym) {
toplevel.c:                    jl_module_t *import = eval_import_path(m, from, ((jl_expr_t*)path)->args, &name, "using");
toplevel.c:            if (jl_is_expr(a) && ((jl_expr_t*)a)->head == jl_dot_sym) {
toplevel.c:                jl_module_t *import = eval_import_path(m, from, ((jl_expr_t*)a)->args, &name, "import");
toplevel.c:            else if (jl_is_expr(a) && ((jl_expr_t*)a)->head == jl_as_sym && jl_expr_nargs(a) == 2 &&
toplevel.c:                     jl_is_expr(jl_exprarg(a, 0)) && ((jl_expr_t*)jl_exprarg(a, 0))->head == jl_dot_sym) {
toplevel.c:                    jl_module_t *import = eval_import_path(m, from, ((jl_expr_t*)path)->args, &name, "import");
toplevel.c:        for (size_t i = 0; i < jl_array_len(ex->args); i++) {
toplevel.c:            jl_sym_t *name = (jl_sym_t*)jl_array_ptr_ref(ex->args, i);
toplevel.c:        size_t i, l = jl_array_len(ex->args);
toplevel.c:        for (i = 0; i < jl_array_len(ex->args); i++) {
toplevel.c:            res = jl_toplevel_eval_flex(m, jl_array_ptr_ref(ex->args, i), fast, 0);
toplevel.c:    assert(jl_typeis(thk->code, jl_array_any_type));
toplevel.c:    body_attributes((jl_array_t*)thk->code, &has_intrinsics, &has_defs, &has_loops, &has_opaque, &has_compile);
toplevel.c:    // jl_resolve_globals_in_ir((jl_array_t*)thk->code, m, NULL, 0);
toplevel.c:        jl_resolve_globals_in_ir((jl_array_t*)thk->code, m, NULL, 0);
toplevel.c:        ct->world_age = world;
toplevel.c:        ct->world_age = last_age;
toplevel.c:            jl_resolve_globals_in_ir((jl_array_t*)thk->code, m, NULL, 0);
toplevel.c:        if (m != jl_main_module) { // TODO: this was grand-fathered in
toplevel.c:                const char* name = jl_symbol_name(m->name);
toplevel.c:                          "precompilation - don't do this.", name, name, funcname);
toplevel.c:    if (jl_current_task->ptls->in_pure_callback)
toplevel.c:    if (ct->ptls->in_pure_callback)
toplevel.c:    jl_resolve_globals_in_ir((jl_array_t*)thk->code, m, NULL, 0);
toplevel.c:    jl_code_info_t *src = jl_type_infer(li, ct->world_age, 0);
toplevel.c:        return src->rettype;
toplevel.c://------------------------------------------------------------------------------
toplevel.c:    if (ct->ptls->in_pure_callback)
toplevel.c:    if (!jl_is_expr(ast) || ((jl_expr_t*)ast)->head != jl_toplevel_sym) {
toplevel.c:    size_t last_age = ct->world_age;
toplevel.c:            ct->world_age = jl_world_counter;
toplevel.c:    ct->world_age = last_age;
toplevel.c:// Code loading - julia.h C API with native C types
toplevel.c://--------------------------------------------------
array.c:// array constructors ---------------------------------------------------------
array.c:    return ((char*)jl_array_data(a)) + ((jl_array_ndims(a) == 1 ? (a->maxsize - a->offset) : jl_array_len(a)) * a->elsize) + a->offset;
array.c:    if (a->flags.how == 3) {
array.c:        assert(jl_is_string(a) || a->flags.how != 3);
array.c:#define MAXINTVAL (((size_t)-1)>>1)
array.c:            // an extra byte for each isbits union array element, stored after a->maxsize
array.c:        a = (jl_array_t*)jl_gc_alloc(ct->ptls, tsz, atype);
array.c:        a->flags.how = 0;
array.c:        a = (jl_array_t*)jl_gc_alloc(ct->ptls, tsz, atype);
array.c:        a->flags.how = 2;
array.c:        jl_gc_track_malloced_array(ct->ptls, a);
array.c:    a->flags.pooled = tsz <= GC_MAX_SZCLASS;
array.c:    a->data = data;
array.c:        ((char*)data)[tot - 1] = '\0';
array.c:    a->length = nel;
array.c:    a->flags.ndims = ndims;
array.c:    a->flags.ptrarray = !isunboxed;
array.c:    a->flags.hasptr = hasptr;
array.c:    a->elsize = elsz;
array.c:    a->flags.isshared = 0;
array.c:    a->flags.isaligned = 1;
array.c:    a->offset = 0;
array.c:        a->nrows = nel;
array.c:        a->maxsize = nel;
array.c:    else if (a->flags.ndims != ndims) {
array.c:        size_t *adims = &a->nrows;
array.c:    int hasptr = isunboxed && (jl_is_datatype(eltype) && ((jl_datatype_t*)eltype)->layout->npointers > 0);
array.c:    int zi = !isunboxed || hasptr || isunion || (jl_is_datatype(eltype) && ((jl_datatype_t*)eltype)->zeroinit);
array.c:    a = (jl_array_t*)jl_gc_alloc(ct->ptls, tsz, atype);
array.c:    a->flags.pooled = tsz <= GC_MAX_SZCLASS;
array.c:    a->flags.ndims = ndims;
array.c:    a->offset = 0;
array.c:    a->data = NULL;
array.c:    a->flags.isaligned = data->flags.isaligned;
array.c:    assert(isboxed == data->flags.ptrarray);
array.c:        a->elsize = LLT_ALIGN(elsz, align);
array.c:        a->flags.ptrarray = 0;
array.c:        a->flags.hasptr = data->flags.hasptr;
array.c:        a->elsize = sizeof(void*);
array.c:        a->flags.ptrarray = 1;
array.c:        a->flags.hasptr = 0;
array.c:    a->flags.how = 3;
array.c:    a->data = data->data;
array.c:    a->flags.isshared = 1;
array.c:    data->flags.isshared = 1;
array.c:        a->length = l;
array.c:        a->nrows = l;
array.c:        a->maxsize = l;
array.c:    else if (a->flags.ndims != ndims) {
array.c:        size_t *adims = &a->nrows;
array.c:        a->length = l;
array.c:    a = (jl_array_t*)jl_gc_alloc(ct->ptls, tsz, jl_array_uint8_type);
array.c:    a->flags.pooled = tsz <= GC_MAX_SZCLASS;
array.c:    a->flags.ndims = 1;
array.c:    a->offset = 0;
array.c:    a->data = jl_string_data(str);
array.c:    a->flags.isaligned = 0;
array.c:    a->elsize = 1;
array.c:    a->flags.ptrarray = 0;
array.c:    a->flags.hasptr = 0;
array.c:    a->flags.how = 3;
array.c:    a->flags.isshared = 1;
array.c:    a->length = l;
array.c:    a->nrows = a->maxsize = l;
array.c:    if (((uintptr_t)data) & ((align > JL_HEAP_ALIGNMENT ? JL_HEAP_ALIGNMENT : align) - 1))
array.c:    a = (jl_array_t*)jl_gc_alloc(ct->ptls, tsz, atype);
array.c:    a->flags.pooled = tsz <= GC_MAX_SZCLASS;
array.c:    a->data = data;
array.c:    a->length = nel;
array.c:    a->elsize = LLT_ALIGN(elsz, align);
array.c:    a->flags.ptrarray = !isunboxed;
array.c:    a->flags.hasptr = isunboxed && (jl_is_datatype(eltype) && ((jl_datatype_t*)eltype)->layout->npointers > 0);
array.c:    a->flags.ndims = 1;
array.c:    a->flags.isshared = 1;
array.c:    a->flags.isaligned = 0;  // TODO: allow passing memalign'd buffers
array.c:        a->flags.how = 2;
array.c:        jl_gc_track_malloced_array(ct->ptls, a);
array.c:        a->flags.how = 0;
array.c:    a->nrows = nel;
array.c:    a->maxsize = nel;
array.c:    a->offset = 0;
array.c:    if (((uintptr_t)data) & ((align > JL_HEAP_ALIGNMENT ? JL_HEAP_ALIGNMENT : align) - 1))
array.c:    a = (jl_array_t*)jl_gc_alloc(ct->ptls, tsz, atype);
array.c:    a->flags.pooled = tsz <= GC_MAX_SZCLASS;
array.c:    a->data = data;
array.c:    a->length = nel;
array.c:    a->elsize = LLT_ALIGN(elsz, align);
array.c:    a->flags.ptrarray = !isunboxed;
array.c:    a->flags.hasptr = isunboxed && (jl_is_datatype(eltype) && ((jl_datatype_t*)eltype)->layout->npointers > 0);
array.c:    a->flags.ndims = ndims;
array.c:    a->offset = 0;
array.c:    a->flags.isshared = 1;
array.c:    a->flags.isaligned = 0;
array.c:        a->flags.how = 2;
array.c:        jl_gc_track_malloced_array(ct->ptls, a);
array.c:        a->flags.how = 0;
array.c:    if (a->flags.ndims != ndims)
array.c:    memcpy(&a->nrows, dims, ndims * sizeof(size_t));
array.c:    memcpy(a->data, str, len);
array.c:    if (a->flags.how == 3 && a->offset == 0 && a->elsize == 1 &&
array.c:         ((a->maxsize + sizeof(void*) + 1 <= GC_MAX_SZCLASS) == (len + sizeof(void*) + 1 <= GC_MAX_SZCLASS)))) {
array.c:            a->flags.isshared = 1;
array.c:            a->nrows = 0;
array.c:            a->length = 0;
array.c:            a->maxsize = 0;
array.c:    a->nrows = 0;
array.c:    a->length = 0;
array.c:    a->maxsize = 0;
array.c:    jl_ptls_t ptls = ct->ptls;
array.c:        jl_gc_pool_t *p = &ptls->heap.norm_pools[pool_id];
array.c:        s = jl_gc_pool_alloc(ptls, (char*)p - (char*)ptls, osize);
array.c:// array primitives -----------------------------------------------------------
array.c:    assert(a->flags.ptrarray);
array.c:    jl_value_t *elt = jl_atomic_load_relaxed(((_Atomic(jl_value_t*)*)a->data) + i);
array.c:    if (a->flags.ptrarray)
array.c:            return ((jl_datatype_t*)eltype)->instance;
array.c:    jl_value_t *r = undefref_check((jl_datatype_t*)eltype, jl_new_bits(eltype, &((char*)a->data)[i * a->elsize]));
array.c:    if (a->flags.ptrarray) {
array.c:    else if (a->flags.hasptr) {
array.c:         assert(eltype->layout->first_ptr >= 0);
array.c:         jl_value_t **elem = (jl_value_t**)((char*)a->data + i * a->elsize);
array.c:         return elem[eltype->layout->first_ptr] != NULL;
array.c:    if (!a->flags.ptrarray) {
array.c:            hasptr = a->flags.hasptr;
array.c:        arrayassign_safe(hasptr, jl_array_owner(a), &((char*)a->data)[i * a->elsize], rhs, a->elsize);
array.c:        jl_atomic_store_relaxed(((_Atomic(jl_value_t*)*)a->data) + i, rhs);
array.c:    if (a->flags.ptrarray)
array.c:        jl_atomic_store_relaxed(((_Atomic(jl_value_t*)*)a->data) + i, NULL);
array.c:    else if (a->flags.hasptr) {
array.c:        size_t elsize = a->elsize;
array.c:        memset((char*)a->data + elsize * i, 0, elsize);
array.c:// When this function returns, the `->data` pointer always points to
array.c:    assert(!a->flags.isshared || a->flags.how == 3);
array.c:    size_t elsz = a->elsize;
array.c:    size_t oldnbytes = a->maxsize * elsz;
array.c:    size_t oldoffsnb = a->offset * elsz;
array.c:    size_t oldlen = a->nrows;
array.c:        oldnbytes += a->maxsize;
array.c:    if (a->flags.how == 2) {
array.c:        // already malloc'd - use realloc
array.c:        char *olddata = (char*)a->data - oldoffsnb;
array.c:        a->data = jl_gc_managed_realloc(olddata, nbytes, oldnbytes,
array.c:                                        a->flags.isaligned, (jl_value_t*)a);
array.c:    else if (a->flags.how == 3 && jl_is_string(jl_array_data_owner(a)) && !isbitsunion) {
array.c:        if (a->flags.isshared) {
array.c:            s = jl_alloc_string(nbytes - (elsz == 1));
array.c:            s = jl_gc_realloc_string(jl_array_data_owner(a), nbytes - (elsz == 1));
array.c:        a->data = jl_string_data(s);
array.c:            a->data = jl_gc_managed_malloc(nbytes);
array.c:            jl_gc_track_malloced_array(ct->ptls, a);
array.c:            a->flags.how = 2;
array.c:            a->flags.isaligned = 1;
array.c:            a->data = jl_gc_alloc_buf(ct->ptls, nbytes);
array.c:            a->flags.how = 1;
array.c:            jl_gc_wb_buf(a, a->data, nbytes);
array.c:        memset((char*)a->data + oldnbytes - 1, 0, nbytes - oldnbytes + 1);
array.c:    assert(oldlen == a->nrows &&
array.c:    a->flags.isshared = 0;
array.c:    a->maxsize = newlen;
array.c:    if (a->flags.isshared) {
array.c:        if (a->flags.how != 3)
array.c:        assert(a->offset == 0);
array.c:        size_t len = a->maxsize;
array.c:        size_t nbytes = len * a->elsize;
array.c:        char *olddata = (char*)a->data;
array.c:        memcpy(a->data, olddata, nbytes);
array.c:    int exp2 = sizeof(maxsize) * 8 -
array.c:    if (__unlikely(a->flags.isshared)) {
array.c:        if (a->flags.how != 3)
array.c:    size_t elsz = a->elsize;
array.c:    char *data = (char*)a->data;
array.c:    if (a->offset >= inc) {
array.c:        // already have enough space in a->offset
array.c:        newdata = data - nbinc;
array.c:        a->offset -= inc;
array.c:        if (isbitsunion) newtypetagdata = typetagdata - inc;
array.c:            memmove_safe(a->flags.hasptr, newdata, data, idx * elsz);
array.c:        // not enough room for requested growth from existing a->offset
array.c:        size_t oldoffset = a->offset;
array.c:        size_t oldmaxsize = a->maxsize;
array.c:        if (inc > (a->maxsize - n) / 2 - (a->maxsize - n) / 20) {
array.c:            while (n + 2 * inc > newlen - a->offset)
array.c:            size_t newmaxsize = overallocation(a->maxsize);
array.c:            size_t newoffset = (newlen - newnrows) / 2;
array.c:                data = (char*)a->data + oldoffsnb;
array.c:            newdata = (char*)a->data + newoffset * elsz;
array.c:                typetagdata = data + (oldmaxsize - oldoffset) * elsz + oldoffset;
array.c:                newtypetagdata = newdata + (a->maxsize - newoffset) * elsz + newoffset;
array.c:                memmove(newtypetagdata + idx + inc, typetagdata + idx, n - idx);
array.c:                memmove_safe(a->flags.hasptr, newdata, data, nb1);
array.c:            memmove_safe(a->flags.hasptr, newdata + nbinc + nb1, data + nb1, n * elsz - nb1);
array.c:                memmove_safe(a->flags.hasptr, newdata, data, nb1);
array.c:            a->offset = newoffset;
array.c:            // use extra space between a->nrows & a->maxsize
array.c:            a->offset = (a->maxsize - newnrows) / 2;
array.c:            newdata = data - oldoffsnb + a->offset * elsz;
array.c:            if (isbitsunion) newtypetagdata = newdata + (a->maxsize - a->offset) * elsz + a->offset;
array.c:                memmove_safe(a->flags.hasptr, newdata, data, nb1);
array.c:            memmove_safe(a->flags.hasptr, newdata + nbinc + nb1, data + nb1, n * elsz - nb1);
array.c:            if (isbitsunion) memmove(newtypetagdata + idx + inc, typetagdata + idx, n - idx);
array.c:                memmove_safe(a->flags.hasptr, newdata, data, nb1);
array.c:    a->length = newnrows;
array.c:    a->nrows = newnrows;
array.c:    a->data = newdata;
array.c:    if (__unlikely(a->flags.isshared)) {
array.c:        if (a->flags.how != 3)
array.c:    size_t elsz = a->elsize;
array.c:    char *data = (char*)a->data;
array.c:    size_t reqmaxsize = a->offset + n + inc;
array.c:    if (__unlikely(reqmaxsize > a->maxsize)) {
array.c:        size_t newmaxsize = overallocation(a->maxsize);
array.c:        size_t oldmaxsize = a->maxsize;
array.c:        char *newdata = (char*)a->data + a->offset * elsz;
array.c:        if (isbitsunion) newtypetagdata = newdata + (a->maxsize - a->offset) * elsz + a->offset;
array.c:                if (has_gap) memcpy(newtypetagdata + idx + inc, typetagdata + idx, n - idx);
array.c:            if (has_gap) memcpy(newdata + nb1 + nbinc, data + nb1, n * elsz - nb1);
array.c:                typetagdata = newdata + (oldmaxsize - a->offset) * elsz + a->offset;
array.c:                if (has_gap) memmove(newtypetagdata + idx + inc, typetagdata + idx, n - idx);
array.c:            if (has_gap) memmove_safe(a->flags.hasptr, newdata + nb1 + nbinc, newdata + nb1, n * elsz - nb1);
array.c:        a->data = data = newdata;
array.c:            memmove(typetagdata + idx + inc, typetagdata + idx, n - idx);
array.c:        memmove_safe(a->flags.hasptr, data + nb1 + inc * elsz, data + nb1, n * elsz - nb1);
array.c:        // there was enough room for requested growth already in a->maxsize
array.c:    a->length = newnrows;
array.c:    a->nrows = newnrows;
array.c:    if (a->flags.how == 0) return;
array.c:    size_t elsz = a->elsize;
array.c:    size_t newbytes = (a->maxsize - dec) * a->elsize;
array.c:    size_t oldnbytes = (a->maxsize) * a->elsize;
array.c:        newbytes += a->maxsize - dec;
array.c:        oldnbytes += a->maxsize;
array.c:    char *originalptr = ((char*) a->data) - a->offset * a->elsize;
array.c:    if (a->flags.how == 1) {
array.c:        //this is a julia-allocated buffer that needs to be marked
array.c:            typetagdata = (char*)malloc_s(a->nrows);
array.c:            memcpy(typetagdata, jl_array_typetagdata(a), a->nrows);
array.c:        char *originaldata = (char*) a->data - a->offset * a->elsize;
array.c:        char *newdata = (char*)jl_gc_alloc_buf(ct->ptls, newbytes);
array.c:        a->maxsize -= dec;
array.c:            memcpy(newtypetagdata, typetagdata, a->nrows);
array.c:        a->data = newdata + a->offset * elsz;
array.c:    else if (a->flags.how == 2) {
array.c:        //malloc-allocated pointer this array object manages
array.c:            typetagdata = (char*)malloc_s(a->nrows);
array.c:            memcpy(typetagdata, jl_array_typetagdata(a), a->nrows);
array.c:        size_t oldoffsnb = a->offset * elsz;
array.c:        a->data = ((char*)jl_gc_managed_realloc(originalptr, newbytes, oldnbytes,
array.c:                a->flags.isaligned, (jl_value_t*) a)) + oldoffsnb;
array.c:        a->maxsize -= dec;
array.c:            memcpy(newtypetagdata, typetagdata, a->nrows);
array.c:    else if (a->flags.how == 3) {
array.c:    if (offset >= 13 * a->maxsize / 20)
array.c:        offset = 17 * (a->maxsize - a->nrows) / 100;
array.c:    size_t elsz = a->elsize;
array.c:    size_t offset = a->offset;
array.c:    a->length = n - dec;
array.c:    a->nrows = n - dec;
array.c:        char *olddata = (char*)a->data;
array.c:        char *newdata = olddata - (a->offset - newoffs) * elsz;
array.c:            newtypetagdata = typetagdata - (a->offset - newoffs);
array.c:        size_t nbtotal = a->nrows * elsz; // size in bytes of the new array
array.c:            memmove_safe(a->flags.hasptr, newdata, olddata, nb1);
array.c:            memmove_safe(a->flags.hasptr, newdata + nb1, olddata + nb1 + nbdec, nbtotal - nb1);
array.c:            if (isbitsunion) memmove(newtypetagdata + idx, typetagdata + idx + dec, a->nrows - idx);
array.c:        a->data = newdata;
array.c:        char *data = (char*)a->data;
array.c:        a->data = data + nbdec;
array.c:    a->offset = newoffs;
array.c:    char *data = (char*)a->data;
array.c:    size_t elsz = a->elsize;
array.c:        memmove_safe(a->flags.hasptr, data + idx * elsz, data + last * elsz, (n - last) * elsz);
array.c:            memmove(typetagdata + idx, typetagdata + last, n - last);
array.c:    n -= dec;
array.c:    a->nrows = n;
array.c:    a->length = n;
array.c:    if (__unlikely(a->flags.isshared))
array.c:    if (idx < n - last) {
array.c:    if (__unlikely(a->flags.isshared))
array.c:    if (__unlikely(a->flags.isshared))
array.c:    jl_array_del_at_end(a, n - dec, dec, n);
array.c:    size_t min = a->offset + a->length;
array.c:    if (sz <= a->maxsize) {
array.c:        size_t dec = a->maxsize - sz;
array.c:        if (dec < a->maxsize / 8) return;
array.c:        size_t inc = sz - n;
array.c:        a->nrows = n;
array.c:        a->length = n;
array.c:    size_t elsz = ary->elsize;
array.c:                                      &ary->nrows, !ary->flags.ptrarray,
array.c:                                      ary->flags.hasptr, isunion, 0, elsz);
array.c:    memcpy(new_ary->data, ary->data, len * elsz);
array.c:        // `val` is young or old-unmarked
array.c:        if (val && !(jl_astaggedvalue(val)->bits.gc & GC_MARKED)) {
array.c:        void *val = jl_atomic_load_relaxed(src_pa + n - i - 1);
array.c:        jl_atomic_store_relaxed(dest_pa + n - i - 1, val);
array.c:        // `val` is young or old-unmarked
array.c:        if (val && !(jl_astaggedvalue(val)->bits.gc & GC_MARKED)) {
array.c:    assert(dest->flags.ptrarray && src->flags.ptrarray);
array.c:    if (__unlikely(jl_astaggedvalue(owner)->bits.gc == GC_OLD_MARKED)) {
array.c:        if (jl_astaggedvalue(src_owner)->bits.gc != GC_OLD_MARKED) {
array.c:            n -= done;
array.c:    jl_array_ptr_set(a, n - 1, item);
array.c:    assert(a->flags.how != 3);
array.c:    if (!a->flags.isshared)
array.c:    return a->flags.how == 1;
array.c:    //   * how: 0-2
array.c:    if (a->flags.how == 3) {
array.c:        return a->elsize == 1 && jl_has_implicit_byte_owned(a);
array.c:    ((char*)a->data)[a->nrows] = 0;
iddict.c:// compute empirical max-probe for a given size
iddict.c:#define h2index(hv, sz) (size_t)(((hv) & ((sz)-1)) * 2)
iddict.c:    jl_value_t **ol = (jl_value_t **)a->data;
iddict.c:    _Atomic(jl_value_t*) *tab = (_Atomic(jl_value_t*)*)a->data;
iddict.c:        empty_slot = -1;
iddict.c:                if (empty_slot == -1)
iddict.c:                if (empty_slot == -1)
iddict.c:            if (empty_slot == -1 && jl_atomic_load_relaxed(&tab[index + 1]) == NULL) {
iddict.c:            index = (index + 2) & (sz - 1);
iddict.c:        if (empty_slot != -1) {
iddict.c:        tab = (_Atomic(jl_value_t*)*)a->data;
iddict.c:    _Atomic(jl_value_t*) *tab = (_Atomic(jl_value_t*)*)a->data;
iddict.c:        index = (index + 2) & (sz - 1);
iddict.c:    jl_atomic_store_relaxed(bp - 1, jl_nothing); // clear the key
iddict.c:    while (i < alen && ((void **)t->data)[i + 1] == NULL)
iddict.c:        return (size_t)-1;
.gitignore:/libjulia-debug.a
.gitignore:/libjulia-debug.so
.gitignore:/libjulia-debug.dylib
.gitignore:/libjulia-release.a
.gitignore:/libjulia-release.so
.gitignore:/libjulia-release.dylib
flisp/system.lsp:; -*- scheme -*-
flisp/system.lsp:   (lambda (x) (cdr x))              (lambda (x y) (set-car! x y))
flisp/system.lsp:   (lambda (x y) (set-cdr! x y))     (lambda rest (apply apply rest))
flisp/system.lsp:   (lambda rest (apply + rest))      (lambda rest (apply - rest))
flisp/system.lsp:(if (not (bound? '*syntax-environment*))
flisp/system.lsp:    (define *syntax-environment* (table)))
flisp/system.lsp:(define (set-syntax! s v) (put! *syntax-environment* s v))
flisp/system.lsp:(define (symbol-syntax s) (get *syntax-environment* s #f))
flisp/system.lsp:(define-macro (define-macro form . body)
flisp/system.lsp:  `(set-syntax! ',(car form)
flisp/system.lsp:(define-macro (letrec binds . body)
flisp/system.lsp:(define-macro (let binds . body)
flisp/system.lsp:(define-macro (cond . clauses)
flisp/system.lsp:  (define (cond-clauses->if lst)
flisp/system.lsp:			(cond-clauses->if (cdr lst)))
flisp/system.lsp:		      (if (1arg-lambda? (caddr clause))
flisp/system.lsp:				   ,(cond-clauses->if (cdr lst)))))
flisp/system.lsp:				   ,(cond-clauses->if (cdr lst))))))
flisp/system.lsp:			    (cond-clauses->if (cdr lst)))))))))
flisp/system.lsp:  (cond-clauses->if clauses))
flisp/system.lsp:; standard procedures ---------------------------------------------------------
flisp/system.lsp:(define (1- n) (- n 1))
flisp/system.lsp:(define (mod0 x y) (- x (* (div0 x y) y)))
flisp/system.lsp:				  -1))
flisp/system.lsp:(define (mod x y) (- x (* (div x y) y)))
flisp/system.lsp:(define (abs x)   (if (< x 0) (- x) x))
flisp/system.lsp:  (set! call-with-values
flisp/system.lsp:; list utilities --------------------------------------------------------------
flisp/system.lsp:(define (list-tail lst n)
flisp/system.lsp:      (list-tail (cdr lst) (- n 1))))
flisp/system.lsp:(define (list-head lst n)
flisp/system.lsp:	    (list-head (cdr lst) (- n 1)))))
flisp/system.lsp:(define (list-ref lst n)
flisp/system.lsp:  (car (list-tail lst n)))
flisp/system.lsp:	(else        (length= (cdr lst) (- n 1)))))
flisp/system.lsp:	(else        (length> (cdr lst) (- n 1)))))
flisp/system.lsp:(define (last-pair l)
flisp/system.lsp:      (last-pair (cdr l))))
flisp/system.lsp:      (cdr (last-pair l))))
flisp/system.lsp:(define (to-proper l)
flisp/system.lsp:	(else (cons (car l) (to-proper (cdr l))))))
flisp/system.lsp:		(set-car! lst (f (car lst)))
flisp/system.lsp:  (define (filter- f lst acc)
flisp/system.lsp:			      (cdr (set-cdr! acc (cons (car lst) ())))))
flisp/system.lsp:  (filter- pred lst (list ())))
flisp/system.lsp:  (define (separate- pred lst yes no)
flisp/system.lsp:				    (cdr (set-cdr! yes (cons (car lst) ()))))
flisp/system.lsp:				    (cdr (set-cdr! no  (cons (car lst) ())))))
flisp/system.lsp:  (separate- pred lst (list ()) (list ())))
flisp/system.lsp:  (define (count- f l n)
flisp/system.lsp:	(count- f (cdr l) (if (f (car l))
flisp/system.lsp:  (count- f l 0))
flisp/system.lsp:(define (reverse- zero lst)
flisp/system.lsp:      (reverse- (cons (car lst) zero) (cdr lst))))
flisp/system.lsp:(define (reverse lst) (reverse- () lst))
flisp/system.lsp:(define (reverse!- prev l)
flisp/system.lsp:			(set-cdr! l (prog1 prev
flisp/system.lsp:(define (reverse! l) (reverse!- () l))
flisp/system.lsp:(define (delete-duplicates lst)
flisp/system.lsp:		(delete-duplicates tail)
flisp/system.lsp:		      (delete-duplicates tail)))))))
flisp/system.lsp:; backquote -------------------------------------------------------------------
flisp/system.lsp:(define (revappend l1 l2) (reverse-  l2 l1))
flisp/system.lsp:(define (nreconc   l1 l2) (reverse!- l2 l1))
flisp/system.lsp:(define (self-evaluating? x)
flisp/system.lsp:           (eq? x (top-level-value x)))))
flisp/system.lsp:(define-macro (quasiquote x) (bq-process x 0))
flisp/system.lsp:(define (splice-form? x)
flisp/system.lsp:  (or (and (pair? x) (or (eq? (car x) 'unquote-splicing)
flisp/system.lsp:                         (eq? (car x) 'unquote-nsplicing)
flisp/system.lsp:(define (bq-bracket1 x d)
flisp/system.lsp:                (bq-process (cdr x) (- d 1))))
flisp/system.lsp:      (bq-process x d)))
flisp/system.lsp:(define (bq-bracket x d)
flisp/system.lsp:  (cond ((atom? x)  (list list (bq-process x d)))
flisp/system.lsp:                              (bq-process (cdr x) (- d 1))))))
flisp/system.lsp:        ((eq? (car x) 'unquote-splicing)
flisp/system.lsp:             (list 'copy-list (cadr x))
flisp/system.lsp:             (list list (list list ''unquote-splicing
flisp/system.lsp:                              (bq-process (cadr x) (- d 1))))))
flisp/system.lsp:        ((eq? (car x) 'unquote-nsplicing)
flisp/system.lsp:             (list list (list list ''unquote-nsplicing
flisp/system.lsp:                              (bq-process (cadr x) (- d 1))))))
flisp/system.lsp:        (else  (list list (bq-process x d)))))
flisp/system.lsp:(define (bq-process x d)
flisp/system.lsp:         (let ((body (bq-process (vector->list x) d)))
flisp/system.lsp:         (list list ''quasiquote (bq-process (cadr x) (+ d 1))))
flisp/system.lsp:             (list cons ''unquote (bq-process (cdr x) (- d 1)))))
flisp/system.lsp:        ((not (any splice-form? x))
flisp/system.lsp:               (forms (map (lambda (x) (bq-bracket1 x d)) x)))
flisp/system.lsp:                   (list cons (car forms) (bq-process lc d))
flisp/system.lsp:                   (nconc (cons list* forms) (list (bq-process lc d)))))))
flisp/system.lsp:                                                  (bq-process (cdr p)
flisp/system.lsp:                                                              (- d 1)))))))
flisp/system.lsp:                         (loop (cdr p) (cons (bq-bracket (car p) d) q)))))
flisp/system.lsp:                  (cons 'nconc (reverse! (cons (bq-process p d) q)))))))))
flisp/system.lsp:; standard macros -------------------------------------------------------------
flisp/system.lsp:(define (quote-value v)
flisp/system.lsp:  (if (self-evaluating? v)
flisp/system.lsp:(define-macro (let* binds . body)
flisp/system.lsp:(define-macro (when   c . body) (list 'if c (cons 'begin body) #f))
flisp/system.lsp:(define-macro (unless c . body) (list 'if c #f (cons 'begin body)))
flisp/system.lsp:(define-macro (case key . clauses)
flisp/system.lsp:  (define (vals->cond key v)
flisp/system.lsp:	  ((symbol? v)     `(eq?  ,key ,(quote-value v)))
flisp/system.lsp:          ((atom? v)       `(eqv? ,key ,(quote-value v)))
flisp/system.lsp:	  ((null? (cdr v)) `(eqv? ,key ,(quote-value (car v))))
flisp/system.lsp:		      (cons (vals->cond g (car clause))
flisp/system.lsp:#;(define-macro (do vars test-spec . commands)
flisp/system.lsp:	(test-expr (car test-spec))
flisp/system.lsp:		       (if ,test-expr
flisp/system.lsp:			     ,@(cdr test-spec))
flisp/system.lsp:(define-macro (receive formals expr . body)
flisp/system.lsp:  `(call-with-values (lambda () ,expr)
flisp/system.lsp:(define-macro (dotimes var . body)
flisp/system.lsp:    `(for 0 (- ,cnt 1)
flisp/system.lsp:(define (map-int f n)
flisp/system.lsp:      (for 1 (- n 1)
flisp/system.lsp:             (begin (set-cdr! acc (cons (f i) ()))
flisp/system.lsp:(define (iota n) (map-int identity n))
flisp/system.lsp:(define-macro (with-bindings binds . body)
flisp/system.lsp:       (unwind-protect
flisp/system.lsp:; exceptions ------------------------------------------------------------------
flisp/system.lsp:(define-macro (throw tag value) `(raise (list 'thrown-value ,tag ,value)))
flisp/system.lsp:(define-macro (catch tag expr)
flisp/system.lsp:                                     (eq? (car  ,e) 'thrown-value)
flisp/system.lsp:(define-macro (unwind-protect expr finally)
flisp/system.lsp:; debugging utilities ---------------------------------------------------------
flisp/system.lsp:(define-macro (assert expr) `(if ,expr #t (raise '(assert-failed ,expr))))
flisp/system.lsp:  (letrec ((sample-traced-lambda (lambda args (begin (write (cons 'x args))
flisp/system.lsp:		   (function:code sample-traced-lambda))))))
flisp/system.lsp:  (let* ((func (top-level-value sym))
flisp/system.lsp:	(set-top-level-value! sym
flisp/system.lsp:  (let ((func (top-level-value sym)))
flisp/system.lsp:	(set-top-level-value! sym
flisp/system.lsp:(define-macro (time expr)
flisp/system.lsp:	(princ "Elapsed time: " (- (time.now) ,t0) " seconds\n")))))
flisp/system.lsp:; text I/O --------------------------------------------------------------------
flisp/system.lsp:(define (print . args) (for-each write args))
flisp/system.lsp:  (with-bindings ((*print-readably* #f))
flisp/system.lsp:		 (for-each write args)))
flisp/system.lsp:(define (newline (port *output-stream*))
flisp/system.lsp:(define (read-all-of f s)
flisp/system.lsp:(define (io.readlines s) (read-all-of io.readline s))
flisp/system.lsp:(define (read-all s) (read-all-of read s))
flisp/system.lsp:	  (eof-object)
flisp/system.lsp:(define-macro (with-output-to stream . body)
flisp/system.lsp:  `(with-bindings ((*output-stream* ,stream))
flisp/system.lsp:(define-macro (with-input-from stream . body)
flisp/system.lsp:  `(with-bindings ((*input-stream* ,stream))
flisp/system.lsp:; vector functions ------------------------------------------------------------
flisp/system.lsp:(define (list->vector l) (apply vector l))
flisp/system.lsp:(define (vector->list v)
flisp/system.lsp:           (set! l (cons (aref v (- n i)) l))))
flisp/system.lsp:    (for 0 (- n 1)
flisp/system.lsp:; table functions -------------------------------------------------------------
flisp/system.lsp:; string functions ------------------------------------------------------------
flisp/system.lsp:#;(define (string.trim s at-start at-end)
flisp/system.lsp:  (define (trim-start s chars i L)
flisp/system.lsp:	(trim-start s chars (string.inc s i) L)
flisp/system.lsp:  (define (trim-end s chars i)
flisp/system.lsp:	(trim-end s chars (string.dec s i))
flisp/system.lsp:		(trim-start s at-start 0 L)
flisp/system.lsp:		(trim-end   s at-end   L))))
flisp/system.lsp:	((odd? k) (string s (string.rep s (- k 1))))
flisp/system.lsp:#;(define (string.lpad s n c) (string (string.rep c (- n (string.count s))) s))
flisp/system.lsp:#;(define (string.rpad s n c) (string s (string.rep c (- n (string.count s)))))
flisp/system.lsp:(define (print-to-string v)
flisp/system.lsp:	(for-each (lambda (s) (begin (io.write b sep)
flisp/system.lsp:; toplevel --------------------------------------------------------------------
flisp/system.lsp:			    (symbol-syntax (car e))))
flisp/system.lsp:#;(define (macroexpand-1 e)
flisp/system.lsp:  (define (splice-begin body)
flisp/system.lsp:	   (append (splice-begin (cdar body)) (splice-begin (cdr body))))
flisp/system.lsp:	   (cons (car body) (splice-begin (cdr body))))))
flisp/system.lsp:  (define (expand-body body env)
flisp/system.lsp:			  (splice-begin body)
flisp/system.lsp:	       (dvars (if def? (get-defined-vars body) ()))
flisp/system.lsp:	      (map (lambda (x) (expand-in x env)) body)
flisp/system.lsp:	      (let* ((ex-nondefs    ; expand non-definitions
flisp/system.lsp:			       (let ((form (expand-in (car body) env)))
flisp/system.lsp:					    (map list (get-defined-vars form))
flisp/system.lsp:		     (body ex-nondefs))
flisp/system.lsp:			   (set-car! body (expand-in (car body) env))
flisp/system.lsp:			   (set-car! body (cdar body)))
flisp/system.lsp:		ex-nondefs)))))
flisp/system.lsp:  (define (expand-lambda-list l env)
flisp/system.lsp:		  (list (caar l) (expand-in (cadar l) env))
flisp/system.lsp:	      (expand-lambda-list (cdr l) env))))
flisp/system.lsp:  (define (l-vars l)
flisp/system.lsp:	  ((pair? (car l)) (cons (caar l) (l-vars (cdr l))))
flisp/system.lsp:	  (else            (cons (car l)  (l-vars (cdr l))))))
flisp/system.lsp:  (define (expand-lambda e env)
flisp/system.lsp:	  (vars    (l-vars (cadr e))))
flisp/system.lsp:	`(lambda ,(expand-lambda-list formals env)
flisp/system.lsp:	   ,.(expand-body body env)
flisp/system.lsp:  (define (expand-define e env)
flisp/system.lsp:	    `(define ,(cadr e) ,(expand-in (caddr e) env)))
flisp/system.lsp:	      (vars    (l-vars (cdadr e))))
flisp/system.lsp:	    `(define ,(cons name (expand-lambda-list formals env))
flisp/system.lsp:	       ,.(expand-body body env))))))
flisp/system.lsp:  (define (expand-let-syntax e env)
flisp/system.lsp:	    (expand-body (cddr e)
flisp/system.lsp:				       ((compile-thunk
flisp/system.lsp:					 (expand-in (cadr bind) env)))
flisp/system.lsp:  ; given let-syntax definition environment (menv) and environment
flisp/system.lsp:  (define (local-expansion-env menv lenv) menv)
flisp/system.lsp:  (define (expand-in e env)
flisp/system.lsp:					  (expand-in (car e) env))
flisp/system.lsp:		 (expand-in (apply (cadr bnd) (cdr e))
flisp/system.lsp:			    (local-expansion-env (caddr bnd) env)))
flisp/system.lsp:				          (expand-in (apply f (cdr e)) env)))
flisp/system.lsp:		((eq? head 'lambda)     (expand-lambda e env))
flisp/system.lsp:		((eq? head 'define)     (expand-define e env))
flisp/system.lsp:		((eq? head 'let-syntax) (expand-let-syntax e env))
flisp/system.lsp:  (expand-in e ()))
flisp/system.lsp:(define (eval x) ((compile-thunk (expand x))))
flisp/system.lsp:(define (load-process x) (eval x))
flisp/system.lsp:		 (load-process E))
flisp/system.lsp:		  ; evaluate last form in almost-tail position
flisp/system.lsp:		  (load-process E))))
flisp/system.lsp:	 (raise `(load-error ,filename ,e)))))))
flisp/system.lsp:; | (-||||_(_)|__|_)|_)
flisp/system.lsp:;-------------------|----------------------------------------------------------
flisp/system.lsp:    (princ "> ") (io.flush *output-stream*)
flisp/system.lsp:		       (lambda (e) (begin (io.discardbuffer *input-stream*)
flisp/system.lsp:      (and (not (io.eof? *input-stream*))
flisp/system.lsp:	   (let ((V (load-process v)))
flisp/system.lsp:		      (top-level-exception-handler e)
flisp/system.lsp:(define (top-level-exception-handler e)
flisp/system.lsp:  (with-output-to *stderr*
flisp/system.lsp:		  (print-exception e)
flisp/system.lsp:		  (print-stack-trace (stacktrace))))
flisp/system.lsp:(define (print-stack-trace st)
flisp/system.lsp:  (define (find-in-f f tgt path)
flisp/system.lsp:	    (for 0 (1- (length v))
flisp/system.lsp:				 (find-in-f (aref v i) tgt path))))))))
flisp/system.lsp:  (define (fn-name f e)
flisp/system.lsp:		      (for-each (lambda (topfun)
flisp/system.lsp:				  (find-in-f topfun f ()))
flisp/system.lsp:  (let ((st (reverse! (list-tail st (if *interactive* 5 4))))
flisp/system.lsp:						  (top-level-value s)))
flisp/system.lsp:    (for-each
flisp/system.lsp:       (print (cons (fn-name (aref f 0) e)
flisp/system.lsp:		    (cdr (vector->list f))))
flisp/system.lsp:(define (print-exception e)
flisp/system.lsp:	      (eq? (car e) 'type-error)
flisp/system.lsp:	      (eq? (car e) 'bounds-error)
flisp/system.lsp:	      (eq? (car e) 'unbound-error)
flisp/system.lsp:	      (eq? (car e) 'load-error))
flisp/system.lsp:	 (print-exception (caddr e))
flisp/system.lsp:(define (simple-sort l)
flisp/system.lsp:		 (nconc (simple-sort less)
flisp/system.lsp:			(simple-sort grtr))))))
flisp/system.lsp:(define (make-system-image fname)
flisp/system.lsp:	(excludes '(*linefeed* *directory-separator* *argv* that
flisp/system.lsp:			       *print-pretty* *print-width* *print-readably*
flisp/system.lsp:			       *print-level* *print-length* *os-name*)))
flisp/system.lsp:    (with-bindings ((*print-pretty* #t)
flisp/system.lsp:		    (*print-readably* #t))
flisp/system.lsp:			    (or (not (builtin? (top-level-value s)))
flisp/system.lsp:					     (string (top-level-value s)))))
flisp/system.lsp:			    (not (iostream? (top-level-value s)))))
flisp/system.lsp:		     (simple-sort (environment)))))
flisp/system.lsp:	(write (apply nconc (map list syms (map top-level-value syms))) f)
flisp/system.lsp:  (if (or (eq? *os-name* 'win32)
flisp/system.lsp:	  (eq? *os-name* 'win64)
flisp/system.lsp:	  (eq? *os-name* 'windows))
flisp/system.lsp:      (begin (set! *directory-separator* "\\")
flisp/system.lsp:      (begin (set! *directory-separator* "/")
flisp/system.lsp:  (set! *output-stream* *stdout*)
flisp/system.lsp:  (set! *input-stream*  *stdin*)
flisp/system.lsp:  (set! *error-stream*  *stderr*))
flisp/system.lsp:	    (lambda (e) (begin (top-level-exception-handler e)
flisp/julia_charmap.h:    { 0x025B, 0x03B5 }, // latin small letter open e -> greek small letter epsilon
flisp/julia_charmap.h:    { 0x00B5, 0x03BC }, // micro sign -> greek small letter mu
flisp/julia_charmap.h:    { 0x00B7, 0x22C5 }, // middot char -> dot operator (#25098)
flisp/julia_charmap.h:    { 0x0387, 0x22C5 }, // Greek interpunct -> dot operator (#25098)
flisp/julia_charmap.h:    { 0x2212, 0x002D }, // minus -> hyphen-minus (#26193)
flisp/string.c:    return fl_isstring(fl_ctx, args[0]) ? fl_ctx->T : fl_ctx->F;
flisp/string.c:    return size_wrap(fl_ctx, u8_charnum(str+start, stop-start));
flisp/string.c:    value_t oldpr = symbol_value(fl_ctx->printreadablysym);
flisp/string.c:    value_t oldpp = symbol_value(fl_ctx->printprettysym);
flisp/string.c:    set(fl_ctx->printreadablysym, fl_ctx->F);
flisp/string.c:    set(fl_ctx->printprettysym, fl_ctx->F);
flisp/string.c:    set(fl_ctx->printreadablysym, oldpr);
flisp/string.c:    set(fl_ctx->printprettysym, oldpp);
flisp/string.c:    value_t ns = cvalue_string(fl_ctx, i2-i1);
flisp/string.c:    memcpy(cv_data((cvalue_t*)ptr(ns)), &s[i1], i2-i1);
flisp/string.c:    if (sl > len || i > len-sl)
flisp/string.c:    char *p = (char*)memchr(s+start, c, len-start);
flisp/string.c:        return fl_ctx->F;
flisp/string.c:    return size_wrap(fl_ctx, (size_t)(p - s));
flisp/string.c:    if (iscprim(v) && cp_class(cp) == fl_ctx->wchartype) {
flisp/string.c:    else if (iscprim(v) && cp_class(cp) == fl_ctx->bytetype) {
flisp/string.c:    if (needlesz > len-start)
flisp/string.c:        return fl_ctx->F;
flisp/string.c:    for(i=start; i < len-needlesz+1; i++) {
flisp/string.c:            if (!memcmp(&s[i+1], needle+1, needlesz-1))
flisp/string.c:    return fl_ctx->F;
flisp/string.c:    while (cnt--) {
flisp/string.c:    while (cnt--) {
flisp/string.c:        (void)(isutf(s[--i]) || isutf(s[--i]) || isutf(s[--i]) || --i);
flisp/string.c:        lerrorf(fl_ctx, fl_ctx->ArgError, "%s: invalid radix", fname);
flisp/string.c:        argcount(fl_ctx, "number->string", nargs, 2);
flisp/string.c:    else if (!iscprim(n)) type_error(fl_ctx, "number->string", "integer", n);
flisp/string.c:        num = -num;
flisp/string.c:        radix = get_radix_arg(fl_ctx, args[1], "number->string");
flisp/string.c:        *(--str) = '-';
flisp/string.c:        argcount(fl_ctx, "string->number", nargs, 2);
flisp/string.c:    char *str = tostring(fl_ctx, args[0], "string->number");
flisp/string.c:        radix = get_radix_arg(fl_ctx, args[1], "string->number");
flisp/string.c:        return fl_ctx->F;
flisp/string.c:    return u8_isvalid(s, len) ? fl_ctx->T : fl_ctx->F;
flisp/string.c:    { "number->string", fl_numbertostring },
flisp/string.c:    { "string->number", fl_stringtonumber },
flisp/Makefile:LLT_debug := $(LLT_BUILDDIR)/libsupport-debug.a
flisp/Makefile:LIBS += -lpthread
flisp/Makefile:FLAGS := -I$(LLTSRCDIR) $(JCFLAGS) $(HFILEDIRS:%=-I%) \
flisp/Makefile:        -I$(LIBUV_INC) -I$(UTF8PROC_INC) -I$(build_includedir) $(LIBDIRS:%=-L%) \
flisp/Makefile:        -DLIBRARY_EXPORTS -DUTF8PROC_EXPORTS
flisp/Makefile:FLAGS += -DUSE_COMPUTED_GOTO
flisp/Makefile:FLAGS += -Wall -Wno-strict-aliasing -fvisibility=hidden -Wpointer-arith -Wundef
flisp/Makefile:FLAGS += -Wold-style-definition -Wstrict-prototypes -Wc++-compat
flisp/Makefile:debug: $(BUILDDIR)/$(EXENAME)-debug$(EXE)
flisp/Makefile:	mkdir -p $(BUILDDIR)
flisp/Makefile:	@$(call PRINT_CC, $(CC) $(JCPPFLAGS) $(SHIPFLAGS) $(DISABLE_ASSERTIONS) -c $< -o $@)
flisp/Makefile:	@$(call PRINT_CC, $(CC) $(JCPPFLAGS) $(DEBUGFLAGS) -c $< -o $@)
flisp/Makefile:	$(MAKE) -C $(NATIVE_BUILDDIR)/$(LLTDIR) $(subst $(abspath $(NATIVE_BUILDDIR)/$(LLTDIR))/,,$(abspath $(LLT_release)))
flisp/Makefile:	$(MAKE) -C $(NATIVE_BUILDDIR)/$(LLTDIR) $(subst $(abspath $(NATIVE_BUILDDIR)/$(LLTDIR))/,,$(abspath $(LLT_debug)))
flisp/Makefile:$(BUILDDIR)/$(LIBTARGET)-debug.a: $(DOBJS) | $(BUILDDIR)
flisp/Makefile:	rm -rf $@
flisp/Makefile:	@$(call PRINT_LINK, $(AR) -rcs $@ $(DOBJS))
flisp/Makefile:	rm -rf $@
flisp/Makefile:	@$(call PRINT_LINK, $(AR) -rcs $@ $(OBJS))
flisp/Makefile:$(BUILDDIR)/$(EXENAME)-debug$(EXE): $(DOBJS) $(LIBFILES_debug) $(BUILDDIR)/$(LIBTARGET)-debug.a $(BUILDDIR)/flmain.dbg.obj | $(BUILDDIR)/flisp.boot
flisp/Makefile:	@$(call PRINT_LINK, $(CCLD) $(DEBUGFLAGS) $(JLDFLAGS) $(DOBJS) $(BUILDDIR)/flmain.dbg.obj -o $@ $(BUILDDIR)/$(LIBTARGET)-debug.a $(LIBFILES_debug) $(LIBS) $(OSLIBS))
flisp/Makefile:	@$(call PRINT_LINK, $(CCLD) $(SHIPFLAGS) $(JLDFLAGS) $(OBJS) $(BUILDDIR)/flmain.o -o $@ $(BUILDDIR)/$(LIBTARGET).a $(LIBFILES_release) $(LIBS) $(OSLIBS))
flisp/Makefile:	mkdir -p $(BUILDDIR)/host
flisp/Makefile:	@echo '# -- This file is automatically generated in julia/src/flisp/Makefile -- #' > $@
flisp/Makefile:	make -C $(BUILDDIR)/host $(EXENAME)
flisp/Makefile:	rm -f $(BUILDDIR)/*.o
flisp/Makefile:	rm -f $(BUILDDIR)/*.dbg.obj
flisp/Makefile:	rm -f $(BUILDDIR)/*.a
flisp/Makefile:	rm -f $(BUILDDIR)/$(EXENAME)$(EXE)
flisp/Makefile:	rm -f $(BUILDDIR)/$(EXENAME)-debug$(EXE)
flisp/Makefile:	rm -f $(BUILDDIR)/host/*
flisp/Makefile:.PHONY: flisp-deps
flisp/builtins.c:        return fl_ctx->NIL;
flisp/builtins.c:    value_t lst, first=fl_ctx->NIL;
flisp/builtins.c:            while (iscons(c->cdr))
flisp/builtins.c:                c = (cons_t*)ptr(c->cdr);
flisp/builtins.c:            pcdr = &c->cdr;
flisp/builtins.c:        else if (lst != fl_ctx->NIL) {
flisp/builtins.c:    return fl_ctx->F;
flisp/builtins.c:        if (c->car == args[0])
flisp/builtins.c:        args[1] = c->cdr;
flisp/builtins.c:    return fl_ctx->F;
flisp/builtins.c:        if (cp_class(cv) == fl_ctx->bytetype)
flisp/builtins.c:        else if (cp_class(cv) == fl_ctx->wchartype)
flisp/builtins.c:        if (cv_class(cv)->eltype != NULL)
flisp/builtins.c:    else if (a == fl_ctx->NIL) {
flisp/builtins.c:    return fl_ctx->NIL;
flisp/builtins.c:            iskeyword((symbol_t*)ptr(args[0]))) ? fl_ctx->T : fl_ctx->F;
flisp/builtins.c:    argcount(fl_ctx, "top-level-value", nargs, 1);
flisp/builtins.c:    symbol_t *sym = tosymbol(fl_ctx, args[0], "top-level-value");
flisp/builtins.c:    if (sym->binding == UNBOUND)
flisp/builtins.c:        fl_raise(fl_ctx, fl_list2(fl_ctx, fl_ctx->UnboundError, args[0]));
flisp/builtins.c:    return sym->binding;
flisp/builtins.c:    argcount(fl_ctx, "set-top-level-value!", nargs, 2);
flisp/builtins.c:    symbol_t *sym = tosymbol(fl_ctx, args[0], "set-top-level-value!");
flisp/builtins.c:        sym->binding = args[1];
flisp/builtins.c:        if (root->name[0] != ':' && (root->binding != UNBOUND)) {
flisp/builtins.c:        global_env_list(fl_ctx, root->left, pv);
flisp/builtins.c:        root = root->right;
flisp/builtins.c:    value_t lst = fl_ctx->NIL;
flisp/builtins.c:    global_env_list(fl_ctx, fl_ctx->symtab, &lst);
flisp/builtins.c:        return (isconstant((symbol_t*)ptr(args[0])) ? fl_ctx->T : fl_ctx->F);
flisp/builtins.c:        if (car_(args[0]) == fl_ctx->QUOTE)
flisp/builtins.c:            return fl_ctx->T;
flisp/builtins.c:        return fl_ctx->F;
flisp/builtins.c:    return fl_ctx->T;
flisp/builtins.c:    argcount(fl_ctx, "integer-valued?", nargs, 1);
flisp/builtins.c:        return fl_ctx->T;
flisp/builtins.c:            return fl_ctx->T;
flisp/builtins.c:            if (f < 0) f = -f;
flisp/builtins.c:                return fl_ctx->T;
flisp/builtins.c:            if (d < 0) d = -d;
flisp/builtins.c:                return fl_ctx->T;
flisp/builtins.c:    return fl_ctx->F;
flisp/builtins.c:        fl_ctx->T : fl_ctx->F;
flisp/builtins.c:        lerror(fl_ctx, fl_ctx->ArgError, "vector.alloc: too few arguments");
flisp/builtins.c:        lerror(fl_ctx, fl_ctx->ArgError, "vector.alloc: invalid size");
flisp/builtins.c:            lerrorf(fl_ctx, fl_ctx->IOError, "path.cwd: could not get cwd: %s", uv_strerror(err));
flisp/builtins.c:        lerrorf(fl_ctx, fl_ctx->IOError, "path.cwd: could not cd to %s: %s", ptr, uv_strerror(err));
flisp/builtins.c:    return fl_ctx->T;
flisp/builtins.c:    if (stat(str, &sbuf) == -1)
flisp/builtins.c:        return fl_ctx->F;
flisp/builtins.c:    return fl_ctx->T;
flisp/builtins.c:    if (val == NULL) return fl_ctx->F;
flisp/builtins.c:        return symbol_value(fl_ctx->emptystringsym);
flisp/builtins.c:    if (args[1] == fl_ctx->F) {
flisp/builtins.c:        lerror(fl_ctx, fl_ctx->ArgError, "os.setenv: invalid environment variable");
flisp/builtins.c:    return fl_ctx->T;
flisp/builtins.c:    { "top-level-value", fl_top_level_value },
flisp/builtins.c:    { "set-top-level-value!", fl_set_top_level_value },
flisp/builtins.c:    { "integer-valued?", fl_integer_valuedp },
flisp/color.lsp:; -*- scheme -*-
flisp/color.lsp:; dictionaries ----------------------------------------------------------------
flisp/color.lsp:(define (dict-new) ())
flisp/color.lsp:(define (dict-extend dl key value)
flisp/color.lsp:        (else (cons (car dl) (dict-extend (cdr dl) key value)))))
flisp/color.lsp:(define (dict-lookup dl key)
flisp/color.lsp:        (else (dict-lookup (cdr dl) key))))
flisp/color.lsp:(define (dict-keys dl) (map car dl))
flisp/color.lsp:; graphs ----------------------------------------------------------------------
flisp/color.lsp:(define (graph-empty) (dict-new))
flisp/color.lsp:(define (graph-connect g n1 n2)
flisp/color.lsp:  (dict-extend
flisp/color.lsp:   (dict-extend g n2 (cons n1 (dict-lookup g n2)))
flisp/color.lsp:   (cons n2 (dict-lookup g n1))))
flisp/color.lsp:(define (graph-adjacent? g n1 n2) (member n2 (dict-lookup g n1)))
flisp/color.lsp:(define (graph-neighbors g n) (dict-lookup g n))
flisp/color.lsp:(define (graph-nodes g) (dict-keys g))
flisp/color.lsp:(define (graph-add-node g n1) (dict-extend g n1 ()))
flisp/color.lsp:(define (graph-from-edges edge-list)
flisp/color.lsp:  (if (null? edge-list)
flisp/color.lsp:      (graph-empty)
flisp/color.lsp:    (graph-connect (graph-from-edges (cdr edge-list))
flisp/color.lsp:                   (caar edge-list)
flisp/color.lsp:                   (cdar edge-list))))
flisp/color.lsp:; graph coloring --------------------------------------------------------------
flisp/color.lsp:(define (node-colorable? g coloring node-to-color color-of-node)
flisp/color.lsp:        color-of-node
flisp/color.lsp:           (let ((color-pair (assq n coloring)))
flisp/color.lsp:             (if (pair? color-pair) (cdr color-pair) ())))
flisp/color.lsp:         (graph-neighbors g node-to-color)))))
flisp/color.lsp:(define (try-each f lst)
flisp/color.lsp:	(if ret ret (try-each f (cdr lst))))))
flisp/color.lsp:(define (color-node g coloring colors uncolored-nodes color)
flisp/color.lsp:   ((null? uncolored-nodes) coloring)
flisp/color.lsp:   ((node-colorable? g coloring (car uncolored-nodes) color)
flisp/color.lsp:    (let ((new-coloring
flisp/color.lsp:           (cons (cons (car uncolored-nodes) color) coloring)))
flisp/color.lsp:      (try-each (lambda (c)
flisp/color.lsp:                  (color-node g new-coloring colors (cdr uncolored-nodes) c))
flisp/color.lsp:(define (color-graph g colors)
flisp/color.lsp:      (and (null? (graph-nodes g)) ())
flisp/color.lsp:      (color-node g () colors (graph-nodes g) (car colors))))
flisp/color.lsp:(define (color-pairs pairs colors)
flisp/color.lsp:  (color-graph (graph-from-edges pairs) colors))
flisp/color.lsp:; queens ----------------------------------------------------------------------
flisp/color.lsp:(define (can-attack x y)
flisp/color.lsp:    (or (= x1 x2) (= y1 y2) (= (abs (- y2 y1)) (abs (- x2 x1))))))
flisp/color.lsp:(define (generate-5x5-pairs)
flisp/color.lsp:        (if (and (not (= x y)) (can-attack x y))
flisp/cvalues.c:static const int ALIGN2   = sizeof(struct prim_int16) - 2;
flisp/cvalues.c:static const int ALIGN4   = sizeof(struct prim_int32) - 4;
flisp/cvalues.c:static const int ALIGN8   = sizeof(struct prim_int64) - 8;
flisp/cvalues.c:static const int ALIGNPTR = sizeof(struct prim_ptr) - sizeof(void*);
flisp/cvalues.c:// cvalues-specific builtins
flisp/cvalues.c:    if (fl_ctx->nfinalizers == fl_ctx->maxfinalizers) {
flisp/cvalues.c:        size_t nn = (fl_ctx->maxfinalizers==0 ? 256 : fl_ctx->maxfinalizers*2);
flisp/cvalues.c:        cvalue_t **temp = (cvalue_t**)realloc(fl_ctx->Finalizers, nn*sizeof(value_t));
flisp/cvalues.c:            lerror(fl_ctx, fl_ctx->OutOfMemoryError, "out of memory");
flisp/cvalues.c:        fl_ctx->Finalizers = temp;
flisp/cvalues.c:        fl_ctx->maxfinalizers = nn;
flisp/cvalues.c:    fl_ctx->Finalizers[fl_ctx->nfinalizers++] = cv;
flisp/cvalues.c:// remove dead objects from finalization list in-place
flisp/cvalues.c:    cvalue_t **lst = fl_ctx->Finalizers;
flisp/cvalues.c:    size_t n=0, ndel=0, l=fl_ctx->nfinalizers;
flisp/cvalues.c:            if (t->vtable != NULL && t->vtable->finalize != NULL) {
flisp/cvalues.c:                t->vtable->finalize(fl_ctx, tagptr(tmp, TAG_CVALUE));
flisp/cvalues.c:    } while ((n < l-ndel) && SWAP_sf(lst[n],lst[n+ndel]));
flisp/cvalues.c:    fl_ctx->nfinalizers -= ndel;
flisp/cvalues.c:    fl_ctx->malloc_pressure = 0;
flisp/cvalues.c:        return CVALUE_NWORDS - 1 + NWORDS(n);
flisp/cvalues.c:    cv->type = (fltype_t*)(((uintptr_t)cv->type) | CV_OWNED_BIT);
flisp/cvalues.c:    cprim_t *pcp = (cprim_t*)alloc_words(fl_ctx, CPRIM_NWORDS-1+NWORDS(sz));
flisp/cvalues.c:    pcp->type = type;
flisp/cvalues.c:    if (valid_numtype(type->numtype)) {
flisp/cvalues.c:    if (type->eltype == fl_ctx->bytetype) {
flisp/cvalues.c:            return symbol_value(fl_ctx->emptystringsym);
flisp/cvalues.c:        size_t nw = CVALUE_NWORDS - 1 + NWORDS(sz) + (sz==0 ? 1 : 0);
flisp/cvalues.c:        pcv->type = type;
flisp/cvalues.c:        pcv->data = &pcv->_space[0];
flisp/cvalues.c:        if (type->vtable != NULL && type->vtable->finalize != NULL)
flisp/cvalues.c:        if (fl_ctx->malloc_pressure > ALLOC_LIMIT_TRIGGER)
flisp/cvalues.c:        pcv->type = type;
flisp/cvalues.c:        pcv->data = malloc(sz);
flisp/cvalues.c:        // TODO: if pcv->data == NULL
flisp/cvalues.c:        fl_ctx->malloc_pressure += sz;
flisp/cvalues.c:        sz--;
flisp/cvalues.c:        ((char*)pcv->data)[sz] = '\0';
flisp/cvalues.c:    pcv->len = sz;
flisp/cvalues.c:// ptr is user-managed; we don't autorelease it unless the
flisp/cvalues.c:// into; fl_ctx->NIL if none.
flisp/cvalues.c:    pcv->data = ptr;
flisp/cvalues.c:    pcv->len = sz;
flisp/cvalues.c:    pcv->type = type;
flisp/cvalues.c:    if (parent != fl_ctx->NIL) {
flisp/cvalues.c:        pcv->type = (fltype_t*)(((uintptr_t)pcv->type) | CV_PARENT_BIT);
flisp/cvalues.c:        pcv->parent = parent;
flisp/cvalues.c:    return cvalue(fl_ctx, fl_ctx->stringtype, sz);
flisp/cvalues.c:    return cvalue_from_ref(fl_ctx, fl_ctx->stringtype, (char*)str, n, fl_ctx->NIL);
flisp/cvalues.c:    cv->data = data;
flisp/cvalues.c:    if (nargs==0) { PUSH(fl_ctx, fixnum(0)); args = &fl_ctx->Stack[fl_ctx->SP-1]; } \
flisp/cvalues.c:    value_t cp = cprim(fl_ctx, fl_ctx->typenam##type, sizeof(fl_##ctype##_t)); \
flisp/cvalues.c:    if (cvalue_##ctype##_init(fl_ctx, fl_ctx->typenam##type,            \
flisp/cvalues.c:    value_t cp = cprim(fl_ctx, fl_ctx->typenam##type, sizeof(fl_##ctype##_t)); \
flisp/cvalues.c:    return iscvalue(v) && cv_class((cvalue_t*)ptr(v))->eltype != NULL;
flisp/cvalues.c:    else if (arg == fl_ctx->NIL)
flisp/cvalues.c:    value_t type = ft->type;
flisp/cvalues.c:    fltype_t *eltype = ft->eltype;
flisp/cvalues.c:    elsize = ft->elsz;
flisp/cvalues.c:            lerror(fl_ctx, fl_ctx->ArgError, "array: size mismatch");
flisp/cvalues.c:    else if (iscons(arg) || arg==fl_ctx->NIL) {
flisp/cvalues.c:            lerror(fl_ctx, fl_ctx->ArgError, "array: size mismatch");
flisp/cvalues.c:            fltype_t *aet = cv_class(cv)->eltype;
flisp/cvalues.c:                    lerror(fl_ctx, fl_ctx->ArgError, "array: size mismatch");
flisp/cvalues.c:                lerror(fl_ctx, fl_ctx->ArgError, "array: element type mismatch");
flisp/cvalues.c:    cnt = nargs - 1;
flisp/cvalues.c:    elsize = type->elsz;
flisp/cvalues.c:        cvalue_init(fl_ctx, type->eltype, arg, dest);
flisp/cvalues.c:    return cv_len(cv)/(cv_class(cv)->elsz);
flisp/cvalues.c:    if (type == fl_ctx->int8sym || type == fl_ctx->uint8sym || type == fl_ctx->bytesym) {
flisp/cvalues.c:    if (type == fl_ctx->int16sym || type == fl_ctx->uint16sym) {
flisp/cvalues.c:    if (type == fl_ctx->int32sym || type == fl_ctx->uint32sym || type == fl_ctx->wcharsym ||
flisp/cvalues.c:        type == fl_ctx->floatsym) {
flisp/cvalues.c:    if (type == fl_ctx->int64sym || type == fl_ctx->uint64sym || type == fl_ctx->doublesym) {
flisp/cvalues.c:    if (type == fl_ctx->ptrdiffsym || type == fl_ctx->sizesym) {
flisp/cvalues.c:        if (hed == fl_ctx->pointersym || hed == fl_ctx->cfunctionsym) {
flisp/cvalues.c:        if (hed == fl_ctx->arraysym) {
flisp/cvalues.c:                lerror(fl_ctx, fl_ctx->ArgError, "sizeof: incomplete type");
flisp/cvalues.c:    lerror(fl_ctx, fl_ctx->ArgError, "sizeof: invalid c type");
flisp/cvalues.c:// get pointer and size for any plain-old-data value
flisp/cvalues.c:        if (cv_class(pcv) == fl_ctx->iostreamtype && (x->bm == bm_mem)) {
flisp/cvalues.c:            *pdata = x->buf;
flisp/cvalues.c:            *psz = (size_t)x->size;
flisp/cvalues.c:        *psz = cp_class(pcp)->size;
flisp/cvalues.c:    type_error(fl_ctx, fname, "plain-old-data", v);
flisp/cvalues.c:    case TAG_CONS: return fl_ctx->pairsym;
flisp/cvalues.c:    case TAG_NUM:  return fl_ctx->fixnumsym;
flisp/cvalues.c:    case TAG_SYM:  return fl_ctx->symbolsym;
flisp/cvalues.c:    case TAG_VECTOR: return fl_ctx->vectorsym;
flisp/cvalues.c:        if (args[0] == fl_ctx->T || args[0] == fl_ctx->F)
flisp/cvalues.c:            return fl_ctx->booleansym;
flisp/cvalues.c:        if (args[0] == fl_ctx->NIL)
flisp/cvalues.c:            return fl_ctx->nullsym;
flisp/cvalues.c:        if (args[0] == fl_ctx->FL_EOF)
flisp/cvalues.c:            return symbol(fl_ctx, "eof-object");
flisp/cvalues.c:            return fl_ctx->builtinsym;
flisp/cvalues.c:        return fl_ctx->FUNCTION;
flisp/cvalues.c:        nv->data = &nv->_space[0];
flisp/cvalues.c:    if (t->vtable != NULL && t->vtable->relocate != NULL)
flisp/cvalues.c:        t->vtable->relocate(fl_ctx, v, ncv);
flisp/cvalues.c:        ncv->data = malloc(len);
flisp/cvalues.c:        // TODO: if ncv->data == NULL
flisp/cvalues.c:        memcpy(ncv->data, cv_data(cv), len);
flisp/cvalues.c:            ncv->type = (fltype_t*)(((uintptr_t)ncv->type) & ~CV_PARENT_BIT);
flisp/cvalues.c:            ncv->parent = fl_ctx->NIL;
flisp/cvalues.c:        ncv->data = &ncv->_space[0];
flisp/cvalues.c:        lerror(fl_ctx, fl_ctx->ArgError, "copy: argument must be a leaf atom");
flisp/cvalues.c:        lerror(fl_ctx, fl_ctx->ArgError, "copy: argument must be a plain-old-data type");
flisp/cvalues.c:    argcount(fl_ctx, "plain-old-data?", nargs, 1);
flisp/cvalues.c:        fl_ctx->T : fl_ctx->F;
flisp/cvalues.c:    cvinitfunc_t f=type->init;
flisp/cvalues.c:        lerror(fl_ctx, fl_ctx->ArgError, "c-value: invalid c type");
flisp/cvalues.c:    if (type == fl_ctx->int8sym)
flisp/cvalues.c:    else if (type == fl_ctx->uint8sym || type == fl_ctx->bytesym)
flisp/cvalues.c:    else if (type == fl_ctx->int16sym)
flisp/cvalues.c:    else if (type == fl_ctx->uint16sym)
flisp/cvalues.c:    else if (type == fl_ctx->int32sym || type == fl_ctx->wcharsym)
flisp/cvalues.c:    else if (type == fl_ctx->int32sym || type == fl_ctx->wcharsym || type == fl_ctx->ptrdiffsym)
flisp/cvalues.c:    else if (type == fl_ctx->uint32sym)
flisp/cvalues.c:    else if (type == fl_ctx->uint32sym || type == fl_ctx->sizesym)
flisp/cvalues.c:    else if (type == fl_ctx->int64sym || type == fl_ctx->ptrdiffsym)
flisp/cvalues.c:    else if (type == fl_ctx->int64sym)
flisp/cvalues.c:    else if (type == fl_ctx->uint64sym || type == fl_ctx->sizesym)
flisp/cvalues.c:    else if (type == fl_ctx->uint64sym)
flisp/cvalues.c:    else if (type == fl_ctx->floatsym)
flisp/cvalues.c:    else if (type == fl_ctx->doublesym)
flisp/cvalues.c:// type, including user-defined.
flisp/cvalues.c:        argcount(fl_ctx, "c-value", nargs, 2);
flisp/cvalues.c:    if (ft->eltype != NULL) {
flisp/cvalues.c:        size_t elsz = ft->elsz;
flisp/cvalues.c:        cv = cvalue(fl_ctx, ft, ft->size);
flisp/cvalues.c:            return fixnum(-1);
flisp/cvalues.c:    numel = cv_len(cv)/(cv_class(cv)->elsz);
flisp/cvalues.c:    fltype_t *eltype = cv_class((cvalue_t*)ptr(args[0]))->eltype;
flisp/cvalues.c:    numerictype_t nt = eltype->numtype;
flisp/cvalues.c:        el = cvalue(fl_ctx, eltype, eltype->size);
flisp/cvalues.c:    size_t sz = eltype->size;
flisp/cvalues.c:    fltype_t *eltype = cv_class((cvalue_t*)ptr(args[0]))->eltype;
flisp/cvalues.c:    char *dest = data + index*eltype->size;
flisp/cvalues.c:    if (ismanaged(fl_ctx, args[0]) || (cv=(cvalue_t*)name->dlcache) == NULL) {
flisp/cvalues.c:        lerrorf(fl_ctx, fl_ctx->ArgError, "builtin: function %s not found", name->name);
flisp/cvalues.c:    // TODO: if cv->data == NULL
flisp/cvalues.c:    cv->type = fl_ctx->builtintype;
flisp/cvalues.c:    cv->data = &cv->_space[0];
flisp/cvalues.c:    cv->len = sizeof(value_t);
flisp/cvalues.c:    *(void**)cv->data = (void*)(uintptr_t)f;
flisp/cvalues.c:    ((symbol_t*)ptr(sym))->dlcache = cv;
flisp/cvalues.c:    ptrhash_put(&fl_ctx->reverse_dlsym_lookup_table, cv, (void*)sym);
flisp/cvalues.c:    { "c-value", cvalue_new },
flisp/cvalues.c:    { "plain-old-data?", fl_podp },
flisp/cvalues.c:#define cv_intern(fl_ctx, tok) fl_ctx->tok##sym = symbol(fl_ctx, #tok)
flisp/cvalues.c:    set(fl_ctx->tok##sym, cbuiltin(fl_ctx, #tok, cvalue_##tok))
flisp/cvalues.c:    fl_ctx->name##type = get_type(fl_ctx, fl_ctx->name##sym);   \
flisp/cvalues.c:    fl_ctx->name##type->init = &cvalue_##name##_init
flisp/cvalues.c:    fl_ctx->name##type = get_type(fl_ctx, fl_ctx->name##sym);   \
flisp/cvalues.c:    fl_ctx->name##type->init = &cvalue_##ctype##_init
flisp/cvalues.c:    fl_ctx->malloc_pressure = 0;
flisp/cvalues.c:    fl_ctx->Finalizers = NULL;
flisp/cvalues.c:    fl_ctx->nfinalizers = 0;
flisp/cvalues.c:    fl_ctx->maxfinalizers = 0;
flisp/cvalues.c:    htable_new(&fl_ctx->TypeTable, 256);
flisp/cvalues.c:    htable_new(&fl_ctx->reverse_dlsym_lookup_table, 256);
flisp/cvalues.c:    fl_ctx->builtintype = define_opaque_type(fl_ctx->builtinsym, sizeof(builtin_t), NULL, NULL);
flisp/cvalues.c:    fl_ctx->cfunctionsym = symbol(fl_ctx, "c-function");
flisp/cvalues.c:    fl_ctx->stringtypesym = symbol(fl_ctx, "*string-type*");
flisp/cvalues.c:    setc(fl_ctx->stringtypesym, fl_list2(fl_ctx, fl_ctx->arraysym, fl_ctx->bytesym));
flisp/cvalues.c:    fl_ctx->wcstringtypesym = symbol(fl_ctx, "*wcstring-type*");
flisp/cvalues.c:    setc(fl_ctx->wcstringtypesym, fl_list2(fl_ctx, fl_ctx->arraysym, fl_ctx->wcharsym));
flisp/cvalues.c:    fl_ctx->stringtype = get_type(fl_ctx, symbol_value(fl_ctx->stringtypesym));
flisp/cvalues.c:    fl_ctx->wcstringtype = get_type(fl_ctx, symbol_value(fl_ctx->wcstringtypesym));
flisp/cvalues.c:    fl_ctx->emptystringsym = symbol(fl_ctx, "*empty-string*");
flisp/cvalues.c:    setc(fl_ctx->emptystringsym, cvalue_static_cstring(fl_ctx, ""));
flisp/cvalues.c:    value_t arg=fl_ctx->NIL;
flisp/cvalues.c:        uint64_t negpart = (uint64_t)(-Saccum);
flisp/cvalues.c:        Uaccum -= negpart;
flisp/cvalues.c:        return fixnum(-numval(n));
flisp/cvalues.c:        case T_INT8:   return fixnum(-(int32_t)*(int8_t*)a);
flisp/cvalues.c:        case T_UINT8:  return fixnum(-(int32_t)*(uint8_t*)a);
flisp/cvalues.c:        case T_INT16:  return fixnum(-(int32_t)*(int16_t*)a);
flisp/cvalues.c:        case T_UINT16: return fixnum(-(int32_t)*(uint16_t*)a);
flisp/cvalues.c:            return mk_int32(fl_ctx, -i32);
flisp/cvalues.c:            if (ui32 <= ((uint32_t)INT_MAX)+1) return mk_int32(fl_ctx, -(int32_t)ui32);
flisp/cvalues.c:            return mk_int64(fl_ctx, -(int64_t)ui32);
flisp/cvalues.c:            return mk_int64(fl_ctx, -i64);
flisp/cvalues.c:        case T_UINT64: return mk_int64(fl_ctx, -(int64_t)*(uint64_t*)a);
flisp/cvalues.c:        case T_FLOAT:  return mk_float(fl_ctx, -*(float*)a);
flisp/cvalues.c:        case T_DOUBLE: return mk_double(fl_ctx, -*(double*)a);
flisp/cvalues.c:    type_error(fl_ctx, "-", "number", n);
flisp/cvalues.c:    value_t arg=fl_ctx->NIL;
flisp/cvalues.c:  returns -1, 0, or 1 based on ordering of a and b
flisp/cvalues.c:          -0.0 not considered equal to 0.0
flisp/cvalues.c:        if (numval(a) < numval(b)) return -1;
flisp/cvalues.c:        return -1;
flisp/cvalues.c:    lerror(fl_ctx, fl_ctx->DivideError, "/: division by zero");
flisp/cvalues.c:            return return_from_int64(fl_ctx, -(int64_t)(*(uint64_t*)aptr /
flisp/cvalues.c:                                                        (uint64_t)(-b64)));
flisp/cvalues.c:            return return_from_int64(fl_ctx, -((int64_t)((uint64_t)(-a64) /
flisp/cvalues.c:    return fl_ctx->NIL;
flisp/cvalues.c:        return fixnum(-1);
flisp/cvalues.c:            return fixnum(numval(a)>>(-n));
flisp/cvalues.c:            n = -n;
flisp/cvalues.c:    return fl_ctx->NIL;
flisp/unittest.lsp:; -*- scheme -*-
flisp/unittest.lsp:(define-macro (assert-fail expr . what)
flisp/unittest.lsp:(define (every-int n)
flisp/unittest.lsp:(define (every-sint n)
flisp/unittest.lsp:(define (test-lt a b)
flisp/unittest.lsp:              (eval `(assert (= -1 (compare ,neg ,pos))))
flisp/unittest.lsp:(define (test-eq a b)
flisp/unittest.lsp:(test-lt (every-sint -1) (every-int 1))
flisp/unittest.lsp:(test-lt (every-int 0) (every-int 1))
flisp/unittest.lsp:(test-eq (every-int 88) (every-int 88))
flisp/unittest.lsp:(test-eq (every-sint -88) (every-sint -88))
flisp/unittest.lsp:(define (test-square a)
flisp/unittest.lsp:(test-square (every-sint -67))
flisp/unittest.lsp:(test-square (every-int 3))
flisp/unittest.lsp:(test-square (every-int 0x80000000))
flisp/unittest.lsp:(test-square (every-sint 0x80000000))
flisp/unittest.lsp:(test-square (every-sint -0x80000000))
flisp/unittest.lsp:(assert (= (/ -1) -1))
flisp/unittest.lsp:(assert (= (- 4999950000 4999941999) 8001))
flisp/unittest.lsp:(assert (< (- #uint32(0x80000000)) 0))
flisp/unittest.lsp:(assert (> (- #int32(0x80000000)) 0))
flisp/unittest.lsp:(assert (< (- #uint64(0x8000000000000000)) 0))
flisp/unittest.lsp:(assert (> (- #int64(0x8000000000000000)) 0))
flisp/unittest.lsp:(assert (equal? (uint64 (double -123)) #uint64(0xffffffffffffff85)))
flisp/unittest.lsp:; -0.0 etc.
flisp/unittest.lsp:(assert (not (equal? -0.0 0.0)))
flisp/unittest.lsp:(assert (not (equal? -0.0 0)))
flisp/unittest.lsp:(assert (not (eqv? -0.0 0)))
flisp/unittest.lsp:(assert (not (eqv? -0.0 0.0)))
flisp/unittest.lsp:(assert (= 0.0 -0.0))
flisp/unittest.lsp:(assert (= 0.1875 0x1.8p-3))
flisp/unittest.lsp:(assert (= 0.1875 0x1.8p-3f))
flisp/unittest.lsp:(assert-fail ((lambda (x) x) 1 2))
flisp/unittest.lsp:(assert-fail ((lambda (x) x)))
flisp/unittest.lsp:(assert-fail ((lambda (x y . z) z) 1))
flisp/unittest.lsp:(assert-fail (car 'x) type-error)
flisp/unittest.lsp:(assert-fail gjegherqpfdf___trejif unbound-error)
flisp/unittest.lsp:(define as (apply list* (map-int (lambda (x) (gensym)) (+ MAX_ARGS 1))))
flisp/unittest.lsp:(define as (apply list* (map-int (lambda (x) (gensym)) (+ MAX_ARGS 100))))
flisp/unittest.lsp:(define ff (compile `(lambda ,as (set! ,(car (last-pair as)) 42)
flisp/unittest.lsp:			     ,(car (last-pair as)))))
flisp/unittest.lsp:(define ff (compile `(lambda ,as (set! ,(car (last-pair as)) 42)
flisp/unittest.lsp:			     (lambda () ,(car (last-pair as))))))
flisp/unittest.lsp:(define as (map-int (lambda (x) (gensym)) 1000))
flisp/unittest.lsp:(define f (compile `(lambda ,as ,(car (last-pair as)))))
flisp/unittest.lsp:(define as (apply list* (map-int (lambda (x) (gensym)) 995)))
flisp/unittest.lsp:(assert-fail (keys4 e: 10))   ; unsupported keyword
flisp/unittest.lsp:(assert-fail (keys4 a: 1 b:)) ; keyword with no argument
flisp/unittest.lsp:(assert-fail (aref #(1) 3) bounds-error)
flisp/unittest.lsp:(assert (eof-object? (eof-object)))
flisp/unittest.lsp:(assert (not (eof-object? 1)))
flisp/unittest.lsp:(assert (not (eof-object? 'a)))
flisp/unittest.lsp:(assert (not (eof-object? '())))
flisp/unittest.lsp:(assert (not (eof-object? #f)))
flisp/unittest.lsp:(assert (not (null? (eof-object))))
flisp/unittest.lsp:(assert (not (builtin? (eof-object))))
flisp/unittest.lsp:(assert (not (function? (eof-object))))
flisp/unittest.lsp:; ok, a couple end-to-end tests as well
flisp/unittest.lsp:(define (fib n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2)))))
flisp/unittest.lsp:(assert (equal? (color-pairs (generate-5x5-pairs) '(a b c d e))
flisp/julia_extensions.c:        lerror(fl_ctx, fl_ctx->IOError, "invalid UTF-8 sequence");
flisp/julia_extensions.c:    argcount(fl_ctx, "skip-ws", nargs, 2);
flisp/julia_extensions.c:    ios_t *s = fl_toiostream(fl_ctx, args[0], "skip-ws");
flisp/julia_extensions.c:    int newlines = (args[1]!=fl_ctx->F);
flisp/julia_extensions.c:    value_t skipped = fl_ctx->F;
flisp/julia_extensions.c:            return fl_ctx->FL_EOF;
flisp/julia_extensions.c:            skipped = fl_ctx->T;
flisp/julia_extensions.c:              (wc >= 0x22c0 && wc <= 0x22c3) ||  // N-ary big ops: , , , 
flisp/julia_extensions.c:            // super- and subscript +-=()
flisp/julia_extensions.c:            (wc >= 0x309B && wc <= 0x309C) || // katakana-hiragana sound marks
flisp/julia_extensions.c:            // bold-digits and double-struck digits
flisp/julia_extensions.c:// chars that we will never allow to be part of a valid non-operator identifier
flisp/julia_extensions.c:          // ASCII and Latin1 non-connector punctuation
flisp/julia_extensions.c:    argcount(fl_ctx, "identifier-char?", nargs, 1);
flisp/julia_extensions.c:    if (!iscprim(args[0]) || ((cprim_t*)ptr(args[0]))->type != fl_ctx->wchartype)
flisp/julia_extensions.c:        type_error(fl_ctx, "identifier-char?", "wchar", args[0]);
flisp/julia_extensions.c:    return jl_id_char(wc) ? fl_ctx->T : fl_ctx->F;
flisp/julia_extensions.c:    argcount(fl_ctx, "identifier-start-char?", nargs, 1);
flisp/julia_extensions.c:    if (!iscprim(args[0]) || ((cprim_t*)ptr(args[0]))->type != fl_ctx->wchartype)
flisp/julia_extensions.c:        type_error(fl_ctx, "identifier-start-char?", "wchar", args[0]);
flisp/julia_extensions.c:    return jl_id_start_char(wc) ? fl_ctx->T : fl_ctx->F;
flisp/julia_extensions.c:    argcount(fl_ctx, "never-identifier-char?", nargs, 1);
flisp/julia_extensions.c:    if (!iscprim(args[0]) || ((cprim_t*)ptr(args[0]))->type != fl_ctx->wchartype)
flisp/julia_extensions.c:        type_error(fl_ctx, "never-identifier-char?", "wchar", args[0]);
flisp/julia_extensions.c:    return never_id_char(wc) ? fl_ctx->T : fl_ctx->F;
flisp/julia_extensions.c:    argcount(fl_ctx, "op-suffix-char?", nargs, 1);
flisp/julia_extensions.c:    if (!iscprim(args[0]) || ((cprim_t*)ptr(args[0]))->type != fl_ctx->wchartype)
flisp/julia_extensions.c:        type_error(fl_ctx, "op-suffix-char?", "wchar", args[0]);
flisp/julia_extensions.c:    return jl_op_suffix_char(wc) ? fl_ctx->T : fl_ctx->F;
flisp/julia_extensions.c:    argcount(fl_ctx, "strip-op-suffix", nargs, 1);
flisp/julia_extensions.c:        type_error(fl_ctx, "strip-op-suffix", "symbol", args[0]);
flisp/julia_extensions.c:    if (!i) return args[0]; // only suffix chars --- might still be a valid identifier
flisp/julia_extensions.c:    argcount(fl_ctx, "underscore-symbol?", nargs, 1);
flisp/julia_extensions.c:    if (!issymbol(args[0])) return fl_ctx->F;
flisp/julia_extensions.c:    if (*op == '\0') return fl_ctx->F; // return false for empty symbol
flisp/julia_extensions.c:    return *op ? fl_ctx->F : fl_ctx->T;
flisp/julia_extensions.c:               least 32 bits on all Julia-supported systems, and because
flisp/julia_extensions.c:// return NFC-normalized UTF8-encoded version of s, with
flisp/julia_extensions.c:    if (newlen > fl_ctx->jlbuflen) {
flisp/julia_extensions.c:        fl_ctx->jlbuflen = newlen * 2;
flisp/julia_extensions.c:        fl_ctx->jlbuf = realloc(fl_ctx->jlbuf, fl_ctx->jlbuflen);
flisp/julia_extensions.c:        if (!fl_ctx->jlbuf) lerror(fl_ctx, fl_ctx->OutOfMemoryError, "error allocating UTF8 buffer");
flisp/julia_extensions.c:    result = utf8proc_decompose_custom((uint8_t*)s,0, (int32_t*)fl_ctx->jlbuf,result, (utf8proc_option_t)options,
flisp/julia_extensions.c:    result = utf8proc_reencode((int32_t*)fl_ctx->jlbuf,result, (utf8proc_option_t)options);
flisp/julia_extensions.c:    return (char*) fl_ctx->jlbuf;
flisp/julia_extensions.c:    argcount(fl_ctx, "accum-julia-symbol", nargs, 2);
flisp/julia_extensions.c:    ios_t *s = fl_toiostream(fl_ctx, args[1], "accum-julia-symbol");
flisp/julia_extensions.c:    if (!iscprim(args[0]) || ((cprim_t*)ptr(args[0]))->type != fl_ctx->wchartype)
flisp/julia_extensions.c:        type_error(fl_ctx, "accum-julia-symbol", "wchar", args[0]);
flisp/julia_extensions.c:    argcount(fl_ctx, "string->normsymbol", nargs, 1);
flisp/julia_extensions.c:        type_error(fl_ctx, "string->normsymbol", "string", args[0]);
flisp/julia_extensions.c:    { "skip-ws", fl_skipws },
flisp/julia_extensions.c:    { "accum-julia-symbol", fl_accum_julia_symbol },
flisp/julia_extensions.c:    { "identifier-char?", fl_julia_identifier_char },
flisp/julia_extensions.c:    { "identifier-start-char?", fl_julia_identifier_start_char },
flisp/julia_extensions.c:    { "never-identifier-char?", fl_julia_never_identifier_char },
flisp/julia_extensions.c:    { "op-suffix-char?", fl_julia_op_suffix_char },
flisp/julia_extensions.c:    { "strip-op-suffix", fl_julia_strip_op_suffix },
flisp/julia_extensions.c:    { "underscore-symbol?", fl_julia_underscore_symbolp },
flisp/julia_extensions.c:    { "string->normsymbol", fl_string2normsymbol },
flisp/compiler.lsp:; -*- scheme -*-
flisp/compiler.lsp:	  cons list car cdr set-car! set-cdr!
flisp/compiler.lsp:	  + - * / div0 = < compare
flisp/compiler.lsp:	  seta seta.l removed-setc removed-setc.l
flisp/compiler.lsp:    (for 0 (1- (length keys))
flisp/compiler.lsp:(define arg-counts
flisp/compiler.lsp:	 cdr      1      set-car! 2
flisp/compiler.lsp:	 set-cdr! 2      =        2
flisp/compiler.lsp:(define (make-code-emitter) (vector () (table) 0 () 0))
flisp/compiler.lsp:  (let ((const-to-idx (bcode:ctable b))
flisp/compiler.lsp:    (if (has? const-to-idx v)
flisp/compiler.lsp:	(get const-to-idx v)
flisp/compiler.lsp:	(begin (put! const-to-idx v nconst)
flisp/compiler.lsp:	  (set-car! (aref e 0) 'cadr)
flisp/compiler.lsp:(define (make-label e)   (gensym))
flisp/compiler.lsp:(define (mark-label e l) (emit e 'label l))
flisp/compiler.lsp:;; labels are fixed-up.
flisp/compiler.lsp:(define (encode-byte-code e)
flisp/compiler.lsp:	 (v  (list->vector cl))
flisp/compiler.lsp:		       ;; instructions accepting 32-bit arguments
flisp/compiler.lsp:	  (label-to-loc   (table))
flisp/compiler.lsp:	  (fixup-to-label (table))
flisp/compiler.lsp:	      (begin (put! label-to-loc (aref v (+ i 1)) (sizeof bcode))
flisp/compiler.lsp:		       (put! fixup-to-label (sizeof bcode) nxt)
flisp/compiler.lsp:				 (- (get label-to-loc labl)
flisp/compiler.lsp:       fixup-to-label)
flisp/compiler.lsp:(define (const-to-idx-vec e)
flisp/compiler.lsp:(define (index-of item lst start)
flisp/compiler.lsp:	(else (index-of item (cdr lst) (+ start 1)))))
flisp/compiler.lsp:(define (capture-var! g sym)
flisp/compiler.lsp:    (let ((n (index-of sym ce 0)))
flisp/compiler.lsp:(define (in-env? s env)
flisp/compiler.lsp:	   (in-env? s (cdr env)))))
flisp/compiler.lsp:(define (lookup-sym s env lev)
flisp/compiler.lsp:	    (lookup-sym s
flisp/compiler.lsp:				(eof-object? x))))
flisp/compiler.lsp:(define (compile-sym g env s deref)
flisp/compiler.lsp:  (let ((loc (lookup-sym s env 0)))
flisp/compiler.lsp:		    (printable? (top-level-value s)))
flisp/compiler.lsp:	       (emit g 'loadv (top-level-value s))
flisp/compiler.lsp:	   (emit g 'loadc (capture-var! g s))
flisp/compiler.lsp:(define (compile-set! g env s rhs)
flisp/compiler.lsp:  (let ((loc (lookup-sym s env 0)))
flisp/compiler.lsp:	(begin (compile-in g env #f rhs)
flisp/compiler.lsp:			  (capture-var! g s))))
flisp/compiler.lsp:		       (compile-in g env #f rhs)
flisp/compiler.lsp:		       (bcode:stack g -1)
flisp/compiler.lsp:		       (emit g 'set-car!))
flisp/compiler.lsp:		(begin (compile-in g env #f rhs)
flisp/compiler.lsp:(define (box-vars g env)
flisp/compiler.lsp:(define (compile-if g env tail? x)
flisp/compiler.lsp:  (let ((elsel (make-label g))
flisp/compiler.lsp:	(endl  (make-label g))
flisp/compiler.lsp:	   (compile-in g env tail? then))
flisp/compiler.lsp:	   (compile-in g env tail? else))
flisp/compiler.lsp:	   (compile-in g env #f test)
flisp/compiler.lsp:	   (compile-in g env tail? then)
flisp/compiler.lsp:	   (mark-label g elsel)
flisp/compiler.lsp:	   (compile-in g env tail? else)
flisp/compiler.lsp:	   (mark-label g endl)))))
flisp/compiler.lsp:(define (compile-begin g env tail? forms)
flisp/compiler.lsp:  (cond ((atom? forms) (compile-in g env tail? (void)))
flisp/compiler.lsp:	 (compile-in g env tail? (car forms)))
flisp/compiler.lsp:	 (compile-in g env #f (car forms))
flisp/compiler.lsp:	 (compile-begin g env tail? (cdr forms)))))
flisp/compiler.lsp:(define (compile-prog1 g env x)
flisp/compiler.lsp:  (compile-in g env #f (cadr x))
flisp/compiler.lsp:	     (compile-begin g env #f (cddr x))
flisp/compiler.lsp:	     (bcode:stack g -1))))
flisp/compiler.lsp:(define (compile-while g env cond body)
flisp/compiler.lsp:  (let ((top  (make-label g))
flisp/compiler.lsp:	(end  (make-label g)))
flisp/compiler.lsp:    (compile-in g env #f (void))
flisp/compiler.lsp:    (mark-label g top)
flisp/compiler.lsp:    (compile-in g env #f cond)
flisp/compiler.lsp:    (bcode:stack g -1)
flisp/compiler.lsp:    (compile-in g env #f body)
flisp/compiler.lsp:    (mark-label g end)))
flisp/compiler.lsp:(define (1arg-lambda? func)
flisp/compiler.lsp:(define (compile-for g env lo hi func)
flisp/compiler.lsp:  (if (1arg-lambda? func)
flisp/compiler.lsp:      (begin (compile-in g env #f lo)
flisp/compiler.lsp:	     (compile-in g env #f hi)
flisp/compiler.lsp:	     (compile-in g env #f func)
flisp/compiler.lsp:	     (bcode:stack g -2))
flisp/compiler.lsp:      (error "for: third form must be a 1-argument lambda")))
flisp/compiler.lsp:(define (compile-short-circuit g env tail? forms default branch)
flisp/compiler.lsp:  (cond ((atom? forms)        (compile-in g env tail? default))
flisp/compiler.lsp:	((atom? (cdr forms))  (compile-in g env tail? (car forms)))
flisp/compiler.lsp:	 (let ((end  (make-label g)))
flisp/compiler.lsp:	   (compile-in g env #f (car forms))
flisp/compiler.lsp:	   (bcode:stack g -1)
flisp/compiler.lsp:	   (compile-short-circuit g env tail? (cdr forms) default branch)
flisp/compiler.lsp:	   (mark-label g end)))))
flisp/compiler.lsp:(define (compile-and g env tail? forms)
flisp/compiler.lsp:  (compile-short-circuit g env tail? forms #t 'brf))
flisp/compiler.lsp:(define (compile-or g env tail? forms)
flisp/compiler.lsp:  (compile-short-circuit g env tail? forms #f 'brt))
flisp/compiler.lsp:(define (compile-arglist g env lst)
flisp/compiler.lsp:  (for-each (lambda (a)
flisp/compiler.lsp:	      (compile-in g env #f a)
flisp/compiler.lsp:(define (argc-error head count)
flisp/compiler.lsp:(define builtin->instruction
flisp/compiler.lsp:		    aset! 'aset!  - '-  boolean? 'boolean?  not 'not
flisp/compiler.lsp:		    set-cdr! 'set-cdr!  / '/
flisp/compiler.lsp:		    set-car! 'set-car!  car 'car
flisp/compiler.lsp:(define (compile-builtin-call g env tail? x head b nargs)
flisp/compiler.lsp:  (let ((count (get arg-counts head #f)))
flisp/compiler.lsp:	(argc-error b count))
flisp/compiler.lsp:      (-    (cond ((= nargs 0) (argc-error b 1))
flisp/compiler.lsp:		(argc-error b 1)
flisp/compiler.lsp:		    (argc-error b 2)
flisp/compiler.lsp:(define (compile-let g env tail? form)
flisp/compiler.lsp:	  (n    (compile-arglist g env args)))
flisp/compiler.lsp:	     (vars-to-env vars (complex-bindings (caddr lam) vars) sp)))
flisp/compiler.lsp:	(box-vars g newvars)
flisp/compiler.lsp:	  (compile-in g newenv tail? (caddr lam))
flisp/compiler.lsp:	  (bcode:stack g (- n))
flisp/compiler.lsp:(define (compile-app g env tail? x)
flisp/compiler.lsp:		    (not (in-env? head env))
flisp/compiler.lsp:		    (builtin? (top-level-value head)))
flisp/compiler.lsp:	       (top-level-value head)
flisp/compiler.lsp:	  (begin (compile-in g env #f head)
flisp/compiler.lsp:		 (let ((nargs (compile-arglist g env (cdr x))))
flisp/compiler.lsp:		   (bcode:stack g (- nargs))
flisp/compiler.lsp:			(builtin->instruction head))))
flisp/compiler.lsp:		     (not (in-env? head env))
flisp/compiler.lsp:		     (equal? (top-level-value 'cadr) cadr)
flisp/compiler.lsp:		(begin (compile-in g env #f (cadr x))
flisp/compiler.lsp:		    (compile-let g env tail? x)
flisp/compiler.lsp:			  (begin (compile-in g env #f head)
flisp/compiler.lsp:		      (let ((nargs (compile-arglist g env (cdr x))))
flisp/compiler.lsp:			(bcode:stack g (- nargs))
flisp/compiler.lsp:			(if (not b) (bcode:stack g -1))
flisp/compiler.lsp:			    (compile-builtin-call g env tail? x head b nargs)
flisp/compiler.lsp:(define (fits-i8 x) (and (fixnum? x) (>= x -128) (<= x 127)))
flisp/compiler.lsp:(define (compile-in g env tail? x)
flisp/compiler.lsp:  (cond ((symbol? x) (compile-sym g env x #t))
flisp/compiler.lsp:	       ((fits-i8 x) (emit g 'loadi8 x))
flisp/compiler.lsp:	       ((eof-object? x)
flisp/compiler.lsp:		(compile-in g env tail? (list (top-level-value 'eof-object))))
flisp/compiler.lsp:	((or (not (symbol? (car x))) (bound? (car x)) (in-env? (car x) env))
flisp/compiler.lsp:	 (compile-app g env tail? x))
flisp/compiler.lsp:	   (quote    (if (self-evaluating? (cadr x))
flisp/compiler.lsp:			 (compile-in g env tail? (cadr x))
flisp/compiler.lsp:	   (if       (compile-if g env tail? x))
flisp/compiler.lsp:	   (begin    (compile-begin g env tail? (cdr x)))
flisp/compiler.lsp:	   (prog1    (compile-prog1 g env x))
flisp/compiler.lsp:	   (lambda   (receive (the-f cenv) (compile-f- env x)
flisp/compiler.lsp:		       (begin (emit g 'loadv the-f)
flisp/compiler.lsp:				    (for-each (lambda (var)
flisp/compiler.lsp:						(compile-sym g env var #f))
flisp/compiler.lsp:	   (and      (compile-and g env tail? (cdr x)))
flisp/compiler.lsp:	   (or       (compile-or  g env tail? (cdr x)))
flisp/compiler.lsp:	   (while    (compile-while g env (cadr x) (cons 'begin (cddr x))))
flisp/compiler.lsp:	   (for      (compile-for   g env (cadr x) (caddr x) (cadddr x)))
flisp/compiler.lsp:	   (return   (compile-in g env #t (cadr x))
flisp/compiler.lsp:	   (set!     (compile-set! g env (cadr x) (caddr x)))
flisp/compiler.lsp:	   (trycatch (compile-in g env #f `(lambda () ,(cadr x)))
flisp/compiler.lsp:		     (unless (1arg-lambda? (caddr x))
flisp/compiler.lsp:			     (error "trycatch: second form must be a 1-argument lambda"))
flisp/compiler.lsp:		     (compile-in g env #f (caddr x))
flisp/compiler.lsp:	   (else   (compile-app g env tail? x))))))
flisp/compiler.lsp:(define (keyword-arg? x) (and (pair? x) (keyword? (car x))))
flisp/compiler.lsp:(define (keyword->symbol k)
flisp/compiler.lsp:(define (lambda-vars l)
flisp/compiler.lsp:  (define (check-formals l o opt kw)
flisp/compiler.lsp:	       (check-formals (cdr l) o opt kw)))
flisp/compiler.lsp:	       (check-formals (cdr l) o opt #t)
flisp/compiler.lsp:		   (check-formals (cdr l) o #t kw))))
flisp/compiler.lsp:  (check-formals l l #f #f)
flisp/compiler.lsp:  (map (lambda (s) (if (pair? s) (keyword->symbol (car s)) s))
flisp/compiler.lsp:       (to-proper l)))
flisp/compiler.lsp:(define (emit-optional-arg-inits g env opta vars i)
flisp/compiler.lsp:      (let ((nxt (make-label g)))
flisp/compiler.lsp:	(compile-in g (extend-env env (list-head vars i) '()) #f (cadar opta))
flisp/compiler.lsp:	(mark-label g nxt)
flisp/compiler.lsp:	(emit-optional-arg-inits g env (cdr opta) vars (+ i 1)))))
flisp/compiler.lsp:(define (expand-define x)
flisp/compiler.lsp:			     (print-to-string x))))))
flisp/compiler.lsp:(define get-defined-vars
flisp/compiler.lsp:  (letrec ((get-defined-vars-
flisp/compiler.lsp:		     (apply nconc (map get-defined-vars- (cdr expr))))
flisp/compiler.lsp:    (lambda (expr) (delete-duplicates (get-defined-vars- expr)))))
flisp/compiler.lsp:(define (lower-define e)
flisp/compiler.lsp:  (define (lambda-body e)
flisp/compiler.lsp:      (let ((V     (get-defined-vars B))
flisp/compiler.lsp:	    (new-B (lower-define B)))
flisp/compiler.lsp:	    new-B
flisp/compiler.lsp:	    (cons `(lambda ,V ,new-B)
flisp/compiler.lsp:	 (lower-define (expand-define e)))
flisp/compiler.lsp:	 `(lambda ,(cadr e) ,(lambda-body e) . ,(lastcdr e)))
flisp/compiler.lsp:	 (map lower-define e))))
flisp/compiler.lsp:(define (lambda:vars e) (lambda-vars (cadr e)))
flisp/compiler.lsp:(define (complex-bindings- e vars head nested capt setd)
flisp/compiler.lsp:	 (complex-bindings- (caddr e) vars #f nested capt setd))
flisp/compiler.lsp:	 (complex-bindings- (lambda:body e)
flisp/compiler.lsp:	 (cons (complex-bindings- (car e) vars (inlineable? e) nested capt setd)
flisp/compiler.lsp:		      (complex-bindings- x vars #f nested capt setd))
flisp/compiler.lsp:(define (complex-bindings e vars)
flisp/compiler.lsp:    (complex-bindings- e vars #f #f capt setd)
flisp/compiler.lsp:(define (vars-to-env vars cb offs)
flisp/compiler.lsp:(define (extend-env env vars cb)
flisp/compiler.lsp:  (cons (vars-to-env vars cb 0)
flisp/compiler.lsp:(define (compile f) (compile-f () (lower-define f)))
flisp/compiler.lsp:(define (compile-thunk expr)
flisp/compiler.lsp:  ;; to eval a top-level expression we need to avoid internal define
flisp/compiler.lsp:  (compile-f () `(lambda () ,(lower-define expr))))
flisp/compiler.lsp:(define (compile-f env f)
flisp/compiler.lsp:	   (compile-f- env f)
flisp/compiler.lsp:(define (compile-f- env f)
flisp/compiler.lsp:  (let ((g     (make-code-emitter))
flisp/compiler.lsp:	   (nreq  (- nargs (length opta)))
flisp/compiler.lsp:	   (kwa   (filter keyword-arg? opta)))
flisp/compiler.lsp:		      (if (null? atail) nargs (- nargs)))
flisp/compiler.lsp:		  (bcode:indexfor g (make-perfect-hash-table
flisp/compiler.lsp:			(if (null? atail) nargs (- nargs)))))
flisp/compiler.lsp:	    (emit-optional-arg-inits g env opta vars nreq)))
flisp/compiler.lsp:      (let ((newenv (extend-env env vars (complex-bindings (lambda:body f) vars))))
flisp/compiler.lsp:	(box-vars g (car newenv))
flisp/compiler.lsp:	(compile-in g newenv #t (lambda:body f))
flisp/compiler.lsp:	(values (function (encode-byte-code (bcode:code g))
flisp/compiler.lsp:			  (const-to-idx-vec g) name)
flisp/compiler.lsp:#;(define (ref-int32-LE a i)
flisp/compiler.lsp:#;(define (ref-int16-LE a i)
flisp/compiler.lsp:  (string.lpad (number->string n 16) 5 #\0))
flisp/compiler.lsp:    (define (print-val v)
flisp/compiler.lsp:    (princ "maxstack " (ref-int32-LE code 0) "\n")
flisp/compiler.lsp:	       (princ (hex5 (- i 4)) ":  "
flisp/compiler.lsp:		  (print-val (aref vals (ref-int32-LE code i)))
flisp/compiler.lsp:		  (print-val (aref vals (aref code i)))
flisp/compiler.lsp:		 ((loada seta loadc call tcall list + - * / vector
flisp/compiler.lsp:		  (princ (number->string (aref code i)))
flisp/compiler.lsp:		  (princ (number->string (ref-int32-LE code i)))
flisp/compiler.lsp:		  (princ (number->string (ref-int32-LE code i)) " ")
flisp/compiler.lsp:		  (princ (number->string (ref-int32-LE code i)))
flisp/compiler.lsp:			(princ (number->string (ref-int32-LE code i)) " ")
flisp/compiler.lsp:		  (princ (number->string (ref-int32-LE code i)) " ")
flisp/compiler.lsp:		  (princ "@" (hex5 (+ i -4 (ref-int16-LE code i))))
flisp/compiler.lsp:		  (princ "@" (hex5 (+ i -4 (ref-int32-LE code i))))
flisp/compiler.lsp:; From SRFI 89 by Marc Feeley (http://srfi.schemers.org/srfi-89/srfi-89.html)
flisp/compiler.lsp:; The result is a perfect hash-table represented as a vector of
flisp/compiler.lsp:; the hash-table it is at index
flisp/compiler.lsp:;   X = (* 2 ($hash-keyword K N))
flisp/compiler.lsp:(define (make-perfect-hash-table alist)
flisp/compiler.lsp:  (define ($hash-keyword key n) (mod0 (abs (hash key)) n))
flisp/compiler.lsp:              (let ((x (* 2 ($hash-keyword key n))))
flisp/flisp.boot:(*banner* ";  _\n; |_ _ _ |_ _ |  . _ _\n; | (-||||_(_)|__|_)|_)\n;-------------------|----------------------------------------------------------\n\n"
flisp/flisp.boot:		      #fn("8000s0c0|v2;" [#.-])
flisp/flisp.boot:	  *interactive* #f *syntax-environment*
flisp/flisp.boot:						      thrown-value])  assert #fn(";000r1c0|]c1c2c3|L2L2L2L4;" [if
flisp/flisp.boot:  raise quote assert-failed])  case #fn("A000s1]\x8c6g6c0O2c130c2g7|L2L1c3c4L1c5c6g6g7q2}3232L3;" [#fn("8000r2}c0\x8250c0;}\x8540^;}C6=0c1|e2}31L3;}?6=0c3|e2}31L3;}N\x85>0c3|e2}M31L3;e4c5}326=0c6|c7}L2L3;c8|c7}L2L3;" [else
flisp/flisp.boot:  eq? quote-value eqv? every #.symbol? memq quote memv] vals->cond)
flisp/flisp.boot:  #fn("7000r1~M\x7f|M32|NK;" [])])  unwind-protect #fn("A000r2c030c030c1g7c2_}L3L2L1c3c4|c2g6L1c5g7L1c6g6L2L3L3L3g7L1L3L3;" [#fn(gensym)
flisp/flisp.boot:  let lambda prog1 trycatch begin raise])  with-bindings #fn("G000s1c0c1|32c0e2|32c0c3|32c4c5L1c0c6g8g633L1c7c0c8g6g73331c9c4c:L1c7}3132c4c:L1c7c0c;g6g8333132L3L144;" [#fn(map)
flisp/flisp.boot:  #fn(nconc) let #.list #fn(copy-list) #fn("7000r2c0|}L3;" [set!])
flisp/flisp.boot:  unwind-protect begin #fn("7000r2c0|}L3;" [set!])])  time #fn(">000r1c030c1g5c2L1L2L1c3|c4c5c6c2L1g5L3c7L4L3L3;" [#fn(gensym)
flisp/flisp.boot:  let time.now prog1 princ "Elapsed time: " - " seconds\n"])  dotimes #fn("A000s1|M|\x84c0`c1g7aL3c2c3L1g6L1L1c4}3133L4;" [for
flisp/flisp.boot:  - #fn(nconc) lambda #fn(copy-list)])  define-macro #fn(">000s1c0c1|ML2c2c3L1|NL1c4}3133L3;" [set-syntax!
flisp/flisp.boot:  quote #fn(nconc) lambda #fn(copy-list)])  unless #fn("<000s1c0|^c1}KL4;" [if
flisp/flisp.boot:  begin])  with-output-to #fn("<000s1c0c1L1c2|L2L1L1c3}3143;" [#fn(nconc)
flisp/flisp.boot:							       with-bindings
flisp/flisp.boot:							       *output-stream*
flisp/flisp.boot:							       #fn(copy-list)])  cond #fn(":000s0]\x8c5g5c0g5q1O2g5M|41;" [#fn(">000r1|?640^;|Mg5Mc0<17802g5M]<6C0g5N\x8560g5M;c1g5NK;g5N\x85@0c2g5M~M|N31L3;g5\x84c3\x82\x980e4e5g531316c0e6e5g53131c7g6g5ML2L1c8g6c1e9e5g53131K~M|N31L4L3;c:30c7g6g5ML2L1c8g6e5g531g6L2~M|N31L4L3;c8g5Mc1g5NK~M|N31L4;" [else
flisp/flisp.boot:  begin or => 1arg-lambda? caddr caadr let if cddr #fn(gensym)] cond-clauses->if)])  with-input-from #fn("<000s1c0c1L1c2|L2L1L1c3}3143;" [#fn(nconc)
flisp/flisp.boot:  with-bindings *input-stream* #fn(copy-list)])  quasiquote #fn("7000r1e0|`42;" [bq-process])  letrec #fn(">000s1c0c0c1L1c2c3|32L1c2c4|32c5}3134L1c2c6|3242;" [#fn(nconc)
flisp/flisp.boot:  lambda #fn(map) #.car #fn("8000r1c0c1L1c2|3142;" [#fn(nconc) set! #fn(copy-list)])
flisp/flisp.boot:  #fn(copy-list) #fn("5000r1e040;" [void])])  receive #fn("?000s2c0c1_}L3c2c1L1|L1c3g23133L3;" [call-with-values
flisp/flisp.boot:  lambda #fn(nconc) #fn(copy-list)])  let* #fn("@000s1|?6E0c0c1L1_L1c2}3133L1;c0c1L1e3|31L1L1c2|NF6H0c0c4L1|NL1c2}3133L1530}3133e5|31L2;" [#fn(nconc)
flisp/flisp.boot:  lambda #fn(copy-list) caar let* cadar])  when #fn(";000s1c0|c1}K^L4;" [if
flisp/flisp.boot:  trycatch lambda if and pair? eq? car quote thrown-value cadr caddr raise])  let #fn(">000s1^|C6B0|m62}Mm02}Nm1530]2c0c1L1c2c3|32L1c4}3133c2c5|32g66C0c6g6g7L2L1g6L3540g7g8K;" [#fn(nconc)
flisp/flisp.boot:  #fn(copy-list) #fn("5000r1|F650|\x84;e040;" [void]) letrec]))
flisp/flisp.boot:	  1+ #fn("6000r1|aw;" [] 1+) 1-
flisp/flisp.boot:	  #fn("6000r1|ax;" [] 1-) 1arg-lambda? #fn("7000r1|F16T02|Mc0<16J02|NF16B02|\x84F16:02e1|\x84a42;" [lambda
flisp/flisp.boot:  length=] 1arg-lambda?)
flisp/flisp.boot:	  Instructions #table(jmp.l 8  loadg.l 54  loadt 45  brn.l 88  lvargc 75  box 92  boolean? 18  eq? 12  + 34  loada 55  brn 87  box.l 93  aset! 44  brt.l 10  seta.l 62  null? 17  ret 11  vector 42  loadv 51  cadr 84  builtin? 23  setg.l 60  apply 33  keyargs 91  trycatch 68  dup 1  aref 43  list 28  set-car! 31  seta 61  removed-setc.l 64  cons 27  brne 82  closure 65  dummy_nil 97  neg 73  loadc0 78  pop 2  pair? 22  brbound 90  loada1 77  / 37  loadc1 79  vargc 67  sub2 72  brf.l 9  function? 26  load1 49  call.l 80  symbol? 19  = 39  loada0 76  call 3  set-cdr! 32  compare 41  dummy_t 95  load0 48  atom? 15  tcall 4  equal? 14  car 29  loadc.l 58  eqv? 13  loada.l 56  for 69  loadf 46  tcall.l 81  removed-setc 63  dummy_f 96  brt 7  jmp 5  < 40  brf 6  tapply 70  loadnil 47  argc 66  not 16  add2 71  largc 74  cdr 30  brnn 85  brne.l 83  loadc 57  - 35  shift 94  * 36  nop 0  div0 38  loadv.l 52  optargs 89  vector? 24  brnn.l 86  loadg 53  fixnum? 25  number? 20  setg 59  bound? 21  loadi8 50)
flisp/flisp.boot:	  __init_globals #fn("6000r0e0c1<17B02e0c2<17802e0c3<6>0c4k52c6k75;0c8k52c9k72e:k;2e<k=2e>k?;" [*os-name*
flisp/flisp.boot:  win32 win64 windows "\\" *directory-separator* "\r\n" *linefeed* "/" "\n"
flisp/flisp.boot:  *stdout* *output-stream* *stdin* *input-stream* *stderr* *error-stream*] __init_globals)
flisp/flisp.boot:					  #fn("6000r1e0|312c1a41;" [top-level-exception-handler
flisp/flisp.boot:	  #fn("7000r2}F16D02|}M3117:02e0|}N42;" [any] any) arg-counts #table(#.equal? 2  #.atom? 1  #.set-cdr! 2  #.symbol? 1  #.car 1  #.eq? 2  #.aref 2  #.boolean? 1  #.not 1  #.null? 1  #.eqv? 2  #.number? 1  #.pair? 1  #.builtin? 1  #.aset! 3  #.div0 2  #.= 2  #.bound? 1  #.compare 2  #.vector? 1  #.cdr 1  #.set-car! 2  #.< 2  #.fixnum? 1  #.cons 2)
flisp/flisp.boot:	  argc-error #fn(";000r2e0c1|c2}}aW670c3540c445;" [error "compile error: "
flisp/flisp.boot:							   " arguments."] argc-error)
flisp/flisp.boot:	  box-vars #fn("9000r2]\x8c6g6c0|g6q2O2g6M\x8e1}41;" [#fn("9000r1|F6Q0|M\x846B0e0~c1e2|M3133530]2\x7fM|N41;];" [emit
flisp/flisp.boot:  box caddr])] box-vars)
flisp/flisp.boot:	  bq-bracket #fn(";000r2|?6=0c0e1|}32L2;|Mc2\x82R0}`W680c0|NK;c0c3c4e1|N}ax32L3L2;|Mc5\x82S0}`W690c6|\x84L2;c0c0c7e1|\x84}ax32L3L2;|Mc8\x82O0}`W650|\x84;c0c0c9e1|\x84}ax32L3L2;c0e1|}32L2;" [#.list
flisp/flisp.boot:  bq-process unquote #.cons 'unquote unquote-splicing copy-list 'unquote-splicing
flisp/flisp.boot:  unquote-nsplicing 'unquote-nsplicing] bq-bracket)
flisp/flisp.boot:	  bq-bracket1 #fn(":000r2|F16802|Mc0<6K0}`W650|\x84;c1c2e3|N}ax32L3;e3|}42;" [unquote
flisp/flisp.boot:  #.cons 'unquote bq-process] bq-bracket1)
flisp/flisp.boot:	  bq-process #fn("<000r2|C680c0|L2;|H6T0e1e2|31}32g6Mc3\x8290c4g6NK;c5c4g6L3;|?640|;|Mc6\x82B0c3c7e1|\x84}aw32L3;|Mc8\x82W0}`W16:02e9|b232650|\x84;c:c;e1|N}ax32L3;e<e=|327t0e>|31c?c@}q1|32g6\x8580c3g7K;g7N\x85A0c:g7Me1g6}32L3;cAcBg7Ke1g6}32L142;]\x8c6g6cC}g6q2O2g6M\x8e1|_42;" [quote
flisp/flisp.boot:  bq-process vector->list #.list #.vector #.apply quasiquote 'quasiquote
flisp/flisp.boot:  unquote length= #.cons 'unquote any splice-form? lastcdr #fn(map)
flisp/flisp.boot:  #fn("7000r1e0|~42;" [bq-bracket1]) #fn(nconc)
flisp/flisp.boot:  reverse! unquote nreconc #.list 'unquote bq-process bq-bracket])] bq-process)
flisp/flisp.boot:	  builtin->instruction #fn("8000r1c0~|^43;" [#fn(get)] [#table(#.equal? equal?  #.* *  #.car car  #.apply apply  #.aref aref  #.- -  #.boolean? boolean?  #.builtin? builtin?  #.null? null?  #.eqv? eqv?  #.function? function?  #.bound? bound?  #.cdr cdr  #.list list  #.set-car! set-car!  #.cons cons  #.atom? atom?  #.set-cdr! set-cdr!  #.symbol? symbol?  #.eq? eq?  #.vector vector  #.not not  #.pair? pair?  #.number? number?  #.div0 div0  #.aset! aset!  #.+ +  #.= =  #.compare compare  #.vector? vector?  #./ /  #.< <  #.fixnum? fixnum?)])
flisp/flisp.boot:	  #2=#fn("5000r1|\x84;" [] cadr) call-with-values #fn("7000r2|30g6F16802~g6M<690}g6Nv2;}g641;" [] [#1=(*values*)])
flisp/flisp.boot:	  capture-var! #fn("<000r2e0|31e1}g6`33g717G02c2g631|b3c3g6}L132\\2;" [bcode:cenv
flisp/flisp.boot:  index-of #fn(length) #fn(append!)] capture-var!)
flisp/flisp.boot:	  #fn("8000r1e0_e1|3142;" [compile-f lower-define] compile) compile-and
flisp/flisp.boot:	  #fn(";000r4e0|}g2g3]c146;" [compile-short-circuit brf] compile-and)
flisp/flisp.boot:	  compile-app #fn("E000r4g3Mg8C16Z02e0g8}32@16M02g8E16E02c1g83116:02c2g831G6;0c2g831540g8e3g3Nc4326i0e5|}^g9342e6|a322e7|}g3N33e6|g:y322e8|g2670c9540c:g:43;g9G16902e;g931g9c<<16V02e0g9}32@16I02c2c<31e<>16;02e=g3b2326E0e5|}^g3\x84342e8|c<42;g9F16D02g9Mc><16902e?g3316=0e@|}g2g344;g:7E0e5|}^g9342e6|a32530]2e7|}g3N33e6|g;y322g:7<0e6|b/32530]2g:6C0eA|}g2g3g9g:g;47;e8|g2670cB540cCg;43;" [in-env?
flisp/flisp.boot:  #fn(constant?) #fn(top-level-value) length> 255 compile-in bcode:stack
flisp/flisp.boot:  compile-arglist emit tcall.l call.l builtin->instruction cadr length= lambda
flisp/flisp.boot:  inlineable? compile-let compile-builtin-call tcall call] compile-app)
flisp/flisp.boot:	  compile-arglist #fn("8000r3c0c1|}q2g2322c2g241;" [#fn(for-each)
flisp/flisp.boot:							    #fn("9000r1e0~\x7f^|342e1~a42;" [compile-in
flisp/flisp.boot:  bcode:stack]) #fn(length)] compile-arglist)
flisp/flisp.boot:	  compile-begin #fn("9000r4g3?6?0e0|}g2e13044;g3N?6>0e0|}g2g3M44;e0|}^g3M342e2|c3322e4|}g2g3N44;" [compile-in
flisp/flisp.boot:  void emit pop compile-begin] compile-begin)
flisp/flisp.boot:	  compile-builtin-call #fn("<000r7c0e1g4^33g;16=02e2g3Ng;32@6=0e3g5g;32530]2g5g<c4\x82K0g6`W6:0e5|c642;e5|g5g643;g<c7\x82[0g6`W6:0e5|c842;g6b2W6:0e5|c942;e5|g5g643;g<c:\x82j0g6`W6:0e3g5a42;g6aW6:0e5|c;42;g6b2W6:0e5|c<42;e5|g5g643;g<c=\x82K0g6`W6:0e5|c>42;e5|g5g643;g<c?\x82K0g6`W6:0e3g5a42;e5|g5g643;g<c@\x82M0g6`W6<0e5|cAcB43;e5|g5g643;g<cC\x82W0g6b2X6;0e3g5b242;e5|g2670cD540cCg643;e5|g542;" [#fn(get)
flisp/flisp.boot:  arg-counts length= argc-error list emit loadnil + load0 add2 - neg sub2 *
flisp/flisp.boot:  load1 / vector loadv [] apply tapply] compile-builtin-call)
flisp/flisp.boot:	  compile-f #fn("8000r2e0c1|}q2c242;" [call-with-values #fn("7000r0e0~\x7f42;" [compile-f-])
flisp/flisp.boot:					       #fn("5000r2|;" [])] compile-f)
flisp/flisp.boot:	  compile-f- #fn("O000r2e030}\x84e1}\x8431e2}31e3c4}\x8432e1}31g;\x8570c5540g;g7?660`580c6g731g=c6g:31xe3e7g:32g:\x87\xa20g?\x85L0e8g6c9g>g8\x8570g=550g=y345r0e:g6e;c<c=c<c>g?32e?c6g?31313331322e8g6c@g>c6g?31g8\x8570g=550g=y352eAg6|g:g9g>35530]2eBg=cC326I0e8g6g8\x8570cD540cEg=335W0g8\x87?0e8g6cFg=335E0g:\x85?0e8g6cGg=33530^2eH|g9eIeJ}31g93233eKg6g@M322g6b4c6g931b4w\\2eLg6g@]eJ}31342e8g6cM322eNcOePeQg63131eRg631g<33eSg63142;" [make-code-emitter
flisp/flisp.boot:  lastcdr lambda:vars filter #.pair? lambda #fn(length) keyword-arg? emit
flisp/flisp.boot:  optargs bcode:indexfor make-perfect-hash-table
flisp/flisp.boot:  #fn(map) #.cons #.car iota keyargs emit-optional-arg-inits > 255 largc lvargc
flisp/flisp.boot:  vargc argc extend-env complex-bindings lambda:body box-vars compile-in ret
flisp/flisp.boot:  values #fn(function) encode-byte-code bcode:code const-to-idx-vec bcode:cenv] compile-f-)
flisp/flisp.boot:	  compile-for #fn("9000r5e0g4316n0e1|}^g2342e2|a322e1|}^g3342e2|a322e1|}^g4342e3|c4322e2|b.42;e5c641;" [1arg-lambda?
flisp/flisp.boot:  compile-in bcode:stack emit for error "for: third form must be a 1-argument lambda"] compile-for)
flisp/flisp.boot:	  compile-if #fn("@000r4e0|31e0|31g3\x84e1g331e2g331F6;0e3g331560e430g:]\x82=0e5|}g2g;44;g:^\x82=0e5|}g2g<44;e5|}^g:342e6|c7g8332e5|}g2g;342g26<0e6|c8325;0e6|c9g9332e:|g8322e5|}g2g<342e:|g942;" [make-label
flisp/flisp.boot:  caddr cdddr cadddr void compile-in emit brf ret jmp mark-label] compile-if)
flisp/flisp.boot:	  compile-in #fn("<000r4g3C6<0e0|}g3]44;g3?6\xaf0g3`\x82:0e1|c242;g3a\x82:0e1|c342;g3]\x82:0e1|c442;g3^\x82:0e1|c542;g3_\x82:0e1|c642;e7g3316<0e1|c8g343;c9g3316C0e:|}g2c;c<31L144;e1|c=g343;g3MC@17D02g3ME17;02e>g3M}326=0e?|}g2g344;g3Mg8c@\x82S0eAg3\x84316>0e:|}g2g3\x8444;e1|c=g3\x8443;g8cB\x82=0eC|}g2g344;g8cD\x82>0eE|}g2g3N44;g8cF\x82;0eG|}g343;g8cH\x82D0eIcJ}g3q2cK|}q242;g8cL\x82>0eM|}g2g3N44;g8cN\x82>0eO|}g2g3N44;g8cP\x82E0eQ|}g3\x84cDeRg331K44;g8cS\x82H0eT|}g3\x84eUg331eVg33145;g8cW\x82E0e:|}]g3\x84342e1|cX42;g8cY\x82B0eZ|}g3\x84eUg33144;g8c[\x82p0e:|}^cH_g3\x84L3342e\\eUg33131660^580e]c^312e:|}^eUg331342e1|c[42;e?|}g2g344;" [compile-sym
flisp/flisp.boot:  emit load0 load1 loadt loadf loadnil fits-i8 loadi8 #fn(eof-object?)
flisp/flisp.boot:  compile-in #fn(top-level-value) eof-object loadv in-env? compile-app quote
flisp/flisp.boot:  self-evaluating? if compile-if begin compile-begin prog1 compile-prog1 lambda
flisp/flisp.boot:  call-with-values #fn("7000r0e0~\x7f42;" [compile-f-])
flisp/flisp.boot:  #fn("9000r2e0~c1|332}\x87K0c2c3~\x7fq2}322e0~c4c5}3143;];" [emit loadv #fn(for-each)
flisp/flisp.boot:							      #fn("9000r1e0~\x7f|^44;" [compile-sym])
flisp/flisp.boot:  and compile-and or compile-or while compile-while cddr for compile-for caddr
flisp/flisp.boot:  cadddr return ret set! compile-set! trycatch 1arg-lambda? error "trycatch: second form must be a 1-argument lambda"] compile-in)
flisp/flisp.boot:	  compile-let #fn("A000r4g3Mg3Ne0|31g8\x84e1|}g933e2g;e3e4g831g;32g:33e5|g=322c6g=}M32}NKe7|g>g2e4g831342e8|g<y322e9g<`3216602g2@6<0e:|c;g<43;];" [bcode:sp
flisp/flisp.boot:  compile-arglist vars-to-env complex-bindings caddr box-vars #fn(append!)
flisp/flisp.boot:  compile-in bcode:stack > emit shift] compile-let)
flisp/flisp.boot:	  compile-or #fn(";000r4e0|}g2g3^c146;" [compile-short-circuit brt] compile-or)
flisp/flisp.boot:	  compile-prog1 #fn(":000r3e0|}^g2\x84342e1g231F6W0e2|a322e3|}^e1g231342e4|c5322e2|b/42;];" [compile-in
flisp/flisp.boot:  cddr bcode:stack compile-begin emit pop] compile-prog1)
flisp/flisp.boot:	  compile-set! #fn("?000r4e0g2}`33g8c1\x82F0e2|}^g3342e3|c4g243;g8M`We5g8N31g96<0e6g8N31590e7|g232g:6g0e3|g9670c8540c9g;332e:|a322e2|}^g3342e:|b/322e3|c;42;e2|}^g3342g97A0e<c=c>g23231530]2e3|c?g;43;" [lookup-sym
flisp/flisp.boot:  global compile-in emit setg vinfo:heap? vinfo:index capture-var! loada loadc
flisp/flisp.boot:  bcode:stack set-car! error #fn(string) "internal error: misallocated var "
flisp/flisp.boot:  seta] compile-set!)
flisp/flisp.boot:	  compile-short-circuit #fn("<000r6g3?6=0e0|}g2g444;g3N?6>0e0|}g2g3M44;e1|31e0|}^g3M342e2|a322e3|c4322e3|g5g:332e2|b/322e3|c5322e6|}g2g3Ng4g5362e7|g:42;" [compile-in
flisp/flisp.boot:  make-label bcode:stack emit dup pop compile-short-circuit mark-label] compile-short-circuit)
flisp/flisp.boot:	  compile-sym #fn(";000r4e0g2}`33g8c1\x82b0c2g23116=02e3c4g231316@0e5|c6c4g23143;e5|c7g243;g8M`W6\\0e5|c8e9g8N31332g316:02e:g8N316:0e5|c;42;];e5|c<e=|g232332g316:02e:g8N316:0e5|c;42;];" [lookup-sym
flisp/flisp.boot:  global #fn(constant?) printable? #fn(top-level-value) emit loadv loadg loada
flisp/flisp.boot:  vinfo:index vinfo:heap? car loadc capture-var!] compile-sym)
flisp/flisp.boot:	  compile-thunk #fn(":000r1e0_c1_e2|31L342;" [compile-f lambda
flisp/flisp.boot:						      lower-define] compile-thunk)
flisp/flisp.boot:	  compile-while #fn(";000r4e0|31e0|31e1|}^e230342e3|a322e4|g8322e1|}^g2342e5|c6g9332e5|c7322e3|b/322e1|}^g3342e5|c8g8332e4|g942;" [make-label
flisp/flisp.boot:  compile-in void bcode:stack mark-label emit brf pop jmp] compile-while)
flisp/flisp.boot:	  complex-bindings #fn("=000r2c030c030e1|}^^g6g7362e2c3g6q1e4g73142;" [#fn(table)
flisp/flisp.boot:  complex-bindings- filter #fn("7000r1c0~|42;" [#fn(has?)]) table.keys] complex-bindings)
flisp/flisp.boot:	  complex-bindings- #fn("=000r6}\x8540^;|C6M0g316902c0|}326;0c1g4|]43;];|?17802e2|31640^;|Mc3\x82o0c0|\x84}326Q0c1g5|\x84]332g36>0c1g4|\x84]33530]530]2e4e5|31}^g3g4g546;|Mc6\x82U0e4e7|31e8}e9|3132^g2@17502g3g4g546;e4|M}e:|31g3g4g536c;c<}g3g4g5q4|N32K;" [#fn(memq)
flisp/flisp.boot:  #fn(put!) quoted? set! complex-bindings- caddr lambda lambda:body diff
flisp/flisp.boot:  lambda:vars inlineable? #fn(map) #fn(";000r1e0|~^\x7fi2i346;" [complex-bindings-])] complex-bindings-)
flisp/flisp.boot:	  const-to-idx-vec #fn("9000r1c0e1|3131e2c3g5q1e4|31322g5;" [#fn(vector.alloc)
flisp/flisp.boot:  bcode:nconst table.foreach #fn("7000r2~}|\\;" []) bcode:ctable] const-to-idx-vec)
flisp/flisp.boot:	  count #fn("9000r2]\x8c6g6c0g6q1O2g6M|}`43;" [#fn("9000r3}\x8550g2;~M|}N|}M31690g2aw540g243;" [] count-)] count)
flisp/flisp.boot:	  delete-duplicates #fn(":000r1e0|bD326O0c130]\x8c6g6c2g5g6q2O2g6M\x8e1|_42;|?640|;|M|Ne3g5g632690e4g641;g5e4g631K;" [length>
flisp/flisp.boot:  #fn(has?) #fn(put!)]) member delete-duplicates] delete-duplicates)
flisp/flisp.boot:	  emit-optional-arg-inits #fn("<000r5g2F6\x900e0|31e1|c2g4332e1|c3g9332e4|e5}e6g3g432_33^e7g231342e1|c8g4332e1|c9322e:|g9322e;|}g2Ng3g4aw45;];" [make-label
flisp/flisp.boot:  emit brbound brt compile-in extend-env list-head cadar seta pop mark-label
flisp/flisp.boot:  emit-optional-arg-inits] emit-optional-arg-inits)
flisp/flisp.boot:	  encode-byte-code #fn("S000r1e0|31e1g531e2c3g631b3c3g631b2VT2wc432c3g631`c530c530c630^^c7g<c8322]g9g8X6\xd912g6g9[m=2g=c9\x82P0c:g:g6g9aw[c;g<31332g9b2wm95\xa81c7g<e<c=e>g76\x830g=gDc?\x8270c@5p0gDcA\x8270cB5d0gDcC\x8270cD5X0gDcE\x8270cF5L0gDcG\x8270cH5@0gDcI\x8270cJ540g=\x8e1540g=3231322g9awm92g9g8X6:0g6g9[530^m>2cKg=cL326`0c:g;c;g<31g>332c7g<g7670eM540eN`31322g9awm95\xeb0g=cO\x82H0c7g<eMg>31322g9awm95\xce0g>D6\xc70g=cKg?cP326H0c7g<eMg>31322g9awm95\x9f0cKg?cQ326\x810c7g<eMg>31322g9awm92c7g<eMg6g9[31322g9awm92g=cR\x82K0c7g<eMg6g9[31322g9awm9530]5E0c7g<eSg>31322g9awm9\x8e1530^5\x83.2eTcUg<g7g:q3g;322cVg<41;" [reverse!
flisp/flisp.boot:  list->vector >= #fn(length) 65536 #fn(table)
flisp/flisp.boot:  #fn(io.tostring!)] encode-byte-code)
flisp/flisp.boot:	  #fn("7000r1e0e1|313140;" [compile-thunk expand] eval) even? #fn("7000r1c0|a32`W;" [#fn(logand)] even?)
flisp/flisp.boot:  caar begin #fn(append) cdar] splice-begin) *expanded* #fn("A000r2|?640|;~Mc0}326:0\x7fM|31530|~Mc1}32g76;0e2g631530_c3c4c5g832}32\x8c9g77A0c4c6i2g9q2g642;]\x8c:g:c7g:i2g9i3q4O2g:M\x8e1g631g:]g;F6c02i3Me8g;31<7C0g;i2Mg;Mg9M32O5;0g;e9g;31O2g;Nm;5\xfb/2g:;" [begin
flisp/flisp.boot:  define get-defined-vars #fn(nconc) #fn(map) #.list #fn("7000r1~M|\x7fM42;" [])
flisp/flisp.boot:  caar #fn(nconc) #fn(map) #.list get-defined-vars]) caar cdar] expand-body)
flisp/flisp.boot:  cadar] expand-lambda-list) #fn("7000r1|?660|L1;|MF6?0e0|31~M|N31K;|M~M|N31K;" [caar] l-vars)
flisp/flisp.boot:  cddr #fn(nconc) #fn(map) #.list lambda] expand-lambda)
flisp/flisp.boot:  define caddr cdadr caadr #fn(nconc) #fn(map) #.list] expand-define)
flisp/flisp.boot:						      #fn("9000r1|Me0~M|\x84\x7f323130\x7fL3;" [compile-thunk])] expand-let-syntax)
flisp/flisp.boot:  #fn("5000r2|;" [] local-expansion-env) #fn("<000r2|?640|;|Mc0g6}32c1~}|q3g716702g7NF6I0~Mg7\x84|NQ2\x7fMe2g731}3242;g717?02g6C@17602g6E670g840;e3|31g96>0~Mg9|NQ2}42;g6c4\x8240|;g6c5\x82:0i2M|}42;g6c6\x82:0i3M|}42;g6c7\x82:0i4M|}42;g840;" [#fn(assq)
flisp/flisp.boot:  caddr macrocall? quote lambda define let-syntax] expand-in)] expand)
flisp/flisp.boot:	  expand-define #fn("?000r1|\x84e0|31F6:0e0|315L0|\x84C6;0e130L15=0e2c3e4|3132g5C6<0c5g5g6ML3;c5g5Mc6c7L1g5NL1c8g631g5M34L3;" [cddr
flisp/flisp.boot:  void error "compile error: invalid syntax " print-to-string set! #fn(nconc)
flisp/flisp.boot:  lambda #fn(copy-list)] expand-define)
flisp/flisp.boot:	  extend-env #fn("8000r3e0}g2`33|K;" [vars-to-env] extend-env) filter
flisp/flisp.boot:	  #fn("9000r2]c0|q1m62g6|}_L143;" [#fn("8000r3g2]}F6Q02~}M316?0g2}M_KPNm2530]2}Nm15\x0e/2N;" [] filter-)] filter)
flisp/flisp.boot:	  fits-i8 #fn("7000r1|I16F02e0|b\xb03216:02e1|b\xaf42;" [>= <=] fits-i8)
flisp/flisp.boot:	  get-defined-vars #fn("7000r1e0~M|3141;" [delete-duplicates] [#0=(#fn("8000r1|?640_;|Mc0<16602|NF6d0|\x84C16702|\x84L117S02|\x84F16E02e1|31C16:02e1|31L117402_;|Mc2\x82?0c3c4~M|N32v2;_;" [define
flisp/flisp.boot:	  identity #fn("5000r1|;" [] identity) in-env?
flisp/flisp.boot:	  #fn("7000r2}F16F02c0|}M3217:02e1|}N42;" [#fn(assq) in-env?] in-env?)
flisp/flisp.boot:	  index-of #fn("9000r3}\x8540^;|}M\x8250g2;e0|}Ng2aw43;" [index-of] index-of)
flisp/flisp.boot:  #fn(eof-object)] io.readall)
flisp/flisp.boot:	  io.readlines #fn("7000r1e0e1|42;" [read-all-of io.readline] io.readlines)
flisp/flisp.boot:	  iota #fn("7000r1e0e1|42;" [map-int identity] iota) keyword->symbol
flisp/flisp.boot:								    #fn(length)] keyword->symbol)
flisp/flisp.boot:	  keyword-arg? #fn("6000r1|F16902c0|M41;" [#fn(keyword?)] keyword-arg?)
flisp/flisp.boot:	  lambda-vars #fn(":000r1]\x8c5g5c0g5q1O2g5M||^^342c1c2e3|3142;" [#fn(":000r4|A17502|C640];|F16602|MC6T0g217502g36<0e0c1}c243;~M|N}g2g344;|F16602|MF6\x890e3|Mb23216902e4|31C660^5=0e0c5|Mc6}342c7e4|31316=0~M|N}g2]44;g36<0e0c1}c843;~M|N}]g344;|F6>0e0c9|Mc6}44;|}\x82:0e0c1}42;e0c9|c6}44;" [error
flisp/flisp.boot:  "compile error: invalid formal argument "] check-formals)
flisp/flisp.boot:  #fn(map) #fn("6000r1|F690e0|M41;|;" [keyword->symbol]) to-proper] lambda-vars)
flisp/flisp.boot:	  #fn("6000r1e0|\x8441;" [lambda-vars] lambda:vars) last-pair #fn("6000r1|N?640|;e0|N41;" [last-pair] last-pair)
flisp/flisp.boot:	  lastcdr #fn("6000r1|?640|;e0|31N;" [last-pair] lastcdr) length=
flisp/flisp.boot:	  list->vector #fn("6000r1c0|v2;" [#.vector] list->vector) list-head
flisp/flisp.boot:	  #fn("9000r2e0}`32640_;|Me1|N}ax32K;" [<= list-head] list-head)
flisp/flisp.boot:	  list-ref #fn("7000r2e0|}32M;" [list-tail] list-ref) list-tail
flisp/flisp.boot:	  #fn("8000r2e0}`32640|;e1|N}ax42;" [<= list-tail] list-tail) list? #fn("6000r1|A17@02|F16902e0|N41;" [list?] list?)
flisp/flisp.boot:  #fn(read) load-process #fn(io.close)])])
flisp/flisp.boot:  #fn(raise) load-error])] load)
flisp/flisp.boot:	  load-process #fn("6000r1e0|41;" [eval] load-process) lookup-sym
flisp/flisp.boot:								  lookup-sym] lookup-sym)
flisp/flisp.boot:	  lower-define #fn(";000r1]c0m52|?17802e1|31640|;|Mc2\x82<0e3e4|3141;|Mc5\x82K0c6c5L1|\x84L1g5|31L1e7|3144;c8e3|42;" [#fn("=000r1e0|31F6N0e1|31F6=0c2e0|31K570e3|31560e430e5g531e6g531g6\x8550g7;c7g6g7L3c8c9g632K;" [cddr
flisp/flisp.boot:  cdddr begin caddr void get-defined-vars lower-define lambda #fn(map)
flisp/flisp.boot:  #fn("5000r1e040;" [void])] lambda-body) quoted? define lower-define
flisp/flisp.boot:  expand-define lambda #fn(nconc) lastcdr #fn(map)] lower-define)
flisp/flisp.boot:	  macrocall? #fn("6000r1|MC16902e0|M41;" [symbol-syntax] macrocall?)
flisp/flisp.boot:	  make-code-emitter #fn("9000r0_c030`_`Z5;" [#fn(table)] make-code-emitter)
flisp/flisp.boot:	  make-label #fn("5000r1c040;" [#fn(gensym)] make-label)
flisp/flisp.boot:	  make-perfect-hash-table #fn(";000r1]\x8c5g5c0O2]\x8c6g6c1g5g6|q3O2g6M\x8e1c2|3141;" [#fn("8000r2e0e1c2|3131}42;" [mod0
flisp/flisp.boot:  abs #fn(hash)] $hash-keyword) #fn("=000r1c0b2|T2^32]\x8c6g6c1~|g5\x7fg6q5O2g6M\x8e1i241;" [#fn(vector.alloc)
flisp/flisp.boot:  cdar])]) #fn(length)] make-perfect-hash-table)
flisp/flisp.boot:	  make-system-image #fn("<000r1c0|c1c2c334c4e5e6]k52]k62c7g7g8q2c8g6g5q2c9g9q1tg9302;" [#fn(file)
flisp/flisp.boot:  :write :create :truncate (*linefeed* *directory-separator* *argv* that
flisp/flisp.boot:				       *print-pretty* *print-width*
flisp/flisp.boot:				       *print-readably* *print-level*
flisp/flisp.boot:				       *print-length* *os-name*) *print-pretty*
flisp/flisp.boot:  *print-readably* #fn("5000r0~k02\x7fk1;" [*print-pretty* *print-readably*])
flisp/flisp.boot:  #fn(top-level-value) #fn(string) #fn(memq)
flisp/flisp.boot:  #fn(iostream?)]) simple-sort #fn(environment)
flisp/flisp.boot:  #fn(write) #fn(nconc) #fn(map) #.list #fn(top-level-value)
flisp/flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] make-system-image)
flisp/flisp.boot:	  map-int #fn(";000r2e0}`32640_;|`31_K_\x8c7g7g6O2a}axc1g7|q2u2g6;" [<=
flisp/flisp.boot:  #fn("7000r1~M\x7f|31_KP2~~MNO;" [])] map-int)
flisp/flisp.boot:	  mark-label #fn("8000r2e0|c1}43;" [emit label] mark-label) max
flisp/flisp.boot:	  newline #fn("8000\x8900001000\x8a0000770e0m02c1|e2322];" [*output-stream*
flisp/flisp.boot:	  nreconc #fn("7000r2e0}|42;" [reverse!-] nreconc) odd?
flisp/flisp.boot:	  princ #fn(";000s0e0^k02c1g5q1c2|q1c3g6q1tg6302;" [*print-readably* #fn("5000r0~k0;" [*print-readably*])
flisp/flisp.boot:							    #fn("7000r0c0c1~42;" [#fn(for-each)
flisp/flisp.boot:	  print #fn("9000s0c0c1|42;" [#fn(for-each)
flisp/flisp.boot:	  print-exception #fn("=000r1|F16D02|Mc0<16:02e1|b4326P0e2c3|\x84c4e5|31c6352e7e8|31315!0|F16D02|Mc9<16:02e1|b4326N0e2|\x84c:e8|31c;342e7e5|31315\xea0|F16@02|Mc<<16602|NF6?0e2c=|\x84c>335\xc60|F16802|Mc?<6B0e2c@312e2|NQ25\xa70|F16802|McA<6G0eBe5|31312e2cC|\x84325\x830eD|3116:02e1|b2326c0e7|M312e2cE312|\x84cFg53117602g5C670e2540e7g531\x8e15>0e2cG312e7|312e2eH41;" [type-error
flisp/flisp.boot:  bounds-error ": index " " out of bounds for " unbound-error "eval: variable "
flisp/flisp.boot:  " has no value" error "error: " load-error print-exception "in file " list?
flisp/flisp.boot:  ": " #fn(string?) "*** Unhandled exception: " *linefeed*] print-exception)
flisp/flisp.boot:	  print-stack-trace #fn("?000r1]]\x8c5\x8c6g5c0g5q1O2g6c1g5q1O2e2e3|e4670b5540b43231e5e6c7c8c9303232`\x8c9c:c;g9g6g8q3g742;" [#fn("=000r3c0|31g2Kc1|31c1}31\x82?0c2c3c4g7L341;c5|31`e6c7g83131c8g8~}g7q4u;" [#fn(function:name)
flisp/flisp.boot:  #fn(function:code) #fn(raise) thrown-value ffound #fn(function:vals) 1- #fn(length)
flisp/flisp.boot:  #fn("8000r1e0~|[316>0\x7fM~|[i2i343;];" [closure?])] find-in-f)
flisp/flisp.boot:  #fn(";000r2c0~|}q3c1tg66I0c2e3c4c5e6g63132c73241;c8;" [#fn("8000r0c0c1~\x7fq2i2322^;" [#fn(for-each)
flisp/flisp.boot:  #fn("8000r1~M|\x7f_43;" [])]) #fn("6000r1|F16B02|Mc0<16802|\x84c1<680e2|41;c3|41;" [thrown-value
flisp/flisp.boot:							 "/" lambda] fn-name)
flisp/flisp.boot:  reverse! list-tail *interactive* filter closure? #fn(map)
flisp/flisp.boot:  #fn("6000r1|E16802c0|41;" [#fn(top-level-value)])
flisp/flisp.boot:  #fn(environment) #fn(for-each) #fn("8000r1e0c1~Mc2332e3\x7fM|`[i232e4|31NK312e5302~~MawO;" [princ
flisp/flisp.boot:  "#" " " print vector->list newline])] print-stack-trace)
flisp/flisp.boot:	  print-to-string #fn("8000r1c030c1|g5322c2g541;" [#fn(buffer)
flisp/flisp.boot:							   #fn(io.tostring!)] print-to-string)
flisp/flisp.boot:						    #fn(eof-object?)] printable?)
flisp/flisp.boot:	  quote-value #fn("6000r1e0|31640|;c1|L2;" [self-evaluating? quote] quote-value)
flisp/flisp.boot:	  quoted? #fn("6000r1|Mc0<;" [quote] quoted?) read-all
flisp/flisp.boot:	  #fn("7000r1e0c1|42;" [read-all-of #fn(read)] read-all) read-all-of #fn(":000r2]\x8c6g6c0}g6|q3O2g6M\x8e1_|}3142;" [#fn("8000r2c0~31680e1|41;\x7fM}|Ki2~3142;" [#fn(io.eof?)
flisp/flisp.boot:  reverse!])] read-all-of)
flisp/flisp.boot:  "> " #fn(io.flush) *output-stream* #fn("5000r0c040;" [#fn(read)])
flisp/flisp.boot:  #fn("6000r1c0e1312c2|41;" [#fn(io.discardbuffer) *input-stream* #fn(raise)])
flisp/flisp.boot:  #fn(io.eof?) *input-stream* load-process print that] prompt)
flisp/flisp.boot:					  #fn("6000r1e0|312];" [top-level-exception-handler])
flisp/flisp.boot:	  revappend #fn("7000r2e0}|42;" [reverse-] revappend) reverse
flisp/flisp.boot:	  #fn("7000r1e0_|42;" [reverse-] reverse) reverse! #fn("7000r1e0_|42;" [reverse!-] reverse!)
flisp/flisp.boot:	  reverse!- #fn("8000r2]}F6B02}N}|}m02P2m15\x1d/2|;" [] reverse!-)
flisp/flisp.boot:	  reverse- #fn("7000r2}\x8540|;e0}M|K}N42;" [reverse-] reverse-)
flisp/flisp.boot:	  self-evaluating? #fn("7000r1|?16602|C@17K02c0|3116A02|C16:02|c1|31<;" [#fn(constant?)
flisp/flisp.boot:  #fn(top-level-value)] self-evaluating?)
flisp/flisp.boot:	  separate #fn(":000r2]c0m62g6|}_L1_L144;" [#fn("9000r4g2g3K]}F6Z02|}M316?0g2}M_KPNm25<0g3}M_KPNm32}Nm15\x05/2e0g8MNg8NN42;" [values] separate-)] separate)
flisp/flisp.boot:	  set-syntax! #fn("8000r2c0e1|}43;" [#fn(put!)
flisp/flisp.boot:					     *syntax-environment*] set-syntax!)
flisp/flisp.boot:	  simple-sort #fn("9000r1|A17602|NA640|;|Me0c1g5|q2c2g5q142;" [call-with-values
flisp/flisp.boot:  #fn("9000r2c0e1|31~L1e1}3143;" [#fn(nconc) simple-sort])] simple-sort)
flisp/flisp.boot:	  splice-form? #fn("7000r1|F16X02|Mc0<17N02|Mc1<17D02|Mc2<16:02e3|b23217702|c2<;" [unquote-splicing
flisp/flisp.boot:  unquote-nsplicing unquote length>] splice-form?)
flisp/flisp.boot:  #fn(buffer) #fn(io.write) #fn(for-each)
flisp/flisp.boot:	  symbol-syntax #fn("8000r1c0e1|^43;" [#fn(get)
flisp/flisp.boot:					       *syntax-environment*] symbol-syntax)
flisp/flisp.boot:	  to-proper #fn("7000r1|\x8540|;|?660|L1;|Me0|N31K;" [to-proper] to-proper)
flisp/flisp.boot:	  top-level-exception-handler #fn("9000r1e0e1k02c2g5q1c3|q1c4g6q1tg6302;" [*output-stream*
flisp/flisp.boot:  *stderr* #fn("5000r0~k0;" [*output-stream*])
flisp/flisp.boot:  #fn("6000r0e0~312e1c23041;" [print-exception print-stack-trace #fn(stacktrace)])
flisp/flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] top-level-exception-handler)
flisp/flisp.boot:	  values #fn("8000s0|F16602|NA650|M;~|K;" [] [#1#]) vars-to-env
flisp/flisp.boot:  #fn(memq)]) iota #fn(length)] vars-to-env)
flisp/flisp.boot:	  vector->list #fn("<000r1c0|31_\x8c6ag5c1g6|g5q3u2g6M;" [#fn(length)
flisp/flisp.boot:								  #fn("8000r1~\x7fi2|x[~MKO;" [])] vector->list)
flisp/table.c:    for(i=0; i < h->size; i+=2) {
flisp/table.c:        if (h->table[i+1] != HT_NOTFOUND) {
flisp/table.c:            fl_print_child(fl_ctx, f, (value_t)h->table[i]);
flisp/table.c:            fl_print_child(fl_ctx, f, (value_t)h->table[i+1]);
flisp/table.c:    for(i=0; i < h->size; i+=2) {
flisp/table.c:        if (h->table[i+1] != HT_NOTFOUND) {
flisp/table.c:            print_traverse(fl_ctx, (value_t)h->table[i]);
flisp/table.c:            print_traverse(fl_ctx, (value_t)h->table[i+1]);
flisp/table.c:    if (oldh->table == &oldh->_space[0])
flisp/table.c:        h->table = &h->_space[0];
flisp/table.c:    for(i=0; i < h->size; i++) {
flisp/table.c:        if (h->table[i] != HT_NOTFOUND)
flisp/table.c:            h->table[i] = (void*)relocate_lispvalue(fl_ctx, (value_t)h->table[i]);
flisp/table.c:    return iscvalue(v) && cv_class((cvalue_t*)ptr(v)) == fl_ctx->tabletype;
flisp/table.c:    return ishashtable(fl_ctx, args[0]) ? fl_ctx->T : fl_ctx->F;
flisp/table.c:        lerror(fl_ctx, fl_ctx->ArgError, "table: arguments must come in pairs");
flisp/table.c:        fl_ctx->table_vtable.finalize = NULL;
flisp/table.c:        nt = cvalue(fl_ctx, fl_ctx->tabletype, sizeof(htable_t));
flisp/table.c:        fl_ctx->table_vtable.finalize = free_htable;
flisp/table.c:        nt = cvalue(fl_ctx, fl_ctx->tabletype, 2*sizeof(void*));
flisp/table.c:    value_t k=fl_ctx->NIL, arg=fl_ctx->NIL;
flisp/table.c:    void **table0 = h->table;
flisp/table.c:    if (table0 == &h->_space[0] && h->table != &h->_space[0]) {
flisp/table.c:        cv->len = 2*sizeof(void*);
flisp/table.c:    lerrorf(fl_ctx, fl_list2(fl_ctx, fl_ctx->KeyError, key), "%s: key not found", fname);
flisp/table.c:    return equalhash_has_r(h, (void*)args[1], (void*)fl_ctx) ? fl_ctx->T : fl_ctx->F;
flisp/table.c:    size_t i, n = h->size;
flisp/table.c:    void **table = h->table;
flisp/table.c:            if (h->size != n)
flisp/table.c:                lerror(fl_ctx, fl_ctx->EnumerationError, "table.foldl: table modified");
flisp/table.c:            table = h->table;
flisp/table.c:    fl_ctx->table_vtable.print = print_htable;
flisp/table.c:    fl_ctx->table_vtable.relocate = relocate_htable;
flisp/table.c:    fl_ctx->table_vtable.finalize = free_htable;
flisp/table.c:    fl_ctx->table_vtable.print_traverse = print_traverse_htable;
flisp/table.c:    fl_ctx->tablesym = symbol(fl_ctx, "table");
flisp/table.c:    fl_ctx->tabletype = define_opaque_type(fl_ctx->tablesym, sizeof(htable_t),
flisp/table.c:                                           &fl_ctx->table_vtable, NULL);
flisp/.gitignore:/flisp-debug
flisp/.gitignore:/flisp-release
flisp/flmain.c:    value_t lst=fl_ctx->NIL, temp;
flisp/flmain.c:    for(i=argc-1; i >= 0; i--) {
flisp/flmain.c:    value_t str = symbol_value(symbol(fl_ctx, "*install-dir*"));
flisp/flmain.c:        fl_print(fl_ctx, ios_stderr, fl_ctx->lasterror);
flisp/aliases.scm:(define-macro (begin0 first . rest)
flisp/aliases.scm:(define vector-ref aref)
flisp/aliases.scm:(define vector-set! aset!)
flisp/aliases.scm:(define vector-length length)
flisp/aliases.scm:(define (char-numeric? c) (not (not (string.find "0123456789" c))))
flisp/aliases.scm:(define string-append string)
flisp/aliases.scm:(define string-length string.count)
flisp/aliases.scm:(define string->symbol symbol)
flisp/aliases.scm:(define (symbol->string s) (string s))
flisp/aliases.scm:(define (list->string l) (apply string l))
flisp/aliases.scm:(define (string->list s)
flisp/aliases.scm:(define (read-char (s *input-stream*)) (io.getc s))
flisp/aliases.scm:(define (peek-char (s *input-stream*)) (io.peekc s))
flisp/aliases.scm:(define (write-char c (s *output-stream*)) (io.putc s c))
flisp/aliases.scm:(define (port-eof? p) (io.eof? p))
flisp/aliases.scm:(define (open-input-string str)
flisp/aliases.scm:(define (open-output-string) (buffer))
flisp/aliases.scm:(define (open-string-output-port)
flisp/aliases.scm:(define (get-output-string b)
flisp/aliases.scm:      (if (eof-object? s) "" s))))
flisp/aliases.scm:(define (open-input-file name) (file name :read))
flisp/aliases.scm:(define (open-output-file name) (file name :write :create))
flisp/aliases.scm:(define (current-input-port (p *input-stream*))
flisp/aliases.scm:  (set! *input-stream* p))
flisp/aliases.scm:(define (current-output-port (p *output-stream*))
flisp/aliases.scm:  (set! *output-stream* p))
flisp/aliases.scm:(define (display x (port *output-stream*))
flisp/aliases.scm:  (with-output-to port (princ x))
flisp/aliases.scm:; --- gambit
flisp/aliases.scm:(define (with-exception-catcher hand thk)
flisp/aliases.scm:(define make-table table)
flisp/aliases.scm:(define table-ref get)
flisp/aliases.scm:(define table-set! put!)
flisp/print.c:        fl_ctx->HPOS = 0;
flisp/print.c:        fl_ctx->HPOS++;
flisp/print.c:    fl_ctx->HPOS += u8_strwidth(s);
flisp/print.c:    fl_ctx->HPOS += u8_strwidth(s);
flisp/print.c:    if (n > fl_ctx->SCR_WIDTH-12)
flisp/print.c:    fl_ctx->VPOS++;
flisp/print.c:    fl_ctx->HPOS = n;
flisp/print.c:        n -= 8;
flisp/print.c:        n--;
flisp/print.c:            bp = (value_t*)ptrhash_bp(&fl_ctx->printconses, (void*)v);
flisp/print.c:                *bp = fixnum(fl_ctx->printlabel++);
flisp/print.c:        bp = (value_t*)ptrhash_bp(&fl_ctx->printconses, (void*)v);
flisp/print.c:            *bp = fixnum(fl_ctx->printlabel++);
flisp/print.c:        print_traverse(fl_ctx, f->bcode);
flisp/print.c:        print_traverse(fl_ctx, f->vals);
flisp/print.c:        print_traverse(fl_ctx, f->env);
flisp/print.c:        if (t->vtable != NULL && t->vtable->print_traverse != NULL)
flisp/print.c:            t->vtable->print_traverse(fl_ctx, v);
flisp/print.c:  The following implements a simple pretty-printing algorithm. This is
flisp/print.c:  an unlimited-width approach that doesn't require an extra pass.
flisp/print.c:  pathological or deeply-nested expressions, but those are difficult
flisp/print.c:    return (isfixnum(v) || isbuiltin(v) || v==fl_ctx->F || v==fl_ctx->T || v==fl_ctx->NIL ||
flisp/print.c:            v == fl_ctx->FL_EOF);
flisp/print.c:                                cdr_(cdr_(v))==fl_ctx->NIL)))
flisp/print.c:    if (head == fl_ctx->LAMBDA || head == fl_ctx->TRYCATCH || head == fl_ctx->definesym ||
flisp/print.c:        head == fl_ctx->defmacrosym || head == fl_ctx->forsym)
flisp/print.c:    return -1;
flisp/print.c:    return -1;
flisp/print.c:    return ((head == fl_ctx->forsym) && !allsmallp(fl_ctx, cdr_(v)));
flisp/print.c:    return ((head == fl_ctx->definesym || head == fl_ctx->defmacrosym) &&
flisp/print.c:    if (c == fl_ctx->LAMBDA || c == fl_ctx->setqsym)
flisp/print.c:    if (c == fl_ctx->IF) // TODO: others
flisp/print.c:    if (iscons(cdr_(v)) && cdr_(cdr_(v)) == fl_ctx->NIL &&
flisp/print.c:        !ptrhash_has(&fl_ctx->printconses, (void*)cdr_(v)) &&
flisp/print.c:        (((car_(v) == fl_ctx->QUOTE)     && (op = "'"))  ||
flisp/print.c:         ((car_(v) == fl_ctx->BACKQUOTE) && (op = "`"))  ||
flisp/print.c:         ((car_(v) == fl_ctx->COMMA)     && (op = ","))  ||
flisp/print.c:         ((car_(v) == fl_ctx->COMMAAT)   && (op = ",@")) ||
flisp/print.c:         ((car_(v) == fl_ctx->COMMADOT)  && (op = ",.")))) {
flisp/print.c:    int startpos = fl_ctx->HPOS;
flisp/print.c:    int newindent=fl_ctx->HPOS, blk=blockindent(fl_ctx, v);
flisp/print.c:        if (fl_ctx->print_length >= 0 && n >= fl_ctx->print_length && cd!=fl_ctx->NIL) {
flisp/print.c:        lastv = fl_ctx->VPOS;
flisp/print.c:        if (!iscons(cd) || ptrhash_has(&fl_ctx->printconses, (void*)cd)) {
flisp/print.c:            if (cd != fl_ctx->NIL) {
flisp/print.c:        if (!fl_ctx->print_pretty ||
flisp/print.c:            ((head == fl_ctx->LAMBDA) && n == 0)) {
flisp/print.c:            // never break line before lambda-list
flisp/print.c:            ind = (((fl_ctx->VPOS > lastv) ||
flisp/print.c:                    (fl_ctx->HPOS>fl_ctx->SCR_WIDTH/2 && !nextsmall && !thistiny && n>0)) ||
flisp/print.c:                   (fl_ctx->HPOS > fl_ctx->SCR_WIDTH-4) ||
flisp/print.c:                   (est!=-1 && (fl_ctx->HPOS+est > fl_ctx->SCR_WIDTH-2)) ||
flisp/print.c:                   ((head == fl_ctx->LAMBDA) && !nextsmall) ||
flisp/print.c:                if (si != -1)
flisp/print.c:                    newindent = fl_ctx->HPOS;
flisp/print.c:    if ((label=(value_t)ptrhash_get(&fl_ctx->printconses, (void*)v)) !=
flisp/print.c:            //fl_ctx->HPOS+=ios_printf(f, "#%ld#", numval(label));
flisp/print.c:            str = uint2str(buf, sizeof(buf)-1, numval(label), 10);
flisp/print.c:        //fl_ctx->HPOS+=ios_printf(f, "#%ld=", numval(label));
flisp/print.c:        str = uint2str(buf, sizeof(buf)-1, numval(label), 10);
flisp/print.c:    if (fl_ctx->print_level >= 0 && fl_ctx->P_LEVEL >= fl_ctx->print_level &&
flisp/print.c:    fl_ctx->P_LEVEL++;
flisp/print.c:    case TAG_NUM1: //fl_ctx->HPOS+=ios_printf(f, "%ld", numval(v)); break;
flisp/print.c:        str = uint2str(&buf[1], sizeof(buf)-1, labs(numval(v)), 10);
flisp/print.c:            *(--str) = '-';
flisp/print.c:        if (fl_ctx->print_princ)
flisp/print.c:        if (v == fl_ctx->T) {
flisp/print.c:        else if (v == fl_ctx->F) {
flisp/print.c:        else if (v == fl_ctx->NIL) {
flisp/print.c:        else if (v == fl_ctx->FL_EOF) {
flisp/print.c:            if (!fl_ctx->print_princ)
flisp/print.c:            if (!fl_ctx->print_princ) {
flisp/print.c:                char *data = (char*)cvalue_data(fn->bcode);
flisp/print.c:                size_t i, sz = cvalue_len(fn->bcode);
flisp/print.c:                fl_print_child(fl_ctx, f, fn->bcode);
flisp/print.c:                for(i=0; i < sz; i++) data[i] -= 48;
flisp/print.c:                fl_print_child(fl_ctx, f, fn->vals);
flisp/print.c:                if (fn->env != fl_ctx->NIL) {
flisp/print.c:                    fl_print_child(fl_ctx, f, fn->env);
flisp/print.c:                if (fn->name != fl_ctx->LAMBDA) {
flisp/print.c:                    fl_print_child(fl_ctx, f, fn->name);
flisp/print.c:            int newindent = fl_ctx->HPOS, est;
flisp/print.c:                if (fl_ctx->print_length >= 0 && i >= fl_ctx->print_length && i < sz-1) {
flisp/print.c:                if (i < sz-1) {
flisp/print.c:                    if (!fl_ctx->print_pretty) {
flisp/print.c:                        if (fl_ctx->HPOS > fl_ctx->SCR_WIDTH-4 ||
flisp/print.c:                            (est!=-1 && (fl_ctx->HPOS+est > fl_ctx->SCR_WIDTH-2)) ||
flisp/print.c:                            (fl_ctx->HPOS > fl_ctx->SCR_WIDTH/2 &&
flisp/print.c:    fl_ctx->P_LEVEL--;
flisp/print.c:        // alternate print algorithm that preserves data if it's not UTF-8
flisp/print.c:            outsn(fl_ctx, buf, f, n-1);
flisp/print.c:    if (type == fl_ctx->bytesym) {
flisp/print.c:        if (fl_ctx->print_princ)
flisp/print.c:            fl_ctx->HPOS+=ios_printf(f, "0x%hhx", ch);
flisp/print.c:            fl_ctx->HPOS+=ios_printf(f, "#byte(0x%hhx)", ch);
flisp/print.c:    else if (type == fl_ctx->wcharsym) {
flisp/print.c:        if (fl_ctx->print_princ) {
flisp/print.c:            else fl_ctx->HPOS+=ios_printf(f, "x%04x", (int)wc);
flisp/print.c:    else if (type == fl_ctx->floatsym || type == fl_ctx->doublesym) {
flisp/print.c:        if (type == fl_ctx->floatsym) { d = (double)*(float*)data; }
flisp/print.c:                rep = (char*)(sign_bit(d) ? "-nan.0" : "+nan.0");
flisp/print.c:                rep = (char*)(sign_bit(d) ? "-inf.0" : "+inf.0");
flisp/print.c:            if (type == fl_ctx->floatsym && !fl_ctx->print_princ && !weak)
flisp/print.c:                fl_ctx->HPOS+=ios_printf(f, "#%s(%s)", symbol_name(fl_ctx, type), rep);
flisp/print.c:                outsn(fl_ctx, "-0.0", f, 4);
flisp/print.c:            if (type == fl_ctx->floatsym && !fl_ctx->print_princ && !weak)
flisp/print.c:            double ad = d < 0 ? -d : d;
flisp/print.c:            if ((long)d == d && ad < 1e6 && ad >= 1e-4) {
flisp/print.c:                if (type == fl_ctx->floatsym)
flisp/print.c:            if (type == fl_ctx->floatsym && !fl_ctx->print_princ && !weak)
flisp/print.c:    else if (type == fl_ctx->uint64sym
flisp/print.c:             || type == fl_ctx->sizesym
flisp/print.c:        if (weak || fl_ctx->print_princ)
flisp/print.c:            fl_ctx->HPOS += ios_printf(f, "%llu", ui64);
flisp/print.c:            fl_ctx->HPOS += ios_printf(f, "#%s(%llu)", symbol_name(fl_ctx, type), ui64);
flisp/print.c:            if (jl_static_print != NULL && fl_ctx->jl_sym == type) {
flisp/print.c:                fl_ctx->HPOS += ios_printf(f, "#<julia: ");
flisp/print.c:                fl_ctx->HPOS += jl_static_print(f, *(void**)data);
flisp/print.c:                fl_ctx->HPOS += ios_printf(f, ">");
flisp/print.c:                fl_ctx->HPOS += ios_printf(f, "#<%s>", symbol_name(fl_ctx, type));
flisp/print.c:            if (weak || fl_ctx->print_princ)
flisp/print.c:                fl_ctx->HPOS += ios_printf(f, "%lld", i64);
flisp/print.c:                fl_ctx->HPOS += ios_printf(f, "#%s(%lld)", symbol_name(fl_ctx, type), i64);
flisp/print.c:        if (car_(type) == fl_ctx->arraysym) {
flisp/print.c:            if (eltype == fl_ctx->bytesym) {
flisp/print.c:                if (fl_ctx->print_princ) {
flisp/print.c:                        fl_ctx->HPOS = u8_strwidth(nl+1);
flisp/print.c:                        fl_ctx->HPOS += u8_strwidth(data);
flisp/print.c:            else if (eltype == fl_ctx->wcharsym) {
flisp/print.c:                if (eltype == fl_ctx->uint8sym) {
flisp/print.c:    if (cv_class(cv) == fl_ctx->builtintype) {
flisp/print.c:        label = (value_t)ptrhash_get(&fl_ctx->reverse_dlsym_lookup_table, cv);
flisp/print.c:            fl_ctx->HPOS += ios_printf(f, "#<builtin @0x%08zx>", (size_t)fptr);
flisp/print.c:            if (fl_ctx->print_princ) {
flisp/print.c:    else if (cv_class(cv)->vtable != NULL &&
flisp/print.c:             cv_class(cv)->vtable->print != NULL) {
flisp/print.c:        cv_class(cv)->vtable->print(fl_ctx, v, f);
flisp/print.c:        size_t len = iscprim(v) ? cv_class(cv)->size : cv_len(cv);
flisp/print.c:    value_t pw = symbol_value(fl_ctx->printwidthsym);
flisp/print.c:    fl_ctx->SCR_WIDTH = numval(pw);
flisp/print.c:    fl_ctx->print_pretty = (symbol_value(fl_ctx->printprettysym) != fl_ctx->F);
flisp/print.c:    if (fl_ctx->print_pretty)
flisp/print.c:    fl_ctx->print_princ = (symbol_value(fl_ctx->printreadablysym) == fl_ctx->F);
flisp/print.c:    value_t pl = symbol_value(fl_ctx->printlengthsym);
flisp/print.c:    if (isfixnum(pl)) fl_ctx->print_length = numval(pl);
flisp/print.c:    else fl_ctx->print_length = -1;
flisp/print.c:    pl = symbol_value(fl_ctx->printlevelsym);
flisp/print.c:    if (isfixnum(pl)) fl_ctx->print_level = numval(pl);
flisp/print.c:    else fl_ctx->print_level = -1;
flisp/print.c:    fl_ctx->P_LEVEL = 0;
flisp/print.c:    fl_ctx->printlabel = 0;
flisp/print.c:    fl_ctx->HPOS = fl_ctx->VPOS = 0;
flisp/print.c:    if (fl_ctx->print_level >= 0 || fl_ctx->print_length >= 0) {
flisp/print.c:        memset(fl_ctx->consflags, 0, 4*bitvector_nwords(fl_ctx->heapsize/sizeof(cons_t)));
flisp/print.c:        !fl_isstring(fl_ctx, v) && v!=fl_ctx->T && v!=fl_ctx->F && v!=fl_ctx->NIL) {
flisp/print.c:        htable_reset(&fl_ctx->printconses, 32);
flisp/print.c:    htable_new(&fl_ctx->printconses, 32);
flisp/print.c:    fl_ctx->SCR_WIDTH = 80;
flisp/print.c:    fl_ctx->HPOS = 0;
flisp/flisp.h:#define fits_bits(x,b) (((x)>>(b-1)) == 0 || (~((x)>>(b-1))) == 0)
flisp/flisp.h:#define car_(v) (((cons_t*)ptr(v))->car)
flisp/flisp.h:#define cdr_(v) (((cons_t*)ptr(v))->cdr)
flisp/flisp.h:#define car(fl_ctx, v)  (tocons(fl_ctx, (v),"car")->car)
flisp/flisp.h:#define cdr(fl_ctx, v)  (tocons(fl_ctx, (v),"cdr")->cdr)
flisp/flisp.h:#define set(s, v)  (((symbol_t*)ptr(s))->binding = (v))
flisp/flisp.h:#define setc(s, v) do { ((symbol_t*)ptr(s))->flags |= 1; \
flisp/flisp.h:                        ((symbol_t*)ptr(s))->binding = (v); } while (0)
flisp/flisp.h:#define isconstant(s) ((s)->flags&0x1)
flisp/flisp.h:#define iskeyword(s) ((s)->flags&0x2)
flisp/flisp.h:#define symbol_value(s) (((symbol_t*)ptr(s))->binding)
flisp/flisp.h:#define ismanaged(ctx, v) ((((unsigned char*)ptr(v)) >= ctx->fromspace) && \
flisp/flisp.h:                           (((unsigned char*)ptr(v)) < ctx->fromspace + ctx->heapsize))
flisp/flisp.h:#define iscbuiltin(ctx, x) (iscvalue(x) && (cv_class((cvalue_t*)ptr(x))==ctx->builtintype))
flisp/flisp.h:#define FL_UNSPECIFIED(fl_ctx) fl_ctx->T
flisp/flisp.h:value_t fl_compare(fl_context_t *fl_ctx, value_t a, value_t b);  // -1, 0, or 1
flisp/flisp.h:  fl_savestate(fl_ctx, &_ctx); fl_ctx->exc_ctx = &_ctx;                      \
flisp/flisp.h:      for (l__tr=1; l__tr; l__tr=0, (void)(fl_ctx->exc_ctx=fl_ctx->exc_ctx->prev))
flisp/flisp.h:#define owned(cv)      ((uintptr_t)(cv)->type & CV_OWNED_BIT)
flisp/flisp.h:#define hasparent(cv)  ((uintptr_t)(cv)->type & CV_PARENT_BIT)
flisp/flisp.h:#define isinlined(cv)  ((cv)->data == &(cv)->_space[0])
flisp/flisp.h:#define cv_class(cv)   ((fltype_t*)(((uintptr_t)(cv)->type)&~3))
flisp/flisp.h:#define cv_len(cv)     ((cv)->len)
flisp/flisp.h:#define cv_type(cv)    (cv_class(cv)->type)
flisp/flisp.h:#define cv_data(cv)    ((cv)->data)
flisp/flisp.h:#define cv_isstr(fl_ctx, cv)   (cv_class(cv)->eltype == fl_ctx->bytetype)
flisp/flisp.h:#define cv_isPOD(cv)   (cv_class(cv)->init != NULL)
flisp/flisp.h:#define cp_class(cp)   ((cp)->type)
flisp/flisp.h:#define cp_type(cp)    (cp_class(cp)->type)
flisp/flisp.h:#define cp_numtype(cp) (cp_class(cp)->numtype)
flisp/flisp.h:#define cp_data(cp)    (&(cp)->_space[0])
flisp/flisp.h:    // error utilities --------------------------------------------------
flisp/flisp.h:        lerrorf(fl_ctx, fl_ctx->ArgError,"%s: too %s arguments", fname, nargs<c ? "few":"many");
flisp/profile.scm:(define (string.rpad s n c) (string s (string.rep c (- n (string.count s)))))
flisp/profile.scm:        ((odd? k) (string s (string.rep s (- k 1))))
flisp/profile.scm:          (let ((f (top-level-value s)))
flisp/profile.scm:            (set-top-level-value! s
flisp/profile.scm:               (define last-tt running)
flisp/profile.scm:               (define last-t0 (cddr tt))
flisp/profile.scm:               (set! running last-tt)
flisp/profile.scm:               (define tdelta (- t1 t0))
flisp/profile.scm:               (if last-tt (set-car! (cdr last-tt) (- (cadr last-tt) tdelta)))
flisp/profile.scm:               (set-car! (cdr tt) (+ (cadr tt) tdelta))
flisp/profile.scm:               (set-cdr! (cdr tt) (+ last-t0 tdelta))
flisp/profile.scm:               (set-car! tt (+ (car tt) 1))
flisp/profile.scm:  (set! show-profiles
flisp/profile.scm:          (princ (string.rpad "--------" width #\ )
flisp/profile.scm:                 "------     --------------------    -------------------")
flisp/profile.scm:          (for-each
flisp/profile.scm:           (reverse (simple-sort (map (lambda (l) (reverse (to-proper l)))
flisp/profile.scm:       (princ (string.rpad "--------" width #\ )
flisp/profile.scm:                 "------     --------------------    -------------------")
flisp/profile.scm:  (set! clear-profiles
flisp/profile.scm:          (for-each (lambda (k)
flisp/flisp.c:  * lexical scope, lisp-1
flisp/flisp.c:  * data types: 30-bit integer, symbol, pair, vector, char, string, table
flisp/flisp.c:      iostream, procedure, low-level data types
flisp/flisp.c:  * case-sensitive
flisp/flisp.c:  * Scheme-style varargs (dotted formal argument lists)
flisp/flisp.c:  * "human-readable" bytecode with self-hosted compiler
flisp/flisp.c:  * #. read macro for eval-when-read and readably printing builtins
flisp/flisp.c:  * symbol character-escaping printer
flisp/flisp.c:      "cons", "list", "car", "cdr", "set-car!", "set-cdr!",
flisp/flisp.c:      "+", "-", "*", "/", "div0", "=", "<", "compare",
flisp/flisp.c:#define ANYARGS -10000
flisp/flisp.c:      -2,
flisp/flisp.c:      ANYARGS, -1, ANYARGS, -1, 2,  2, 2, 2,
flisp/flisp.c:#define PUSH(fl_ctx, v) (fl_ctx->Stack[fl_ctx->SP++] = (v))
flisp/flisp.c:#define POP(fl_ctx)   (fl_ctx->Stack[--fl_ctx->SP])
flisp/flisp.c:#define POPN(fl_ctx, n) (fl_ctx->SP-=(n))
flisp/flisp.c:    htable_free(&rs->backrefs);
flisp/flisp.c:    htable_free(&rs->gensyms);
flisp/flisp.c:// error utilities ------------------------------------------------------------
flisp/flisp.c:  _ctx.sp=fl_ctx->SP; _ctx.frame=fl_ctx->curr_frame; _ctx.rdst=fl_ctx->readstate; _ctx.prev=fl_ctx->exc_ctx; \
flisp/flisp.c:  _ctx.ngchnd = fl_ctx->N_GCHND; fl_ctx->exc_ctx = &_ctx;                                    \
flisp/flisp.c:    for (l__tr=1; l__tr; l__tr=0, (void)(fl_ctx->exc_ctx=fl_ctx->exc_ctx->prev))
flisp/flisp.c:                fl_ctx->lasterror=fl_ctx->NIL,fl_ctx->throwing_frame=0,fl_ctx->SP=_ctx.sp,fl_ctx->curr_frame=_ctx.frame)
flisp/flisp.c:    _ctx->sp = fl_ctx->SP;
flisp/flisp.c:    _ctx->frame = fl_ctx->curr_frame;
flisp/flisp.c:    _ctx->rdst = fl_ctx->readstate;
flisp/flisp.c:    _ctx->prev = fl_ctx->exc_ctx;
flisp/flisp.c:    _ctx->ngchnd = fl_ctx->N_GCHND;
flisp/flisp.c:    fl_ctx->lasterror = fl_ctx->NIL;
flisp/flisp.c:    fl_ctx->throwing_frame = 0;
flisp/flisp.c:    fl_ctx->SP = _ctx->sp;
flisp/flisp.c:    fl_ctx->curr_frame = _ctx->frame;
flisp/flisp.c:    fl_ctx->lasterror = e;
flisp/flisp.c:    while (fl_ctx->readstate != (fl_readstate_t*)fl_ctx->exc_ctx->rdst) {
flisp/flisp.c:        free_readstate(fl_ctx->readstate);
flisp/flisp.c:        fl_ctx->readstate = fl_ctx->readstate->prev;
flisp/flisp.c:    if (fl_ctx->throwing_frame == 0)
flisp/flisp.c:        fl_ctx->throwing_frame = fl_ctx->curr_frame;
flisp/flisp.c:    fl_ctx->N_GCHND = fl_ctx->exc_ctx->ngchnd;
flisp/flisp.c:    fl_exception_context_t *thisctx = fl_ctx->exc_ctx;
flisp/flisp.c:    if (fl_ctx->exc_ctx->prev)   // don't throw past toplevel
flisp/flisp.c:        fl_ctx->exc_ctx = fl_ctx->exc_ctx->prev;
flisp/flisp.c:    fl_longjmp(thisctx->buf, 1);
flisp/flisp.c:    fl_raise(fl_ctx, fl_listn(fl_ctx, 4, fl_ctx->TypeError, symbol(fl_ctx, fname), symbol(fl_ctx, expected), got));
flisp/flisp.c:    fl_raise(fl_ctx, fl_listn(fl_ctx, 4, fl_ctx->BoundsError, symbol(fl_ctx, fname), arr, ind));
flisp/flisp.c:// safe cast operators --------------------------------------------------------
flisp/flisp.c:// symbol table ---------------------------------------------------------------
flisp/flisp.c:    return len>1 && ((str[0] == ':' || str[len-1] == ':') && str[1] != '\0');
flisp/flisp.c:#define CHECK_ALIGN8(p) assert((((uintptr_t)(p))&0x7)==0 && "flisp requires malloc to return 8-aligned pointers")
flisp/flisp.c:    sym = (symbol_t*)malloc((offsetof(symbol_t,name)+len+1+7)&-8);
flisp/flisp.c:    sym->left = sym->right = NULL;
flisp/flisp.c:    sym->flags = 0;
flisp/flisp.c:        sym->flags |= 0x2;
flisp/flisp.c:        sym->binding = UNBOUND;
flisp/flisp.c:    sym->type = NULL;
flisp/flisp.c:    sym->dlcache = NULL;
flisp/flisp.c:    sym->hash = memhash32(str, len)^0xAAAAAAAA;
flisp/flisp.c:    strcpy(&sym->name[0], str);
flisp/flisp.c:        x = strcmp(str, (*ptree)->name);
flisp/flisp.c:            ptree = &(*ptree)->left;
flisp/flisp.c:            ptree = &(*ptree)->right;
flisp/flisp.c:    symbol_t **pnode = symtab_lookup(&fl_ctx->symtab, str);
flisp/flisp.c:    fl_ctx->gsnameno = 1-fl_ctx->gsnameno;
flisp/flisp.c:    char *n = uint2str(fl_ctx->gsname[fl_ctx->gsnameno]+1, sizeof(fl_ctx->gsname[0])-1, fl_ctx->gensym_ctr++, 10);
flisp/flisp.c:    *(--n) = 'g';
flisp/flisp.c:    gs->id = fl_ctx->gensym_ctr++;
flisp/flisp.c:    gs->binding = UNBOUND;
flisp/flisp.c:    gs->isconst = 0;
flisp/flisp.c:    gs->type = NULL;
flisp/flisp.c:    return isgensym(fl_ctx, args[0]) ? fl_ctx->T : fl_ctx->F;
flisp/flisp.c:        fl_ctx->gsnameno = 1-fl_ctx->gsnameno;
flisp/flisp.c:        char *n = uint2str(fl_ctx->gsname[fl_ctx->gsnameno]+1, sizeof(fl_ctx->gsname[0])-1, gs->id, 10);
flisp/flisp.c:        *(--n) = 'g';
flisp/flisp.c:    return ((symbol_t*)ptr(v))->name;
flisp/flisp.c:// conses ---------------------------------------------------------------------
flisp/flisp.c:    if (fl_ctx->n_allocd > GC_INTERVAL)
flisp/flisp.c:    ((void**)c)[-1] = fl_ctx->tochain;
flisp/flisp.c:    fl_ctx->tochain = c;
flisp/flisp.c:    fl_ctx->n_allocd += sizeof(cons_t);
flisp/flisp.c:    if (__unlikely(fl_ctx->curheap > fl_ctx->lim))
flisp/flisp.c:    c = (cons_t*)fl_ctx->curheap;
flisp/flisp.c:    fl_ctx->curheap += sizeof(cons_t);
flisp/flisp.c:    if (fl_ctx->n_allocd > GC_INTERVAL)
flisp/flisp.c:    first[-1] = (value_t)fl_ctx->tochain;
flisp/flisp.c:    fl_ctx->tochain = first;
flisp/flisp.c:    fl_ctx->n_allocd += (n*sizeof(value_t));
flisp/flisp.c:    if (__unlikely((value_t*)fl_ctx->curheap > ((value_t*)fl_ctx->lim)+2-n)) {
flisp/flisp.c:        while ((value_t*)fl_ctx->curheap > ((value_t*)fl_ctx->lim)+2-n) {
flisp/flisp.c:    first = (value_t*)fl_ctx->curheap;
flisp/flisp.c:    fl_ctx->curheap += (n*sizeof(value_t));
flisp/flisp.c:#define cons_index(fl_ctx, c)  (((cons_t*)ptr(c))-((cons_t*)fl_ctx->fromspace))
flisp/flisp.c:#define ismarked(fl_ctx, c)    ((((value_t*)ptr(c))[-1]&1) != 0)
flisp/flisp.c:#define mark_cons(fl_ctx, c)   ((((value_t*)ptr(c))[-1]) |= 1)
flisp/flisp.c:#define unmark_cons(fl_ctx, c) ((((value_t*)ptr(c))[-1]) &= (~(value_t)1))
flisp/flisp.c:#define ismarked(fl_ctx, c)    bitvector_get(fl_ctx->consflags, cons_index(fl_ctx, c))
flisp/flisp.c:#define mark_cons(fl_ctx, c)   bitvector_set(fl_ctx->consflags, cons_index(fl_ctx, c), 1)
flisp/flisp.c:#define unmark_cons(fl_ctx, c) bitvector_set(fl_ctx->consflags, cons_index(fl_ctx, c), 0)
flisp/flisp.c:    if (n == 0) return fl_ctx->the_empty_vector;
flisp/flisp.c:// cvalues --------------------------------------------------------------------
flisp/flisp.c:// print ----------------------------------------------------------------------
flisp/flisp.c:// collector ------------------------------------------------------------------
flisp/flisp.c:    if (fl_ctx->N_GCHND >= FL_N_GC_HANDLES)
flisp/flisp.c:        lerror(fl_ctx, fl_ctx->OutOfMemoryError, "out of gc handles");
flisp/flisp.c:    fl_ctx->GCHandleStack[fl_ctx->N_GCHND++] = pv;
flisp/flisp.c:    assert(fl_ctx->N_GCHND >= n);
flisp/flisp.c:    fl_ctx->N_GCHND -= n;
flisp/flisp.c:        if (root->binding != UNBOUND)
flisp/flisp.c:            root->binding = relocate(fl_ctx, root->binding);
flisp/flisp.c:        trace_globals(fl_ctx, root->left);
flisp/flisp.c:        root = root->right;
flisp/flisp.c:            *pcdr = nc = tagptr((cons_t*)fl_ctx->curheap, TAG_CONS);
flisp/flisp.c:            fl_ctx->curheap += sizeof(cons_t);
flisp/flisp.c:        *pcdr = (d==fl_ctx->NIL) ? fl_ctx->NIL : relocate(fl_ctx, d);
flisp/flisp.c:        // N.B.: 0-length vectors secretly have space for a first element
flisp/flisp.c:        if (vector_elt(v,-1) & 0x1) {
flisp/flisp.c:        size_t nw = CPRIM_NWORDS-1+NWORDS(cp_class(pcp)->size);
flisp/flisp.c:        while (nw--)
flisp/flisp.c:        nfn->bcode = fn->bcode;
flisp/flisp.c:        nfn->vals = fn->vals;
flisp/flisp.c:        nfn->env = relocate(fl_ctx, fn->env);
flisp/flisp.c:        nfn->vals = relocate(fl_ctx, nfn->vals);
flisp/flisp.c:        nfn->bcode = relocate(fl_ctx, nfn->bcode);
flisp/flisp.c:        nfn->name = fn->name;
flisp/flisp.c:        ng->id = gs->id;
flisp/flisp.c:        ng->binding = gs->binding;
flisp/flisp.c:        ng->isconst = 0;
flisp/flisp.c:        if (ng->binding != UNBOUND)
flisp/flisp.c:            ng->binding = relocate(fl_ctx, ng->binding);
flisp/flisp.c:    temp = fl_ctx->tochain;
flisp/flisp.c:    fl_ctx->tochain = NULL;
flisp/flisp.c:    fl_ctx->n_allocd = -100000000000LL;
flisp/flisp.c:    size_t hsz = fl_ctx->gc_grew ? fl_ctx->heapsize*2 : fl_ctx->heapsize;
flisp/flisp.c:    fl_ctx->tospace = LLT_ALLOC(hsz);
flisp/flisp.c:    fl_ctx->curheap = fl_ctx->tospace;
flisp/flisp.c:    fl_ctx->lim = fl_ctx->curheap + hsz - sizeof(cons_t);
flisp/flisp.c:    if (fl_ctx->throwing_frame > fl_ctx->curr_frame) {
flisp/flisp.c:        top = fl_ctx->throwing_frame - 3;
flisp/flisp.c:        f = fl_ctx->Stack[fl_ctx->throwing_frame-3];
flisp/flisp.c:        top = fl_ctx->SP;
flisp/flisp.c:        f = fl_ctx->curr_frame;
flisp/flisp.c:            fl_ctx->Stack[i] = relocate(fl_ctx, fl_ctx->Stack[i]);
flisp/flisp.c:        top = f - 3;
flisp/flisp.c:        f = fl_ctx->Stack[f-3];
flisp/flisp.c:    for (i=0; i < fl_ctx->N_GCHND; i++)
flisp/flisp.c:        *fl_ctx->GCHandleStack[i] = relocate(fl_ctx, *fl_ctx->GCHandleStack[i]);
flisp/flisp.c:    trace_globals(fl_ctx, fl_ctx->symtab);
flisp/flisp.c:    rs = fl_ctx->readstate;
flisp/flisp.c:        for(i=0; i < rs->backrefs.size; i++)
flisp/flisp.c:            rs->backrefs.table[i] = (void*)relocate(fl_ctx, (value_t)rs->backrefs.table[i]);
flisp/flisp.c:        for(i=0; i < rs->gensyms.size; i++)
flisp/flisp.c:            rs->gensyms.table[i] = (void*)relocate(fl_ctx, (value_t)rs->gensyms.table[i]);
flisp/flisp.c:        rs->source = relocate(fl_ctx, rs->source);
flisp/flisp.c:        rs = rs->prev;
flisp/flisp.c:    fl_ctx->lasterror = relocate(fl_ctx, fl_ctx->lasterror);
flisp/flisp.c:    fl_ctx->memory_exception_value = relocate(fl_ctx, fl_ctx->memory_exception_value);
flisp/flisp.c:    fl_ctx->the_empty_vector = relocate(fl_ctx, fl_ctx->the_empty_vector);
flisp/flisp.c:        void *next = ((void**)temp)[-1];
flisp/flisp.c:        free(&((void**)temp)[-1]);
flisp/flisp.c:    fl_ctx->n_allocd = 0;
flisp/flisp.c:           (fl_ctx->curheap-fl_ctx->tospace)/sizeof(cons_t), fl_ctx->heapsize/sizeof(cons_t));
flisp/flisp.c:    temp = fl_ctx->tospace;
flisp/flisp.c:    fl_ctx->tospace = fl_ctx->fromspace;
flisp/flisp.c:    fl_ctx->fromspace = (unsigned char*)temp;
flisp/flisp.c:    if (fl_ctx->gc_grew || mustgrow
flisp/flisp.c:        || ((fl_ctx->lim-fl_ctx->curheap) < (int)(fl_ctx->heapsize/128))
flisp/flisp.c:        || ((fl_ctx->lim-fl_ctx->curheap) < (int)(fl_ctx->heapsize/5))
flisp/flisp.c:        temp = LLT_REALLOC(fl_ctx->tospace, fl_ctx->heapsize*2);
flisp/flisp.c:            fl_raise(fl_ctx, fl_ctx->memory_exception_value);
flisp/flisp.c:        fl_ctx->tospace = (unsigned char*)temp;
flisp/flisp.c:        if (fl_ctx->gc_grew) {
flisp/flisp.c:            fl_ctx->heapsize*=2;
flisp/flisp.c:            temp = bitvector_resize(fl_ctx->consflags, 0, fl_ctx->heapsize/sizeof(cons_t), 1);
flisp/flisp.c:                fl_raise(fl_ctx, fl_ctx->memory_exception_value);
flisp/flisp.c:            fl_ctx->consflags = (uint32_t*)temp;
flisp/flisp.c:        fl_ctx->gc_grew = !fl_ctx->gc_grew;
flisp/flisp.c:    LLT_FREE(fl_ctx->tospace);
flisp/flisp.c:    if ((value_t*)fl_ctx->curheap > ((value_t*)fl_ctx->lim)-2) {
flisp/flisp.c:    size_t newsz = fl_ctx->N_STACK + (fl_ctx->N_STACK>>1);
flisp/flisp.c:    value_t *ns = (value_t*)realloc(fl_ctx->Stack, newsz*sizeof(value_t));
flisp/flisp.c:        lerror(fl_ctx, fl_ctx->OutOfMemoryError, "stack overflow");
flisp/flisp.c:    fl_ctx->Stack = ns;
flisp/flisp.c:    fl_ctx->N_STACK = newsz;
flisp/flisp.c:// utils ----------------------------------------------------------------------
flisp/flisp.c:    value_t f = fl_ctx->Stack[fl_ctx->SP-n-1];
flisp/flisp.c:    uint32_t saveSP = fl_ctx->SP;
flisp/flisp.c:        v = ((builtin_t*)ptr(f))[3](fl_ctx, &fl_ctx->Stack[fl_ctx->SP-n], n);
flisp/flisp.c:        value_t tab = symbol_value(fl_ctx->builtins_table_sym);
flisp/flisp.c:        fl_ctx->Stack[fl_ctx->SP-n-1] = vector_elt(tab, uintval(f));
flisp/flisp.c:    fl_ctx->SP = saveSP;
flisp/flisp.c:    uint32_t n = fl_ctx->SP;
flisp/flisp.c:        if (fl_ctx->SP >= fl_ctx->N_STACK)
flisp/flisp.c:    n = fl_ctx->SP - n - 1;
flisp/flisp.c:    while (fl_ctx->SP+n > fl_ctx->N_STACK)
flisp/flisp.c:    uint32_t si = fl_ctx->SP;
flisp/flisp.c:    while (fl_ctx->SP+n > fl_ctx->N_STACK)
flisp/flisp.c:    si = fl_ctx->SP-1;
flisp/flisp.c:    value_t l = fl_ctx->NIL;
flisp/flisp.c:        l = fl_cons(fl_ctx, fl_ctx->Stack[si--], l);
flisp/flisp.c:        c->car = fl_ctx->Stack[si++];
flisp/flisp.c:        c->cdr = tagptr(c+1, TAG_CONS);
flisp/flisp.c:    (c-1)->cdr = fl_ctx->NIL;
flisp/flisp.c:    fl_ctx->Stack[fl_ctx->SP-1] = fl_cons(fl_ctx, b, fl_ctx->NIL);
flisp/flisp.c:    a = fl_cons(fl_ctx, fl_ctx->Stack[fl_ctx->SP-2], fl_ctx->Stack[fl_ctx->SP-1]);
flisp/flisp.c:    c[1].cdr = fl_ctx->NIL;
flisp/flisp.c:        return c->type != fl_ctx->wchartype;
flisp/flisp.c:// read -----------------------------------------------------------------------
flisp/flisp.c:// equal ----------------------------------------------------------------------
flisp/flisp.c:// eval -----------------------------------------------------------------------
flisp/flisp.c:    i = nargs-1;
flisp/flisp.c:        c->car = args[i-1];
flisp/flisp.c:        c->cdr = args[i];
flisp/flisp.c:        i -= 2;
flisp/flisp.c:        v = fl_ctx->NIL;
flisp/flisp.c:    for(; i >= 0; i--) {
flisp/flisp.c:        c->car = args[i];
flisp/flisp.c:        c->cdr = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:        fl_ctx->Stack[fl_ctx->SP-1] = n;
flisp/flisp.c:        c->car = args[i];
flisp/flisp.c:        c->cdr = tagptr(c+1, TAG_CONS);
flisp/flisp.c:        (c-2)->cdr = (c-1)->car;
flisp/flisp.c:        (c-1)->cdr = fl_ctx->NIL;
flisp/flisp.c:        return fl_ctx->NIL;
flisp/flisp.c:    PUSH(fl_ctx, fl_ctx->NIL);
flisp/flisp.c:    value_t *plcons = &fl_ctx->Stack[fl_ctx->SP-2];
flisp/flisp.c:    value_t *pL = &fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:    cdr_(c) = fl_ctx->NIL;
flisp/flisp.c:        cdr_(c) = fl_ctx->NIL;
flisp/flisp.c:    uint32_t saveSP = fl_ctx->SP;
flisp/flisp.c:    value_t thunk = fl_ctx->Stack[fl_ctx->SP-2];
flisp/flisp.c:    fl_ctx->Stack[fl_ctx->SP-2] = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:    fl_ctx->Stack[fl_ctx->SP-1] = thunk;
flisp/flisp.c:        v = fl_ctx->Stack[saveSP-2];
flisp/flisp.c:        PUSH(fl_ctx, fl_ctx->lasterror);
flisp/flisp.c:    fl_ctx->SP = saveSP;
flisp/flisp.c:  |--required args--|--opt args--|--kw args--|--rest args...
flisp/flisp.c:    value_t s1 = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:    value_t s3 = fl_ctx->Stack[fl_ctx->SP-3];
flisp/flisp.c:    value_t s4 = fl_ctx->Stack[fl_ctx->SP-4];
flisp/flisp.c:        lerror(fl_ctx, fl_ctx->ArgError, "apply: too few arguments");
flisp/flisp.c:        v = fl_ctx->Stack[bp+i];
flisp/flisp.c:            lerrorf(fl_ctx, fl_ctx->ArgError, "keyword %s requires an argument",
flisp/flisp.c:        value_t hv = fixnum(((symbol_t*)ptr(v))->hash);
flisp/flisp.c:                args[idx] = fl_ctx->Stack[bp+i];
flisp/flisp.c:            lerrorf(fl_ctx, fl_ctx->ArgError, "unsupported keyword %s", symbol_name(fl_ctx, v));
flisp/flisp.c:        v = fl_ctx->Stack[bp+i];
flisp/flisp.c:    nrestargs = nargs - i;
flisp/flisp.c:        lerror(fl_ctx, fl_ctx->ArgError, "apply: too many arguments");
flisp/flisp.c:        memmove(&fl_ctx->Stack[bp+ntot], &fl_ctx->Stack[bp+i], nrestargs*sizeof(value_t));
flisp/flisp.c:    memcpy(&fl_ctx->Stack[bp+nreq], args, extr*sizeof(value_t));
flisp/flisp.c:    fl_ctx->SP = bp + nargs;
flisp/flisp.c:    assert(fl_ctx->SP < fl_ctx->N_STACK-4);
flisp/flisp.c:    fl_ctx->curr_frame = fl_ctx->SP;
flisp/flisp.c:  - put the stack in this state
flisp/flisp.c:  - provide arg count
flisp/flisp.c:  - respect tail position
flisp/flisp.c:  - restore fl_ctx->SP
flisp/flisp.c:  - check arg counts
flisp/flisp.c:  - allocate vararg array
flisp/flisp.c:  - push closed env, set up new environment
flisp/flisp.c:    uint32_t top_frame = fl_ctx->curr_frame;
flisp/flisp.c:#define fl_apply_c fl_ctx->apply_c
flisp/flisp.c:#define fl_apply_pv fl_ctx->apply_pv
flisp/flisp.c:#define fl_apply_accum fl_ctx->apply_accum
flisp/flisp.c:#define fl_apply_func fl_ctx->apply_func
flisp/flisp.c:#define fl_apply_v fl_ctx->apply_v
flisp/flisp.c:#define fl_apply_e fl_ctx->apply_e
flisp/flisp.c:    fl_apply_func = fl_ctx->Stack[fl_ctx->SP-nargs-1];
flisp/flisp.c:    while (fl_ctx->SP+GET_INT32(ip) > fl_ctx->N_STACK) {
flisp/flisp.c:    bp = fl_ctx->SP-nargs;
flisp/flisp.c:    PUSH(fl_ctx, fl_ctx->curr_frame);
flisp/flisp.c:    fl_ctx->SP++;//PUSH(fl_ctx, 0); //ip
flisp/flisp.c:    fl_ctx->curr_frame = fl_ctx->SP;
flisp/flisp.c:                    lerror(fl_ctx, fl_ctx->ArgError, "apply: too many arguments");
flisp/flisp.c:                    lerror(fl_ctx, fl_ctx->ArgError, "apply: too few arguments");
flisp/flisp.c:            s = (fixnum_t)nargs - (fixnum_t)i;
flisp/flisp.c:                fl_apply_v = list(fl_ctx, &fl_ctx->Stack[bp+i], s);
flisp/flisp.c:                fl_ctx->Stack[bp+i] = fl_apply_v;
flisp/flisp.c:                    fl_ctx->Stack[bp+i+1] = fl_ctx->Stack[bp+nargs+0];
flisp/flisp.c:                    fl_ctx->Stack[bp+i+2] = fl_ctx->Stack[bp+nargs+1];
flisp/flisp.c:                    fl_ctx->Stack[bp+i+3] = i+1;
flisp/flisp.c:                    fl_ctx->Stack[bp+i+4] = 0;
flisp/flisp.c:                    fl_ctx->SP =  bp+i+5;
flisp/flisp.c:                    fl_ctx->curr_frame = fl_ctx->SP;
flisp/flisp.c:                lerror(fl_ctx, fl_ctx->ArgError, "apply: too few arguments");
flisp/flisp.c:                fl_ctx->SP++;
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-2] = i+1;
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-3] = fl_ctx->Stack[fl_ctx->SP-4];
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-4] = fl_ctx->Stack[fl_ctx->SP-5];
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-5] = fl_ctx->NIL;
flisp/flisp.c:                fl_ctx->curr_frame = fl_ctx->SP;
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[bp+i];
flisp/flisp.c:            if (fl_apply_v != UNBOUND) PUSH(fl_ctx, fl_ctx->T);
flisp/flisp.c:            else PUSH(fl_ctx, fl_ctx->F);
flisp/flisp.c:        OP(OP_DUP) fl_ctx->SP++; fl_ctx->Stack[fl_ctx->SP-1] = fl_ctx->Stack[fl_ctx->SP-2]; NEXT_OP;
flisp/flisp.c:            fl_apply_func = fl_ctx->Stack[fl_ctx->SP-n-1];
flisp/flisp.c:                    fl_ctx->curr_frame = fl_ctx->Stack[fl_ctx->curr_frame-3];
flisp/flisp.c:                    for(s=-1; s < (fixnum_t)n; s++)
flisp/flisp.c:                        fl_ctx->Stack[bp+s] = fl_ctx->Stack[fl_ctx->SP-n+s];
flisp/flisp.c:                    fl_ctx->SP = bp+n;
flisp/flisp.c:                        else if (s != ANYARGS && (signed)n < -s)
flisp/flisp.c:                            argcount(fl_ctx, builtin_names[i], n, -s);
flisp/flisp.c:                        for(s=fl_ctx->SP-n-1; s < (int)fl_ctx->SP-1; s++)
flisp/flisp.c:                            fl_ctx->Stack[s] = fl_ctx->Stack[s+1];
flisp/flisp.c:                        fl_ctx->SP--;
flisp/flisp.c:                s = fl_ctx->SP;
flisp/flisp.c:                fl_apply_v = ((builtin_t)(uintptr_t)(((void**)ptr(fl_apply_func))[3]))(fl_ctx, &fl_ctx->Stack[fl_ctx->SP-n], n);
flisp/flisp.c:                fl_ctx->SP = s-n;
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-1] = fl_apply_v;
flisp/flisp.c:            fl_apply_func = fl_ctx->Stack[fl_ctx->SP-n-1];
flisp/flisp.c:                    fl_ctx->Stack[fl_ctx->curr_frame-1] = (uintptr_t)ip;
flisp/flisp.c:                        else if (s != ANYARGS && (signed)n < -s)
flisp/flisp.c:                            argcount(fl_ctx, builtin_names[i], n, -s);
flisp/flisp.c:                        for(s=fl_ctx->SP-n-1; s < (int)fl_ctx->SP-1; s++)
flisp/flisp.c:                            fl_ctx->Stack[s] = fl_ctx->Stack[s+1];
flisp/flisp.c:                        fl_ctx->SP--;
flisp/flisp.c:                s = fl_ctx->SP;
flisp/flisp.c:                fl_apply_v = ((builtin_t)(uintptr_t)(((void**)ptr(fl_apply_func))[3]))(fl_ctx, &fl_ctx->Stack[fl_ctx->SP-n], n);
flisp/flisp.c:                fl_ctx->SP = s-n;
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-1] = fl_apply_v;
flisp/flisp.c:            if (fl_apply_v == fl_ctx->F) ip += (intptr_t)GET_INT16(ip);
flisp/flisp.c:            if (fl_apply_v != fl_ctx->F) ip += (intptr_t)GET_INT16(ip);
flisp/flisp.c:            if (fl_apply_v == fl_ctx->F) ip += (intptr_t)GET_INT32(ip);
flisp/flisp.c:            if (fl_apply_v != fl_ctx->F) ip += (intptr_t)GET_INT32(ip);
flisp/flisp.c:            if (fl_ctx->Stack[fl_ctx->SP-2] != fl_ctx->Stack[fl_ctx->SP-1]) ip += (intptr_t)GET_INT16(ip);
flisp/flisp.c:            if (fl_ctx->Stack[fl_ctx->SP-2] != fl_ctx->Stack[fl_ctx->SP-1]) ip += (intptr_t)GET_INT32(ip);
flisp/flisp.c:            if (fl_apply_v != fl_ctx->NIL) ip += (intptr_t)GET_INT16(ip);
flisp/flisp.c:            if (fl_apply_v != fl_ctx->NIL) ip += (intptr_t)GET_INT32(ip);
flisp/flisp.c:            if (fl_apply_v == fl_ctx->NIL) ip += (intptr_t)GET_INT16(ip);
flisp/flisp.c:            if (fl_apply_v == fl_ctx->NIL) ip += (intptr_t)GET_INT32(ip);
flisp/flisp.c:            fl_ctx->SP = fl_ctx->curr_frame;
flisp/flisp.c:            fl_ctx->curr_frame = fl_ctx->Stack[fl_ctx->SP-3];
flisp/flisp.c:            if (fl_ctx->curr_frame == top_frame) return fl_apply_v;
flisp/flisp.c:            fl_ctx->SP -= (4+nargs);
flisp/flisp.c:            ip = (uint8_t*)fl_ctx->Stack[fl_ctx->curr_frame-1];
flisp/flisp.c:            nargs        = fl_ctx->Stack[fl_ctx->curr_frame-2];
flisp/flisp.c:            bp           = fl_ctx->curr_frame - 4 - nargs;
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = fl_apply_v;
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-2] = ((fl_ctx->Stack[fl_ctx->SP-2] == fl_ctx->Stack[fl_ctx->SP-1]) ? fl_ctx->T : fl_ctx->F);
flisp/flisp.c:            if (fl_ctx->Stack[fl_ctx->SP-2] == fl_ctx->Stack[fl_ctx->SP-1]) {
flisp/flisp.c:                fl_apply_v = fl_ctx->T;
flisp/flisp.c:            else if (!leafp(fl_ctx->Stack[fl_ctx->SP-2]) || !leafp(fl_ctx->Stack[fl_ctx->SP-1])) {
flisp/flisp.c:                fl_apply_v = fl_ctx->F;
flisp/flisp.c:                fl_apply_v = (compare_(fl_ctx, fl_ctx->Stack[fl_ctx->SP-2], fl_ctx->Stack[fl_ctx->SP-1], 1)==0 ? fl_ctx->T : fl_ctx->F);
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-2] = fl_apply_v; POPN(fl_ctx, 1);
flisp/flisp.c:            if (fl_ctx->Stack[fl_ctx->SP-2] == fl_ctx->Stack[fl_ctx->SP-1]) {
flisp/flisp.c:                fl_apply_v = fl_ctx->T;
flisp/flisp.c:                fl_apply_v = (compare_(fl_ctx, fl_ctx->Stack[fl_ctx->SP-2], fl_ctx->Stack[fl_ctx->SP-1], 1)==0 ? fl_ctx->T : fl_ctx->F);
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-2] = fl_apply_v; POPN(fl_ctx, 1);
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = (iscons(fl_ctx->Stack[fl_ctx->SP-1]) ? fl_ctx->T : fl_ctx->F); NEXT_OP;
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = (iscons(fl_ctx->Stack[fl_ctx->SP-1]) ? fl_ctx->F : fl_ctx->T); NEXT_OP;
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = ((fl_ctx->Stack[fl_ctx->SP-1]==fl_ctx->F) ? fl_ctx->T : fl_ctx->F); NEXT_OP;
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = ((fl_ctx->Stack[fl_ctx->SP-1]==fl_ctx->NIL) ? fl_ctx->T : fl_ctx->F); NEXT_OP;
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = ((fl_apply_v == fl_ctx->T || fl_apply_v == fl_ctx->F) ? fl_ctx->T:fl_ctx->F); NEXT_OP;
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = (issymbol(fl_ctx->Stack[fl_ctx->SP-1]) ? fl_ctx->T : fl_ctx->F); NEXT_OP;
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = (fl_isnumber(fl_ctx, fl_apply_v) ? fl_ctx->T:fl_ctx->F); NEXT_OP;
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = (isfixnum(fl_ctx->Stack[fl_ctx->SP-1]) ? fl_ctx->T : fl_ctx->F); NEXT_OP;
flisp/flisp.c:            sym = tosymbol(fl_ctx, fl_ctx->Stack[fl_ctx->SP-1], "bound?");
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = ((sym->binding == UNBOUND) ? fl_ctx->F : fl_ctx->T);
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:        fl_ctx->Stack[fl_ctx->SP-1] = (isbuiltin(fl_apply_v) || iscbuiltin(fl_ctx, fl_apply_v)) ? fl_ctx->T : fl_ctx->F;
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = ((tag(fl_apply_v)==TAG_FUNCTION &&
flisp/flisp.c:                                 iscbuiltin(fl_ctx, fl_apply_v)) ? fl_ctx->T : fl_ctx->F;
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = (isvector(fl_ctx->Stack[fl_ctx->SP-1]) ? fl_ctx->T : fl_ctx->F); NEXT_OP;
flisp/flisp.c:            if (fl_ctx->curheap > fl_ctx->lim)
flisp/flisp.c:            fl_apply_c = (cons_t*)fl_ctx->curheap;
flisp/flisp.c:            fl_ctx->curheap += sizeof(cons_t);
flisp/flisp.c:            fl_apply_c->car = fl_ctx->Stack[fl_ctx->SP-2];
flisp/flisp.c:            fl_apply_c->cdr = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-2] = tagptr(fl_apply_c, TAG_CONS);
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = car_(fl_apply_v);
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = cdr_(fl_apply_v);
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = car_(fl_apply_v);
flisp/flisp.c:            car(fl_ctx, fl_ctx->Stack[fl_ctx->SP-2]) = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:            cdr(fl_ctx, fl_ctx->Stack[fl_ctx->SP-2]) = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:                fl_apply_v = list(fl_ctx, &fl_ctx->Stack[fl_ctx->SP-n], n);
flisp/flisp.c:                PUSH(fl_ctx, fl_ctx->NIL);
flisp/flisp.c:            n = fl_ctx->SP-(n-2);  // n-2 == # leading arguments not in the list
flisp/flisp.c:                if (fl_ctx->SP >= fl_ctx->N_STACK)
flisp/flisp.c:            n = fl_ctx->SP-n;
flisp/flisp.c:            n = fl_ctx->SP-(n-2);  // n-2 == # leading arguments not in the list
flisp/flisp.c:                if (fl_ctx->SP >= fl_ctx->N_STACK)
flisp/flisp.c:            n = fl_ctx->SP-n;
flisp/flisp.c:            i = fl_ctx->SP-n;
flisp/flisp.c:            for (; i < fl_ctx->SP; i++) {
flisp/flisp.c:                if (isfixnum(fl_ctx->Stack[i])) {
flisp/flisp.c:                    s += numval(fl_ctx->Stack[i]);
flisp/flisp.c:                    fl_apply_v = fl_add_any(fl_ctx, &fl_ctx->Stack[i], fl_ctx->SP-i, s);
flisp/flisp.c:            if (i==fl_ctx->SP)
flisp/flisp.c:            if (bothfixnums(fl_ctx->Stack[fl_ctx->SP-1], fl_ctx->Stack[fl_ctx->SP-2])) {
flisp/flisp.c:                s = numval(fl_ctx->Stack[fl_ctx->SP-1]) + numval(fl_ctx->Stack[fl_ctx->SP-2]);
flisp/flisp.c:                fl_apply_v = fl_add_any(fl_ctx, &fl_ctx->Stack[fl_ctx->SP-2], 2, 0);
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = fl_apply_v;
flisp/flisp.c:            i = fl_ctx->SP-n;
flisp/flisp.c:            PUSH(fl_ctx, fl_ctx->Stack[i]);
flisp/flisp.c:            fl_ctx->Stack[i] = fixnum(0);
flisp/flisp.c:            fl_ctx->Stack[i+1] = fl_neg(fl_ctx, fl_add_any(fl_ctx, &fl_ctx->Stack[i], n, 0));
flisp/flisp.c:            fl_ctx->Stack[i] = POP(fl_ctx);
flisp/flisp.c:            fl_apply_v = fl_add_any(fl_ctx, &fl_ctx->Stack[i], 2, 0);
flisp/flisp.c:            if (isfixnum(fl_ctx->Stack[fl_ctx->SP-1]))
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-1] = fixnum(-numval(fl_ctx->Stack[fl_ctx->SP-1]));
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-1] = fl_neg(fl_ctx, fl_ctx->Stack[fl_ctx->SP-1]);
flisp/flisp.c:            if (bothfixnums(fl_ctx->Stack[fl_ctx->SP-2], fl_ctx->Stack[fl_ctx->SP-1])) {
flisp/flisp.c:                s = numval(fl_ctx->Stack[fl_ctx->SP-2]) - numval(fl_ctx->Stack[fl_ctx->SP-1]);
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-1] = fl_neg(fl_ctx, fl_ctx->Stack[fl_ctx->SP-1]);
flisp/flisp.c:                fl_apply_v = fl_add_any(fl_ctx, &fl_ctx->Stack[fl_ctx->SP-2], 2, 0);
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = fl_apply_v;
flisp/flisp.c:            i = fl_ctx->SP-n;
flisp/flisp.c:            for (; i < fl_ctx->SP; i++) {
flisp/flisp.c:                if (isfixnum(fl_ctx->Stack[i])) {
flisp/flisp.c:                    fl_apply_accum *= numval(fl_ctx->Stack[i]);
flisp/flisp.c:                    fl_apply_v = fl_mul_any(fl_ctx, &fl_ctx->Stack[i], fl_ctx->SP-i, fl_apply_accum);
flisp/flisp.c:            if (i == fl_ctx->SP) {
flisp/flisp.c:            i = fl_ctx->SP-n;
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-1] = fl_div2(fl_ctx, fixnum(1), fl_ctx->Stack[i]);
flisp/flisp.c:                    PUSH(fl_ctx, fl_ctx->Stack[i]);
flisp/flisp.c:                    fl_ctx->Stack[i] = fixnum(1);
flisp/flisp.c:                    fl_ctx->Stack[i+1] = fl_mul_any(fl_ctx, &fl_ctx->Stack[i], n, 1);
flisp/flisp.c:                    fl_ctx->Stack[i] = POP(fl_ctx);
flisp/flisp.c:                fl_apply_v = fl_div2(fl_ctx, fl_ctx->Stack[i], fl_ctx->Stack[i+1]);
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[fl_ctx->SP-2]; fl_apply_e = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = fl_apply_v;
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[fl_ctx->SP-2]; fl_apply_e = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:                fl_apply_v = (fl_apply_v == fl_apply_e) ? fl_ctx->T : fl_ctx->F;
flisp/flisp.c:                fl_apply_v = (!numeric_compare(fl_ctx,fl_apply_v,fl_apply_e,1,0,"=")) ? fl_ctx->T : fl_ctx->F;
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = fl_apply_v;
flisp/flisp.c:            if (bothfixnums(fl_ctx->Stack[fl_ctx->SP-2], fl_ctx->Stack[fl_ctx->SP-1])) {
flisp/flisp.c:                fl_apply_v = (numval(fl_ctx->Stack[fl_ctx->SP-2]) < numval(fl_ctx->Stack[fl_ctx->SP-1])) ? fl_ctx->T : fl_ctx->F;
flisp/flisp.c:                fl_apply_v = (numval(fl_compare(fl_ctx, fl_ctx->Stack[fl_ctx->SP-2], fl_ctx->Stack[fl_ctx->SP-1])) < 0) ?
flisp/flisp.c:                    fl_ctx->T : fl_ctx->F;
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = fl_apply_v;
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-2] = compare_(fl_ctx, fl_ctx->Stack[fl_ctx->SP-2], fl_ctx->Stack[fl_ctx->SP-1], 0);
flisp/flisp.c:                memcpy(&vector_elt(fl_apply_v,0), &fl_ctx->Stack[fl_ctx->SP-n], n*sizeof(value_t));
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[fl_ctx->SP-2];
flisp/flisp.c:                fl_apply_e = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:                fl_apply_v = cvalue_array_aref(fl_ctx, &fl_ctx->Stack[fl_ctx->SP-2]);
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = fl_apply_v;
flisp/flisp.c:            fl_apply_e = fl_ctx->Stack[fl_ctx->SP-3];
flisp/flisp.c:                i = tofixnum(fl_ctx, fl_ctx->Stack[fl_ctx->SP-2], "aset!");
flisp/flisp.c:                    bounds_error(fl_ctx, "aset!", fl_apply_v, fl_ctx->Stack[fl_ctx->SP-1]);
flisp/flisp.c:                vector_elt(fl_apply_e, i) = (fl_apply_v=fl_ctx->Stack[fl_ctx->SP-1]);
flisp/flisp.c:                fl_apply_v = cvalue_array_aset(fl_ctx, &fl_ctx->Stack[fl_ctx->SP-3]);
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = fl_apply_v;
flisp/flisp.c:            s  = tofixnum(fl_ctx, fl_ctx->Stack[fl_ctx->SP-3], "for");
flisp/flisp.c:            hi = tofixnum(fl_ctx, fl_ctx->Stack[fl_ctx->SP-2], "for");
flisp/flisp.c:            //f = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:            fl_ctx->SP += 2;
flisp/flisp.c:            n = fl_ctx->SP;
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-2] = fl_ctx->Stack[fl_ctx->SP-3];
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-1] = fixnum(s);
flisp/flisp.c:                fl_ctx->SP = n;
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = fl_apply_v;
flisp/flisp.c:        OP(OP_LOADT) PUSH(fl_ctx, fl_ctx->T); NEXT_OP;
flisp/flisp.c:        OP(OP_LOADF) PUSH(fl_ctx, fl_ctx->F); NEXT_OP;
flisp/flisp.c:        OP(OP_LOADNIL) PUSH(fl_ctx, fl_ctx->NIL); NEXT_OP;
flisp/flisp.c:            fl_apply_v = fn_vals(fl_ctx->Stack[bp-1]);
flisp/flisp.c:            fl_apply_v = fn_vals(fl_ctx->Stack[bp-1]);
flisp/flisp.c:            fl_apply_v = fn_vals(fl_ctx->Stack[bp-1]);
flisp/flisp.c:            fl_apply_v = fn_vals(fl_ctx->Stack[bp-1]);
flisp/flisp.c:            if (sym->binding == UNBOUND)
flisp/flisp.c:                fl_raise(fl_ctx, fl_list2(fl_ctx, fl_ctx->UnboundError, fl_apply_v));
flisp/flisp.c:            PUSH(fl_ctx, sym->binding);
flisp/flisp.c:            fl_apply_v = fn_vals(fl_ctx->Stack[bp-1]);
flisp/flisp.c:            fl_apply_v = fn_vals(fl_ctx->Stack[bp-1]);
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:                sym->binding = fl_apply_v;
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[bp+i];
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[bp];
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[bp+1];
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[bp+i];
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:            fl_ctx->Stack[bp+i] = fl_apply_v;
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:            fl_ctx->Stack[bp+i] = fl_apply_v;
flisp/flisp.c:            car_(fl_apply_v) = fl_ctx->Stack[bp+i];
flisp/flisp.c:            cdr_(fl_apply_v) = fl_ctx->NIL;
flisp/flisp.c:            fl_ctx->Stack[bp+i] = fl_apply_v;
flisp/flisp.c:            car_(fl_apply_v) = fl_ctx->Stack[bp+i];
flisp/flisp.c:            cdr_(fl_apply_v) = fl_ctx->NIL;
flisp/flisp.c:            fl_ctx->Stack[bp+i] = fl_apply_v;
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1-i] = fl_ctx->Stack[fl_ctx->SP-1];
flisp/flisp.c:            fl_ctx->SP -= i;
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[bp+nargs];
flisp/flisp.c:            PUSH(fl_ctx, vector_elt(fl_ctx->Stack[bp+nargs], 0));
flisp/flisp.c:            PUSH(fl_ctx, vector_elt(fl_ctx->Stack[bp+nargs], 1));
flisp/flisp.c:            fl_apply_v = fl_ctx->Stack[bp+nargs];
flisp/flisp.c:                fl_apply_pv[i] = fl_ctx->Stack[fl_ctx->SP-n + i-1];
flisp/flisp.c:            if ((value_t*)fl_ctx->curheap > ((value_t*)fl_ctx->lim)-2)
flisp/flisp.c:            fl_apply_pv = (value_t*)fl_ctx->curheap;
flisp/flisp.c:            fl_ctx->curheap += (4*sizeof(value_t));
flisp/flisp.c:            fl_apply_e = fl_ctx->Stack[fl_ctx->SP-2];  // closure to copy
flisp/flisp.c:            fl_apply_pv[2] = fl_ctx->Stack[fl_ctx->SP-1];  // env
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = tagptr(fl_apply_pv, TAG_FUNCTION);
flisp/flisp.c:            fl_ctx->Stack[fl_ctx->SP-1] = fl_apply_v;
flisp/flisp.c:                lerror(fl_ctx, fl_ctx->ArgError, "apply: too few arguments");
flisp/flisp.c:                    lerror(fl_ctx, fl_ctx->ArgError, "apply: too many arguments");
flisp/flisp.c:            else n = -n;
flisp/flisp.c:                n -= nargs;
flisp/flisp.c:                fl_ctx->SP += n;
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-1] = fl_ctx->Stack[fl_ctx->SP-n-1];
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-2] = nargs+n;
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-3] = fl_ctx->Stack[fl_ctx->SP-n-3];
flisp/flisp.c:                fl_ctx->Stack[fl_ctx->SP-4] = fl_ctx->Stack[fl_ctx->SP-n-4];
flisp/flisp.c:                fl_ctx->curr_frame = fl_ctx->SP;
flisp/flisp.c:                    fl_ctx->Stack[bp+nargs+i] = UNBOUND;
flisp/flisp.c:            fl_apply_v = fn_vals(fl_ctx->Stack[bp-1]);
flisp/flisp.c:            nargs = process_keys(fl_ctx, fl_apply_v, i, n, llabs(s)-(i+n), bp, nargs, s<0);
flisp/flisp.c:            sp += (n-i);
flisp/flisp.c:            sp += (n-i);
flisp/flisp.c:            sp -= n;
flisp/flisp.c:            sp -= n;
flisp/flisp.c:            sp--;
flisp/flisp.c:            sp--;
flisp/flisp.c:            sp -= 2;
flisp/flisp.c:            sp -= 2;
flisp/flisp.c:            sp--;
flisp/flisp.c:            sp--;
flisp/flisp.c:        case OP_RET: sp--; break;
flisp/flisp.c:            sp--;
flisp/flisp.c:            sp -= (n-1);
flisp/flisp.c:            sp -= (n-1);
flisp/flisp.c:            sp -= n;
flisp/flisp.c:            sp -= n;
flisp/flisp.c:            sp -= 2;
flisp/flisp.c:            sp -=2;
flisp/flisp.c:    value_t v, lst = fl_ctx->NIL;
flisp/flisp.c:        sz = fl_ctx->Stack[top-2]+1;
flisp/flisp.c:        bp = top-4-sz;
flisp/flisp.c:        memcpy(&vector_elt(v,0), &fl_ctx->Stack[bp], sz*sizeof(value_t));
flisp/flisp.c:        top = fl_ctx->Stack[top-3];
flisp/flisp.c:// builtins -------------------------------------------------------------------
flisp/flisp.c:    while (b->name != NULL) {
flisp/flisp.c:        setc(symbol(fl_ctx, b->name), cbuiltin(fl_ctx, b->name, b->fptr));
flisp/flisp.c:            data[i] -= 48;
flisp/flisp.c:    fn->bcode = args[0];
flisp/flisp.c:    fn->vals = args[1];
flisp/flisp.c:    fn->env = fl_ctx->NIL;
flisp/flisp.c:    fn->name = fl_ctx->LAMBDA;
flisp/flisp.c:            fn->name = args[2];
flisp/flisp.c:                fn->env = args[3];
flisp/flisp.c:            fn->env = args[2];
flisp/flisp.c:                fn->name = args[3];
flisp/flisp.c:        if (isgensym(fl_ctx, fn->name))
flisp/flisp.c:            lerror(fl_ctx, fl_ctx->ArgError, "function: name should not be a gensym");
flisp/flisp.c:    argcount(fl_ctx, "copy-list", nargs, 1);
flisp/flisp.c:        return fl_ctx->NIL;
flisp/flisp.c:    value_t first=fl_ctx->NIL, lst, lastcons=fl_ctx->NIL;
flisp/flisp.c:            if (first == fl_ctx->NIL)
flisp/flisp.c:            while (cdr_(lastcons) != fl_ctx->NIL)
flisp/flisp.c:            lastcons = tagptr((((cons_t*)fl_ctx->curheap)-1), TAG_CONS);
flisp/flisp.c:        else if (lst != fl_ctx->NIL) {
flisp/flisp.c:    if (first == fl_ctx->NIL)
flisp/flisp.c:    return _stacktrace(fl_ctx, fl_ctx->throwing_frame ? fl_ctx->throwing_frame : fl_ctx->curr_frame);
flisp/flisp.c:        lerror(fl_ctx, fl_ctx->ArgError, "map: too few arguments");
flisp/flisp.c:    if (!iscons(args[1])) return fl_ctx->NIL;
flisp/flisp.c:    uint32_t first, last, argSP = args-fl_ctx->Stack;
flisp/flisp.c:    assert(args >= fl_ctx->Stack && argSP < fl_ctx->N_STACK);
flisp/flisp.c:        if (fl_ctx->SP+4 > fl_ctx->N_STACK) grow_stack(fl_ctx);
flisp/flisp.c:        PUSH(fl_ctx, fl_ctx->Stack[argSP]);
flisp/flisp.c:        PUSH(fl_ctx, car_(fl_ctx->Stack[argSP+1]));
flisp/flisp.c:        car_(v) = POP(fl_ctx); cdr_(v) = fl_ctx->NIL;
flisp/flisp.c:        first = fl_ctx->SP-2;
flisp/flisp.c:        last = fl_ctx->SP-1;
flisp/flisp.c:        fl_ctx->Stack[argSP+1] = cdr_(fl_ctx->Stack[argSP+1]);
flisp/flisp.c:        while (iscons(fl_ctx->Stack[argSP+1])) {
flisp/flisp.c:            PUSH(fl_ctx, fl_ctx->Stack[argSP]);
flisp/flisp.c:            PUSH(fl_ctx, car_(fl_ctx->Stack[argSP+1]));
flisp/flisp.c:            car_(v) = POP(fl_ctx); cdr_(v) = fl_ctx->NIL;
flisp/flisp.c:            cdr_(fl_ctx->Stack[last]) = v;
flisp/flisp.c:            fl_ctx->Stack[last] = v;
flisp/flisp.c:            fl_ctx->Stack[argSP+1] = cdr_(fl_ctx->Stack[argSP+1]);
flisp/flisp.c:        while (fl_ctx->SP+nargs+1 > fl_ctx->N_STACK) grow_stack(fl_ctx);
flisp/flisp.c:        PUSH(fl_ctx, fl_ctx->Stack[argSP]);
flisp/flisp.c:            PUSH(fl_ctx, car(fl_ctx, fl_ctx->Stack[argSP+i]));
flisp/flisp.c:            fl_ctx->Stack[argSP+i] = cdr_(fl_ctx->Stack[argSP+i]);
flisp/flisp.c:        v = _applyn(fl_ctx, nargs-1);
flisp/flisp.c:        car_(v) = POP(fl_ctx); cdr_(v) = fl_ctx->NIL;
flisp/flisp.c:        first = fl_ctx->SP-2;
flisp/flisp.c:        last = fl_ctx->SP-1;
flisp/flisp.c:        while (iscons(fl_ctx->Stack[argSP+1])) {
flisp/flisp.c:            PUSH(fl_ctx, fl_ctx->Stack[argSP]);
flisp/flisp.c:                PUSH(fl_ctx, car(fl_ctx, fl_ctx->Stack[argSP+i]));
flisp/flisp.c:                fl_ctx->Stack[argSP+i] = cdr_(fl_ctx->Stack[argSP+i]);
flisp/flisp.c:            v = _applyn(fl_ctx, nargs-1);
flisp/flisp.c:            car_(v) = POP(fl_ctx); cdr_(v) = fl_ctx->NIL;
flisp/flisp.c:            cdr_(fl_ctx->Stack[last]) = v;
flisp/flisp.c:            fl_ctx->Stack[last] = v;
flisp/flisp.c:    return fl_ctx->Stack[first];
flisp/flisp.c:        lerror(fl_ctx, fl_ctx->ArgError, "for-each: expected 2 arguments");
flisp/flisp.c:    uint32_t argSP = args-fl_ctx->Stack;
flisp/flisp.c:    assert(args >= fl_ctx->Stack && argSP < fl_ctx->N_STACK);
flisp/flisp.c:    if (fl_ctx->SP+2 > fl_ctx->N_STACK) grow_stack(fl_ctx);
flisp/flisp.c:    PUSH(fl_ctx, fl_ctx->T);
flisp/flisp.c:    PUSH(fl_ctx, fl_ctx->T);
flisp/flisp.c:    while (iscons(fl_ctx->Stack[argSP+1])) {
flisp/flisp.c:        fl_ctx->Stack[fl_ctx->SP-2] = fl_ctx->Stack[argSP];
flisp/flisp.c:        fl_ctx->Stack[fl_ctx->SP-1] = car_(fl_ctx->Stack[argSP+1]);
flisp/flisp.c:        fl_ctx->Stack[argSP+1] = cdr_(fl_ctx->Stack[argSP+1]);
flisp/flisp.c:    return fl_ctx->T;
flisp/flisp.c:    { "copy-list", fl_copylist },
flisp/flisp.c:    { "for-each", fl_foreach },
flisp/flisp.c:// initialization -------------------------------------------------------------
flisp/flisp.c:    fl_ctx->SP = 0;
flisp/flisp.c:    fl_ctx->curr_frame = 0;
flisp/flisp.c:    fl_ctx->N_GCHND = 0;
flisp/flisp.c:    fl_ctx->readstate = NULL;
flisp/flisp.c:    fl_ctx->gensym_ctr = 0;
flisp/flisp.c:    fl_ctx->gsnameno = 0;
flisp/flisp.c:    fl_ctx->tochain = NULL;
flisp/flisp.c:    fl_ctx->n_allocd = 0;
flisp/flisp.c:    fl_ctx->heapsize = initial_heapsize;
flisp/flisp.c:    fl_ctx->fromspace = (unsigned char*)LLT_ALLOC(fl_ctx->heapsize);
flisp/flisp.c:    fl_ctx->tospace   = NULL;
flisp/flisp.c:    fl_ctx->tospace   = (unsigned char*)LLT_ALLOC(fl_ctx->heapsize);
flisp/flisp.c:    fl_ctx->curheap = fl_ctx->fromspace;
flisp/flisp.c:    fl_ctx->lim = fl_ctx->curheap+fl_ctx->heapsize-sizeof(cons_t);
flisp/flisp.c:    fl_ctx->consflags = bitvector_new(fl_ctx->heapsize/sizeof(cons_t), 1);
flisp/flisp.c:    fl_ctx->N_STACK = 262144;
flisp/flisp.c:    fl_ctx->Stack = (value_t*)malloc(fl_ctx->N_STACK*sizeof(value_t));
flisp/flisp.c:    // TODO: if fl_ctx->Stack == NULL
flisp/flisp.c:    CHECK_ALIGN8(fl_ctx->Stack);
flisp/flisp.c:    fl_ctx->NIL = builtin(OP_THE_EMPTY_LIST);
flisp/flisp.c:    fl_ctx->T = builtin(OP_BOOL_CONST_T);
flisp/flisp.c:    fl_ctx->F = builtin(OP_BOOL_CONST_F);
flisp/flisp.c:    fl_ctx->FL_EOF = builtin(OP_EOF_OBJECT);
flisp/flisp.c:    fl_ctx->LAMBDA = symbol(fl_ctx, "lambda");        fl_ctx->FUNCTION = symbol(fl_ctx, "function");
flisp/flisp.c:    fl_ctx->QUOTE = symbol(fl_ctx, "quote");          fl_ctx->TRYCATCH = symbol(fl_ctx, "trycatch");
flisp/flisp.c:    fl_ctx->BACKQUOTE = symbol(fl_ctx, "quasiquote");       fl_ctx->COMMA = symbol(fl_ctx, "unquote");
flisp/flisp.c:    fl_ctx->COMMAAT = symbol(fl_ctx, "unquote-splicing");   fl_ctx->COMMADOT = symbol(fl_ctx, "unquote-nsplicing");
flisp/flisp.c:    fl_ctx->IOError = symbol(fl_ctx, "io-error");     fl_ctx->ParseError = symbol(fl_ctx, "parse-error");
flisp/flisp.c:    fl_ctx->TypeError = symbol(fl_ctx, "type-error"); fl_ctx->ArgError = symbol(fl_ctx, "arg-error");
flisp/flisp.c:    fl_ctx->UnboundError = symbol(fl_ctx, "unbound-error");
flisp/flisp.c:    fl_ctx->KeyError = symbol(fl_ctx, "key-error");   fl_ctx->OutOfMemoryError = symbol(fl_ctx, "memory-error");
flisp/flisp.c:    fl_ctx->BoundsError = symbol(fl_ctx, "bounds-error");
flisp/flisp.c:    fl_ctx->DivideError = symbol(fl_ctx, "divide-error");
flisp/flisp.c:    fl_ctx->EnumerationError = symbol(fl_ctx, "enumeration-error");
flisp/flisp.c:    fl_ctx->pairsym = symbol(fl_ctx, "pair");
flisp/flisp.c:    fl_ctx->symbolsym = symbol(fl_ctx, "symbol");     fl_ctx->fixnumsym = symbol(fl_ctx, "fixnum");
flisp/flisp.c:    fl_ctx->vectorsym = symbol(fl_ctx, "vector");     fl_ctx->builtinsym = symbol(fl_ctx, "builtin");
flisp/flisp.c:    fl_ctx->booleansym = symbol(fl_ctx, "boolean");   fl_ctx->nullsym = symbol(fl_ctx, "null");
flisp/flisp.c:    fl_ctx->definesym = symbol(fl_ctx, "define");     fl_ctx->defmacrosym = symbol(fl_ctx, "define-macro");
flisp/flisp.c:    fl_ctx->forsym = symbol(fl_ctx, "for");
flisp/flisp.c:    fl_ctx->setqsym = symbol(fl_ctx, "set!");         fl_ctx->evalsym = symbol(fl_ctx, "eval");
flisp/flisp.c:    fl_ctx->vu8sym = symbol(fl_ctx, "vu8");           fl_ctx->fnsym = symbol(fl_ctx, "fn");
flisp/flisp.c:    fl_ctx->nulsym = symbol(fl_ctx, "nul");           fl_ctx->alarmsym = symbol(fl_ctx, "alarm");
flisp/flisp.c:    fl_ctx->backspacesym = symbol(fl_ctx, "backspace"); fl_ctx->tabsym = symbol(fl_ctx, "tab");
flisp/flisp.c:    fl_ctx->linefeedsym = symbol(fl_ctx, "linefeed"); fl_ctx->vtabsym = symbol(fl_ctx, "vtab");
flisp/flisp.c:    fl_ctx->pagesym = symbol(fl_ctx, "page");         fl_ctx->returnsym = symbol(fl_ctx, "return");
flisp/flisp.c:    fl_ctx->escsym = symbol(fl_ctx, "esc");           fl_ctx->spacesym = symbol(fl_ctx, "space");
flisp/flisp.c:    fl_ctx->deletesym = symbol(fl_ctx, "delete");     fl_ctx->newlinesym = symbol(fl_ctx, "newline");
flisp/flisp.c:    fl_ctx->tsym = symbol(fl_ctx, "t"); fl_ctx->Tsym = symbol(fl_ctx, "T");
flisp/flisp.c:    fl_ctx->fsym = symbol(fl_ctx, "f"); fl_ctx->Fsym = symbol(fl_ctx, "F");
flisp/flisp.c:    set(fl_ctx->printprettysym=symbol(fl_ctx, "*print-pretty*"), fl_ctx->T);
flisp/flisp.c:    set(fl_ctx->printreadablysym=symbol(fl_ctx, "*print-readably*"), fl_ctx->T);
flisp/flisp.c:    set(fl_ctx->printwidthsym=symbol(fl_ctx, "*print-width*"), fixnum(fl_ctx->SCR_WIDTH));
flisp/flisp.c:    set(fl_ctx->printlengthsym=symbol(fl_ctx, "*print-length*"), fl_ctx->F);
flisp/flisp.c:    set(fl_ctx->printlevelsym=symbol(fl_ctx, "*print-level*"), fl_ctx->F);
flisp/flisp.c:    fl_ctx->builtins_table_sym = symbol(fl_ctx, "*builtins*");
flisp/flisp.c:    fl_ctx->lasterror = fl_ctx->NIL;
flisp/flisp.c:    setc(symbol(fl_ctx, "top-level-bound?"), builtin(OP_BOUNDP));
flisp/flisp.c:    set(symbol(fl_ctx, "*os-name*"), symbol(fl_ctx, "linux"));
flisp/flisp.c:    set(symbol(fl_ctx, "*os-name*"), symbol(fl_ctx, "win32"));
flisp/flisp.c:    set(symbol(fl_ctx, "*os-name*"), symbol(fl_ctx, "macos"));
flisp/flisp.c:    set(symbol(fl_ctx, "*os-name*"), symbol(fl_ctx, "unknown"));
flisp/flisp.c:    fl_ctx->jl_sym = symbol(fl_ctx, "julia_value");
flisp/flisp.c:    fl_ctx->the_empty_vector = tagptr(alloc_words(fl_ctx, 1), TAG_VECTOR);
flisp/flisp.c:    vector_setsize(fl_ctx->the_empty_vector, 0);
flisp/flisp.c:        setc(symbol(fl_ctx, "*install-dir*"), cvalue_static_cstring(fl_ctx, strdup(dirname(exename))));
flisp/flisp.c:    fl_ctx->memory_exception_value = fl_list2(fl_ctx, fl_ctx->OutOfMemoryError,
flisp/flisp.c:// top level ------------------------------------------------------------------
flisp/flisp.c:    return fl_applyn(fl_ctx, 1, symbol_value(fl_ctx->evalsym), expr);
flisp/flisp.c:    value_t img = cvalue(fl_ctx, fl_ctx->iostreamtype, sizeof(ios_t));
flisp/flisp.c:    saveSP = fl_ctx->SP;
flisp/flisp.c:            e = fl_read_sexpr(fl_ctx, fl_ctx->Stack[fl_ctx->SP-1]);
flisp/flisp.c:            if (ios_eof(value2c(ios_t*,fl_ctx->Stack[fl_ctx->SP-1]))) break;
flisp/flisp.c:                fl_ctx->SP = saveSP;
flisp/flisp.c:                    sym->binding = car_(e);
flisp/flisp.c:        fl_print(fl_ctx, ios_stderr, fl_ctx->lasterror);
flisp/flisp.c:    ios_close(value2c(ios_t*,fl_ctx->Stack[fl_ctx->SP-1]));
flisp/iostream.c:    if (news->buf == &olds->local[0]) {
flisp/iostream.c:        news->buf = &news->local[0];
flisp/iostream.c:    return iscvalue(v) && cv_class((cvalue_t*)ptr(v)) == fl_ctx->iostreamtype;
flisp/iostream.c:    return fl_isiostream(fl_ctx, args[0]) ? fl_ctx->T : fl_ctx->F;
flisp/iostream.c:    argcount(fl_ctx, "eof-object", nargs, 0);
flisp/iostream.c:    return fl_ctx->FL_EOF;
flisp/iostream.c:    argcount(fl_ctx, "eof-object?", nargs, 1);
flisp/iostream.c:    return (fl_ctx->FL_EOF == args[0]) ? fl_ctx->T : fl_ctx->F;
flisp/iostream.c:        if      (args[i] == fl_ctx->wrsym)    w = 1;
flisp/iostream.c:        else if (args[i] == fl_ctx->apsym)    { a = 1; w = 1; }
flisp/iostream.c:        else if (args[i] == fl_ctx->crsym)    { c = 1; w = 1; }
flisp/iostream.c:        else if (args[i] == fl_ctx->truncsym) { t = 1; w = 1; }
flisp/iostream.c:        else if (args[i] == fl_ctx->rdsym)    r = 1;
flisp/iostream.c:    value_t f = cvalue(fl_ctx, fl_ctx->iostreamtype, sizeof(ios_t));
flisp/iostream.c:        lerrorf(fl_ctx, fl_ctx->IOError, "file: could not open \"%s\"", fname);
flisp/iostream.c:    value_t f = cvalue(fl_ctx, fl_ctx->iostreamtype, sizeof(ios_t));
flisp/iostream.c:        lerror(fl_ctx, fl_ctx->OutOfMemoryError, "buffer: could not allocate stream");
flisp/iostream.c:        arg = symbol_value(fl_ctx->instrsym);
flisp/iostream.c:        return fl_ctx->FL_EOF;
flisp/iostream.c:        return fl_ctx->FL_EOF;
flisp/iostream.c:        lerror(fl_ctx, fl_ctx->IOError, "invalid UTF-8 sequence");
flisp/iostream.c:        return fl_ctx->FL_EOF;
flisp/iostream.c:        lerror(fl_ctx, fl_ctx->IOError, "invalid UTF-8 sequence");
flisp/iostream.c:    if (!iscprim(args[1]) || ((cprim_t*)ptr(args[1]))->type != fl_ctx->wchartype)
flisp/iostream.c:    if (!iscprim(args[1]) || ((cprim_t*)ptr(args[1]))->type != fl_ctx->wchartype)
flisp/iostream.c:        lerror(fl_ctx, fl_ctx->ArgError, "io_ungetc: unicode not yet supported");
flisp/iostream.c:    s->u_colno -= utf8proc_charwidth(wc);
flisp/iostream.c:        return fl_ctx->F;
flisp/iostream.c:    return fl_ctx->T;
flisp/iostream.c:    return fl_ctx->T;
flisp/iostream.c:    return fl_ctx->T;
flisp/iostream.c:    return (ios_eof(s) ? fl_ctx->T : fl_ctx->F);
flisp/iostream.c:    argcount(fl_ctx, "input-port-line", nargs, 1);
flisp/iostream.c:    ios_t *s = toiostream(fl_ctx, args[0], "input-port-line");
flisp/iostream.c:    return size_wrap(fl_ctx, s->lineno);
flisp/iostream.c:    argcount(fl_ctx, "input-port-column", nargs, 1);
flisp/iostream.c:    ios_t *s = toiostream(fl_ctx, args[0], "input-port-column");
flisp/iostream.c:    return size_wrap(fl_ctx, s->u_colno);
flisp/iostream.c:        return fl_ctx->F;
flisp/iostream.c:    return fl_ctx->T;
flisp/iostream.c:    if (res == -1)
flisp/iostream.c:        return fl_ctx->F;
flisp/iostream.c:        s = toiostream(fl_ctx, symbol_value(fl_ctx->outstrsym), "write");
flisp/iostream.c:        n = tosize(fl_ctx, args[2], "io.read") * ft->elsz;
flisp/iostream.c:        if (ft->eltype != NULL && !iscons(cdr_(cdr_(args[1]))))
flisp/iostream.c:            lerror(fl_ctx, fl_ctx->ArgError, "io.read: incomplete type");
flisp/iostream.c:        n = ft->size;
flisp/iostream.c:        return fl_ctx->FL_EOF;
flisp/iostream.c:            *nb = sz - *offs;
flisp/iostream.c:    if (iscprim(args[1]) && ((cprim_t*)ptr(args[1]))->type == fl_ctx->wchartype) {
flisp/iostream.c:            lerror(fl_ctx, fl_ctx->ArgError,
flisp/iostream.c:        get_start_count_args(fl_ctx, &args[1], nargs-1, sz, &offs, &nb, "io.write");
flisp/iostream.c:        if ((iscprim(arg) && cp_class((cprim_t*)ptr(arg))==fl_ctx->wchartype) ||
flisp/iostream.c:            lerrorf(fl_ctx, fl_ctx->ArgError, "%s: delimiter out of range", fname);
flisp/iostream.c:    cv->len = n;
flisp/iostream.c:        cv->data = ios_take_buffer(&dest, &sz);
flisp/iostream.c:        ((char*)cv->data)[n] = '\0';
flisp/iostream.c:        return fl_ctx->FL_EOF;
flisp/iostream.c:    if (st->buf == &st->local[0]) {
flisp/iostream.c:        n = (size_t)st->size;
flisp/iostream.c:        memcpy(cvalue_data(str), st->buf, n);
flisp/iostream.c:        char *b = ios_take_buffer(st, &n); n--;
flisp/iostream.c:        str = cvalue_from_ref(fl_ctx, fl_ctx->stringtype, b, n, fl_ctx->NIL);
flisp/iostream.c:    if (src->bm != bm_mem)
flisp/iostream.c:        lerror(fl_ctx, fl_ctx->ArgError, "io.tostring!: requires memory stream");
flisp/iostream.c:    { "eof-object", fl_eof_object },
flisp/iostream.c:    { "eof-object?", fl_eof_objectp },
flisp/iostream.c:    { "input-port-line", fl_iolineno },
flisp/iostream.c:    { "input-port-column", fl_iocolno },
flisp/iostream.c:    fl_ctx->iostreamsym = symbol(fl_ctx, "iostream");
flisp/iostream.c:    fl_ctx->rdsym = symbol(fl_ctx, ":read");
flisp/iostream.c:    fl_ctx->wrsym = symbol(fl_ctx, ":write");
flisp/iostream.c:    fl_ctx->apsym = symbol(fl_ctx, ":append");
flisp/iostream.c:    fl_ctx->crsym = symbol(fl_ctx, ":create");
flisp/iostream.c:    fl_ctx->truncsym = symbol(fl_ctx, ":truncate");
flisp/iostream.c:    fl_ctx->instrsym = symbol(fl_ctx, "*input-stream*");
flisp/iostream.c:    fl_ctx->outstrsym = symbol(fl_ctx, "*output-stream*");
flisp/iostream.c:    fl_ctx->iostreamtype = define_opaque_type(fl_ctx->iostreamsym, sizeof(ios_t),
flisp/iostream.c:    setc(symbol(fl_ctx, "*stdout*"), cvalue_from_ref(fl_ctx, fl_ctx->iostreamtype, ios_stdout,
flisp/iostream.c:                                                     sizeof(ios_t), fl_ctx->NIL));
flisp/iostream.c:    setc(symbol(fl_ctx, "*stderr*"), cvalue_from_ref(fl_ctx, fl_ctx->iostreamtype, ios_stderr,
flisp/iostream.c:                                                     sizeof(ios_t), fl_ctx->NIL));
flisp/iostream.c:    setc(symbol(fl_ctx, "*stdin*" ), cvalue_from_ref(fl_ctx, fl_ctx->iostreamtype, ios_stdin,
flisp/iostream.c:                                                     sizeof(ios_t), fl_ctx->NIL));
flisp/mkboot1.lsp:; -*- scheme -*-
flisp/mkboot1.lsp:(make-system-image "flisp.boot")
flisp/read.c:#define readF(fl_ctx) value2c(ios_t*,fl_ctx->readstate->source)
flisp/read.c:    else if (tok[0] == '-') {
flisp/read.c:        if (!strcmp(tok,"-NaN") || !strcasecmp(tok,"-nan.0")) {
flisp/read.c:        if (!strcmp(tok,"-Inf") || !strcasecmp(tok,"-inf.0")) {
flisp/read.c:        lerrorf(fl_ctx, fl_ctx->ParseError, "read: overflow in numeric constant %s", tok);
flisp/read.c:        if (f->bpos < f->size) {
flisp/read.c:            ch = f->buf[f->bpos++];
flisp/read.c:            // single-line comment
flisp/read.c:    fl_ctx->readtoktype = TOK_NONE;
flisp/read.c:    fl_ctx->readbuf[(*pi)++] = c;
flisp/read.c:    if (*pi >= (int)(sizeof(fl_ctx->readbuf)-1))
flisp/read.c:        lerror(fl_ctx, fl_ctx->ParseError, "read: token too long");
flisp/read.c:    fl_ctx->readbuf[i++] = '\0';
flisp/read.c:    if (fl_ctx->readtoktype != TOK_NONE)
flisp/read.c:        return fl_ctx->readtoktype;
flisp/read.c:        fl_ctx->readtoktype = TOK_OPEN;
flisp/read.c:        fl_ctx->readtoktype = TOK_CLOSE;
flisp/read.c:        fl_ctx->readtoktype = TOK_OPENB;
flisp/read.c:        fl_ctx->readtoktype = TOK_CLOSEB;
flisp/read.c:        fl_ctx->readtoktype = TOK_QUOTE;
flisp/read.c:        fl_ctx->readtoktype = TOK_BQ;
flisp/read.c:        fl_ctx->readtoktype = TOK_DOUBLEQUOTE;
flisp/read.c:            lerror(fl_ctx, fl_ctx->ParseError, "read: invalid read macro");
flisp/read.c:            fl_ctx->readtoktype = TOK_SHARPDOT;
flisp/read.c:            fl_ctx->readtoktype = TOK_SHARPQUOTE;
flisp/read.c:                lerror(fl_ctx, fl_ctx->ParseError, "read: end of input in character constant");
flisp/read.c:                if (fl_ctx->readbuf[1] != '\0') {  // not a solitary 'u','U','x'
flisp/read.c:                    if (!read_numtok(fl_ctx, &fl_ctx->readbuf[1], &fl_ctx->readtokval, 16))
flisp/read.c:                        lerror(fl_ctx, fl_ctx->ParseError,
flisp/read.c:                    cval = numval(fl_ctx->readtokval);
flisp/read.c:                fl_ctx->readtokval = symbol(fl_ctx, fl_ctx->readbuf);
flisp/read.c:                if (fl_ctx->readbuf[1] == '\0')       /* one character */;
flisp/read.c:                else if (fl_ctx->readtokval == fl_ctx->nulsym)        cval = 0x00;
flisp/read.c:                else if (fl_ctx->readtokval == fl_ctx->alarmsym)      cval = 0x07;
flisp/read.c:                else if (fl_ctx->readtokval == fl_ctx->backspacesym)  cval = 0x08;
flisp/read.c:                else if (fl_ctx->readtokval == fl_ctx->tabsym)        cval = 0x09;
flisp/read.c:                else if (fl_ctx->readtokval == fl_ctx->linefeedsym)   cval = 0x0A;
flisp/read.c:                else if (fl_ctx->readtokval == fl_ctx->newlinesym)    cval = 0x0A;
flisp/read.c:                else if (fl_ctx->readtokval == fl_ctx->vtabsym)       cval = 0x0B;
flisp/read.c:                else if (fl_ctx->readtokval == fl_ctx->pagesym)       cval = 0x0C;
flisp/read.c:                else if (fl_ctx->readtokval == fl_ctx->returnsym)     cval = 0x0D;
flisp/read.c:                else if (fl_ctx->readtokval == fl_ctx->escsym)        cval = 0x1B;
flisp/read.c:                else if (fl_ctx->readtokval == fl_ctx->spacesym)      cval = 0x20;
flisp/read.c:                else if (fl_ctx->readtokval == fl_ctx->deletesym)     cval = 0x7F;
flisp/read.c:                    lerrorf(fl_ctx, fl_ctx->ParseError, "read: unknown character #\\%s", fl_ctx->readbuf);
flisp/read.c:            fl_ctx->readtoktype = TOK_NUM;
flisp/read.c:            fl_ctx->readtokval = mk_wchar(fl_ctx, cval);
flisp/read.c:            fl_ctx->readtoktype = TOK_SHARPOPEN;
flisp/read.c:            lerror(fl_ctx, fl_ctx->ParseError, "read: unreadable object");
flisp/read.c:                fl_ctx->readtoktype = TOK_BACKREF;
flisp/read.c:                fl_ctx->readtoktype = TOK_LABEL;
flisp/read.c:                lerror(fl_ctx, fl_ctx->ParseError, "read: invalid label");
flisp/read.c:            x = strtol(fl_ctx->readbuf, &end, 10);
flisp/read.c:                lerror(fl_ctx, fl_ctx->ParseError, "read: invalid label");
flisp/read.c:            fl_ctx->readtokval = fixnum(x);
flisp/read.c:                    lerror(fl_ctx, fl_ctx->ParseError, "read: eof within comment");
flisp/read.c:                        commentlevel--;
flisp/read.c:            x = strtol(fl_ctx->readbuf, &end, 10);
flisp/read.c:            if (*end != '\0' || fl_ctx->readbuf[0] == '\0' || errno)
flisp/read.c:                lerror(fl_ctx, fl_ctx->ParseError, "read: invalid gensym label");
flisp/read.c:            fl_ctx->readtoktype = TOK_GENSYM;
flisp/read.c:            fl_ctx->readtokval = fixnum(x);
flisp/read.c:                (isdigit_base(fl_ctx->readbuf[1],base) ||
flisp/read.c:                 fl_ctx->readbuf[1]=='-')) {
flisp/read.c:                if (!read_numtok(fl_ctx, &fl_ctx->readbuf[1], &fl_ctx->readtokval, base))
flisp/read.c:                    lerrorf(fl_ctx, fl_ctx->ParseError, "read: invalid base %d constant", base);
flisp/read.c:                return (fl_ctx->readtoktype=TOK_NUM);
flisp/read.c:            fl_ctx->readtoktype = TOK_SHARPSYM;
flisp/read.c:            fl_ctx->readtokval = symbol(fl_ctx, fl_ctx->readbuf);
flisp/read.c:            lerror(fl_ctx, fl_ctx->ParseError, "read: unknown read macro");
flisp/read.c:        fl_ctx->readtoktype = TOK_COMMA;
flisp/read.c:            return fl_ctx->readtoktype;
flisp/read.c:            fl_ctx->readtoktype = TOK_COMMAAT;
flisp/read.c:            fl_ctx->readtoktype = TOK_COMMADOT;
flisp/read.c:            if (fl_ctx->readbuf[0]=='.' && fl_ctx->readbuf[1]=='\0') {
flisp/read.c:                return (fl_ctx->readtoktype=TOK_DOT);
flisp/read.c:                if (read_numtok(fl_ctx, fl_ctx->readbuf, &fl_ctx->readtokval, 0))
flisp/read.c:                    return (fl_ctx->readtoktype=TOK_NUM);
flisp/read.c:        fl_ctx->readtoktype = TOK_SYM;
flisp/read.c:        fl_ctx->readtokval = symbol(fl_ctx, fl_ctx->readbuf);
flisp/read.c:    return fl_ctx->readtoktype;
flisp/read.c:    v = fl_ctx->Stack[fl_ctx->SP-1];
flisp/read.c:    fl_ctx->Stack[fl_ctx->SP-1] = newv;
flisp/read.c:    value_t v=fl_ctx->the_empty_vector, elt;
flisp/read.c:        ptrhash_put(&fl_ctx->readstate->backrefs, (void*)label, (void*)v);
flisp/read.c:            lerror(fl_ctx, fl_ctx->ParseError, "read: unexpected end of input");
flisp/read.c:        v = fl_ctx->Stack[fl_ctx->SP-1]; // reload after possible alloc in peek()
flisp/read.c:            v = fl_ctx->Stack[fl_ctx->SP-1] = vector_grow(fl_ctx, v, label != UNBOUND);
flisp/read.c:                ptrhash_put(&fl_ctx->readstate->backrefs, (void*)label, (void*)v);
flisp/read.c:        v = fl_ctx->Stack[fl_ctx->SP-1];
flisp/read.c:        lerror(fl_ctx, fl_ctx->ParseError, "read: out of memory reading string");
flisp/read.c:        if (i >= sz-4) {  // -4: leaves room for longest utf8 sequence
flisp/read.c:                lerror(fl_ctx, fl_ctx->ParseError, "read: out of memory reading string");
flisp/read.c:            lerror(fl_ctx, fl_ctx->ParseError, "read: unexpected end of input in string");
flisp/read.c:                lerror(fl_ctx, fl_ctx->ParseError, "read: end of input in escape sequence");
flisp/read.c:                    lerror(fl_ctx, fl_ctx->ParseError, "read: invalid escape sequence");
flisp/read.c:                    lerror(fl_ctx, fl_ctx->ParseError, "read: invalid escape sequence");
flisp/read.c:    PUSH(fl_ctx, fl_ctx->NIL);
flisp/read.c:    pc = &fl_ctx->Stack[fl_ctx->SP-1];  // to keep track of current cons cell
flisp/read.c:            lerror(fl_ctx, fl_ctx->ParseError, "read: unexpected end of input");
flisp/read.c:        c = mk_cons(fl_ctx); car_(c) = cdr_(c) = fl_ctx->NIL;
flisp/read.c:                ptrhash_put(&fl_ctx->readstate->backrefs, (void*)label, (void*)c);
flisp/read.c:                lerror(fl_ctx, fl_ctx->ParseError, "read: unexpected end of input");
flisp/read.c:                lerror(fl_ctx, fl_ctx->ParseError, "read: expected ')'");
flisp/read.c:        lerror(fl_ctx, fl_ctx->ParseError, "read: unexpected ')'");
flisp/read.c:        lerror(fl_ctx, fl_ctx->ParseError, "read: unexpected ']'");
flisp/read.c:        lerror(fl_ctx, fl_ctx->ParseError, "read: unexpected '.'");
flisp/read.c:        return fl_ctx->readtokval;
flisp/read.c:        head = &fl_ctx->COMMA; goto listwith;
flisp/read.c:        head = &fl_ctx->COMMAAT; goto listwith;
flisp/read.c:        head = &fl_ctx->COMMADOT; goto listwith;
flisp/read.c:        head = &fl_ctx->BACKQUOTE; goto listwith;
flisp/read.c:        head = &fl_ctx->QUOTE;
flisp/read.c:        v = fl_list2(fl_ctx, *head, fl_ctx->NIL);
flisp/read.c:        car_(cdr_(v)) = cdr_(cdr_(v)) = fl_ctx->NIL;
flisp/read.c:            ptrhash_put(&fl_ctx->readstate->backrefs, (void*)label, (void*)v);
flisp/read.c:        car_(cdr_(fl_ctx->Stack[fl_ctx->SP-1])) = v;
flisp/read.c:        // femtoLisp doesn't need symbol-function, so #' does nothing
flisp/read.c:        PUSH(fl_ctx, fl_ctx->NIL);
flisp/read.c:        read_list(fl_ctx, &fl_ctx->Stack[fl_ctx->SP-1], label);
flisp/read.c:        sym = fl_ctx->readtokval;
flisp/read.c:        if (sym == fl_ctx->tsym || sym == fl_ctx->Tsym)
flisp/read.c:            return fl_ctx->T;
flisp/read.c:        else if (sym == fl_ctx->fsym || sym == fl_ctx->Fsym)
flisp/read.c:            return fl_ctx->F;
flisp/read.c:            lerrorf(fl_ctx, fl_ctx->ParseError, "read: expected argument list for %s",
flisp/read.c:                    symbol_name(fl_ctx, fl_ctx->readtokval));
flisp/read.c:        PUSH(fl_ctx, fl_ctx->NIL);
flisp/read.c:        read_list(fl_ctx, &fl_ctx->Stack[fl_ctx->SP-1], UNBOUND);
flisp/read.c:        if (sym == fl_ctx->vu8sym) {
flisp/read.c:            sym = fl_ctx->arraysym;
flisp/read.c:            fl_ctx->Stack[fl_ctx->SP-1] = fl_cons(fl_ctx, fl_ctx->uint8sym, fl_ctx->Stack[fl_ctx->SP-1]);
flisp/read.c:        else if (sym == fl_ctx->fnsym) {
flisp/read.c:            sym = fl_ctx->FUNCTION;
flisp/read.c:            fl_raise(fl_ctx, fl_list2(fl_ctx, fl_ctx->UnboundError, sym));
flisp/read.c:        // eval-when-read
flisp/read.c:                fl_raise(fl_ctx, fl_list2(fl_ctx, fl_ctx->UnboundError, sym));
flisp/read.c:        if (ptrhash_has(&fl_ctx->readstate->backrefs, (void*)fl_ctx->readtokval))
flisp/read.c:            lerrorf(fl_ctx, fl_ctx->ParseError, "read: label %ld redefined", numval(fl_ctx->readtokval));
flisp/read.c:        oldtokval = fl_ctx->readtokval;
flisp/read.c:        v = do_read_sexpr(fl_ctx, fl_ctx->readtokval);
flisp/read.c:        ptrhash_put(&fl_ctx->readstate->backrefs, (void*)oldtokval, (void*)v);
flisp/read.c:        v = (value_t)ptrhash_get(&fl_ctx->readstate->backrefs, (void*)fl_ctx->readtokval);
flisp/read.c:            lerrorf(fl_ctx, fl_ctx->ParseError, "read: undefined label %ld", numval(fl_ctx->readtokval));
flisp/read.c:        pv = (value_t*)ptrhash_bp(&fl_ctx->readstate->gensyms, (void*)fl_ctx->readtokval);
flisp/read.c:    state.prev = fl_ctx->readstate;
flisp/read.c:    fl_ctx->readstate = &state;
flisp/read.c:    assert(fl_ctx->readtoktype == TOK_NONE);
flisp/read.c:    fl_gc_handle(fl_ctx, &fl_ctx->readtokval);
flisp/read.c:    fl_ctx->readstate = state.prev;
flisp/read.c:    fl_ctx->readtoktype = TOK_NONE;
flisp/read.c:    fl_ctx->readtokval = 0;
flisp/read.c:    memset(fl_ctx->readbuf, 0, sizeof(fl_ctx->readbuf));
flisp/types.c:        ft = ((symbol_t*)ptr(t))->type;
flisp/types.c:    void **bp = equalhash_bp_r(&fl_ctx->TypeTable, (void*)t, (void*)fl_ctx);
flisp/types.c:    int align, isarray=(iscons(t) && car_(t) == fl_ctx->arraysym && iscons(cdr_(t)));
flisp/types.c:    ft->type = t;
flisp/types.c:        ft->numtype = sym_to_numtype(fl_ctx, t);
flisp/types.c:        ((symbol_t*)ptr(t))->type = ft;
flisp/types.c:        ft->numtype = (numerictype_t)N_NUMTYPES;
flisp/types.c:    ft->size = sz;
flisp/types.c:    ft->vtable = NULL;
flisp/types.c:    ft->artype = NULL;
flisp/types.c:    ft->marked = 1;
flisp/types.c:    ft->elsz = 0;
flisp/types.c:    ft->eltype = NULL;
flisp/types.c:    ft->init = NULL;
flisp/types.c:            if (eltype->size == 0) {
flisp/types.c:                lerror(fl_ctx, fl_ctx->ArgError, "invalid array element type");
flisp/types.c:            ft->elsz = eltype->size;
flisp/types.c:            ft->eltype = eltype;
flisp/types.c:            ft->init = &cvalue_array_init;
flisp/types.c:            eltype->artype = ft;
flisp/types.c:    if (et->artype != NULL)
flisp/types.c:        return et->artype;
flisp/types.c:    return get_type(fl_ctx, fl_list2(fl_ctx, fl_ctx->arraysym, eltype));
flisp/types.c:    ft->type = sym;
flisp/types.c:    ft->size = sz;
flisp/types.c:    ft->numtype = (numerictype_t)N_NUMTYPES;
flisp/types.c:    ft->vtable = vtab;
flisp/types.c:    ft->artype = NULL;
flisp/types.c:    ft->eltype = NULL;
flisp/types.c:    ft->elsz = 0;
flisp/types.c:    ft->marked = 1;
flisp/types.c:    ft->init = init;
flisp/types.c:    htable_t *h = &fl_ctx->TypeTable;
flisp/types.c:    for(i=0; i < h->size; i+=2) {
flisp/types.c:        if (h->table[i] != HT_NOTFOUND) {
flisp/types.c:            nv = (void*)relocate(fl_ctx, (value_t)h->table[i]);
flisp/types.c:            h->table[i] = nv;
flisp/types.c:            if (h->table[i+1] != HT_NOTFOUND)
flisp/types.c:                ((fltype_t*)h->table[i+1])->type = (value_t)nv;
flisp/equal.c:        return fl_ctx->NIL;
flisp/equal.c:    value_t ca = (c==fl_ctx->NIL ? a : c);
flisp/equal.c:    if (cb != fl_ctx->NIL)
flisp/equal.c:                                    bound-1, eq);
flisp/equal.c:        if (d==fl_ctx->NIL || numval(d)!=0) return d;
flisp/equal.c:    if (la < lb) return fixnum(-1);
flisp/equal.c:        return fl_ctx->NIL;
flisp/equal.c:            return (numval(a) < numval(b)) ? fixnum(-1) : fixnum(1);
flisp/equal.c:            if (cp_class((cprim_t*)ptr(b)) == fl_ctx->wchartype)
flisp/equal.c:        return fixnum(-1);
flisp/equal.c:        if (tagb > TAG_SYM) return fixnum(-1);
flisp/equal.c:        if (cp_class((cprim_t*)ptr(a)) == fl_ctx->wchartype) {
flisp/equal.c:            if (!iscprim(b) || cp_class((cprim_t*)ptr(b)) != fl_ctx->wchartype)
flisp/equal.c:                return fixnum(-1);
flisp/equal.c:        else if (iscprim(b) && cp_class((cprim_t*)ptr(b)) == fl_ctx->wchartype) {
flisp/equal.c:                d = bounded_compare(fl_ctx, fa->bcode, fb->bcode, bound-1, eq);
flisp/equal.c:                if (d==fl_ctx->NIL || numval(d) != 0) return d;
flisp/equal.c:                d = bounded_compare(fl_ctx, fa->vals, fb->vals, bound-1, eq);
flisp/equal.c:                if (d==fl_ctx->NIL || numval(d) != 0) return d;
flisp/equal.c:                d = bounded_compare(fl_ctx, fa->env, fb->env, bound-1, eq);
flisp/equal.c:                if (d==fl_ctx->NIL || numval(d) != 0) return d;
flisp/equal.c:            return (uintval(a) < uintval(b)) ? fixnum(-1) : fixnum(1);
flisp/equal.c:        d = bounded_compare(fl_ctx, car_(a), car_(b), bound-1, eq);
flisp/equal.c:        if (d==fl_ctx->NIL || numval(d) != 0) return d;
flisp/equal.c:        bound--;
flisp/equal.c:    return (taga < tagb) ? fixnum(-1) : fixnum(1);
flisp/equal.c:            if (d!=fl_ctx->NIL && numval(d)!=0) return d;
flisp/equal.c:            return fixnum(-1);
flisp/equal.c:    if (ca!=fl_ctx->NIL && ca==cb)
flisp/equal.c:    if (la < lb) return fixnum(-1);
flisp/equal.c:                if (d!=fl_ctx->NIL && numval(d)!=0) return d;
flisp/equal.c:                return fixnum(-1);
flisp/equal.c:                if (d!=fl_ctx->NIL && numval(d)!=0) return d;
flisp/equal.c:                return fixnum(-1);
flisp/equal.c:            if (ca!=fl_ctx->NIL && ca==cb)
flisp/equal.c:        d = bounded_compare(fl_ctx, fa->bcode, fb->bcode, 1, eq);
flisp/equal.c:        if (ca!=fl_ctx->NIL && ca==cb)
flisp/equal.c:        d = cyc_compare(fl_ctx, fa->vals, fb->vals, table, eq);
flisp/equal.c:        a = fa->env;
flisp/equal.c:        b = fb->env;
flisp/equal.c:    htable_new(&fl_ctx->equal_eq_hashtable, 512);
flisp/equal.c:    if (guess == fl_ctx->NIL) {
flisp/equal.c:        guess = cyc_compare(fl_ctx, a, b, &fl_ctx->equal_eq_hashtable, eq);
flisp/equal.c:        htable_reset(&fl_ctx->equal_eq_hashtable, 512);
flisp/equal.c:        return (a == b) ? fl_ctx->T : fl_ctx->F;
flisp/equal.c:    return (numval(compare_(fl_ctx, a,b,1))==0 ? fl_ctx->T : fl_ctx->F);
flisp/equal.c:  - use hash updates instead of calling lookup then insert. i.e. get the
flisp/equal.c:  * less redundant tag checking, 3-bit tags
flisp/equal.c:            return bounded_hash(fl_ctx, ((function_t*)ptr(a))->bcode, bound, oob);
flisp/equal.c:        return ((symbol_t*)ptr(a))->hash;
flisp/equal.c:        if (cp_class(cp) == fl_ctx->wchartype)
flisp/equal.c:            // so we can hash better when a list is cdr-deep (a common case)
flisp/equal.c:                bound--;
flisp/equal.c:        h = MIX(h, bounded_hash(fl_ctx, a, bound-1, &oob2)^2);
flisp/mkboot0.lsp:; -*- scheme -*-
flisp/mkboot0.lsp:(if (not (bound? 'top-level-value)) (set! top-level-value %eval))
flisp/mkboot0.lsp:(if (not (bound? 'set-top-level-value!)) (set! set-top-level-value! set))
flisp/mkboot0.lsp:(if (not (bound? 'eof-object?)) (set! eof-object? (lambda (x) #f)))
flisp/mkboot0.lsp:(define (compile-file inf)
flisp/mkboot0.lsp:	  (begin (print (compile-thunk (expand E)))
flisp/mkboot0.lsp:(define (do-boot0)
flisp/mkboot0.lsp:  (for-each (lambda (file)
flisp/mkboot0.lsp:	      (compile-file file))
flisp/mkboot0.lsp:(do-boot0)
symbol.c:#define MAX_SYM_LEN ((size_t)INTPTR_MAX - sizeof(jl_taggedvalue_t) - sizeof(jl_sym_t) - 1)
symbol.c:    // compute the same hash value as v1.6 and earlier, which used `hash_uint(3h - objectid(sym))`
symbol.c:    return inthash(-oid);
symbol.c:    return (sizeof(jl_taggedvalue_t) + sizeof(jl_sym_t) + len + 1 + 7) & -8;
symbol.c:    tag->header = ((uintptr_t)jl_symbol_type) | GC_OLD_MARKED;
symbol.c:    jl_atomic_store_relaxed(&sym->left, NULL);
symbol.c:    jl_atomic_store_relaxed(&sym->right, NULL);
symbol.c:    sym->hash = hash_symbol(str, len);
symbol.c:        intptr_t x = (intptr_t)(h - node->hash);
symbol.c:            ptree = &node->left;
symbol.c:            ptree = &node->right;
symbol.c:static _Atomic(uint32_t) gs_ctr = 0;  // TODO: per-module?
symbol.c:    n = uint2str(&name[2], sizeof(name)-2, ctr, 10);
symbol.c:    *(--n) = '#'; *(--n) = '#';
symbol.c:    if (len == (size_t)-1) {
symbol.c:    memcpy(name + 3 + len, n, sizeof(gs_name) - (n - gs_name));
symbol.c:    jl_sym_t *sym = _jl_symbol(name, alloc_len - (n - gs_name)- 1);
abi_win32.cpp://===-- abi_win32.cpp - x86 ABI description ---------------------*- C++ -*-===//
abi_win32.cpp:// This file is distributed under the BSD-style LDC license:
abi_win32.cpp:// Copyright (c) 2007-2012 LDC Team.
abi_win32.cpp://===----------------------------------------------------------------------===//
abi_win32.cpp://===----------------------------------------------------------------------===//
abi_win32.cpp:    if (dt->layout->nfields > 0) {
abi_win32.cpp:    // rewrite integer sized (non-sret) struct to the corresponding integer
abi_win32.cpp:    if (!dt->layout->nfields)
signals-mach.c:// Note that this file is `#include`d by "signals-unix.c"
signals-mach.c:        jl_atomic_store_release(&ptls2->gc_state, gc_state);
signals-mach.c:        thread_resume(pthread_mach_thread_np(ptls2->system_id));
signals-mach.c:    int8_t gc_state = ptls2->gc_state;
signals-mach.c:    jl_atomic_store_release(&ptls2->gc_state, JL_GC_STATE_WAITING);
signals-mach.c:    // Apple caused this problem in their libunwind in 10.9 (circa keymgr-28)
signals-mach.c:    // (this is quite thread-unsafe)
signals-mach.c:        attach_exception_port(pthread_mach_thread_np(jl_all_tls_states[tid]->system_id), 0);
signals-mach.c:    uintptr_t rsp = state->__rsp;
signals-mach.c:    uintptr_t rsp = state->__sp;
signals-mach.c:#error "julia: throw-in-context not supported on this platform"
signals-mach.c:    if (ptls2 == NULL || ptls2->signal_stack == NULL || is_addr_on_sigstack(ptls2, (void*)rsp)) {
signals-mach.c:        rsp = (rsp - 256) & ~(uintptr_t)15; // redzone and re-alignment
signals-mach.c:        rsp = (uintptr_t)ptls2->signal_stack + sig_stack_size;
signals-mach.c:    rsp -= sizeof(void*);
signals-mach.c:    state->__rsp = rsp; // set stack pointer
signals-mach.c:    state->__rip = (uint64_t)fptr; // "call" the function
signals-mach.c:    state->__sp = rsp;
signals-mach.c:    state->__pc = (uint64_t)fptr;
signals-mach.c:    state->__lr = 0;
signals-mach.c:#error "julia: throw-in-context not supported on this platform"
signals-mach.c:        ptls2->bt_size =
signals-mach.c:            rec_backtrace_ctx(ptls2->bt_data, JL_MAX_BT_SIZE, (bt_context_t *)&state,
signals-mach.c:        ptls2->sig_exception = exception;
signals-mach.c:        jl_ptls_t ptls = ct == NULL ? NULL : ct->ptls;
signals-mach.c:        if (pthread_mach_thread_np(_ptls2->system_id) == thread) {
signals-mach.c:        if (ptls2->tid != 0)
signals-mach.c:        if (ptls2->defer_signal) {
signals-mach.c:    if (msync((void*)(fault_addr & ~(jl_page_size - 1)), 1, MS_ASYNC) == 0) { // check if this was a valid address
signals-mach.c:        if (is_addr_on_stack(ptls2->current_task, (void*)fault_addr)) {
signals-mach.c:        else if (msync((void*)(fault_addr & ~(jl_page_size - 1)), 1, MS_ASYNC) != 0) {
signals-mach.c:    // http://www.opensource.apple.com/source/xnu/xnu-2782.1.97/osfmk/man/thread_set_exception_ports.html
signals-mach.c:    mach_port_t thread = pthread_mach_thread_np(ptls2->system_id);
signals-mach.c:    mach_port_t thread = pthread_mach_thread_np(ptls2->system_id);
signals-mach.c:    mach_port_t thread = pthread_mach_thread_np(ptls2->system_id);
signals-mach.c:    if (force || (!ptls2->defer_signal && ptls2->io_wait)) {
signals-mach.c:    jl_critical_error(exitstate - 128, NULL);
signals-mach.c:    mach_port_t thread = pthread_mach_thread_np(ptls2->system_id);
signals-mach.c:        ptls2->bt_size = rec_backtrace_ctx(ptls2->bt_data, JL_MAX_BT_SIZE, uc, NULL);
signals-mach.c:        ptls2->bt_size = bt_size; // <= JL_MAX_BT_SIZE
signals-mach.c:        memcpy(ptls2->bt_data, bt_data, ptls2->bt_size * sizeof(bt_data[0]));
signals-mach.c:volatile static int forceDwarf = -2;
signals-mach.c:    if (forceDwarf == -2)
signals-mach.c:        forceDwarf = -1;
signals-mach.c:        kern_return_t ret = mach_msg(&bufRequest->Head, MACH_RCV_MSG,
signals-mach.c:        // sample each thread, round-robin style in reverse order
signals-mach.c:        for (int idx = jl_n_threads; idx-- > 0; ) {
signals-mach.c:            // Stop the threads in the random round-robin order.
signals-mach.c:                    bt_size_cur += rec_backtrace_ctx((jl_bt_element_t*)bt_data_prof + bt_size_cur, bt_size_max - bt_size_cur - 1, uc, NULL);
signals-mach.c:                    bt_size_cur += rec_backtrace_ctx_dwarf((jl_bt_element_t*)bt_data_prof + bt_size_cur, bt_size_max - bt_size_cur - 1, uc, NULL);
signals-mach.c:                else if (forceDwarf == -1) {
signals-mach.c:                forceDwarf = -2;
signals-mach.c:                bt_size_cur += rec_backtrace_ctx((jl_bt_element_t*)bt_data_prof + bt_size_cur, bt_size_max - bt_size_cur - 1, uc, NULL);
signals-mach.c:                bt_data_prof[bt_size_cur++].uintptr = ptls->tid + 1;
signals-mach.c:                bt_data_prof[bt_size_cur++].uintptr = (uintptr_t)ptls->current_task;
signals-mach.c:                bt_data_prof[bt_size_cur++].uintptr = ptls->sleep_check_state + 1;
debuginfo.cpp:#include "llvm-version.h"
debuginfo.cpp:// --- storing and accessing source location metadata ---
debuginfo.cpp:// Maintain a mapping of unrealized function names -> linfo objects
debuginfo.cpp:    tbl->BeginAddress = (DWORD)(Code - Section);
debuginfo.cpp:    tbl->EndAddress = (DWORD)(Code - Section + Size);
debuginfo.cpp:    tbl->UnwindData = (DWORD)(UnwindData - Section);
debuginfo.cpp:            memcpy(name, fnname.data(), len-1);
debuginfo.cpp:            name[len-1] = 0;
debuginfo.cpp:        if (region != linfomap.end() && pointer < region->first + region->second.first)
debuginfo.cpp:            linfo = region->second.second;
debuginfo.cpp:        jl_ptls_t ptls = jl_current_task->ptls;
debuginfo.cpp:        // This function modify codeinst->fptr in GC safe region.
debuginfo.cpp:            auto NewObj = cantFail(object::ObjectFile::createObjectFile(NewBuffer->getMemBufferRef()));
debuginfo.cpp:        auto getLoadAddress = [&] (const StringRef &sName) -> uint64_t {
debuginfo.cpp:            return L.getSectionLoadAddress(search->second);
debuginfo.cpp:            di->gp = 0;
debuginfo.cpp:            di->format = UNW_INFO_FORMAT_ARM_EXIDX;
debuginfo.cpp:            di->start_ip = (uintptr_t)arm_text_addr;
debuginfo.cpp:            di->end_ip = (uintptr_t)(arm_text_addr + arm_text_len);
debuginfo.cpp:            di->u.rti.name_ptr = 0;
debuginfo.cpp:            di->u.rti.table_data = arm_exidx_addr;
debuginfo.cpp:            di->u.rti.table_len = arm_exidx_len;
debuginfo.cpp:                assert(Section != EndSection && Section->isText());
debuginfo.cpp:                uint64_t SectionAddr = Section->getAddress();
debuginfo.cpp:                sName = cantFail(Section->getName());
debuginfo.cpp:                Addr += SectionWriteCheck - SectionLoadAddr;
debuginfo.cpp:        *(DWORD*)&UnwindData[8] = (DWORD)(catchjmp - (uint8_t*)SectionWriteCheck); // relative location of catchjmp
debuginfo.cpp:            if (!Section->isText()) continue;
debuginfo.cpp:            uint64_t SectionAddr = Section->getAddress();
debuginfo.cpp:            StringRef secName = cantFail(Section->getName());
debuginfo.cpp:            Addr -= SectionAddr - SectionLoadAddr;
debuginfo.cpp:            uint64_t SectionSize = Section->getSize();
debuginfo.cpp:                codeinst = codeinst_it->second;
debuginfo.cpp:                    linfomap[Addr] = std::make_pair(Size, codeinst->def);
debuginfo.cpp:                        (ptrdiff_t)(SectionAddr - SectionLoadAddr),
debuginfo.cpp:    ((JuliaJITEventListener*)Listener)->_NotifyObjectEmitted(Object, L, memmgr);
debuginfo.cpp:    while (*(--end) != '_') {
debuginfo.cpp:    ret = (char*)malloc_s(end - start + 1);
debuginfo.cpp:    memcpy(ret, start, end - start);
debuginfo.cpp:    ret[end - start] = '\0';
debuginfo.cpp:    auto inlineInfo = context->getInliningInfoForAddress(makeAddress(Section, pointer + slide), infoSpec);
debuginfo.cpp:        memcpy(&new_frames[n_frames - 1], *frames, sizeof(jl_frame_t));
debuginfo.cpp:        bool inlined_frame = i != n_frames - 1;
debuginfo.cpp:            info = context->getLineInfoForAddress(makeAddress(Section, pointer + slide), infoSpec);
debuginfo.cpp:            frame->inlined = 1;
debuginfo.cpp:            frame->fromC = fromC;
debuginfo.cpp:                    frame->linfo = NULL; // TODO: if (new_frames[n_frames - 1].linfo) frame->linfo = lookup(func_name in linfo)?
debuginfo.cpp:            frame->func_name = NULL;
debuginfo.cpp:            jl_copy_str(&frame->func_name, func_name.c_str());
debuginfo.cpp:        if (!frame->func_name)
debuginfo.cpp:            frame->fromC = 1;
debuginfo.cpp:        frame->line = info.Line;
debuginfo.cpp:            frame->file_name = NULL;
debuginfo.cpp:            jl_copy_str(&frame->file_name, file_name.c_str());
debuginfo.cpp:#include <mach-o/dyld.h>
debuginfo.cpp:    for (auto Load : obj->load_commands())
debuginfo.cpp:            memcpy(uuid, ((const MachO::uuid_command*)Load.Ptr)->uuid, 16);
debuginfo.cpp:    while (size--)
debuginfo.cpp:            SplitFile.get()->getBufferStart(),
debuginfo.cpp:            SplitFile.get()->getBufferSize());
debuginfo.cpp:            SplitFile.get().get()->getMemBufferRef(),
debuginfo.cpp:            *saddr = (void*)(ImageBase + fn->BeginAddress);
debuginfo.cpp:        size_t distance = (size_t)-1;
debuginfo.cpp:        for (auto sym : Section.getObject()->symbols()) {
debuginfo.cpp:            size_t new_dist = pointer + slide - symptr;
debuginfo.cpp:        if (distance != (size_t)-1) {
debuginfo.cpp:                *saddr = (void*)(addr - slide);
debuginfo.cpp:        pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
debuginfo.cpp:        pSymbol->MaxNameLen = MAX_SYM_NAME;
debuginfo.cpp:            jl_copy_str(name, pSymbol->Name);
debuginfo.cpp:        return it->second;
debuginfo.cpp:        // Hide Darwin symbols (e.g. CoreFoundation) from non-Darwin systems.
debuginfo.cpp:        size_t msize = (size_t)(((uint64_t)-1) - fbase);
debuginfo.cpp:            membuf->getMemBufferRef(), file_magic::unknown);
debuginfo.cpp:        // On Windows we need to mmap another copy since reading the in-memory copy seems to return object_error:unexpected_eof
debuginfo.cpp:        auto *debugobj = errorobj->getBinary();
debuginfo.cpp:            // for now, we don't support the build-id method
debuginfo.cpp:                    debugobj = errorobj->getBinary();
debuginfo.cpp:            slide = OF->getImageBase() - fbase;
debuginfo.cpp:            slide = -(int64_t)fbase;
debuginfo.cpp:        auto binary = errorobj->takeBinary();
debuginfo.cpp:  for (object::SectionRef Sec : obj->sections()) {
debuginfo.cpp:    // This causes the lookup to return incorrect non-NULL result for local functions
debuginfo.cpp:    fbase = (uintptr_t)extra_info->l_addr;
debuginfo.cpp:            jl_copy_str(&frame0->file_name, frame_info_line.FileName);
debuginfo.cpp:        frame0->line = frame_info_line.LineNumber;
debuginfo.cpp:    if (!jl_dylib_DI_for_fptr(pointer, &Section, &slide, &context, skipC, &isSysImg, &saddr, &frame0->func_name, &frame0->file_name)) {
debuginfo.cpp:        frame0->fromC = 1;
debuginfo.cpp:    frame0->fromC = !isSysImg;
debuginfo.cpp:        intptr_t diff = (uintptr_t)saddr - (uintptr_t)sysimg_fptrs.base;
debuginfo.cpp:                    frame0->linfo = sysimg_fvars_linfo[idx];
debuginfo.cpp:                frame0->linfo = sysimg_fvars_linfo[i];
debuginfo.cpp:    std::map<size_t, ObjectInfo, revcomp> &objmap = jl_jit_events->getObjectMap();
debuginfo.cpp:    if (fit != objmap.end() && fptr < fit->first + fit->second.SectionSize) {
debuginfo.cpp:        *slide = fit->second.slide;
debuginfo.cpp:        *Section = fit->second.Section;
debuginfo.cpp:            if (fit->second.context == nullptr)
debuginfo.cpp:                fit->second.context = DWARFContext::create(*fit->second.object).release();
debuginfo.cpp:            *context = fit->second.context;
debuginfo.cpp:    frames[0].line = -1;
debuginfo.cpp:        frames[0].linfo = jl_jit_events->lookupLinfo(pointer);
debuginfo.cpp:    return jl_jit_events->lookupLinfo((size_t)p);
debuginfo.cpp:  // See http://lists.cs.uiuc.edu/pipermail/llvmdev/2013-April/061768.html
debuginfo.cpp:    for (unsigned i = 0;i < ((sizeof(T) * 8 - 1) / 7 + 1);i++) {
debuginfo.cpp:                    v |= -(uT(1) << valid_bits);
debuginfo.cpp:                             * whether this is a 32-bit or 64-bit address space,
debuginfo.cpp:                             * whether this is a 32-bit or 64-bit address space */
debuginfo.cpp:    di->gp = 0;
debuginfo.cpp:    di->format = UNW_INFO_FORMAT_IP_OFFSET;
debuginfo.cpp:    di->u.rti.name_ptr = 0;
debuginfo.cpp:    di->u.rti.segbase = (unw_word_t)Addr;
debuginfo.cpp:    uintptr_t start_ip = (uintptr_t)-1;
debuginfo.cpp:            const uint8_t *cie_addr = (const uint8_t*)(Entry + 4 - cie_id);
debuginfo.cpp:                safe_trunc<int32_t>((intptr_t)Entry - (intptr_t)Addr);
debuginfo.cpp:            safe_trunc<int32_t>((intptr_t)start_ips[i] - (intptr_t)start_ip);
debuginfo.cpp:    di->u.rti.table_len = nentries * sizeof(*table) / sizeof(unw_word_t);
debuginfo.cpp:    di->u.rti.table_data = (unw_word_t)table;
debuginfo.cpp:    di->start_ip = start_ip;
debuginfo.cpp:    di->end_ip = end_ip;
debuginfo.cpp:    std::map<size_t, ObjectInfo, revcomp> &objmap = jl_jit_events->getObjectMap();
debuginfo.cpp:    if (it != objmap.end() && dwAddr < it->first + it->second.SectionSize) {
abi_win64.cpp://===-- abi_win64.cpp - Windows x86_64 ABI description ----------*- C++ -*-===//
abi_win64.cpp:// This file is distributed under the BSD-style LDC license:
abi_win64.cpp:// Copyright (c) 2007-2012 LDC Team.
abi_win64.cpp://===----------------------------------------------------------------------===//
abi_win64.cpp://===----------------------------------------------------------------------===//
julia_threads.h:// threading ------------------------------------------------------------------
julia_threads.h:// JL_HAVE_ASM -- mostly setjmp
julia_threads.h:// JL_HAVE_ASM && JL_HAVE_UNW_CONTEXT -- libunwind-based
julia_threads.h:// JL_HAVE_UNW_CONTEXT -- libunwind-based
julia_threads.h:// JL_HAVE_ASYNCIFY -- task switching based on the binary asyncify transform
julia_threads.h:// JL_HAVE_UCONTEXT -- posix standard API, requires syscall for resume
julia_threads.h:// JL_HAVE_SIGALTSTACK -- requires several syscall for start, setjmp for resume
julia_threads.h:    void **pc_start; // Cached value of `gc_cache->pc_stack`
julia_threads.h:    void **pc_end; // Cached value of `gc_cache->pc_stack_end`
julia_threads.h:    // currently-held locks, to be released when an exception is thrown
julia_threads.h:// and to avoid Clang warning for -Wunused-volatile-lvalue
julia_threads.h:        size_t safepoint_load = *ptls->safepoint;       \
julia_threads.h:        size_t safepoint_load = ptls->safepoint[-1];    \
julia_threads.h:    jl_atomic_store_release(&ptls->gc_state, state);
julia_threads.h:    // A safe point is required if we transition from GC-safe region to
julia_threads.h:    // non GC-safe region.
julia_threads.h:    return jl_gc_state_set(ptls, state, jl_atomic_load_relaxed(&ptls->gc_state));
jl_tostring.cpp:// exceptions -----------------------------------------------------------------
jl_tostring.cpp:    // values in v are expected to already be gc-rooted
jl_tostring.cpp:    // data is expected to be gc-safe (either gc-rooted, or alloca)
jl_tostring.cpp:    // vt is expected to be gc-rooted (in a linfo-root probably)
jl_tostring.cpp:// exceptions -----------------------------------------------------------------
jl_tostring.cpp:    eh->prev = ct->eh;
jl_tostring.cpp:    eh->gcstack = ct->gcstack;
jl_tostring.cpp:    eh->gc_state = jl_atomic_load_relaxed(&ct->ptls->gc_state);
jl_tostring.cpp:    eh->locks_len = ct->ptls->locks.len;
jl_tostring.cpp:    eh->defer_signal = ct->ptls->defer_signal;
jl_tostring.cpp:    eh->world_age = ct->world_age;
jl_tostring.cpp:    ct->eh = eh;
jl_tostring.cpp:    eh->timing_stack = ct->ptls->timing_stack;
jl_tostring.cpp:    if (ct->ptls->needs_resetstkoflw) {
jl_tostring.cpp:        ct->ptls->needs_resetstkoflw = 0;
jl_tostring.cpp:    // `eh` may be not equal to `ct->eh`. See `jl_pop_handler`
jl_tostring.cpp:    sig_atomic_t old_defer_signal = ct->ptls->defer_signal;
jl_tostring.cpp:    int8_t old_gc_state = jl_atomic_load_relaxed(&ct->ptls->gc_state);
jl_tostring.cpp:    ct->eh = eh->prev;
jl_tostring.cpp:    ct->gcstack = eh->gcstack;
jl_tostring.cpp:    small_arraylist_t *locks = &ct->ptls->locks;
jl_tostring.cpp:    int unlocks = locks->len > eh->locks_len;
jl_tostring.cpp:        for (size_t i = locks->len; i > eh->locks_len; i--)
jl_tostring.cpp:            jl_mutex_unlock_nogc((jl_mutex_t*)locks->items[i - 1]);
jl_tostring.cpp:        locks->len = eh->locks_len;
jl_tostring.cpp:    ct->world_age = eh->world_age;
jl_tostring.cpp:    ct->ptls->defer_signal = eh->defer_signal;
jl_tostring.cpp:    if (old_gc_state != eh->gc_state) {
jl_tostring.cpp:        jl_atomic_store_release(&ct->ptls->gc_state, eh->gc_state);
jl_tostring.cpp:            jl_gc_safepoint_(ct->ptls);
jl_tostring.cpp:    if (old_defer_signal && !eh->defer_signal) {
jl_tostring.cpp:        jl_sigint_safepoint(ct->ptls);
jl_tostring.cpp:    if (jl_gc_have_pending_finalizers && unlocks && eh->locks_len == 0) {
jl_tostring.cpp:    jl_handler_t *eh = ct->eh;
jl_tostring.cpp:    while (--n > 0)
jl_tostring.cpp:        eh = eh->prev;
jl_tostring.cpp:    jl_excstack_t *s = ct->excstack;
jl_tostring.cpp:    return s ? s->top : 0;
jl_tostring.cpp:    jl_excstack_t *s = ct->excstack;
jl_tostring.cpp:        assert(s->top >= state);
jl_tostring.cpp:        s->top = state;
jl_tostring.cpp:    assert(dest->reserved_size >= src->top);
jl_tostring.cpp:    memcpy(jl_excstack_raw(dest), jl_excstack_raw(src), sizeof(jl_bt_element_t)*src->top);
jl_tostring.cpp:    dest->top = src->top;
jl_tostring.cpp:    if (s && s->reserved_size >= reserved_size)
jl_tostring.cpp:    jl_excstack_t *new_s = (jl_excstack_t*)jl_gc_alloc_buf(ct->ptls, bufsz);
jl_tostring.cpp:    new_s->top = 0;
jl_tostring.cpp:    new_s->reserved_size = reserved_size;
jl_tostring.cpp:    jl_reserve_excstack(stack, (*stack ? (*stack)->top : 0) + bt_size + 2);
jl_tostring.cpp:    memcpy(rawstack + s->top, bt_data, sizeof(jl_bt_element_t)*bt_size);
jl_tostring.cpp:    s->top += bt_size + 2;
jl_tostring.cpp:    rawstack[s->top-2].uintptr = bt_size;
jl_tostring.cpp:    rawstack[s->top-1].jlvalue = exception;
jl_tostring.cpp:// conversion -----------------------------------------------------------------
jl_tostring.cpp:    return a->data;
jl_tostring.cpp:    if (!st->name->mutabl)
jl_tostring.cpp:        jl_errorf("setfield!: immutable struct of type %s cannot be changed", jl_symbol_name(st->name->name));
jl_tostring.cpp:// parsing --------------------------------------------------------------------
jl_tostring.cpp:    if (errno==ERANGE && (out==0 || out==HUGE_VAL || out==-HUGE_VAL)) {
jl_tostring.cpp:// MSVC pre-2013 did not define HUGE_VALF
jl_tostring.cpp:    if (errno==ERANGE && (out==0 || out==HUGE_VALF || out==-HUGE_VALF)) {
jl_tostring.cpp:// showing --------------------------------------------------------------------
jl_tostring.cpp:    return stdout_obj ? stdout_obj->value : NULL;
jl_tostring.cpp:    return stderr_obj ? stderr_obj->value : NULL;
jl_tostring.cpp:// toys for debugging ---------------------------------------------------------
jl_tostring.cpp:        if (i != len-1)
jl_tostring.cpp:        return first_arg_datatype(((jl_tvar_t*)a)->ub, got_tuple1);
jl_tostring.cpp:        return first_arg_datatype(((jl_unionall_t*)a)->body, got_tuple1);
jl_tostring.cpp:        jl_datatype_t *d1 = first_arg_datatype(u->a, got_tuple1);
jl_tostring.cpp:        jl_datatype_t *d2 = first_arg_datatype(u->b, got_tuple1);
jl_tostring.cpp:        if (d2 == NULL || d1->name != d2->name)
jl_tostring.cpp:    jl_sym_t *globname = dv->name->mt != NULL ? dv->name->mt->name : NULL;
jl_tostring.cpp:        !strchr(jl_symbol_name(globname), '@') && dv->name->module &&
jl_tostring.cpp:        jl_binding_resolved_p(dv->name->module, globname)) {
jl_tostring.cpp:        jl_binding_t *b = jl_get_module_binding(dv->name->module, globname);
jl_tostring.cpp:        if (b && b->value && (b->value == v || jl_typeof(b->value) == v)) {
jl_tostring.cpp:        vt = vt->super;
jl_tostring.cpp:    return std::string( buf.get(), buf.get() + size - 1 ); // We don't want the '\0' inside
jl_tostring.cpp:        if (vm->T) {
jl_tostring.cpp:            n += jl_static_show_x(out, vm->T, depth);
jl_tostring.cpp:            if (vm->N) {
jl_tostring.cpp:                n += jl_static_show_x(out, vm->N, depth);
jl_tostring.cpp:        jl_sym_t *sym = globfunc ? globname : dv->name->name;
jl_tostring.cpp:        if (jl_core_module && (dv->name->module != jl_core_module || !jl_module_exports_p(jl_core_module, sym))) {
jl_tostring.cpp:            jl_module_to_string(out,dv->name->module);
jl_tostring.cpp:            //n += jl_static_show_x(out, (jl_value_t*)dv->name->module, depth);
jl_tostring.cpp:        if (dv->parameters && (jl_value_t*)dv != dv->name->wrapper &&
jl_tostring.cpp:                    if (j != tlen-1)
jl_tostring.cpp:            else if (dv->name == jl_tuple_typename) {
jl_tostring.cpp:            // tail-recurse on b to flatten the printing of the Union structure in the common case
jl_tostring.cpp:            n += jl_static_show_x(out, ((jl_uniontype_t*)v)->a, depth);
jl_tostring.cpp:            v = ((jl_uniontype_t*)v)->b;
jl_tostring.cpp:        n += jl_static_show_x(out, ua->body, depth);
jl_tostring.cpp:        n += jl_static_show_x(out, (jl_value_t*)ua->var, depth->prev);
jl_tostring.cpp:        n += jl_static_show_x(out, jl_unwrap_unionall(((jl_typename_t*)v)->wrapper), depth);
jl_tostring.cpp:        // show type-var bounds only if they aren't going to be printed by UnionAll later
jl_tostring.cpp:        for (p = depth; p != NULL; p = p->prev) {
jl_tostring.cpp:            if (jl_is_unionall(p->v) && ((jl_unionall_t*)p->v)->var == var) {
jl_tostring.cpp:        jl_value_t *lb = var->lb, *ub = var->ub;
jl_tostring.cpp:            // show type-var lower bound if it is defined
jl_tostring.cpp:        n += jl_static_show_x_sym_escaped(out, var->name);
jl_tostring.cpp:            // show type-var upper bound if it is defined, or if we showed the lower bound
jl_tostring.cpp:        if (m->parent != m && m->parent != jl_main_module) {
jl_tostring.cpp:            n += jl_static_show_x(out, (jl_value_t*)m->parent, depth);
jl_tostring.cpp:        n += jl_printf(out, "%s", jl_symbol_name(m->name));
jl_tostring.cpp:                       (uintptr_t)((jl_ssavalue_t*)v)->id);
jl_tostring.cpp:        if (e->head == jl_assign_sym && jl_array_len(e->args) == 2) {
jl_tostring.cpp:            n += jl_printf(out, "Expr(:%s", jl_symbol_name(e->head));
jl_tostring.cpp:            size_t i, len = jl_array_len(e->args);
jl_tostring.cpp:        if (av->flags.ptrarray) {
jl_tostring.cpp:            if (av->flags.ptrarray) {
jl_tostring.cpp:                char *ptr = ((char*)av->data) + j * av->elsize;
jl_tostring.cpp:            if (j != tlen - 1)
jl_tostring.cpp:        jl_sym_t *sym = dv->name->mt->name;
jl_tostring.cpp:        if (jl_core_module && (dv->name->module != jl_core_module || !jl_module_exports_p(jl_core_module, sym))) {
jl_tostring.cpp:            n += jl_static_show_x(out, (jl_value_t*)dv->name->module, depth);
jl_tostring.cpp:            for(int i = nb - 1; i >= 0; --i)
jl_tostring.cpp:                        uint8_t sel = ((uint8_t*)fld_ptr)[jl_field_size(vt, i) - 1];
jl_tostring.cpp:                else if (i != tlen - 1)
jl_tostring.cpp:                n += jl_static_show_next_(out, (jl_value_t*)((jl_typemap_entry_t*)v)->next, v, depth);
jl_tostring.cpp:        n += jl_static_show_func_sig(out, m->sig);
jl_tostring.cpp:        if (jl_is_method(li->def.method)) {
jl_tostring.cpp:            n += jl_static_show_func_sig(out, li->specTypes);
jl_tostring.cpp:            n += jl_static_show_func_sig(out, li->def.method->sig);
jl_tostring.cpp:            n += jl_static_show_x(out, (jl_value_t*)li->def.module, depth);
jl_tostring.cpp:            n += jl_printf(out, ".<toplevel thunk> -> ");
jl_tostring.cpp:            n += jl_static_show_x(out, li->uninferred, depth);
jl_tostring.cpp:        n += jl_static_show_x(out, jl_unwrap_unionall(((jl_typename_t*)v)->wrapper), depth);
jl_tostring.cpp:        if (vm->T) {
jl_tostring.cpp:            n += jl_static_show_x(out, vm->T, depth);
jl_tostring.cpp:            if (vm->N) {
jl_tostring.cpp:                n += jl_static_show_x(out, vm->N, depth);
jl_tostring.cpp:        jl_sym_t *sym = globfunc ? globname : dv->name->name;
jl_tostring.cpp:        if (jl_core_module && (dv->name->module != jl_core_module || !jl_module_exports_p(jl_core_module, sym))) {
jl_tostring.cpp:            n += jl_static_show_x(out, (jl_value_t*)dv->name->module, depth);
jl_tostring.cpp:        if (dv->parameters && (jl_value_t*)dv != dv->name->wrapper &&
jl_tostring.cpp:                    if (j != tlen-1)
jl_tostring.cpp:            else if (dv->name == jl_tuple_typename) {
jl_tostring.cpp:            // tail-recurse on b to flatten the printing of the Union structure in the common case
jl_tostring.cpp:            n += jl_static_show_x(out, ((jl_uniontype_t*)v)->a, depth);
jl_tostring.cpp:            v = ((jl_uniontype_t*)v)->b;
jl_tostring.cpp:        n += jl_static_show_x(out, ua->body, depth);
jl_tostring.cpp:        n += jl_static_show_x(out, (jl_value_t*)ua->var, depth->prev);
jl_tostring.cpp:        n += jl_static_show_x(out, jl_unwrap_unionall(((jl_typename_t*)v)->wrapper), depth);
jl_tostring.cpp:        // show type-var bounds only if they aren't going to be printed by UnionAll later
jl_tostring.cpp:        for (p = depth; p != NULL; p = p->prev) {
jl_tostring.cpp:            if (jl_is_unionall(p->v) && ((jl_unionall_t*)p->v)->var == var) {
jl_tostring.cpp:        jl_value_t *lb = var->lb, *ub = var->ub;
jl_tostring.cpp:            // show type-var lower bound if it is defined
jl_tostring.cpp:        n += jl_static_show_x_sym_escaped(out, var->name);
jl_tostring.cpp:            // show type-var upper bound if it is defined, or if we showed the lower bound
jl_tostring.cpp:        if (m->parent != m && m->parent != jl_main_module) {
jl_tostring.cpp:            n += jl_static_show_x(out, (jl_value_t*)m->parent, depth);
jl_tostring.cpp:        n += jl_printf(out, "%s", jl_symbol_name(m->name));
jl_tostring.cpp:                       (uintptr_t)((jl_ssavalue_t*)v)->id);
jl_tostring.cpp:        if (e->head == jl_assign_sym && jl_array_len(e->args) == 2) {
jl_tostring.cpp:            n += jl_printf(out, "Expr(:%s", jl_symbol_name(e->head));
jl_tostring.cpp:            size_t i, len = jl_array_len(e->args);
jl_tostring.cpp:        if (av->flags.ptrarray) {
jl_tostring.cpp:            if (av->flags.ptrarray) {
jl_tostring.cpp:                char *ptr = ((char*)av->data) + j * av->elsize;
jl_tostring.cpp:            if (j != tlen - 1)
jl_tostring.cpp:        jl_sym_t *sym = dv->name->mt->name;
jl_tostring.cpp:        if (jl_core_module && (dv->name->module != jl_core_module || !jl_module_exports_p(jl_core_module, sym))) {
jl_tostring.cpp:            n += jl_static_show_x(out, (jl_value_t*)dv->name->module, depth);
jl_tostring.cpp:            for(int i = nb - 1; i >= 0; --i)
jl_tostring.cpp:                        uint8_t sel = ((uint8_t*)fld_ptr)[jl_field_size(vt, i) - 1];
jl_tostring.cpp:                else if (i != tlen - 1)
jl_tostring.cpp:                n += jl_static_show_next_(out, (jl_value_t*)((jl_typemap_entry_t*)v)->next, v, depth);
jl_tostring.cpp:            jl_value_t *m = p->v;
jl_tostring.cpp:                    return jl_printf(out, "<typemap reference #%u @-%u ", nid, dist) +
jl_tostring.cpp:                           jl_static_show_x(out, (jl_value_t*)((jl_typemap_entry_t*)m)->sig, depth) +
jl_tostring.cpp:                jl_value_t *mnext = (jl_value_t*)((jl_typemap_entry_t*)m)->next;
jl_tostring.cpp:                jl_value_t *m2 = p->v;
jl_tostring.cpp:                    jl_value_t *mnext2 = (jl_value_t*)((jl_typemap_entry_t*)m2)->next;
jl_tostring.cpp:        if (p->v == v)
jl_tostring.cpp:            return jl_printf(out, "<circular reference @-%u>", dist);
jl_tostring.cpp:        p = p->prev;
jl_tostring.cpp:    if (start == start->parent){
jl_tostring.cpp:        s << jl_symbol_name(m->name);
jl_tostring.cpp:    while (start->parent != NULL){
jl_tostring.cpp:        start = start->parent;
jl_tostring.cpp:        mods[i] = mods[i-1]->parent;
jl_tostring.cpp:    for (int i = n-1;i > 0;i--){
jl_tostring.cpp:        s << jl_symbol_name(mods[i]->name);
jl_tostring.cpp:    s << jl_symbol_name(m->name);
jl_tostring.cpp:            depth[i].prev = i == 0 ? NULL : &depth[i - 1];
jl_tostring.cpp:            type = ((jl_unionall_t*)type)->body;
jl_tostring.cpp:        depth += nvars - 1;
jl_tostring.cpp:    // Type contains no type variables, or it's fully-unapplied type.
jl_tostring.cpp:    if (jl_nparams(ftype) == 0 || ftype == ((jl_datatype_t*)ftype)->name->wrapper) {
jl_tostring.cpp:        jl_module_to_string(s,((jl_datatype_t*)ftype)->name->module);
jl_tostring.cpp:        const char* funcname = jl_symbol_name(((jl_datatype_t*)ftype)->name->mt->name);
jl_tostring.cpp:        // for non-trival type constructor
jl_tostring.cpp:        if (i != tl - 1) {
jl_tostring.cpp:            depth[i].prev = i == 0 ? NULL : &depth[i - 1];
jl_tostring.cpp:            type = ((jl_unionall_t*)type)->body;
jl_tostring.cpp:        depth += nvars - 1;
jl_tostring.cpp:    if (jl_nparams(ftype) == 0 || ftype == ((jl_datatype_t*)ftype)->name->wrapper) {
jl_tostring.cpp:        n += jl_printf(s, "%s", jl_symbol_name(((jl_datatype_t*)ftype)->name->mt->name));
jl_tostring.cpp:        if (i != tl - 1) {
jl_tostring.cpp:        depth -= nvars - 1;
jl_tostring.cpp:            n += jl_static_show_x(s, (jl_value_t*)tvars->var, first ? NULL : depth);
jl_tostring.cpp:            tvars = (jl_unionall_t*)tvars->body;
jl_tostring.cpp:        jl_printf((JL_STREAM*)STDERR_FILENO, "\n!!! ERROR in jl_ -- ABORTING !!!\n");
jl_tostring.cpp:// logging tools --------------------------------------------------------------
APInt-C.cpp:#include "llvm-version.h"
APInt-C.cpp:#include "APInt-C.h"
APInt-C.cpp:        /* use LLT_ALIGN to round the memory area up to the nearest integerPart-sized chunk */ \
APInt-C.cpp:        /* TODO: this memcpy assumes little-endian,
APInt-C.cpp:         * for big-endian, need to align the copy to the other end */ \
APInt-C.cpp:    z -= a;
APInt-C.cpp:    a -= b;
APInt-C.cpp:    if (onumbits <= 64) { // fast-path, if possible
APInt-C.cpp:            memcpy(pr, &ia, onumbytes); // TODO: assumes little-endian
APInt-C.cpp:                int64_t ia2 = ia < 0 ? -1 : 0;
APInt-C.cpp:            memcpy(pr, &ia, onumbytes); // TODO: assumes little-endian
APInt-C.cpp:    int bits = (0 - inumbits) % host_char_bit;
APInt-C.cpp:    int signbit = (inumbits - 1) % host_char_bit;
APInt-C.cpp:    int sign = ((unsigned char*)pa)[inumbytes - 1] & (1 << signbit) ? -1 : 0;
APInt-C.cpp:        // sign-extend the partial byte
APInt-C.cpp:        ((signed char*)pr)[inumbytes - 1] = ((signed char*)pa)[inumbytes - 1] << bits >> bits;
APInt-C.cpp:    // sign-extend the rest of the bytes
APInt-C.cpp:    memset((char*)pr + inumbytes, sign, onumbytes - inumbytes);
APInt-C.cpp:    int bits = (0 - inumbits) % host_char_bit;
APInt-C.cpp:        ((unsigned char*)pr)[inumbytes - 1] = ((unsigned char*)pa)[inumbytes - 1] << bits >> bits;
APInt-C.cpp:    // zero-extend the rest of the bytes
APInt-C.cpp:    memset((char*)pr + inumbytes, 0, onumbytes - inumbytes);
APInt-C.cpp:    unsigned numbytes = (numbits + host_char_bit - 1) / host_char_bit;
APInt-C.cpp:    int signbit = (numbits - 1) % host_char_bit;
APInt-C.cpp:    int sign = ((unsigned char*)pb)[numbytes - 1] & (1 << signbit);
typemap.c:        t1 = ((jl_tvar_t*)t1)->ub;
typemap.c:        return jl_type_extract_name(((jl_tvar_t*)t1)->ub);
typemap.c:            return (jl_value_t*)dt->name;
typemap.c:        jl_value_t *tn1 = jl_type_extract_name(u1->a);
typemap.c:        jl_value_t *tn2 = jl_type_extract_name(u1->b);
typemap.c:// return false if the name extracted above is an over-approximation
typemap.c:        return jl_type_extract_name_precise(((jl_tvar_t*)t1)->ub, 0);
typemap.c:        if ((invariant || !dt->name->abstract) && !jl_is_kind(t1))
typemap.c:        if (!jl_type_extract_name_precise(u1->a, invariant))
typemap.c:        if (!jl_type_extract_name_precise(u1->b, invariant))
typemap.c:        jl_value_t *tn1 = jl_type_extract_name(u1->a);
typemap.c:        jl_value_t *tn2 = jl_type_extract_name(u1->b);
typemap.c:// ----- Type Signature Subtype Testing ----- //
typemap.c:    if (va) lensig -= 1;
typemap.c:        jl_value_t *unw = jl_is_unionall(decl) ? ((jl_unionall_t*)decl)->body : decl;
typemap.c:                    if (((jl_tvar_t*)tp0)->ub != (jl_value_t*)jl_any_type &&
typemap.c:                        !jl_subtype(jl_tparam0(a), ((jl_tvar_t*)tp0)->ub))
typemap.c:            else if (!jl_is_kind(a) || !jl_is_typevar(tp0) || ((jl_tvar_t*)tp0)->ub != (jl_value_t*)jl_any_type) {
typemap.c:            if (n - i != jl_unbox_long(jl_tparam1(decl)))
typemap.c:            t = ((jl_tvar_t*)t)->ub;
typemap.c:            if (i == n - 1 && jl_is_vararg(ti))
typemap.c:        jl_value_t *a = args[i - 1];
typemap.c:              hash-consed, so pointer comparison should work.
typemap.c:        lensig -= 1;
typemap.c:        jl_value_t *a = (i == 0 ? arg1 : args[i - 1]);
typemap.c:              hash-consed, so pointer comparison should work.
typemap.c:        jl_value_t *unw = jl_is_unionall(decl) ? ((jl_unionall_t*)decl)->body : decl;
typemap.c:                if (((jl_tvar_t*)tp0)->ub != (jl_value_t*)jl_any_type &&
typemap.c:                    !jl_subtype(a, ((jl_tvar_t*)tp0)->ub))
typemap.c:                        da = (jl_datatype_t*)((jl_unionall_t*)da)->body;
typemap.c:                        dt = (jl_datatype_t*)((jl_unionall_t*)dt)->body;
typemap.c:                    if (jl_is_datatype(da) && jl_is_datatype(dt) && da->name != dt->name)
typemap.c:            if (n - i != jl_unbox_long(jl_tparam1(decl)))
typemap.c:            jl_value_t *a = (i == 0 ? arg1 : args[i - 1]);
typemap.c:// ----- MethodCache helper functions ----- //
typemap.c:// predicate to fast-test if this type is a leaf type that can exist in the cache
typemap.c:// be careful not to put non-leaf types or DataType/UnionAll/Union in the
typemap.c:    JL_GC_PROMISE_ROOTED(pml); // clang-sa doesn't trust our JL_PROPAGATES_ROOT claim
typemap.c:    JL_GC_PROMISE_ROOTED(ml); // clang-sa doesn't trust our JL_PROPAGATES_ROOT claim
typemap.c:// ----- Sorted Type Signature Lookup Matching ----- //
typemap.c:        ml = jl_atomic_load_relaxed(&ml->next);
typemap.c:        a = jl_atomic_load_relaxed(&node->targ);
typemap.c:        a = jl_atomic_load_relaxed(&node->arg1);
typemap.c:        a = jl_atomic_load_relaxed(&node->tname);
typemap.c:        a = jl_atomic_load_relaxed(&node->name1);
typemap.c:        if (!jl_typemap_node_visitor(jl_atomic_load_relaxed(&node->linear), fptr, closure))
typemap.c:        if (!jl_typemap_visitor(jl_atomic_load_relaxed(&node->any), fptr, closure))
typemap.c:        dt = dt->super;
typemap.c:// return true if a and b might intersect in the type domain (over just their type-names)
typemap.c:    jl_datatype_t *b = (jl_datatype_t*)jl_unwrap_unionall(bname->wrapper);
typemap.c:        if (a->name == b->name)
typemap.c:        b = b->super;
typemap.c:        a = a->super;
typemap.c:        ha--;
typemap.c:    return a->name == bname;
typemap.c:// for which type  ml->type != Union{}, until fptr return false
typemap.c:    // slow-path scan everything in ml
typemap.c:    register jl_typemap_intersection_visitor_fptr fptr = closure->fptr;
typemap.c:        if (closure->type == (jl_value_t*)ml->sig) {
typemap.c:            // fast-path for the intersection of a type with itself
typemap.c:            if (closure->env)
typemap.c:                closure->env = jl_outer_unionall_vars((jl_value_t*)ml->sig);
typemap.c:            closure->ti = closure->type;
typemap.c:            closure->issubty = 1;
typemap.c:            if (closure->env) {
typemap.c:                closure->env = jl_emptysvec;
typemap.c:                penv = &closure->env;
typemap.c:            closure->ti = jl_type_intersection_env_s(closure->type, (jl_value_t*)ml->sig, penv, &closure->issubty);
typemap.c:            if (closure->ti != (jl_value_t*)jl_bottom_type) {
typemap.c:                if (closure->issubty || !jl_is_dispatch_tupletype(closure->type))
typemap.c:        ml = jl_atomic_load_relaxed(&ml->next);
typemap.c:    jl_value_t *ttypes = jl_unwrap_unionall(closure->type);
typemap.c:    //TODO: fast-path for leaf-type tuples?
typemap.c:    //if (ttypes->isdispatchtuple) {
typemap.c:    //    register jl_typemap_intersection_visitor_fptr fptr = closure->fptr;
typemap.c:    //        struct jl_typemap_assoc search = {(jl_value_t*)closure->type, world, closure->env, 0, ~(size_t)0};
typemap.c:    //            closure->env = search->env;
typemap.c:        if (closure->va && l <= offs + 1) {
typemap.c:            ty = closure->va;
typemap.c:            ty = (jl_value_t*)jl_assume(jl_typeofbottom_type)->super;
typemap.c:                ty = ((jl_tvar_t*)ty)->ub;
typemap.c:                    ty = ((jl_datatype_t*)ty)->name->wrapper;
typemap.c:            jl_array_t *targ = jl_atomic_load_relaxed(&cache->targ);
typemap.c:                    // first, fast-path: optimized pre-intersection test to see if `ty` could intersect with any Type
typemap.c:                        targ = jl_atomic_load_relaxed(&cache->targ); // may be GC'd during type-intersection
typemap.c:            jl_array_t *cachearg1 = jl_atomic_load_relaxed(&cache->arg1);
typemap.c:            jl_array_t *tname = jl_atomic_load_relaxed(&cache->tname);
typemap.c:                    // semi-direct lookup of types
typemap.c:                    jl_datatype_t *super = (jl_datatype_t*)jl_unwrap_unionall(((jl_typename_t*)name)->wrapper);
typemap.c:                            tname = jl_atomic_load_relaxed(&cache->tname); // reload after callback
typemap.c:                            jl_typemap_t *ml = mtcache_hash_lookup(tname, (jl_value_t*)super->name);
typemap.c:                            super = super->super;
typemap.c:                    // first, fast-path: optimized pre-intersection test to see if `ty` could intersect with any Type
typemap.c:                        tname = jl_atomic_load_relaxed(&cache->tname);  // may be GC'd during type-intersection
typemap.c:            jl_array_t *name1 = jl_atomic_load_relaxed(&cache->name1);
typemap.c:                    jl_datatype_t *super = (jl_datatype_t*)jl_unwrap_unionall(((jl_typename_t*)name)->wrapper);
typemap.c:                            name1 = jl_atomic_load_relaxed(&cache->name1); // reload after callback
typemap.c:                            jl_typemap_t *ml = mtcache_hash_lookup(name1, (jl_value_t*)super->name);
typemap.c:                            super = super->super;
typemap.c:        if (!jl_typemap_intersection_node_visitor(jl_atomic_load_relaxed(&cache->linear), closure))
typemap.c:        return jl_typemap_intersection_visitor(jl_atomic_load_relaxed(&cache->any), offs+1, closure);
typemap.c:    jl_value_t *types = search->types;
typemap.c:    int typesisva = n == 0 ? 0 : jl_is_vararg(jl_tparam(unw, n-1));
typemap.c:    for (; ml != (void*)jl_nothing; ml = jl_atomic_load_relaxed(&ml->next)) {
typemap.c:        size_t lensig = jl_nparams(jl_unwrap_unionall((jl_value_t*)ml->sig));
typemap.c:        if (lensig == n || (ml->va && lensig <= n+1)) {
typemap.c:            if (ml->simplesig != (void*)jl_nothing && !isua) {
typemap.c:                size_t lensimplesig = jl_nparams(ml->simplesig);
typemap.c:                int isva = lensimplesig > 0 && jl_is_vararg(jl_tparam(ml->simplesig, lensimplesig - 1));
typemap.c:                    ismatch = sig_match_by_type_simple(jl_svec_data(((jl_datatype_t*)types)->parameters), n,
typemap.c:                                                       ml->simplesig, lensimplesig, isva);
typemap.c:            else if (ml->isleafsig && !typesisva && !isua)
typemap.c:                ismatch = sig_match_by_type_leaf(jl_svec_data(((jl_datatype_t*)types)->parameters),
typemap.c:                                                 ml->sig, lensig);
typemap.c:            else if (ml->issimplesig && !typesisva && !isua)
typemap.c:                ismatch = sig_match_by_type_simple(jl_svec_data(((jl_datatype_t*)types)->parameters), n,
typemap.c:                                                   ml->sig, lensig, ml->va);
typemap.c:                ismatch = jl_subtype_matching(types, (jl_value_t*)ml->sig, search->env ? &search->env : NULL);
typemap.c:                if (ismatch && search->env)
typemap.c:                for (i = 0, l = jl_svec_len(ml->guardsigs); i < l; i++) {
typemap.c:                    if (jl_subtype(types, jl_svecref(ml->guardsigs, i))) {
typemap.c:                    if (search->world < ml->min_world) {
typemap.c:                        if (search->max_valid >= ml->min_world)
typemap.c:                            search->max_valid = ml->min_world - 1;
typemap.c:                    else if (search->world > ml->max_world) {
typemap.c:                        if (search->min_valid <= ml->max_world)
typemap.c:                            search->min_valid = ml->max_world + 1;
typemap.c:                        if (search->min_valid < ml->min_world)
typemap.c:                            search->min_valid = ml->min_world;
typemap.c:                        if (search->max_valid > ml->max_world)
typemap.c:                            search->max_valid = ml->max_world;
typemap.c:                search->env = jl_emptysvec;
typemap.c:    for (; ml != (void*)jl_nothing; ml = jl_atomic_load_relaxed(&ml->next)) {
typemap.c:        if (search->world < ml->min_world || search->world > ml->max_world)
typemap.c:        jl_value_t *types = search->types;
typemap.c:        jl_value_t *b = jl_unwrap_unionall((jl_value_t*)ml->sig);
typemap.c:        int va_a = na > 0 && jl_is_vararg(jl_tparam(a, na - 1));
typemap.c:        int va_b = nb > 0 && jl_is_vararg(jl_tparam(b, nb - 1));
typemap.c:        if (na - va_a > 0 && nb - va_b > 0) {
typemap.c:            if (na - va_a > 1 && nb - va_b > 1) {
typemap.c:                if (na - va_a > 2 && nb - va_b > 2) {
typemap.c:        if (jl_types_equal(types, (jl_value_t*)ml->sig))
typemap.c:        jl_value_t *ttypes = jl_unwrap_unionall((jl_value_t*)search->types);
typemap.c:            ty = jl_tparam(ttypes, l - 1);
typemap.c:            ty = (jl_value_t*)jl_assume(jl_typeofbottom_type)->super;
typemap.c:                return jl_typemap_assoc_by_type(jl_atomic_load_relaxed(&cache->any), search, offs + 1, subtype);
typemap.c:                    jl_array_t *targ = jl_atomic_load_relaxed(&cache->targ);
typemap.c:                jl_array_t *cachearg1 = jl_atomic_load_relaxed(&cache->arg1);
typemap.c:            jl_array_t *tname = jl_atomic_load_relaxed(&cache->tname);
typemap.c:                if (a0) { // TODO: if we start analyzing Union types in jl_type_extract_name, then a0 might be over-approximated here, leading us to miss possible subtypes
typemap.c:                    jl_datatype_t *super = (jl_datatype_t*)jl_unwrap_unionall(((jl_typename_t*)a0)->wrapper);
typemap.c:                        tname = jl_atomic_load_relaxed(&cache->tname); // reload after tree descent (which may hit safepoints)
typemap.c:                        jl_typemap_t *ml = mtcache_hash_lookup(tname, (jl_value_t*)super->name);
typemap.c:                        super = super->super;
typemap.c:            jl_array_t *name1 = jl_atomic_load_relaxed(&cache->name1);
typemap.c:                    if (a0) { // TODO: if we start analyzing Union types in jl_type_extract_name, then a0 might be over-approximated here, leading us to miss possible subtypes
typemap.c:                        jl_datatype_t *super = (jl_datatype_t*)jl_unwrap_unionall(((jl_typename_t*)a0)->wrapper);
typemap.c:                            name1 = jl_atomic_load_relaxed(&cache->name1); // reload after tree descent (which may hit safepoints)
typemap.c:                            jl_typemap_t *ml = mtcache_hash_lookup(name1, (jl_value_t*)super->name);
typemap.c:                            super = super->super;
typemap.c:            jl_typemap_entry_t *li = jl_typemap_entry_assoc_by_type(jl_atomic_load_relaxed(&cache->linear), search);
typemap.c:            return jl_typemap_assoc_by_type(jl_atomic_load_relaxed(&cache->any), search, offs + 1, subtype);
typemap.c:            return jl_typemap_entry_lookup_by_type(jl_atomic_load_relaxed(&cache->linear), search);
typemap.c:    // some manually-unrolled common special cases
typemap.c:    while (ml->simplesig == (void*)jl_nothing && ml->guardsigs == jl_emptysvec && ml->isleafsig) {
typemap.c:        if (world >= ml->min_world && world <= ml->max_world) {
typemap.c:            if (n == jl_nparams(ml->sig) && jl_typeof(arg1) == jl_tparam(ml->sig, 0)) {
typemap.c:                    if (jl_typeof(args[0]) == jl_tparam(ml->sig, 1))
typemap.c:                    if (jl_typeof(args[0]) == jl_tparam(ml->sig, 1) &&
typemap.c:                        jl_typeof(args[1]) == jl_tparam(ml->sig, 2))
typemap.c:                    if (sig_match_leaf(arg1, args, jl_svec_data(ml->sig->parameters), n))
typemap.c:        ml = jl_atomic_load_relaxed(&ml->next);
typemap.c:    for (; ml != (void*)jl_nothing; ml = jl_atomic_load_relaxed(&ml->next)) {
typemap.c:        if (world < ml->min_world || world > ml->max_world)
typemap.c:        size_t lensig = jl_nparams(ml->sig);
typemap.c:        if (lensig == n || (ml->va && lensig <= n+1)) {
typemap.c:            if (ml->simplesig != (void*)jl_nothing) {
typemap.c:                size_t lensimplesig = jl_nparams(ml->simplesig);
typemap.c:                int isva = lensimplesig > 0 && jl_is_vararg(jl_tparam(ml->simplesig, lensimplesig - 1));
typemap.c:                    if (!sig_match_simple(arg1, args, n, jl_svec_data(ml->simplesig->parameters), isva, lensimplesig))
typemap.c:            if (ml->isleafsig) {
typemap.c:                if (!sig_match_leaf(arg1, args, jl_svec_data(ml->sig->parameters), n))
typemap.c:            else if (ml->issimplesig) {
typemap.c:                if (!sig_match_simple(arg1, args, n, jl_svec_data(ml->sig->parameters), ml->va, lensig))
typemap.c:                if (!jl_tuple1_isa(arg1, args, n, ml->sig))
typemap.c:            if (ml->guardsigs != jl_emptysvec) {
typemap.c:                for (i = 0, l = jl_svec_len(ml->guardsigs); i < l; i++) {
typemap.c:                    if (jl_tuple1_isa(arg1, args, n, (jl_tupletype_t*)jl_svecref(ml->guardsigs, i))) {
typemap.c:        jl_value_t *a1 = (offs == 0 ? arg1 : args[offs - 1]);
typemap.c:        jl_array_t *targ = jl_atomic_load_relaxed(&cache->targ);
typemap.c:        jl_array_t *cachearg1 = jl_atomic_load_relaxed(&cache->arg1);
typemap.c:        jl_array_t *tname = jl_atomic_load_relaxed(&cache->tname);
typemap.c:                    a1 = jl_unwrap_unionall(((jl_typename_t*)name)->wrapper);
typemap.c:                    tname = jl_atomic_load_relaxed(&cache->tname); // reload after tree descent (which may hit safepoints)
typemap.c:                            tname, (jl_value_t*)((jl_datatype_t*)a1)->name);
typemap.c:                    a1 = (jl_value_t*)((jl_datatype_t*)a1)->super;
typemap.c:        jl_array_t *name1 = jl_atomic_load_relaxed(&cache->name1);
typemap.c:                name1 = jl_atomic_load_relaxed(&cache->name1); // reload after tree descent (which may hit safepoints)
typemap.c:                        name1, (jl_value_t*)((jl_datatype_t*)ty)->name);
typemap.c:                ty = (jl_value_t*)((jl_datatype_t*)ty)->super;
typemap.c:    jl_typemap_entry_t *linear = jl_atomic_load_relaxed(&cache->linear);
typemap.c:    jl_typemap_t *cacheany = jl_atomic_load_relaxed(&cache->any);
typemap.c:// ----- Method List Insertion Management ----- //
typemap.c:        ml = jl_atomic_load_relaxed(&ml->next);
typemap.c:        (jl_typemap_level_t*)jl_gc_alloc(ct->ptls, sizeof(jl_typemap_level_t),
typemap.c:    jl_atomic_store_relaxed(&cache->arg1, (jl_array_t*)jl_an_empty_vec_any);
typemap.c:    jl_atomic_store_relaxed(&cache->targ, (jl_array_t*)jl_an_empty_vec_any);
typemap.c:    jl_atomic_store_relaxed(&cache->name1, (jl_array_t*)jl_an_empty_vec_any);
typemap.c:    jl_atomic_store_relaxed(&cache->tname, (jl_array_t*)jl_an_empty_vec_any);
typemap.c:    jl_atomic_store_relaxed(&cache->linear, (jl_typemap_entry_t*)jl_nothing);
typemap.c:    jl_atomic_store_relaxed(&cache->any, jl_nothing);
typemap.c:        next = jl_atomic_load_relaxed(&ml->next);
typemap.c:        jl_atomic_store_relaxed(&ml->next, (jl_typemap_entry_t*)jl_nothing);
typemap.c:        if (newrec->isleafsig || !l->isleafsig)
typemap.c:            if (newrec->issimplesig || !l->issimplesig)
typemap.c:        pml = &l->next;
typemap.c:        l = jl_atomic_load_relaxed(&l->next);
typemap.c:    jl_atomic_store_relaxed(&newrec->next, l);
typemap.c:    jl_value_t *ttypes = jl_unwrap_unionall((jl_value_t*)newrec->sig);
typemap.c:        t1 = jl_tparam(ttypes, l - 1);
typemap.c:        t1 = (jl_value_t*)jl_assume(jl_typeofbottom_type)->super;
typemap.c:        jl_typemap_insert_generic(map, &cache->any, (jl_value_t*)cache, newrec, offs+1);
typemap.c:                jl_typemap_array_insert_(map, &cache->targ, a0, newrec, (jl_value_t*)cache, offs);
typemap.c:            jl_typemap_array_insert_(map, &cache->arg1, t1, newrec, (jl_value_t*)cache, offs);
typemap.c:            jl_datatype_t *super = a0 ? (jl_datatype_t*)jl_unwrap_unionall(((jl_typename_t*)a0)->wrapper) : jl_any_type;
typemap.c:            jl_typemap_array_insert_(map, &cache->tname, (jl_value_t*)super->name, newrec, (jl_value_t*)cache, offs);
typemap.c:        if (a0 && a0 != (jl_value_t*)jl_any_type->name) {
typemap.c:            jl_typemap_array_insert_(map, &cache->name1, a0, newrec, (jl_value_t*)cache, offs);
typemap.c:    jl_typemap_list_insert_(map, &cache->linear, (jl_value_t*)cache, newrec);
typemap.c:        (jl_typemap_entry_t*)jl_gc_alloc(ct->ptls, sizeof(jl_typemap_entry_t),
typemap.c:    newrec->sig = type;
typemap.c:    newrec->simplesig = simpletype;
typemap.c:    newrec->func.value = newvalue;
typemap.c:    newrec->guardsigs = guardsigs;
typemap.c:    jl_atomic_store_relaxed(&newrec->next, (jl_typemap_entry_t*)jl_nothing);
typemap.c:    newrec->min_world = min_world;
typemap.c:    newrec->max_world = max_world;
typemap.c:    newrec->va = isva;
typemap.c:    newrec->issimplesig = issimplesig;
typemap.c:    newrec->isleafsig = isleafsig;
llvm-final-gc-lowering.cpp:#include "llvm-version.h"
llvm-final-gc-lowering.cpp:#include "llvm-pass-helpers.h"
llvm-final-gc-lowering.cpp:// The final GC lowering pass. This pass lowers platform-agnostic GC
llvm-final-gc-lowering.cpp:// intrinsics to platform-dependent instruction sequences. The
llvm-final-gc-lowering.cpp:// This pass targets typical back-ends for which the standard Julia
llvm-final-gc-lowering.cpp:// runtime library is available. Atypical back-ends should supply
llvm-final-gc-lowering.cpp:    assert(target->getNumArgOperands() == 1);
llvm-final-gc-lowering.cpp:    unsigned nRoots = cast<ConstantInt>(target->getArgOperand(0))->getLimitedValue(INT_MAX);
llvm-final-gc-lowering.cpp:    gcframe->insertAfter(target);
llvm-final-gc-lowering.cpp:    gcframe->takeName(target);
llvm-final-gc-lowering.cpp:    tempSlot_i8->insertAfter(gcframe);
llvm-final-gc-lowering.cpp:    Type *argsT[2] = {tempSlot_i8->getType(), T_int32};
llvm-final-gc-lowering.cpp:    cast<MemSetInst>(zeroing)->setDestAlignment(16);
llvm-final-gc-lowering.cpp:    zeroing->setMetadata(LLVMContext::MD_tbaa, tbaa_gcframe);
llvm-final-gc-lowering.cpp:    zeroing->insertAfter(tempSlot_i8);
llvm-final-gc-lowering.cpp:    assert(target->getNumArgOperands() == 2);
llvm-final-gc-lowering.cpp:    auto gcframe = target->getArgOperand(0);
llvm-final-gc-lowering.cpp:    unsigned nRoots = cast<ConstantInt>(target->getArgOperand(1))->getLimitedValue(INT_MAX);
llvm-final-gc-lowering.cpp:    IRBuilder<> builder(target->getContext());
llvm-final-gc-lowering.cpp:                        T_size->getPointerTo()),
llvm-final-gc-lowering.cpp:    inst->setMetadata(LLVMContext::MD_tbaa, tbaa_gcframe);
llvm-final-gc-lowering.cpp:    inst->setMetadata(LLVMContext::MD_tbaa, tbaa_gcframe);
llvm-final-gc-lowering.cpp:    assert(target->getNumArgOperands() == 1);
llvm-final-gc-lowering.cpp:    auto gcframe = target->getArgOperand(0);
llvm-final-gc-lowering.cpp:    IRBuilder<> builder(target->getContext());
llvm-final-gc-lowering.cpp:    inst->setMetadata(LLVMContext::MD_tbaa, tbaa_gcframe);
llvm-final-gc-lowering.cpp:    inst->setMetadata(LLVMContext::MD_tbaa, tbaa_gcframe);
llvm-final-gc-lowering.cpp:    assert(target->getNumArgOperands() == 2);
llvm-final-gc-lowering.cpp:    auto gcframe = target->getArgOperand(0);
llvm-final-gc-lowering.cpp:    auto index = target->getArgOperand(1);
llvm-final-gc-lowering.cpp:    IRBuilder<> builder(target->getContext());
llvm-final-gc-lowering.cpp:    gep->takeName(target);
llvm-final-gc-lowering.cpp:    assert(target->getNumArgOperands() == 1);
llvm-final-gc-lowering.cpp:    target->setCalledFunction(queueRootFunc);
llvm-final-gc-lowering.cpp:    assert(target->getNumArgOperands() == 2);
llvm-final-gc-lowering.cpp:    auto sz = (size_t)cast<ConstantInt>(target->getArgOperand(1))->getZExtValue();
llvm-final-gc-lowering.cpp:    builder.SetCurrentDebugLocation(target->getDebugLoc());
llvm-final-gc-lowering.cpp:    auto ptls = target->getArgOperand(0);
llvm-final-gc-lowering.cpp:    newI->setAttributes(newI->getCalledFunction()->getAttributes());
llvm-final-gc-lowering.cpp:    newI->takeName(target);
llvm-final-gc-lowering.cpp:    // Initialize platform-agnostic references.
llvm-final-gc-lowering.cpp:    // Initialize platform-specific references.
llvm-final-gc-lowering.cpp:    ConstantArray *CA = cast<ConstantArray>(used->getInitializer());
llvm-final-gc-lowering.cpp:    for (auto &Op : CA->operands()) {
llvm-final-gc-lowering.cpp:        if (InitAsSet.count(C->stripPointerCasts())) {
llvm-final-gc-lowering.cpp:    used->eraseFromParent();
llvm-final-gc-lowering.cpp:    used->setSection("llvm.metadata");
llvm-final-gc-lowering.cpp:        oldInstruction->replaceAllUsesWith(newInstruction);
llvm-final-gc-lowering.cpp:        it = oldInstruction->eraseFromParent();
llvm-final-gc-lowering.cpp:            Value *callee = CI->getCalledOperand();
llvm-final-gc-lowering.cpp:                it = CI->eraseFromParent();
llvm-final-gc-lowering.cpp:                it = CI->eraseFromParent();
llvm-final-gc-lowering.cpp:    unwrap(PM)->add(createFinalLowerGCPass());
julia_flisp.boot:(*banner* ";  _\n; |_ _ _ |_ _ |  . _ _\n; | (-||||_(_)|__|_)|_)\n;-------------------|----------------------------------------------------------\n\n"
julia_flisp.boot:		      #fn("8000s0c0|v2;" [#.-])
julia_flisp.boot:	  *current-desugar-loc* #f *current-gensyms* () *depwarn-opt* 1
julia_flisp.boot:	  *gensy-counter* 1 *gensyms* () *in-expand* #f *interactive* #f
julia_flisp.boot:	  *scopewarn-opt* 1 *syntax-environment*
julia_flisp.boot:	  #table(check-identifier #fn(";000r1c0c1|L2c2c3c4|c5L4L2L3;" [if
julia_flisp.boot:  invalid-identifier? error string #634="invalid identifier name \"" #635="\""])  with-normal-context #fn("?000s0c0c1L1c2]L2c3^L2c4]L2c5^L2c6^L2c7^L2L6L1c8|3143;" [#fn(nconc)
julia_flisp.boot:  with-bindings range-colon-enabled space-sensitive where-enabled for-generator
julia_flisp.boot:  end-symbol whitespace-newline #fn(copy-list)])  case #fn("A000s1]\x8c6g6c0O2c130c2g7|L2L1c3c4L1c5c6g6g7q2}3232L3;" [#fn("8000r2}c0\x8250c0;}\x8540^;}C6=0c1|e2}31L3;}?6=0c3|e2}31L3;}N\x85>0c3|e2}M31L3;e4c5}326=0c6|c7}L2L3;c8|c7}L2L3;" [else
julia_flisp.boot:  eq? quote-value eqv? every #.symbol? memq quote memv] vals->cond)
julia_flisp.boot:  let time.now prog1 princ "Elapsed time: " - " seconds\n"])  parse-LtoR #fn("B000r3c0c1c2}|L2L2c3c4|L2L2L2c5g2c3L2c6c7|L2c1c8c9c:L2c3c2}|L2L5c4|L2L3L3c2L4L4;" [let
julia_flisp.boot:  loop ex t peek-token if begin take-token list quote call])  unless #fn("<000s1c0|^c1}KL4;" [if
julia_flisp.boot:  begin])  with-output-to #fn("<000s1c0c1L1c2|L2L1L1c3}3143;" [#fn(nconc)
julia_flisp.boot:							       with-bindings
julia_flisp.boot:							       *output-stream*
julia_flisp.boot:							       #fn(copy-list)])  cond #fn(":000s0]\x8c5g5c0g5q1O2g5M|41;" [#fn(">000r1|?640^;|Mg5Mc0<17802g5M]<6C0g5N\x8560g5M;c1g5NK;g5N\x85@0c2g5M~M|N31L3;g5\x84c3\x82\x980e4e5g531316c0e6e5g53131c7g6g5ML2L1c8g6c1e9e5g53131K~M|N31L4L3;c:30c7g6g5ML2L1c8g6e5g531g6L2~M|N31L4L3;c8g5Mc1g5NK~M|N31L4;" [else
julia_flisp.boot:  begin or => 1arg-lambda? caddr caadr let if cddr #fn(gensym)] cond-clauses->if)])  with-end-symbol #fn(";000s0c0c1L1c2]L2L1L1c3|3143;" [#fn(nconc)
julia_flisp.boot:  with-bindings end-symbol #fn(copy-list)])  ts:pbtok #fn("7000r1c0|b3L3;" [aref])  receive #fn("?000s2c0c1_}L3c2c1L1|L1c3g23133L3;" [call-with-values
julia_flisp.boot:  lambda #fn(nconc) #fn(copy-list)])  letrec #fn(">000s1c0c0c1L1c2c3|32L1c2c4|32c5}3134L1c2c6|3242;" [#fn(nconc)
julia_flisp.boot:  lambda #fn(map) #.car #fn("8000r1c0c1L1c2|3142;" [#fn(nconc) set! #fn(copy-list)])
julia_flisp.boot:  #fn(copy-list) #fn("5000r1e040;" [void])])  pattern-lambda #fn("@000r2]]\x8c6g6c0g6q1O2c1g6q1m72g7|31c2g8}L3c2c3L1c4c5|L2c3g9c5g8L2L5L3;" [#fn(":000r1|C16;02c0|c132@660|L1;|F6P0|Mc2\x8240_;e3c4c5~Me6|N3132Q241;_;" [#fn(memq)
julia_flisp.boot:  (_ ...) -/ delete-duplicates #fn(append)
julia_flisp.boot:  #fn(map) to-proper] patargs-) #fn("7000r1c0~M|31K;" [__] patargs) lambda
julia_flisp.boot:  __ex__ plambda-expansion quote])  let #fn(">000s1^|C6B0|m62}Mm02}Nm1530]2c0c1L1c2c3|32L1c4}3133c2c5|32g66C0c6g6g7L2L1g6L3540g7g8K;" [#fn(nconc)
julia_flisp.boot:  #fn(copy-list) #fn("5000r1|F650|\x84;e040;" [void]) letrec])  with-whitespace-newline #fn(";000s0c0c1L1c2]L2L1L1c3|3143;" [#fn(nconc)
julia_flisp.boot:  with-bindings whitespace-newline #fn(copy-list)])  ts:port #fn("7000r1c0|aL3;" [aref])  ts:last-tok #fn("7000r1c0|`L3;" [aref])  throw #fn("9000r2c0c1c2c3L2|}L4L2;" [raise
julia_flisp.boot:  list quote thrown-value])  assert #fn(";000r1c0|]c1c2c3|L2L2L2L4;" [if raise
julia_flisp.boot:  quote assert-failed])  unwind-protect #fn("A000r2c030c030c1g7c2_}L3L2L1c3c4|c2g6L1c5g7L1c6g6L2L3L3L3g7L1L3L3;" [#fn(gensym)
julia_flisp.boot:  let lambda prog1 trycatch begin raise])  with-bindings #fn("G000s1c0c1|32c0e2|32c0c3|32c4c5L1c0c6g8g633L1c7c0c8g6g73331c9c4c:L1c7}3132c4c:L1c7c0c;g6g8333132L3L144;" [#fn(map)
julia_flisp.boot:  #fn(nconc) let #.list #fn(copy-list) #fn("7000r2c0|}L3;" [set!])
julia_flisp.boot:  unwind-protect begin #fn("7000r2c0|}L3;" [set!])])  with-space-sensitive #fn(";000s0c0c1L1c2]L2c3^L2L2L1c4|3143;" [#fn(nconc)
julia_flisp.boot:  with-bindings space-sensitive whitespace-newline #fn(copy-list)])  ts:set-tok! #fn("8000r2c0|`}L4;" [aset!])  dotimes #fn("A000s1|M|\x84c0`c1g7aL3c2c3L1g6L1L1c4}3133L4;" [for
julia_flisp.boot:  - #fn(nconc) lambda #fn(copy-list)])  define-macro #fn(">000s1c0c1|ML2c2c3L1|NL1c4}3133L3;" [set-syntax!
julia_flisp.boot:  quote #fn(nconc) lambda #fn(copy-list)])  with-input-from #fn("<000s1c0c1L1c2|L2L1L1c3}3143;" [#fn(nconc)
julia_flisp.boot:  with-bindings *input-stream* #fn(copy-list)])  pattern-set #fn(";000s0]\x8c5g5c0O2e1c2|q1c3g5q142;" [#fn("5000r1|\x84M;" [] pl-head)
julia_flisp.boot:  call-with-values #fn("7000r0e0c1~42;" [separate #fn("7000r1|F16L02e0|b33216@02|Mc1<16602|\x84F;" [length=
julia_flisp.boot:  pattern-lambda])]) #fn("A000r2e0c1~M|3231c230c3c4L1g7c5L1L2L1L1c6c1c7g7~|q3g63231c8c9c:L2g7c3c;L1c6}3132L4L144;" [delete-duplicates
julia_flisp.boot:  #fn(map) #fn(gensym) #fn(nconc) let make-table #fn(copy-list)
julia_flisp.boot:  #fn(">000r1c0~c1|L2c2c3L1c4e5c6\x7f|q2i2323132L4;" [table-set! quote #fn(nconc)
julia_flisp.boot:						      list #fn(copy-list)
julia_flisp.boot:  vector quote pattern-set list])])  quasiquote #fn("7000r1e0|`42;" [bq-process])  begin0 #fn("<000s1c0c1L1|L1c2}3143;" [#fn(nconc)
julia_flisp.boot:  prog1 #fn(copy-list)])  let* #fn("@000s1|?6E0c0c1L1_L1c2}3133L1;c0c1L1e3|31L1L1c2|NF6H0c0c4L1|NL1c2}3133L1530}3133e5|31L2;" [#fn(nconc)
julia_flisp.boot:  lambda #fn(copy-list) caar let* cadar])  when #fn(";000s1c0|c1}K^L4;" [if
julia_flisp.boot:  trycatch lambda if and pair? eq? car quote thrown-value cadr caddr raise])  without-range-colon #fn(";000s0c0c1L1c2^L2L1L1c3|3143;" [#fn(nconc)
julia_flisp.boot:  with-bindings range-colon-enabled #fn(copy-list)])  parse-RtoL #fn("C000r5c0c1}|L2L2c2c3|L2L2L2c4g2c2L2c5c6|L2c4g3c7c2c1g4|L2L4c7c8c9L2c2c1g4|L2L5L4L3c1L4L3;" [let*
julia_flisp.boot:  ex t peek-token if begin take-token list quote call]))
julia_flisp.boot:	  1+ #fn("6000r1|aw;" [] 1+) 1-
julia_flisp.boot:	  #fn("6000r1|ax;" [] 1-) 1arg-lambda? #fn("7000r1|F16T02|Mc0<16J02|NF16B02|\x84F16:02e1|\x84a42;" [lambda
julia_flisp.boot:  length=] 1arg-lambda?)
julia_flisp.boot:	  <= #0=#fn("6000r2|}X17602|}W;" [] <=) =-to-kw
julia_flisp.boot:	  #fn("6000r1e0|31680c1|NK;|;" [assignment? kw] =-to-kw) > #2=#fn("6000r2}|X;" [] >)
julia_flisp.boot:	  #table(loadi8 50  loadg.l 54  loadt 45  brn.l 88  lvargc 75  box 92  boolean? 18  eq? 12  + 34  loada 55  brn 87  box.l 93  aset! 44  brt.l 10  seta.l 62  null? 17  ret 11  vector 42  loadv 51  cadr 84  builtin? 23  setg.l 60  apply 33  keyargs 91  trycatch 68  dup 1  aref 43  list 28  set-car! 31  seta 61  removed-setc.l 64  cons 27  brne 82  closure 65  dummy_nil 97  neg 73  loadc0 78  pop 2  pair? 22  brbound 90  loada1 77  / 37  loadc1 79  vargc 67  sub2 72  brf.l 9  function? 26  load1 49  call.l 80  symbol? 19  = 39  loada0 76  call 3  set-cdr! 32  compare 41  dummy_t 95  load0 48  atom? 15  tcall 4  equal? 14  car 29  loadc.l 58  eqv? 13  loada.l 56  for 69  loadf 46  tcall.l 81  removed-setc 63  dummy_f 96  brt 7  jmp 5  < 40  brf 6  tapply 70  loadnil 47  argc 66  not 16  add2 71  largc 74  cdr 30  brnn 85  brne.l 83  loadc 57  - 35  shift 94  * 36  nop 0  div0 38  loadv.l 52  optargs 89  vector? 24  brnn.l 86  loadg 53  fixnum? 25  number? 20  setg 59  bound? 21  jmp.l 8)
julia_flisp.boot:  #fn(for-each) #fn("8000r1c0~|]43;" [#fn(put!)])
julia_flisp.boot:	  SuffSet #fn("8000r1e0|31e1e2|32650g5;c3g5q1;" [Set every no-suffix?
julia_flisp.boot:							 #fn(#5="7000r1~e0|3141;" #6=[maybe-strip-op-suffix])] SuffSet)
julia_flisp.boot:	  #fn("6000r0e0c1<17B02e0c2<17802e0c3<6>0c4k52c6k75;0c8k52c9k72e:k;2e<k=2e>k?;" [*os-name*
julia_flisp.boot:  win32 win64 windows "\\" *directory-separator* "\r\n" *linefeed* "/" "\n"
julia_flisp.boot:  *stdout* *output-stream* *stdin* *input-stream* *stderr* *error-stream*] __init_globals)
julia_flisp.boot:					  #fn("6000r1e0|312c1a41;" [top-level-exception-handler
julia_flisp.boot:	  abstract-type-def-expr #fn("9000r3e0c1}q1c2|g2q242;" [call-with-values
julia_flisp.boot:								#fn("6000r0e0~41;" [sparam-name-bounds])
julia_flisp.boot:  global const scope-block #fn(nconc) local-def #fn(copy-list)
julia_flisp.boot:  #fn(map) #fn("6000r1c0|L2;" [local]) #fn("9000r2e0|e1}]3242;" [make-assignment
julia_flisp.boot:								 bounds-to-TypeVar])
julia_flisp.boot:  toplevel-only abstract_type = call core _abstracttype thismodule inert svec
julia_flisp.boot:  _setsuper! _typebody! if && isdefined outerref _equiv_typedef null])] abstract-type-def-expr)
julia_flisp.boot:	  accum-digits #fn(";000r4]\x8c8g8c0g3g2}g8q4O2g8M\x8e1_|42;" [#fn("9000r2~16702}c0=6m0e1\x7f312e2\x7f31c3g631@16902i2g6316;0i3M|g642;c4\x7fc0322e5e6|3141;c3}31@16802i2}316F0e1\x7f312i3M}|Ke2\x7f3142;e5e6|3141;" [#\_
julia_flisp.boot:  read-char peek-char #fn(eof-object?) #fn(io.ungetc) list->string reverse])] accum-digits)
julia_flisp.boot:	  add-box-inits-to-body #fn("<000r2c0e1e2|3132e3|31Me4}c5c0c6g7q1g632Q242;" [#fn(map)
julia_flisp.boot:  arg-name lam:args lam:vinfo insert-after-meta #fn(append)
julia_flisp.boot:  vinfo:asgn vinfo:capt = call core Box])] add-box-inits-to-body)
julia_flisp.boot:	  add-dots #fn("9000r1c0|c1c2|3242;" [#fn(append!)
julia_flisp.boot:  #fn(string) "."])] add-dots)
julia_flisp.boot:	  add-init #fn("8000r3|}\x8250g2;c0c1}|L3g2L3;" [block =] add-init)
julia_flisp.boot:	  add-line-number #fn("9000r2|F16802|Mc0<6D0c1c0L1}L1c2|N3143;c0}|L3;" [block
julia_flisp.boot:  #fn(nconc) #fn(copy-list)] add-line-number)
julia_flisp.boot:	  all-decl-vars #fn("8000r1e0|31640|;e1|31680e2|41;|F16802|Mc3<6>0c3c4e5|N32K;|;" [eventually-call?
julia_flisp.boot:  decl? decl-var tuple #fn(map) all-decl-vars] all-decl-vars)
julia_flisp.boot:	  all-local-names #fn("8000r1]\x8c5g5c0g5q1O2c1g5M|31v2;" [#fn(";000r1|6O0c0e1|31e2|31e3|31~Me4|313144;_;" [#fn(list*)
julia_flisp.boot:  scope:args scope:sp scope:locals scope:prev] all-lists)
julia_flisp.boot:								   #fn(append)] all-local-names)
julia_flisp.boot:	  all-methods-for #fn(":000r2e0|31e1c2g6q1}e3c444;" [method-expr-name
julia_flisp.boot:							     expr-find-all #fn("7000r1e0|b23216D02|Mc1<16:02e2|31~<;" [length>
julia_flisp.boot:  method method-expr-name]) identity #fn("6000r1|F16902|Mc0<@;" [lambda])] all-methods-for)
julia_flisp.boot:	  analyze-type-sig #fn(":000r1|e0c1g5c2c334\x8e117u02|e0c4g5c5c634\x8e117a02|e0c7g5c8c934\x8e117M02|e0c:g5c;c<34\x8e117902e=c>41;" [plambda-expansion
julia_flisp.boot:  (-- name (-s)) #fn("8000r2e0}_c143;" [values (core Any)]) (__ name)
julia_flisp.boot:  (curly (-- name (-s)) . params) #fn("8000r3e0}g2c143;" [values (core Any)])
julia_flisp.boot:  (__ name params) (<: (-- name (-s)) super)
julia_flisp.boot:  (<: (curly (-- name (-s)) . params) super)
julia_flisp.boot:  #fn("8000r4e0}g2g343;" [values]) (__ name params super) error "invalid type signature"] analyze-type-sig)
julia_flisp.boot:	  analyze-typevar #fn(":000r1]c0m52|?6<0g5|31^^L3;|Mc1\x8250|N;|Mc2<16:02e3|b6326k0g5e4|3131e5|31c6<16?02e5e7|3131c6<6>0|\x84e8|31L2580e9c:31K;|Mc6\x82A0g5|\x8431^e5|31L3;|Mc;\x82A0g5|\x8431e5|31^L3;e9c<41;" [#fn("9000r1|C640|;e0c1c2e3|31c43341;" [error
julia_flisp.boot:  #fn(string) "invalid type parameter name \"" deparse "\""] check-sym)
julia_flisp.boot:  var-bounds comparison length= cadddr caddr <: cddr last error "invalid bounds in \"where\""
julia_flisp.boot:  >: "invalid variable expression in \"where\""] analyze-typevar)
julia_flisp.boot:	  analyze-variables! #fn("9000r1e0|___342|;" [analyze-vars] analyze-variables!)
julia_flisp.boot:	  analyze-vars #fn("L000r4|?17802e0|316V0|C6M0e1|}32g86<0e2g8]32530]\x8e1530]2|;|Mg8c3=6A0e1|\x84}32e4g9]42;g8c5=6~0|\x84C16:02e1|\x84}32g96W0e6g9316<0e7g9^32590e7g9]322e8g9]32530]\x8e12e9e:|31}g2g344;g8c;=6Z0e1|\x84}32g96<0e<g9]32530]2c=c>}g2g3q3|N42;g8c?=6\x890e1|\x84}32g96{0e@g931cA>7C0eBcCcD|\x84cE3331530]2cF|\x84g2326C0eBcCcG|\x84cH3331530]2eIg9e:|3142;];g8cJ=6>0eK|}g2g3_45;g8cL=6V0|\x84McJ\x8260]580cMcN312eK|\x84}g2g3eO|3145;g8cP=6\xb20eQ|b2326j0e1eR|31}32g96W0e6g9316<0e7g9^32590e7g9]322e8g9]32530]2|;e9e:|31}g2g3342eS|31McJ\x8260]580cMcT312eKeS|31}g2g3eU|31e:|3146;cVg8cW32640|;c=cX}g2g3q3|N42;" [quoted?
julia_flisp.boot:  var-info-for vinfo:set-read! local-def vinfo:set-never-undef! = vinfo:asgn
julia_flisp.boot:  vinfo:set-sa! vinfo:set-asgn! analyze-vars caddr call vinfo:set-called! #fn(for-each)
julia_flisp.boot:  #fn("9000r1e0|~\x7fi244;" [analyze-vars]) decl vinfo:type (core Any) error #fn(string)
julia_flisp.boot:  vinfo:set-type! lambda analyze-vars-lambda with-static-parameters
julia_flisp.boot:  #fn(raise) (assert-failed (eq? (car (cadr e)) 'lambda)) cddr method length=
julia_flisp.boot:  method-expr-name cadddr (assert-failed (eq? (car (cadddr e)) 'lambda))
julia_flisp.boot:  method-expr-static-parameters #fn(memq) (module toplevel)
julia_flisp.boot:  #fn("9000r1e0|~\x7fi244;" [analyze-vars])] analyze-vars)
julia_flisp.boot:	  analyze-vars-lambda #fn("G000\x8950006000\x8a5000760^m52e0|31e1|31c2c3e4g:32g;32e5e6e7|3131g<32c2c3c8}q1g=32Q2c9e5g>g=32g=32\x8e1\x8e1g56;0e6g531530_e:e7|3131c2c3c;g:32c3e<g;3232e=c>g=g?g4g>q4g332c9e=c?g=g4g?q3}32c3e<gA3232e@e7|31c9g@e=cAg<g?q2}3232gBeBc9g4g33231342cCcDgB322eE|31g@gB`eBc9g4gA3231L4O2|;" [lam:args
julia_flisp.boot:  caddr #fn(nconc) #fn(map) arg-name diff free-vars lam:body #fn("8000r1e0|~32g56=0e1e2g53141;_;" [var-info-for
julia_flisp.boot:  free-vars vinfo:type]) #fn(append) find-global-decls #fn("7000r1e0e1|3141;" [make-var-info
julia_flisp.boot:  decl-var]) make-var-info filter #fn("7000r1c0|~3216G02c0|\x7f32@16;02c0|i232@17:02c0|i342;" [#fn(memq)])
julia_flisp.boot:  analyze-vars #fn("7000r1c0e1|31~32@16>02c0e1|31\x7f32@;" [#fn(memq)
julia_flisp.boot:  delete-duplicates #fn(for-each) #fn("7000r1e0|]42;" [vinfo:set-capt!]) cddr] analyze-vars-lambda)
julia_flisp.boot:	  any #fn("7000r2}F16D02|}M3117:02e0|}N42;" [any] any) apply-patterns
julia_flisp.boot:	  #fn(":000r2|H6n0}F6\\0e0e1|a32}M_33e2g6}32g7}\x82?0e2e1|b232}42;g7;e2e1|b232}42;|\x8540};|M}31g67:0e2|N}42;g6;" [table-ref
julia_flisp.boot:  vector-ref apply-patterns] apply-patterns)
julia_flisp.boot:	  arg-counts #table(#.equal? 2  #.atom? 1  #.set-cdr! 2  #.symbol? 1  #.car 1  #.eq? 2  #.aref 2  #.boolean? 1  #.not 1  #.null? 1  #.eqv? 2  #.number? 1  #.pair? 1  #.builtin? 1  #.aset! 3  #.div0 2  #.= 2  #.bound? 1  #.compare 2  #.vector? 1  #.cdr 1  #.set-car! 2  #.< 2  #.fixnum? 1  #.cons 2)
julia_flisp.boot:	  arg-name #fn("9000r1|C16802e0|31640|;|F780e1|41;|Mg5c2=6@0e3|\x84312e4|\x8441;g5c5=6I0|\x84C7;0e1|\x8431530]2e4|41;g5c6=6K0e7|]326<0e3e8|3141;e1|41;g5c9=690e3|\x8441;e1|41;" [valid-name?
julia_flisp.boot:  bad-formal-argument ... arg-name decl-var :: meta nospecialize-meta? caddr kw] arg-name)
julia_flisp.boot:	  arg-type #fn("9000r1|C650c0;|F780e1|41;|Mg5c2=6W0c3|31b3\x82B0c2e4|\x8431e5|31L3;c2e4|\x8431L2;g5c6=6I0|\x84C7;0e1|\x8431530]2e4|41;g5c7=6K0e8|]326<0e9e5|3141;e1|41;g5c:=690e9|\x8441;e1|41;" [(core
julia_flisp.boot:  Any) bad-formal-argument ... #fn(length) decl-type caddr :: meta
julia_flisp.boot:  nospecialize-meta? arg-type kw] arg-type)
julia_flisp.boot:	  argc-error #fn(";000r2e0c1|c2}}aW670c3540c445;" [error "compile error: "
julia_flisp.boot:							   " arguments."] argc-error)
julia_flisp.boot:	  arglist-to-tuple #fn("D000s4g4F16E02g3A16=02}@16602g2@6A0c0c1L1c2g43142;g2@16\xb002e3g3a3216\xa402g3MF16\x9b02e4g331c5<16\x8d02e6g3M31g916}02}@16G02c0c1L1c2g431c2g9313317]02g4A16U02g9A16M02e3g3Ma326=0c7c5L1L2560c1L1\x8e117\xb402g4A16I02g3A16A02g2@16902e8c93117\x9102e:g3F16E02g3MF16<02e4g331c5<6U0c0c7L1g3ML1c2g431c2c;e<g3N3231345L0c0c7L1c2g431c2c;e<g332313341;" [#fn(nconc)
julia_flisp.boot:  block #fn(copy-list) length= caar parameters parameters-to-block tuple error
julia_flisp.boot:  "unreachable" rm-linenums #fn(map) kw-to-=] arglist-to-tuple)
julia_flisp.boot:	  arglist-unshift #fn("9000r2|F16C02|MF16;02e0|31c1<6D0c2|ML1}L1c3|N3143;c2}L1c3|3142;" [caar
julia_flisp.boot:  parameters #fn(nconc) #fn(copy-list)] arglist-unshift)
julia_flisp.boot:	  assigned-name #fn("7000r1|?640|;c0|Mc13217B02|Mc2<16802e3|31690e4|\x8441;|;" [#fn(memq)
julia_flisp.boot:  (call curly where) :: eventually-call? assigned-name] assigned-name)
julia_flisp.boot:	  assignment-like? #fn("6000r1|F16902e0|M41;" [is-prec-assignment?] assignment-like?)
julia_flisp.boot:	  bad-formal-argument #fn(":000r1e0c1c2e3|31c2c43441;" [error #fn(string)
julia_flisp.boot:								#\" deparse " is not a valid function argument name"] bad-formal-argument)
julia_flisp.boot:	  begin-val #fn(";000r4g2\x85X0g316602}aW6>0c0c1c2L2|L3;c0c1c2L2|}L4;c3c0L1c1c4L2L1}c5g231xL1c6c7g23234c0c1c8L2c0c1c9L2|g8L4L3;" [call
julia_flisp.boot:  #fn(map) #fn("7000r1c0c1c2L2|L3;" [call top length]) first axes] begin-val)
julia_flisp.boot:	  block-form? #fn("7000r1c0|c132@@;" [#fn(memq)
julia_flisp.boot:	  bounds-to-TypeVar #fn("B000\x8910002000\x8a1000760^m12}670e0540e1|M31|\x84e2|31c3c4L1c5c6L2L1c7g6L2L1c8g86G0g76;0g7g8L2560g8L15A0g76;0g7c9L2530_3144;" [unmangled-name
julia_flisp.boot:  identity caddr #fn(nconc) call core TypeVar quote #fn(copy-list) (core Any)] bounds-to-TypeVar)
julia_flisp.boot:	  box-vars #fn("9000r2]\x8c6g6c0|g6q2O2g6M\x8e1}41;" [#fn("9000r1|F6Q0|M\x846B0e0~c1e2|M3133530]2\x7fM|N41;];" [emit
julia_flisp.boot:  box caddr])] box-vars)
julia_flisp.boot:	  bq-bracket #fn(";000r2|?6=0c0e1|}32L2;|Mc2\x82R0}`W680c0|NK;c0c3c4e1|N}ax32L3L2;|Mc5\x82S0}`W690c6|\x84L2;c0c0c7e1|\x84}ax32L3L2;|Mc8\x82O0}`W650|\x84;c0c0c9e1|\x84}ax32L3L2;c0e1|}32L2;" [#.list
julia_flisp.boot:  bq-process unquote #.cons 'unquote unquote-splicing copy-list 'unquote-splicing
julia_flisp.boot:  unquote-nsplicing 'unquote-nsplicing] bq-bracket)
julia_flisp.boot:	  bq-bracket1 #fn(":000r2|F16802|Mc0<6K0}`W650|\x84;c1c2e3|N}ax32L3;e3|}42;" [unquote
julia_flisp.boot:  #.cons 'unquote bq-process] bq-bracket1)
julia_flisp.boot:	  bq-expand-arglist #fn("9000r2]\x8c6g6c0}g6q2O2g6M\x8e1|_42;" [#fn(":000r2|\x8580e0}41;e1|M~32g6F16902g6Me2<6A0\x7fM|Ne3g6N}3242;\x7fM|Ng6}K42;" [reverse!
julia_flisp.boot:  julia-bq-expand- splat-token revappend])] bq-expand-arglist)
julia_flisp.boot:	  bq-process #fn("<000r2|C680c0|L2;|H6T0e1e2|31}32g6Mc3\x8290c4g6NK;c5c4g6L3;|?640|;|Mc6\x82B0c3c7e1|\x84}aw32L3;|Mc8\x82W0}`W16:02e9|b232650|\x84;c:c;e1|N}ax32L3;e<e=|327t0e>|31c?c@}q1|32g6\x8580c3g7K;g7N\x85A0c:g7Me1g6}32L3;cAcBg7Ke1g6}32L142;]\x8c6g6cC}g6q2O2g6M\x8e1|_42;" [quote
julia_flisp.boot:  bq-process vector->list #.list #.vector #.apply quasiquote 'quasiquote
julia_flisp.boot:  unquote length= #.cons 'unquote any splice-form? lastcdr #fn(map)
julia_flisp.boot:  #fn("7000r1e0|~42;" [bq-bracket1]) #fn(nconc)
julia_flisp.boot:  reverse! unquote nreconc #.list 'unquote bq-process bq-bracket])] bq-process)
julia_flisp.boot:	  builtin->instruction #fn("8000r1c0~|^43;" [#fn(get)] [#table(#.equal? equal?  #.* *  #.car car  #.apply apply  #.aref aref  #.- -  #.boolean? boolean?  #.builtin? builtin?  #.null? null?  #.eqv? eqv?  #.function? function?  #.bound? bound?  #.cdr cdr  #.list list  #.set-car! set-car!  #.cons cons  #.atom? atom?  #.set-cdr! set-cdr!  #.symbol? symbol?  #.eq? eq?  #.vector vector  #.not not  #.pair? pair?  #.number? number?  #.div0 div0  #.aset! aset!  #.+ +  #.= =  #.compare compare  #.vector? vector?  #./ /  #.< <  #.fixnum? fixnum?)])
julia_flisp.boot:	  call-with-values #fn("7000r2|30g6F16802~g6M<690}g6Nv2;}g641;" [] [#648=(*values*)])
julia_flisp.boot:	  called-macro-name #fn("7000r1e0|b33216Q02|Mc1<16G02e2|31F16<02e2|31Mc3<6=0e4e2|31\x8441;|;" [length=
julia_flisp.boot:  |.| caddr quote called-macro-name] called-macro-name)
julia_flisp.boot:	  capt-var-access #fn(":000r3g26E0c0c1c2L2}c3g2|32L4;c0c1c2L2}c4|L2L4;" [call
julia_flisp.boot:  core getfield #fn(get) inert] capt-var-access)
julia_flisp.boot:	  capture-var! #fn("<000r2e0|31e1}g6`33g717G02c2g631|b3c3g6}L132\\2;" [bcode:cenv
julia_flisp.boot:  index-of #fn(length) #fn(append!)] capture-var!)
julia_flisp.boot:	  #fn("5000r1|NNN;" [] cdddr) cddr #fn("5000r1|NN;" [] cddr) char-bin?
julia_flisp.boot:				      #\1] char-bin?)
julia_flisp.boot:	  char-hex? #fn("7000r1e0|3117^02e1|c23216:02e3|c43217F02e1|c53216:02e3|c642;" [char-numeric?
julia_flisp.boot:  >= #\a <= #\f #\A #\F] char-hex?)
julia_flisp.boot:	  char-numeric? #fn("7000r1c0c1|32@@;" [#fn(string.find) "0123456789"] char-numeric?)
julia_flisp.boot:	  char-oct? #fn("7000r1e0|c13216:02e2|c342;" [>= #\0 <= #\7] char-oct?)
julia_flisp.boot:	  #fn("6000r1c0|31c1<;" [#fn(typeof) wchar] char?) check-dotop #fn("9000r1e0|316F0e1c2c3e4|31c533315`0|F6Z0|Mc6\x82>0e7e8|31315D0e9|316;0e7|\x8431530]530]2|;" [dotop-named?
julia_flisp.boot:  error #fn(string) "invalid function name \"" deparse "\"" |.| check-dotop
julia_flisp.boot:  caddr quoted?] check-dotop)
julia_flisp.boot:	  check-kw-args #fn(":000r1e0c1|32g5F6b0g5MF16<02c2e3g531<690e4c541;e4c6c7e8g5M31c93341;];" [filter
julia_flisp.boot:  vararg? nospecialize-meta? caddr]) parameters caar error "more than one semicolon in argument list"
julia_flisp.boot:  #fn(string) "invalid keyword argument syntax \"" deparse "\""] check-kw-args)
julia_flisp.boot:	  check-no-return #fn("6000r1e0|31690e1c241;];" [has-return? error "\"return\" not allowed inside comprehension or generator"] check-no-return)
julia_flisp.boot:	  check-valid-name #fn("9000r1e0|3117@02e1c2c3|c43341;" [valid-name?
julia_flisp.boot:								 "\""] check-valid-name)
julia_flisp.boot:	  cl-convert #fn("\x83000r8g2@16C02|F16;02c0|Mc132@6P0|?640|;|Me2|N}g2g3g4g5g6g738K;|C6\xf00c3g2q1k42c5|}g2g3g4g5g6g7q8k62c7|e8g231M32c7|e8g231\x8432|}\x8240|;c0|e9g23132640|;g=6u0g66D0c:c;c<c=L2|L3L25:0e>|}g733e?g=3116902e@g=316?0e6g>eAg=3142;g>;g<6T0e?g<3116902e@g<316>0e6|eAg<3142;|;|;|?640|;|Mc0g<cB32640|;g<cC=6L0|\x84cD\x82A0cEg4eF|31]33530]2|;g<cG=6Z0|\x84eHeF|31}g2g3g4g5g6g738eIg=g>}g2g6g746;g<cJ=6n0c7|\x84e8g231M32g=16D02e?g=3116902e@g=316C0cG|\x84c;c<cKL2L2L3;cL;g<cM=6~0c7|\x84e8g231M32g=16D02e?g=3116902e@g=316C0cG|\x84c;c<cKL2L2L3;eNg=31650cL;cO|\x84L2;g<cP=640|;g<cQ=640|;g<cR=6G0eS|\x84g232650cL;cP|\x84L2;g<cT=6\xf70|\x84g=C16@02c7g=e8g231M32g=C16@02c7g=e8g231\x8432g=}\x8240|;c0g=e9g23132640|;g?6}0e?g?3116902e@g?316f0g66E0c:c;c<c=L2g=L3L25;0e>g=}g733c;c<cTL2g@cUcVL2L4;cW;g>6[0e?g>3116902e@g>316E0c;c<cTL2g=cUcVL2L4;|;|;g<cX=6\xbb0eF|31eY|31eZ|31e[|31e8g@31c\\c]gA\x8432e^g@312c\\c_g2}g7q3gB32c`caL1|\x84L1g=L1c;c<cbL2ccL3L1c<cdL2L1cecfL1g>g?egg@ehg@31M^_eigB3135L5L1cjgC3147;g<ck=6\x1a4el|31em|b232g>660^570eY|31g>670cn580e8g?31c\\c]g@\x8432cog2q1ep|\x8431@16902gBg=31g>@16802eF|31g>17:02gDMcq<@660_5J0e2ergDN31}g2g3g4g5g6g738gD16F02gDMcq\x82;0e[gD31540gDgC6p0c0g=ehg231326A0esctcug=3231530]2cvctg=31`32cw=6;0escx31530]530]2g?6;0e^g?31530]2gC7A1g>6g0cyg4|\x8432640|;cEg4|\x84]332cz|c{c|___`_L4cqc}|L2L2L4L2L3;gA\x85\xa20c`cqL1cjgE31ck|\x84eHe~gFg332}g2g3g4g5g6g738e\x7fg?eHeYg?31c\x80g?c\x8130c\x8130^g6g73832c|g?\x84c`e\x82g@M31L1cjg@N3132gML4\x8e1L4L143;e\x83egg?c\x84]_^3531gGNe\x85e\x86gGM31c\x87`33c`czL1c`cqL1cjgE31ckg=eHgF}g2g3g4g5g6g738e\x88gI31L4L133L1cjgH3143;c\x89g4g=^33c\x89g3g=^3317b02g=16[02c\x8actcvctg=31`32c\x8bW670c\x8c540c\x8dg=c\x8de\x8e303431e\x8fc\x90|g=q2e\x91g231e\x92c\x9334g=16=02cEg3g=gH332e\x94c\x95gAc\\c\x96gI32Q331e\x94c\x95g?6;0e9g?31530_c\\c\x97gI32Q331e\x98e\x99gJgK3231e\x9agJgL32g?6S0e\x94e\x8fc\x9bg=gLg2gB|g3q6eF|31e\x923331530_c\x9cg=gLg2q3e\x98e\x94c\x95g?6:0gO|31530_c\\gOgI32Q33131c\x95gLgP32c\\c\x9dgQ32c\\c\x9eg2q1gM32c\x95gRe\x9fe\xa0gS3232c\x95gQe\x9fc\xa1g2q1gM3232gT\x85?0e\xa2gHgMc\xa3335B0e\xa4gHgTgUgMgSc\xa336\x8e1\x8e1\x8e1g>660_5\xa90e\xa5c\xa6gF32c\\c\xa7gQgR33e\xa8e\xa9gFgHgTg3gR35gU32c\x95c\\c\xaagRgQ33ck^eHgV}g2g3g4g5g6g738egg?gT6?0eFehg?3131590ehg?31M^gQ^35L4L132\x8e1\x8e1\x8e1c\\c\xabg2g6}g7q4gM32c\x95gQe\x9fe\x92c\\c\xacg2q1gMgU333232c`c\xadL1gV\x8570gH5L0c`c;L1c<cbL2L1gHL1cjgV3134L1cjgU3133\x8e1\x8e1gNF6M0e8g231e\x9fc\xaegNq1e8g231M32O530]2gG17=02g>16602gIF6M0c`czL1cfL1L1cjgE31cjgT3144;cEg4g=]332c`czL1eIg=gU}g2g6g736L1cjgS31cjc\\c\xafgN3231cjgE31cjgT3146;g<c|=6\xa10c\xb0c\xb1e\xb2e8|31Mc\xb3eh|313132322e2e\x91|31Nc\x80e\xb4|31c\x8130c\x8130|\x84Ag6g738c||\x84c`e\x82e8|31M31L1_L1cje\xb5e8|31313133c`cqL1cjg=3132L4;g<c\xb6=6Z0eHc`c;L1c<c\xb7L2L1cj|N3133}g2g3g4g5g6g748;g<c\xb8=6\x960|\x84C16;02eS|\x84g232650cL;|\x84C17C02|\x84F16;02e\xb9|31c\xba<6;0esc\xbb31530]2eHc`c;L1c<c\xb7L2L1cj|N3133}g2g3g4g5g6g748;g<c\xbc=6F0eH|\x84}g2g3g4g5g6g748;|Me2|N}g2g3g4g5g6g738K;" [#fn(memq)
julia_flisp.boot:  (lambda method macro opaque_closure) map-cl-convert #fn(";000r1e0|31e1~31c2e1~31Mg5c3bPL3L132O2g5;" [named-gensy
julia_flisp.boot:  lam:vinfo #fn(append) Any] new-undef-var) new-undef-var #fn("G000r2|C660|560e030c1c2c3L2g6c4c5L2L4e6~31c7g7c8L1c9c:g8L2g8L3L4c1c2c;L2g6c4c5L2L4}c<>670g:5P0c1c2c=L2g:e>}\x7fi2i3i4i5i6i738L4c?c9L1c@|g6\x8260_5;0cAg6|L3L131g9L1g;L144;" [make-ssavalue
julia_flisp.boot:  call core isdefined inert contents new-undef-var if null block newvar
julia_flisp.boot:  getfield (core Any) typeassert cl-convert #fn(nconc)
julia_flisp.boot:  #fn(copy-list) =] get-box-contents) get-box-contents #fn(assq) lam:vinfo
julia_flisp.boot:  lam:sp $ call core QuoteNode capt-var-access vinfo:asgn vinfo:capt vinfo:type
julia_flisp.boot:   toplevel null true false meta) toplevel-only struct #fn(put!) caddr =
julia_flisp.boot:  cl-convert convert-assignment local-def Box (null) local vinfo:never-undef
julia_flisp.boot:  newvar const atomic const-if-global local-in? isdefined inert contents (true)
julia_flisp.boot:  _opaque_closure cadddr caddddr last #fn(map) #.car prepare-lambda! #fn("9000r1c0|e1~31\x8432g56;0e2|\x7fi243;|;" [#fn(assq)
julia_flisp.boot:  lam:vinfo capt-var-access]) #fn(nconc) new_opaque_closure apply_type Union
julia_flisp.boot:  Any opaque_closure_method null convert-lambda lam:args symbol-to-idx-map #fn(copy-list)
julia_flisp.boot:  method method-expr-name length= (() () ())
julia_flisp.boot:  #fn("7000r1~16@02|C16902e0|~42;" [local-in?]) outerref? block butlast error
julia_flisp.boot:  #fn(has?) toplevel-butfirst thunk lambda return rename-sig-types
julia_flisp.boot:  add-box-inits-to-body anon #fn(table) clear-capture-bits lift-toplevel |#anon|
julia_flisp.boot:  compact-and-renumber linearize none julia-bq-macro #fn(get)
julia_flisp.boot:  #fn(symbol) #\# "" "#" current-julia-module-counter expr-find-all #fn("7000r1e0|b23216M02|Mc1<16C02|~<@16:02e2|31\x7f<;" [length>
julia_flisp.boot:  method method-expr-name]) lam:body identity #fn("6000r1|F16902|Mc0<@;" [lambda])
julia_flisp.boot:  delete-duplicates #fn(append) #fn("9000r1c0c1e2e3|3131\x8442;" [#fn(map) #.car
julia_flisp.boot:  #fn("7000r1e0e1|3141;" [lam:sp cadddr]) simple-sort intersect diff #fn("9000r1|C16\xaa02~|<@16\xa102c0|\x7f32@16\x9502e1e2i231`3216802i3|316{0e3c4|q1e5i231c6i4q13317C02e3c7|q1e8i43132@6L0c9i5|32640^;e:c;c<|c=3341;];^;" [#fn(memq)
julia_flisp.boot:  length> lam:args expr-contains-p #fn("6000r1|~<;" []) lam:body #fn("7000r1|e0~31<17?02|F16802|Mc1<@;" [caddr
julia_flisp.boot:  #fn("9000r1e0c1~\x7fi2q3e2|31e343;" [expr-find-all #fn("8000r1|C16S02~|<@16J02c0|\x7f32@16>02c0|e1i23142;" [#fn(memq)
julia_flisp.boot:  lam:sp]) caddr identity]) #fn("5000r1e040;" [make-ssavalue])
julia_flisp.boot:  #fn("7000r1e0|~32650c1;e240;" [is-var-boxed? (core Box) make-ssavalue])
julia_flisp.boot:  filter ssavalue? #fn("7000r1e0|~32@;" [is-var-boxed?]) type-for-closure (core
julia_flisp.boot:  Function) type-for-closure-parameterized contains #fn("6000r1|c0<;" [kwftype])
julia_flisp.boot:  #.cons replace-vars fix-function-arg-type
julia_flisp.boot:  #fn(";000r2e0|c1c2c3L2c4}L2c2c5L2L442;" [make-assignment call core TypeVar
julia_flisp.boot:  lam:vinfo $ call core QuoteNode capt-var-access])
julia_flisp.boot:  #fn("7000r2e0|~32640^;c1c2c3L2}L3;" [is-var-boxed? call core typeof]) new #fn("7000r1c0|M~32@;" [#fn(memq)])
julia_flisp.boot:  #fn("6000r1c0|L2;" [moved-local]) #fn(for-each)
julia_flisp.boot:  #fn("7000r1e0|]42;" [vinfo:set-asgn!]) list-tail #fn(length)
julia_flisp.boot:  lambda-optimize-vars! cddr :: typeassert decl caadr outerref "type declarations on global variables are not yet supported"
julia_flisp.boot:  with-static-parameters] cl-convert)
julia_flisp.boot:	  clear-capture-bits #fn("7000r1c0e1|42;" [#fn(map) vinfo:not-capt] clear-capture-bits)
julia_flisp.boot:	  clear-profiles #fn("8000r0c0c1~q1e2~3142;" [#fn(for-each)
julia_flisp.boot:	  closing-token? #fn("6000r1|c0<16602e1@17A02~|3117802c2|41;" [end
julia_flisp.boot:  end-symbol #fn(eof-object?)] [#fn(#3# #4# [#table(#\] #t  #\; #t  #\) #t  #\, #t  else #t  elseif #t  catch #t  finally #t  #\} #t)])])
julia_flisp.boot:	  closure-convert #fn("=000r1e0|^^^^^^^48;" [cl-convert] closure-convert)
julia_flisp.boot:	  closure? #fn("6000r1|J16602|G@;" [] closure?) comp-accum
julia_flisp.boot:	  #fn(";000r4]\x8c8g8c0g2g3g8}q4O2g8M\x8e1|_42;" [#fn(";000r2~|31660}|K;\x7f|31i2Mg6N}\x8580g6M5:0i3}g6M3242;" [])] comp-accum)
julia_flisp.boot:	  compact-and-renumber #fn(";000r3|?640|;|Mc0\x82N0e1||\x84\x8560}540c2|\x84\x8570g2530`43;|Mc3c4}g2q2|N32K;" [lambda
julia_flisp.boot:  renumber-lambda none #fn(map) #fn("8000r1e0|~\x7f43;" [compact-and-renumber])] compact-and-renumber)
julia_flisp.boot:	  compact-ir #fn("O000r4c0c1c1c230c230]`g2g3_a\x8c8\x8c9\x8c:\x8c=\x8c>\x8c?\x8c@\x8cA\x8cB]\x8cCgCc3g:}g2g3g>g=g8gBg9q9O2]\x8cDgDc4gCg@g:g?gA}g>g=g;gBg<gDq<O2gDM\x8e1|N312e5g8M31e5g9M31e5g:M31g<g;Z5;" [(block)
julia_flisp.boot:  make-lineinfo #fn(memq) (meta inbounds gc_preserve_begin gc_preserve_end
julia_flisp.boot:  length= set-lineno! cddr caddr make-lineinfo caar #fn(length) length> meta
julia_flisp.boot:  reverse] compact-ir)
julia_flisp.boot:	  compare-num-strings #fn("9000r2e0|31e0}31e1g631e1g731W680g6g7Y;e1g631e1g731Y;" [strip-leading-0s
julia_flisp.boot:  string-length] compare-num-strings)
julia_flisp.boot:	  compare-one #fn("A000r1e0|31g5F16902e1|31F690e230540g5e3|\x8431@16X02e4|b53216L02e5|N31F16@02e3e5e6|3131316\x860e230c7c8L1c9g5g6\x8260_5<0c:g6g5L3L131c:g7e5|N31L3L1c;|\x84|Mg6L4L134c<g6e5|31g7e=|N3134K;e>g5g6c;|\x84|Mg6L433g6e1|31KK;" [caddr
julia_flisp.boot:  cdddr make-ssavalue dotop-named? length> cadddr cddr #fn(nconc) block #fn(copy-list)
julia_flisp.boot:  = call #fn(list*) cddddr add-init] compare-one)
julia_flisp.boot:	  compile #fn("8000r1e0_e1|3142;" [compile-f lower-define] compile)
julia_flisp.boot:	  compile-and #fn(";000r4e0|}g2g3]c146;" [compile-short-circuit brf] compile-and)
julia_flisp.boot:	  compile-app #fn("E000r4g3Mg8C16Z02e0g8}32@16M02g8E16E02c1g83116:02c2g831G6;0c2g831540g8e3g3Nc4326i0e5|}^g9342e6|a322e7|}g3N33e6|g:y322e8|g2670c9540c:g:43;g9G16902e;g931g9c<<16V02e0g9}32@16I02c2c<31e<>16;02e=g3b2326E0e5|}^g3\x84342e8|c<42;g9F16D02g9Mc><16902e?g3316=0e@|}g2g344;g:7E0e5|}^g9342e6|a32530]2e7|}g3N33e6|g;y322g:7<0e6|b/32530]2g:6C0eA|}g2g3g9g:g;47;e8|g2670cB540cCg;43;" [in-env?
julia_flisp.boot:  #fn(constant?) #fn(top-level-value) length> 255 compile-in bcode:stack
julia_flisp.boot:  compile-arglist emit tcall.l call.l builtin->instruction cadr length= lambda
julia_flisp.boot:  inlineable? compile-let compile-builtin-call tcall call] compile-app)
julia_flisp.boot:	  compile-arglist #fn("8000r3c0c1|}q2g2322c2g241;" [#fn(for-each)
julia_flisp.boot:							    #fn("9000r1e0~\x7f^|342e1~a42;" [compile-in
julia_flisp.boot:  bcode:stack]) #fn(length)] compile-arglist)
julia_flisp.boot:	  compile-begin #fn("9000r4g3?6?0e0|}g2e13044;g3N?6>0e0|}g2g3M44;e0|}^g3M342e2|c3322e4|}g2g3N44;" [compile-in
julia_flisp.boot:  void emit pop compile-begin] compile-begin)
julia_flisp.boot:	  compile-body #fn("o000r3_^]^^^^`c030c030^_`_\x8c7\x8c8\x8c9\x8c:\x8c;\x8c<\x8c=\x8c>\x8cA\x8cB\x8cC\x8cD]]]]]]]]]]]]]]]\x8cE\x8cF\x8cG\x8cH\x8cI\x8cJ\x8cK\x8cL\x8cM\x8cN\x8cO\x8cP\x8cQ\x8cR\x8cSgEc1g7q1O2gFc2g>q1O2gGc3gEq1O2gHc4g7gFgGq3O2gIc5gAgEgJgDgCq5O2gJc6O2gKc7g;gSgDgEgJgCgAgMgIq9O2gLc8gAgIgJgDgEgCq6O2gMc9g2q1O2gNc:g2q1O2gOc;gSg2gEq3O2gPc<gSgEq2O2gQc=gSgEgPgHq4O2gRc>gEq1O2gSc?g=g:gKgEgOgSgRg8g2g7gQgMgHgFgGgPgCgDgLg@g?gBgAgIg<gNg9g;qLO2c@cAg=gMq2eB}cCeDg2313132322gSM|_]]342c@cEg@gJq2gBM322g<M6F0eFcGcHeIg<M313231530]2eJg7M31eKgT}32cLeMcNgUq1gT32Kg=M6C0eOgVcPcQ_g=M3342;gV;" [#fn(table)
julia_flisp.boot:  #fn("7000r1~|~MKO2|;" [] emit) #fn("8000r0~M~a~MwO2;" [] make-label)
julia_flisp.boot:  #fn("7000r1~Mc0|L241;" [label] mark-label)
julia_flisp.boot:  label] make&mark-label) #fn("A000\x8910002000\x8a1000760]m12e0~M31g6\x8560a5:0ae1g631we2~M31g7|Kg6KO2\x7fMc3~MMg7L3312}6}0~M\x84e4~M31e5~M31i2Mi3Mg:32g;6;0\x7fMg;31530]\x8e12\x7fMc6ai4Mg9xwL2312\x7fMc7g8L231\x8e3530]2g7;" [caddr
julia_flisp.boot:  caar cddr = cadddr caddddr leave goto] enter-finally-block)
julia_flisp.boot:  "Attempt to jump into catch block"]) pop_exception] pop-exc-expr)
julia_flisp.boot:  #fn("=000r1]c0~\x7fi2i3i4q5m52|6\xc80e1i5M`326\xb70e2|3116B02e3|31@17702i6M@660^5D0i6M6:0i7M30560e430g66A0i3Mc5g6|L331530]2i6M6F0i8Mc6g617402|L2315K0i3Mc7i5ML2312g5g617402|312g617402|;g5|41;];" [#fn("?000r1~M6C0\x7fMe0|~M32_]^34530|i2M\x8570e1540e2g531660^560e330g66B0i3Mc4g6g5L331530]2i4Mi2M_32g76<0i3Mg731530]\x8e12i3Mc5g617502g5L241;" [convert-for-type-decl
julia_flisp.boot:  valid-ir-return? simple-atom? make-ssavalue = return] actually-return) >
julia_flisp.boot:  simple-atom? ssavalue? make-ssavalue = return leave] emit-return)
julia_flisp.boot:  cadddr > break leave goto] emit-break) #fn(">000s0|\x8590e030580e1|M31e2~31c3e2~31Mg5c4b2L3L132O2g5;" [gensy
julia_flisp.boot:  named-gensy lam:vinfo #fn(append) Any] new-mutable-var)
julia_flisp.boot:  method "method definition" #fn(string) "\""] head-to-text) error #fn(string)
julia_flisp.boot:						    " expression not at top level"] check-top-level)
julia_flisp.boot:  #fn(">000r2|\x8540_;e0c1|32]\x8c7g7c2~}g7g6\x7fi2q6O2g7M\x8e1|_42;" [every #fn("7000r1e0|3117I02|C17B02|F16;02c1|Mc242;" [simple-atom?
julia_flisp.boot:  (null) simple-atom? #fn(memq) (quote inert top core globalref outerref
julia_flisp.boot:				       boundscheck) lam:args make-ssavalue =])] compile-args)
julia_flisp.boot:								  valid-ir-argument?
julia_flisp.boot:								  make-ssavalue
julia_flisp.boot:								  =] compile-cond)
julia_flisp.boot:  length> butlast last |\|\|| goto _ #fn(for-each)
julia_flisp.boot:  gotoifnot #fn(map) #fn("9000r1~Mc0\x7fM|i232i3L341;" [gotoifnot]) &&] emit-cond)
julia_flisp.boot:  #fn(":000r2}6h0e0|}326?0~Mc1|}L3315O0e230~Mc1g6}L3312~Mc1|g6L331\x8e1530]2^;" [valid-ir-rvalue?
julia_flisp.boot:  = make-ssavalue] emit-assignment) #fn("\x93000r4|F@17;02c0|Mc1326\xf10~M16502|C6=0c2~M||33530|g216^02c3|3117T02|F16M02|Mc4<17802|Mc5<16902c3|\x84316E0e6c7c8e9\x7fM313231530]2g36:0i2Mg841;g2650g8;g8C6<0i3Mg8312^;g8F16902g8Mc4<6<0i3Mg8312^;g8F16902g8Mc5<6<0i3Mg8312^;^;|Mc0g8c:326r1c;k<2|Mc=\x82k0c>e<|\x84316?0i4M|\x84L1}32560|\x84L1e?e@|31b432i4MeA|b632}32335\x0b0|McB\x82P0i4MeC|31L1}32M|\x84g9eD|31KK\x8e15\xe60|McE\x82\x800eA|Nb432MeFg931eGg:31c>i4Me?|Nb432}32c>eHg931g;L132L1i4MeA|Nb532}3233\x8e1\x8e1\x8e15\x910eI|b23216B02|\x84cJ<17802|\x84cK>6k0c>|\x84L1e<eC|31316B0i4MeC|31L1}32590eC|31L1i4MeD|31}32335:0i4M|N}32|Mg9Kg36:0i2Mg:41;g2650g:;i3Mg:41;g8cL=6\xf50|\x84g9C16902c3g9316B0i5MeC|31}g2g344;i5MeC|31}]^34~M16602g9C6?0c2~Mg9g933540g9g216502g:6\x930g:?17D02eMg:3117902g:McN<670g:560eO30g<g:<7B0i3McLg<g:L331530]2i3McLg;g<L3312g36<0i2Mg<31530]2g<;i6Mg;g:42;g8cP=6l1i7MeQ|31eI|a3216F02eRg:3116;02eIg:b2326;0eCg:31550i7Mg;g9<@g<16C02g916<02|eSi831<@g<6:0i7g;O530]2g=6B0i3McTcUg;L331530]2]\x8c>g>cVi5}g2g3g>q5O2g>M\x8e1|N31g=6\xc00g3@17V02i9MMF16L02eWi9M31cT<17=02eWi9M31cX<6<0i3McY315\x850i9MMi9MNi9g@O2eZg?316]0eO30i3McLgAg?\x84L3312i3McY312i3Mc[gAL231\x8e15A0i3McY312i3Mg?31\x8e2530]2g<6:0i7g9O530]2;g8c[=6?0i5M|\x84}]]342^;g8c\\=6F0g26?0i5M|\x84}g2g344;^;c0g8c]326\x0e0i:M|\x84}c^33c_c^L2g216602g3@6:0i;M30530^i5MeC|31}g2g334g;6>0i6Mg;g<32530]2g3@16A02eI|b33217502g;6<0i3Mg:31530]2i<M30c`cag=q1g932\x8e12eI|b3326D0i5Meb|31}g2g334540ccg;6>0i6Mg;g=32530]2g37>0g:Ni<M30O5G0ed|b3326<0i2Mg=31530]2g;;g8ce=6\x810i=M30i<M30i:M|\x84}g9332i5MeC|31}^^342i3Mc_g:L2312i>Mg931\x8e1\x8e12g26?0i5Mcc}g2g344;];g8cf=6\x8e0i=M30i<M30i5M|\x84}^^342i?MeC|31}32i3Mcgg;g9L331\x8e12i3Mc_g:L2312i>Mg931\x8e1\x8e12g26?0i5Mcc}g2g344;];g8ch=6p0i=M30i5MeC|31|\x84g9i@MiAML4}K^^342i>Mg931\x8e12g26?0i5Mcc}g2g344;];g8ci=6M0cj|\x84}32g9790e6ck41;iBMg941;c0g8cl326\xaf0|Mcm\x82a0cniC|\x84326C0e6c7co|\x84cp33315B0cqiC|\x84i@MiAML233530]2c2iD|\x84^33g96@0i3Mcrg9L2315?0cqiD|\x84i<M30332g36:0i2Mcc41;g2690e6cs41;];g8ct=6\x830c2iD|\x84^33g917G02i=M30cqiD|\x84g:332g:\x8e1i3McNL1312i3Mc_g:L2312iEi9Mi@MiAM|\x84L4iEMKO2^;c0g8cu326\xe01eO30i=M30i=M30iFM|Mcv\x82:0i;M30530^^i3McLg9cwg:L2L3312i@i@MawO2g=6X0g=g;_i@MiAML5m>2iFg>O2i3McLg=b/L331530]2i5M|\x84}g2^34g216602g3@6:0i;M30530^g@16502g?6>0i6Mg@g?32530]2g36R0g?6<0i2Mg?31530]2g=780^m;530]5E0i3Mcx312i3Mc_g;L2312i@i@MaxO2i>Mg:312i3McyaL2312g=6\x820iGMcz^322i>Mg;312iFg<O2i5MeC|31}^^342]\x8cAgAc{g3i=i3g=i2iBi>gAq8O2gAM\x8e1eCg>31315\x8d0iAg9iAMKO2i5MeC|31}g2g334g@6>0i6Mg@gA32530]2g37@0i3Mc|g9L231530]2g;6<0i>Mg;31530]\x8e12iAiAMNO2g@;g8c}=6`0i9MF16902i9MM|>@16@02cj|\x84e~i831M32690i3M|41;^;g8c\x7f=6I0g26;0e6c\x8031530]2i3M|41;g8c\x81=640^;g8c\x82=640^;g8c\x83=6Q0e~i831c>e~i831M|\x84c\x84b2L3L132O2^;g8c\x85=6j0e\x86|\x84i8326C0e6c7c\x87e9\x7fM313241;i8\x84F6@0iHM780iH\x7fMO;];i3M|41;g8c\x88=690e6c\x8941;g8c\x8a=6@0g3690i2M|41;|;g8c\x8b=6@0g3690i2M|41;|;g8c\x8c=6\x0e0i8\x84\x87G0e6c7c\x8de\x8e\x7fM31c\x8f3331530]2eI|b2326\xcd0i5MeC|31}]^34e\x90g931670g95H0eO30i3McLg:g9L3312g:\x8e1\x8e1eb|31g:F16902g:Mc\x91<6;0eGg:315P0eO30i3McLg;i5Mg:}]^34L3312g;\x8e1i3Mc\x8c|\x8417502c\x92g9g;L4312g26?0i5Mcc}g2g344;];g3690i2M|41;g2640|;i3M|41;g8c\x91=6T0eG|31g36:0i2Mg941;g2650g9;i3Mg941;c0g8c\x93326T0iIM|312i3M|312g36<0i2Mcc31530]2cc;g8c\x94=6=0iIM|N312cc;g8c\x95=6^0iIM|312eO30i3McLg9|L3312g36<0i2Mg931530]2g9;c0g8c\x96326{0iIM|312i3M|312i9MF16G02i9MMF16=02e\x97i9M31c[<g316602g9@6<0i2Mcc31530]\x8e12cc;g8c\x98=6@0i4M|N}32|Mg9K;c0g8c\x99326\xf10i9MF16G02i9MMF16=02e\x97i9M31c[<|McX\x82X0\x7f|O2iJM6@0iJ^O2i3M|315=0i3McX|\x84L2315\x8a0|McT<16D02eI|b23216802|\x84c\x9a<6f0g2@17502g3660]580c\x9bc\x9c312iKM760]580c\x9bc\x9d312iKeC|31O580i3M|312g316602g9@6<0i2Mcc31530]2cc;c0g8c\x9e326E0e6c7c\x9fe\xa0|M31c\xa13341;g8c6=690e6|\x8441;e6c7c\xa2e\xa0|313241;" [#fn(memq)
julia_flisp.boot:  #fn(get) #fn(underscore-symbol?) outerref globalref error #fn(string)
julia_flisp.boot:  "all-underscore identifier used as rvalue" format-loc (call new splatnew
julia_flisp.boot:  #fn("6000r1|?17902e0|31@;" [tuple-call?] atom-or-not-tuple-call?)
julia_flisp.boot:  atom-or-not-tuple-call? foreigncall #fn(append) list-head cddr list-tail
julia_flisp.boot:  cglobal (outerref cglobal) = ssavalue? null make-ssavalue block
julia_flisp.boot:  first-non-meta linenum? lam:body meta push_loc #fn("9000r1|N\x85>0~M|M\x7fi2i344;~M|M\x7f^^342i4M|N41;" [])
julia_flisp.boot:  cdar line (meta pop_loc) complex-return? return unnecessary (if elseif) _
julia_flisp.boot:  goto #fn(for-each) #fn("6000r1e0|31~O;" [cddr]) cadddr (null) length= _while
julia_flisp.boot:  _do_while gotoifnot break-block break #fn(assq)
julia_flisp.boot:  return make-ssavalue = call core === caar gotoifnot break]) pop_exception
julia_flisp.boot:  newvar lam:vinfo global "misplaced \"global\" declaration" local-def local
julia_flisp.boot:  moved-local Any const local-in? "unsupported `const` declaration on local variable"
julia_flisp.boot:  linenode-string " needs to be placed at the top level, or use \"eval\"."
julia_flisp.boot:  valid-ir-argument? lambda (false) (thunk module) toplevel-only toplevel (import
julia_flisp.boot:					popaliasscope inline noinline) ret-type
julia_flisp.boot:  #fn(raise) (assert-failed (or (not value) tail))
julia_flisp.boot:  (assert-failed (not rett)) (   :=) "unsupported assignment operator \""
julia_flisp.boot:  #fn(for-each) #fn(":000r1e0|316Q0~M7;0~c130O530]2c2~M|M\x7fM|M3143;];" [vinfo:asgn
julia_flisp.boot:  #fn(table) #fn(put!)]) list-head #fn(length) lam:args #fn("A000r1|M|\x84e0|31e1|31c2~g8^33g97C0e3c4c5g8c63331530]2g9Me7g:g6326C0e3c4c8g8c933315S0g:g6W6>0g5e:g531P5?0g5Nc;g6g:xL2O\x8e12\x7fMg7g9\x8432g:6<0g5g:g5NKP;];" [caddr
julia_flisp.boot:  "`global const` declaration not allowed inside function" format-loc reverse!
julia_flisp.boot:  definitely-initialized-vars block filter #fn("7000r1|F16D02|Mc0<16:02c1~|\x8432@;" [newvar
julia_flisp.boot:  #fn(has?)]) insert-after-meta #fn(table.foldl)
julia_flisp.boot:  #fn("7000r3c0}|L3g2K;" [=])] compile-body)
julia_flisp.boot:	  compile-builtin-call #fn("<000r7c0e1g4^33g;16=02e2g3Ng;32@6=0e3g5g;32530]2g5g<c4\x82K0g6`W6:0e5|c642;e5|g5g643;g<c7\x82[0g6`W6:0e5|c842;g6b2W6:0e5|c942;e5|g5g643;g<c:\x82j0g6`W6:0e3g5a42;g6aW6:0e5|c;42;g6b2W6:0e5|c<42;e5|g5g643;g<c=\x82K0g6`W6:0e5|c>42;e5|g5g643;g<c?\x82K0g6`W6:0e3g5a42;e5|g5g643;g<c@\x82M0g6`W6<0e5|cAcB43;e5|g5g643;g<cC\x82W0g6b2X6;0e3g5b242;e5|g2670cD540cCg643;e5|g542;" [#fn(get)
julia_flisp.boot:  arg-counts length= argc-error list emit loadnil + load0 add2 - neg sub2 *
julia_flisp.boot:  load1 / vector loadv [] apply tapply] compile-builtin-call)
julia_flisp.boot:	  compile-f #fn("8000r2e0c1|}q2c242;" [call-with-values #fn("7000r0e0~\x7f42;" [compile-f-])
julia_flisp.boot:					       #fn("5000r2|;" [])] compile-f)
julia_flisp.boot:	  compile-f- #fn("O000r2e030}\x84e1}\x8431e2}31e3c4}\x8432e1}31g;\x8570c5540g;g7?660`580c6g731g=c6g:31xe3e7g:32g:\x87\xa20g?\x85L0e8g6c9g>g8\x8570g=550g=y345r0e:g6e;c<c=c<c>g?32e?c6g?31313331322e8g6c@g>c6g?31g8\x8570g=550g=y352eAg6|g:g9g>35530]2eBg=cC326I0e8g6g8\x8570cD540cEg=335W0g8\x87?0e8g6cFg=335E0g:\x85?0e8g6cGg=33530^2eH|g9eIeJ}31g93233eKg6g@M322g6b4c6g931b4w\\2eLg6g@]eJ}31342e8g6cM322eNcOePeQg63131eRg631g<33eSg63142;" [make-code-emitter
julia_flisp.boot:  lastcdr lambda:vars filter #.pair? lambda #fn(length) keyword-arg? emit
julia_flisp.boot:  optargs bcode:indexfor make-perfect-hash-table
julia_flisp.boot:  #fn(map) #.cons #.car iota keyargs emit-optional-arg-inits > 255 largc lvargc
julia_flisp.boot:  vargc argc extend-env complex-bindings lambda:body box-vars compile-in ret
julia_flisp.boot:  values #fn(function) encode-byte-code bcode:code const-to-idx-vec bcode:cenv] compile-f-)
julia_flisp.boot:	  compile-for #fn("9000r5e0g4316n0e1|}^g2342e2|a322e1|}^g3342e2|a322e1|}^g4342e3|c4322e2|b.42;e5c641;" [1arg-lambda?
julia_flisp.boot:  compile-in bcode:stack emit for error "for: third form must be a 1-argument lambda"] compile-for)
julia_flisp.boot:	  compile-if #fn("@000r4e0|31e0|31g3\x84e1g331e2g331F6;0e3g331560e430g:]\x82=0e5|}g2g;44;g:^\x82=0e5|}g2g<44;e5|}^g:342e6|c7g8332e5|}g2g;342g26<0e6|c8325;0e6|c9g9332e:|g8322e5|}g2g<342e:|g942;" [make-label
julia_flisp.boot:  caddr cdddr cadddr void compile-in emit brf ret jmp mark-label] compile-if)
julia_flisp.boot:	  compile-in #fn("<000r4g3C6<0e0|}g3]44;g3?6\xaf0g3`\x82:0e1|c242;g3a\x82:0e1|c342;g3]\x82:0e1|c442;g3^\x82:0e1|c542;g3_\x82:0e1|c642;e7g3316<0e1|c8g343;c9g3316C0e:|}g2c;c<31L144;e1|c=g343;g3MC@17D02g3ME17;02e>g3M}326=0e?|}g2g344;g3Mg8c@\x82S0eAg3\x84316>0e:|}g2g3\x8444;e1|c=g3\x8443;g8cB\x82=0eC|}g2g344;g8cD\x82>0eE|}g2g3N44;g8cF\x82;0eG|}g343;g8cH\x82D0eIcJ}g3q2cK|}q242;g8cL\x82>0eM|}g2g3N44;g8cN\x82>0eO|}g2g3N44;g8cP\x82E0eQ|}g3\x84cDeRg331K44;g8cS\x82H0eT|}g3\x84eUg331eVg33145;g8cW\x82E0e:|}]g3\x84342e1|cX42;g8cY\x82B0eZ|}g3\x84eUg33144;g8c[\x82p0e:|}^cH_g3\x84L3342e\\eUg33131660^580e]c^312e:|}^eUg331342e1|c[42;e?|}g2g344;" [compile-sym
julia_flisp.boot:  emit load0 load1 loadt loadf loadnil fits-i8 loadi8 #fn(eof-object?)
julia_flisp.boot:  compile-in #fn(top-level-value) eof-object loadv in-env? compile-app quote
julia_flisp.boot:  self-evaluating? if compile-if begin compile-begin prog1 compile-prog1 lambda
julia_flisp.boot:  call-with-values #fn("7000r0e0~\x7f42;" [compile-f-])
julia_flisp.boot:  #fn("9000r2e0~c1|332}\x87K0c2c3~\x7fq2}322e0~c4c5}3143;];" [emit loadv #fn(for-each)
julia_flisp.boot:							      #fn("9000r1e0~\x7f|^44;" [compile-sym])
julia_flisp.boot:  and compile-and or compile-or while compile-while cddr for compile-for caddr
julia_flisp.boot:  cadddr return ret set! compile-set! trycatch 1arg-lambda? error "trycatch: second form must be a 1-argument lambda"] compile-in)
julia_flisp.boot:	  compile-let #fn("A000r4g3Mg3Ne0|31g8\x84e1|}g933e2g;e3e4g831g;32g:33e5|g=322c6g=}M32}NKe7|g>g2e4g831342e8|g<y322e9g<`3216602g2@6<0e:|c;g<43;];" [bcode:sp
julia_flisp.boot:  compile-arglist vars-to-env complex-bindings caddr box-vars #fn(append!)
julia_flisp.boot:  compile-in bcode:stack > emit shift] compile-let)
julia_flisp.boot:	  compile-or #fn(";000r4e0|}g2g3^c146;" [compile-short-circuit brt] compile-or)
julia_flisp.boot:	  compile-prog1 #fn(":000r3e0|}^g2\x84342e1g231F6W0e2|a322e3|}^e1g231342e4|c5322e2|b/42;];" [compile-in
julia_flisp.boot:  cddr bcode:stack compile-begin emit pop] compile-prog1)
julia_flisp.boot:	  compile-set! #fn("?000r4e0g2}`33g8c1\x82F0e2|}^g3342e3|c4g243;g8M`We5g8N31g96<0e6g8N31590e7|g232g:6g0e3|g9670c8540c9g;332e:|a322e2|}^g3342e:|b/322e3|c;42;e2|}^g3342g97A0e<c=c>g23231530]2e3|c?g;43;" [lookup-sym
julia_flisp.boot:  global compile-in emit setg vinfo:heap? vinfo:index capture-var! loada loadc
julia_flisp.boot:  bcode:stack set-car! error #fn(string) "internal error: misallocated var "
julia_flisp.boot:  seta] compile-set!)
julia_flisp.boot:	  compile-short-circuit #fn("<000r6g3?6=0e0|}g2g444;g3N?6>0e0|}g2g3M44;e1|31e0|}^g3M342e2|a322e3|c4322e3|g5g:332e2|b/322e3|c5322e6|}g2g3Ng4g5362e7|g:42;" [compile-in
julia_flisp.boot:  make-label bcode:stack emit dup pop compile-short-circuit mark-label] compile-short-circuit)
julia_flisp.boot:	  compile-sym #fn(";000r4e0g2}`33g8c1\x82b0c2g23116=02e3c4g231316@0e5|c6c4g23143;e5|c7g243;g8M`W6\\0e5|c8e9g8N31332g316:02e:g8N316:0e5|c;42;];e5|c<e=|g232332g316:02e:g8N316:0e5|c;42;];" [lookup-sym
julia_flisp.boot:  global #fn(constant?) printable? #fn(top-level-value) emit loadv loadg loada
julia_flisp.boot:  vinfo:index vinfo:heap? car loadc capture-var!] compile-sym)
julia_flisp.boot:	  compile-thunk #fn(":000r1e0_c1_e2|31L342;" [compile-f lambda
julia_flisp.boot:						      lower-define] compile-thunk)
julia_flisp.boot:	  compile-while #fn(";000r4e0|31e0|31e1|}^e230342e3|a322e4|g8322e1|}^g2342e5|c6g9332e5|c7322e3|b/322e1|}^g3342e5|c8g8332e4|g942;" [make-label
julia_flisp.boot:  compile-in void bcode:stack mark-label emit brf pop jmp] compile-while)
julia_flisp.boot:	  complex-bindings #fn("=000r2c030c030e1|}^^g6g7362e2c3g6q1e4g73142;" [#fn(table)
julia_flisp.boot:  complex-bindings- filter #fn("7000r1c0~|42;" [#fn(has?)]) table.keys] complex-bindings)
julia_flisp.boot:	  complex-bindings- #fn("=000r6}\x8540^;|C6M0g316902c0|}326;0c1g4|]43;];|?17802e2|31640^;|Mc3\x82o0c0|\x84}326Q0c1g5|\x84]332g36>0c1g4|\x84]33530]530]2e4e5|31}^g3g4g546;|Mc6\x82U0e4e7|31e8}e9|3132^g2@17502g3g4g546;e4|M}e:|31g3g4g536c;c<}g3g4g5q4|N32K;" [#fn(memq)
julia_flisp.boot:  #fn(put!) quoted? set! complex-bindings- caddr lambda lambda:body diff
julia_flisp.boot:  lambda:vars inlineable? #fn(map) #fn(";000r1e0|~^\x7fi2i346;" [complex-bindings-])] complex-bindings-)
julia_flisp.boot:	  complex-return? #fn("7000r1e0|3116<02|\x84e1g531@;" [return?
julia_flisp.boot:							       simple-atom?] complex-return?)
julia_flisp.boot:	  const-to-idx-vec #fn("9000r1c0e1|3131e2c3g5q1e4|31322g5;" [#fn(vector.alloc)
julia_flisp.boot:  bcode:nconst table.foreach #fn("7000r2~}|\\;" []) bcode:ctable] const-to-idx-vec)
julia_flisp.boot:	  contains-macrocall #fn("7000r1|F16:02e0c1|42;" [contains #fn("6000r1|F16802|Mc0<;" [macrocall])] contains-macrocall)
julia_flisp.boot:	  convert-assignment #fn("G000r6|C6l1c0|e1g331M32c0|e1g331\x8432g:16902e2g:3117G02g;16902e2g;3117502c3g;16D02e4g;3116902e5g;31g:16D02e4g:3116902e5g:31g=@16@02g>@16802g<c3>690c6|}L3;e7}3117702}c8>660}560e930g<c3>670g?5I0e:g?e;g<g2g3^^^g4g53832g=6]0c<c=c>L2g46:0c?|L25;0e@|g2g533cAcBL2g@L55T0g>6H0c<c=c>L2|cAcBL2g@L5590c6|g@L3g?}\x82:0cCgA}L3;cCc6g?}L3gAg?L4;|F16B02|McD<17802|McE<690c6|}L3;eF|31690c6|}L3;eGcHcIeJ|31cK3341;" [#fn(assq)
julia_flisp.boot:  lam:vinfo vinfo:type (core Any) vinfo:asgn vinfo:capt = simple-atom? (the_exception)
julia_flisp.boot:  make-ssavalue convert-for-type-decl cl-convert call core setfield! $
julia_flisp.boot:  capt-var-access inert contents block outerref globalref ssavalue? error #fn(string)
julia_flisp.boot:  "invalid assignment location \"" deparse "\""] convert-assignment)
julia_flisp.boot:	  convert-for-type-decl #fn("=000r2}c0>640|;}?17B02e1}3117802e2}31660^560e330g617402}c4c5c6L2c4c7c8L2g7|L4g7L4g66D0c9c:g6e;}31L3g8L3;g8;" [(core
julia_flisp.boot:  Any) ssavalue? quoted? make-ssavalue call core typeassert top convert block
julia_flisp.boot:  = renumber-assigned-ssavalues] convert-for-type-decl)
julia_flisp.boot:	  convert-lambda #fn("?000r5e0|e1e2|31}|c330c330^g2g43832c4e5|31e6e7|31M31_e8e7|3131e9c:e;|31g33231L4g9L4;" [add-box-inits-to-body
julia_flisp.boot:  cl-convert cadddr #fn(table) lambda lam:args clear-capture-bits lam:vinfo
julia_flisp.boot:  caddr delete-duplicates #fn(append) lam:sp] convert-lambda)
julia_flisp.boot:	  count #fn("9000r2]\x8c6g6c0g6q1O2g6M|}`43;" [#fn("9000r3}\x8550g2;~M|}N|}M31690g2aw540g243;" [] count-)] count)
julia_flisp.boot:	  ctor-def #fn("D000r6|F16802|Mc0<g:6:0e1|31530_g:670|\x84530|c2c3c2e4g53232g<}<7r0c5e6c7c8L1g:6G0c7c0L1g<L1c9g;3133540g<L1c9g33133g532g2g4_g=33L3;c5e6c7c8L1g:6G0c7c0L1g<L1c9g;3133540g<L1c9g33133g532g2g4g;g=33L3;" [curly
julia_flisp.boot:  cddr #fn(map) #.car analyze-typevar function with-wheres #fn(nconc) call #fn(copy-list)] ctor-def)
julia_flisp.boot:	  ctors-min-initialized #fn("<000r1|F16c02e0|Me1c2g6c3c434\x8e1|Me1c5g7c6c734\x8e1e8|M31e8|N3144;" [min
julia_flisp.boot:  plambda-expansion (call (-/ new) . args)
julia_flisp.boot:  (call (curly (-/ new) . p) . args) #fn("6000r3c0g241;" [#fn(length)])
julia_flisp.boot:  (__ p args) ctors-min-initialized] ctors-min-initialized)
julia_flisp.boot:	  ctrans-op |'| current-filename none current-input-port
julia_flisp.boot:	  #fn("6000\x8900001000\x8a0000770e0m02|k0;" [*input-stream*] current-input-port)
julia_flisp.boot:	  current-output-port #fn("6000\x8900001000\x8a0000770e0m02|k0;" [*output-stream*] current-output-port)
julia_flisp.boot:	  decl-type #fn("6000r1e0|31680e1|41;c2;" [decl? caddr (core Any)] decl-type)
julia_flisp.boot:	  decl-var #fn("6000r1e0|31650|\x84;|;" [decl?] decl-var) decl-var*
julia_flisp.boot:  call decl-var* = curly :: where decl-var] decl-var*)
julia_flisp.boot:	  decl-vars* #fn("8000r1|F16802|Mc0<6?0c1c2e3|N32v2;e4|31L1;" [tuple #fn(append)
julia_flisp.boot:  #fn(map) decl-vars* decl-var*] decl-vars*)
julia_flisp.boot:	  dedent-triplequoted-string #fn("9000r1e0|31e1g5`326@0e2e3c4g5q1|43;|;" [triplequoted-string-indentation
julia_flisp.boot:  length> map-at even? #fn("9000r1e0|e1c2~K31c243;" [string-replace
julia_flisp.boot:						     list->string #\linefeed])] dedent-triplequoted-string)
julia_flisp.boot:	  default-ignorable-char? #fn("7000r1e0|3117R02e1|c23216:02e3|c43217:02e5|c642;" [zero-width-space?
julia_flisp.boot:			      #\ #\)] default-ignorable-char?)
julia_flisp.boot:	  default-inner-ctors #fn("D000r6e0}g232c1e2c3c4L1g3F6F0c3c5L1|L1c6g33133530|L1c6g:3133c7c8g43232c3c9L1c6g531c3c4L1c:L1c6g:3133L133L3g3A16;02e;c<g2326\x9d0c=e>c?c4c@cAL2c@cBL2g2ML4g2N33c9L1c1c3c4L1|L1c6c7eCg:g2333133c3c9L1c6g531c3c:L1cD|L2L1c6g:3133L133L3L4g;L2;g;L1;" [safe-field-names
julia_flisp.boot:  function with-wheres #fn(nconc) call curly #fn(copy-list)
julia_flisp.boot:  #fn(map) #fn("6000r1c0|K;" [var-bounds]) block new any #fn("6000r1|c0>@;" [(core
julia_flisp.boot:  core === Any make-decl outerref] default-inner-ctors)
julia_flisp.boot:	  default-outer-ctor #fn("A000r6e0}g232c1e2c3c4L1|L1c5c6e7g:g2333133c6c8g43232c3c9L1c5g531c3c4L1c3c:L1|L1c5g33133L1c5g:3133L133L3;" [safe-field-names
julia_flisp.boot:  function with-wheres #fn(nconc) call #fn(copy-list)
julia_flisp.boot:  #fn(map) make-decl #fn("6000r1c0|K;" [var-bounds]) block curly] default-outer-ctor)
julia_flisp.boot:	  defined-julia-global #fn("5000r1^;" [] defined-julia-global)
julia_flisp.boot:	  definitely-initialized-vars #fn("=000r2c030c030\x8c6]\x8c8g8c1g7g6}g8q4O2g8M\x8e1|41;" [#fn(table)
julia_flisp.boot:  #fn("<000r1|\x8540~;|Me0c1\x7fq1g5322g5F16902g5Mc2<6_0e3g5\x84i232g616:02e4g631@6?0c5\x7fMg5\x84]33530]\x8e15\xad0g5F16b02c6g5Mc73217T02g5Mc8<16I02e9g531F16=02e9g531Mc:<6;0\x7fc;30O5j0g5F16902g5Mc8<6X0c<\x7fMg5\x84326H0c=\x7fMg5\x84322c5~g5\x84]33530]530^\x8e12i3M|N41;" [for-each-isdefined
julia_flisp.boot:				    #fn(del!)]) newvar var-info-for vinfo:capt
julia_flisp.boot:  #fn(has?) #fn(del!)])] definitely-initialized-vars)
julia_flisp.boot:	  delete-duplicates #fn(":000r1e0|bD326O0c130]\x8c6g6c2g5g6q2O2g6M\x8e1|_42;|?640|;|M|Ne3g5g632690e4g641;g5e4g631K;" [length>
julia_flisp.boot:  #fn(has?) #fn(put!)]) member delete-duplicates] delete-duplicates)
julia_flisp.boot:  #fn(string?) print-to-string #fn(typeof) julia_value #fn(string.find) "#<julia: "
julia_flisp.boot:  caaddr 'inert deparse-colon-dot copyast #\(
julia_flisp.boot:  #\) (... |'|) syntactic-op? <: >: --> length= " " as deparse-import-path " as "
julia_flisp.boot:  operator? deparse-prefix-call cddr ($ &) caadr (outerref null true false
julia_flisp.boot:  "(" ")" :: comparison string.join #fn(map) macrocall deparse-arglist kw " = "
julia_flisp.boot:  deparse-semicolons typed_ncat row nrow bracescat string #\"
julia_flisp.boot:  deparse-generator flatten filter " if " comprehension "[ " " ]"
julia_flisp.boot:  typed_comprehension block deparse-block "begin" toplevel "\n" (function macro
julia_flisp.boot:  for while) #fn("6000r1|F16802|Mc0<650|N;|L1;" [block] block-stmts)
julia_flisp.boot:  block-stmts return "return " (break continue) (if elseif)
julia_flisp.boot:  #fn("6000r1|Mc0\x8290e1|\x8441;|\x84;" [elseif caddr] if-cond) if-cond
julia_flisp.boot:  indented-block elseif "else" let "let " cdadr try "try\n" string.rep "    "
julia_flisp.boot:	  deparse-arglist #fn(";000\x8910002000\x8a1000770c0m12e1|316[0c2e3c4e5|N32}32e6|Na32670c7540c8e5|M3143;e3c4e5|32}42;" [", "
julia_flisp.boot:  has-parameters? #fn(string) string.join #fn(map) deparse length= "," ""] deparse-arglist)
julia_flisp.boot:	  deparse-block #fn(";000r3c0|c1e2}g232e3c4g232c545;" [#fn(string) "\n"
julia_flisp.boot:							       indented-block
julia_flisp.boot:							       "end"] deparse-block)
julia_flisp.boot:	  deparse-colon-dot #fn("8000r1e0|316>0c1c2e3|3142;e3|41;" [dotop? #fn(string)
julia_flisp.boot:								    ":" deparse] deparse-colon-dot)
julia_flisp.boot:	  deparse-flatten #fn("<000\x8920003000\x8a2000760]m22g216?02|F16802|Mc0<6G0e1|\x84e2e3|31c432}K^43;g216?02|F16802|Mc5<6K0|\x84e1g7\x84e2e3g731c432}K]43;c6e7|31c8e9e:}31c83243;" [generator
julia_flisp.boot:  deparse-flatten deparse-arglist cddr ", " flatten #fn(string) deparse " for "
julia_flisp.boot:  string.join reverse] deparse-flatten)
julia_flisp.boot:	  deparse-generator #fn(":000r1|Mc0\x8290e1|_42;c2e3|\x8431c4e5e6|31c73243;" [flatten
julia_flisp.boot:  deparse-flatten #fn(string) deparse " for " deparse-arglist cddr ", "] deparse-generator)
julia_flisp.boot:	  deparse-import-path #fn("<000r1|F16802|Mc0<6J0]\x8c5g5c1g5q1O2g5M\x8e1|N`42;|F16802|Mc2<6P0c3e4|\x8431c5e6c7e4e8|3132c93243;c3|41;" [|.|
julia_flisp.boot:  #fn(string) deparse-import-path ": " string.join #fn(map) cddr ", "] deparse-import-path)
julia_flisp.boot:	  deparse-prefix-call #fn(":000r4c0e1|3117702|c2<6B0c0c3e4|31c533570e4|31g2e6}31g344;" [#fn(string)
julia_flisp.boot:  decl? : "(" deparse ")" deparse-arglist] deparse-prefix-call)
julia_flisp.boot:	  deparse-semicolons #fn("9000r1e0|`32650c1;c2c3e4e5|313142;" [<= "" #fn(string)
julia_flisp.boot:  ";" deparse-semicolons 1-] deparse-semicolons)
julia_flisp.boot:	  deprecation-message #fn(";000r2e0}31g6Mg6\x84e1|g8g743;" [extract-line-file
julia_flisp.boot:								    frontend-depwarn] deprecation-message)
julia_flisp.boot:	  disallow-space #fn("8000r3e0|316A0e1c2|a[31}g243;];" [ts:space?
julia_flisp.boot:								disallowed-space-error
julia_flisp.boot:								#fn(input-port-line)] disallow-space)
julia_flisp.boot:	  disallowed-space-error #fn("@000r3e0c1c2g2c3e4}31c5g2c6e7c8|3:41;" [error
julia_flisp.boot:  current-filename ":"] disallowed-space-error)
julia_flisp.boot:	  display #fn(":000\x8910002000\x8a1000770e0m12e0}k02c1g6q1c2|q1c3g7q1tg7302\x8e1\x8e12];" [*output-stream*
julia_flisp.boot:  #fn("5000r0~k0;" [*output-stream*]) #fn("6000r0e0~41;" [princ])
julia_flisp.boot:	  doc-string-literal? #fn("6000r2e0}3117?02}F16802}Mc1<;" [simple-string-literal?
julia_flisp.boot:								   string] doc-string-literal?)
julia_flisp.boot:	  dot-opchar? #fn(#3# #4# [#table(#\ #t  #\ #t  #\< #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\. #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\! #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\- #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\= #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\+ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\' #t  #\ #t  #\ #t  #\ #t  #\ #t  #\~ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\| #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\% #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\> #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\* #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\^ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\& #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\/ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t  #\ #t)])
julia_flisp.boot:	  dot-operators (|.'| .+ .- .! .~ . . . . . . . .= .+= .-= .=
julia_flisp.boot:			 . . . . . . . . . .--> .<-- .<--> |.\|\|| .&&
julia_flisp.boot:	  dotop-named? #fn("7000r1e0e1|3141;" [dotop? identifier-name] dotop-named?)
julia_flisp.boot:	  dotop? #fn(#5# #6# [#fn(#3# #4# [#table(. #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .+= #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .<= #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .= #t  . #t  . #t  .&& #t  . #t  .!== #t  . #t  . #t  .>>> #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .<-- #t  . #t  . #t  . #t  . #t  . #t  . #t  .//= #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .=== #t  . #t  . #t  . #t  .--> #t  . #t  . #t  . #t  . #t  . #t  .>: #t  . #t  . #t  . #t  . #t  .<< #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .*= #t  . #t  . #t  . #t  .= #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .! #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .%= #t  . #t  . #t  . #t  . #t  . #t  |.\|>| #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .=> #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .> #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .^= #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .+ #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .// #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .++ #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .- #t  |.\\=| #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .* #t  . #t  . #t  . #t  . #t  . #t  .>>= #t  . #t  . #t  . #t  . #t  . #t  .!= #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .== #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .<: #t  . #t  . #t  . #t  . #t  . #t  . #t  .< #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  |.\\| #t  . #t  |.<\|| #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .>> #t  . #t  .&= #t  . #t  |.\|=| #t  .= #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .~ #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .>= #t  . #t  . #t  |.'| #t  . #t  . #t  . #t  .-= #t  . #t  .<--> #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .% #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  |.\|\|| #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  ./= #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  |.\|| #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .= #t  . #t  . #t  .& #t  . #t  .<<= #t  . #t  . #t  . #t  ./ #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .>>>= #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  .^ #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t)])])
julia_flisp.boot:	  dots->vararg #fn(";000r1|\x8540|;e0|31e1|31e2g6316H0c3c4g531c5c6g6\x84L3L142;c3c4g531g6L142;" [butlast
julia_flisp.boot:  last vararg? #fn(nconc) #fn(copy-list) curly Vararg] dots->vararg)
julia_flisp.boot:	  eager-any #fn("9000r2]\x8c6g6c0g6|q2O2g6M\x8e1}^42;" [#fn("8000r2|\x8540};~M|N\x7f|M3117402}42;" [])] eager-any)
julia_flisp.boot:	  effect-free? #fn("7000r1|F@17Y02e0|3117O02e1|3117E02e2|3117;02c3|Mc442;" [ssavalue?
julia_flisp.boot:  sym-dot? quoted? #fn(memq) (null true false)] effect-free?)
julia_flisp.boot:	  emit-optional-arg-inits #fn("<000r5g2F6\x900e0|31e1|c2g4332e1|c3g9332e4|e5}e6g3g432_33^e7g231342e1|c8g4332e1|c9322e:|g9322e;|}g2Ng3g4aw45;];" [make-label
julia_flisp.boot:  emit brbound brt compile-in extend-env list-head cadar seta pop mark-label
julia_flisp.boot:  emit-optional-arg-inits] emit-optional-arg-inits)
julia_flisp.boot:	  encode-byte-code #fn("S000r1e0|31e1g531e2c3g631b3c3g631b2VT2wc432c3g631`c530c530c630^^c7g<c8322]g9g8X6\xd912g6g9[m=2g=c9\x82P0c:g:g6g9aw[c;g<31332g9b2wm95\xa81c7g<e<c=e>g76\x830g=gDc?\x8270c@5p0gDcA\x8270cB5d0gDcC\x8270cD5X0gDcE\x8270cF5L0gDcG\x8270cH5@0gDcI\x8270cJ540g=\x8e1540g=3231322g9awm92g9g8X6:0g6g9[530^m>2cKg=cL326`0c:g;c;g<31g>332c7g<g7670eM540eN`31322g9awm95\xeb0g=cO\x82H0c7g<eMg>31322g9awm95\xce0g>D6\xc70g=cKg?cP326H0c7g<eMg>31322g9awm95\x9f0cKg?cQ326\x810c7g<eMg>31322g9awm92c7g<eMg6g9[31322g9awm92g=cR\x82K0c7g<eMg6g9[31322g9awm9530]5E0c7g<eSg>31322g9awm9\x8e1530^5\x83.2eTcUg<g7g:q3g;322cVg<41;" [reverse!
julia_flisp.boot:  list->vector >= #fn(length) 65536 #fn(table)
julia_flisp.boot:  #fn(io.tostring!)] encode-byte-code)
julia_flisp.boot:	  end-symbol #f end-val
julia_flisp.boot:  #fn("7000r1c0c1c2L2|L3;" [call top length])] end-val)
julia_flisp.boot:	  ends-interpolated-atom? #fn("6000r1c0|3117B02e1|3117802c2|41;" [#fn(eof-object?)
julia_flisp.boot:  opchar? #fn(never-identifier-char?)] ends-interpolated-atom?)
julia_flisp.boot:	  eq-sym? #fn("6000r2|}<17L02e0|3116B02e0}3116802|N}N=;" [ssavalue?] eq-sym?)
julia_flisp.boot:	  error #fn("9000s0c0c1|K41;" [#fn(raise) error] error) error-wrap
julia_flisp.boot:	  #fn("7000r1e0c1|42;" [with-exception-catcher
julia_flisp.boot:  (error io-error) "incomplete:" #fn(string?) >= string-length substring
julia_flisp.boot:  incomplete error (error "malformed expression")])] error-wrap)
julia_flisp.boot:	  eval #fn("7000r1e0e1|313140;" [compile-thunk expand] eval) even?
julia_flisp.boot:	  #fn("7000r1c0|a32`W;" [#fn(logand)] even?) eventually-call? #fn("6000r1|F16W02|Mc0<17M02|Mc1<17802|Mc2<16902e3|\x8441;" [call
julia_flisp.boot:  where :: eventually-call?] eventually-call?)
julia_flisp.boot:	  eventually-decl? #fn("6000r1e0|3117J02|F16C02|Mc1<16902e2|\x8441;" [decl?
julia_flisp.boot:  atomic symdecl?] eventually-decl?)
julia_flisp.boot:  caar begin #fn(append) cdar] splice-begin) *expanded* #fn("A000r2|?640|;~Mc0}326:0\x7fM|31530|~Mc1}32g76;0e2g631530_c3c4c5g832}32\x8c9g77A0c4c6i2g9q2g642;]\x8c:g:c7g:i2g9i3q4O2g:M\x8e1g631g:]g;F6c02i3Me8g;31<7C0g;i2Mg;Mg9M32O5;0g;e9g;31O2g;Nm;5\xfb/2g:;" [begin
julia_flisp.boot:  define get-defined-vars #fn(nconc) #fn(map) #.list #fn("7000r1~M|\x7fM42;" [])
julia_flisp.boot:  caar #fn(nconc) #fn(map) #.list get-defined-vars]) caar cdar] expand-body)
julia_flisp.boot:  cadar] expand-lambda-list) #fn("7000r1|?660|L1;|MF6?0e0|31~M|N31K;|M~M|N31K;" [caar] l-vars)
julia_flisp.boot:  cddr #fn(nconc) #fn(map) #.list lambda] expand-lambda)
julia_flisp.boot:  define caddr cdadr caadr #fn(nconc) #fn(map) #.list] expand-define)
julia_flisp.boot:						      #fn("9000r1|Me0~M|\x84\x7f323130\x7fL3;" [compile-thunk])] expand-let-syntax)
julia_flisp.boot:  #fn("5000r2|;" [] local-expansion-env) #fn("<000r2|?640|;|Mc0g6}32c1~}|q3g716702g7NF6I0~Mg7\x84|NQ2\x7fMe2g731}3242;g717?02g6C@17602g6E670g840;e3|31g96>0~Mg9|NQ2}42;g6c4\x8240|;g6c5\x82:0i2M|}42;g6c6\x82:0i3M|}42;g6c7\x82:0i4M|}42;g840;" [#fn(assq)
julia_flisp.boot:  caddr macrocall? quote lambda define let-syntax] expand-in)] expand)
julia_flisp.boot:	  expand-and #fn("9000r1e0c1|32N]\x8c6g6c2g6q1O2g6M\x8e1g541;" [flatten-ex
julia_flisp.boot:  && #fn("8000r1|\x8550c0;|N\x8550|M;c1|M~M|N31c2L1L4;" [(true) if false])] expand-and)
julia_flisp.boot:	  expand-arrow #12=#fn("F000r1|\x84e0|31g5F16902g5Mc1<6I0e2g531e3g731g7\x84m52\x8e1530^g5F6A0e4e5c6g53231560g5L1c7c8c9e:303231e;c<c=g9L2c>g76W0c?c1L1c?c@L1g9L1cAg83133L1cAg731335D0c?c@L1g9L1cAg83133g6L3L341;" [caddr
julia_flisp.boot:  where flatten-where-expr cddr tuple-to-arglist filter #fn("6000r1e0|31@;" [linenum?])
julia_flisp.boot:  #fn(symbol) #fn(string) "#" current-julia-module-counter expand-forms block
julia_flisp.boot:  local function #fn(nconc) call #fn(copy-list)] expand-arrow)
julia_flisp.boot:	  expand-atomic-decl #14=#fn("6000r1e0c141;" [error "unimplemented or unsupported atomic declaration"] expand-atomic-decl)
julia_flisp.boot:	  expand-compare-chain #fn("6000r1e0|31M;" [expand-vector-compare] expand-compare-chain)
julia_flisp.boot:	  expand-condition #fn("C000r1|F16802|Mc0<g56;0e1|31N530_g56:0e2|31530|g7F16<02c3g7Mc4326\x8a0c5g7ML1c6c7e8e9g7Mg732N323132g8N\x85D0g8Mc:\x8270c;540c<540g8g56K0c5c0L1c6c7e8g63231g9L143;g9;e8|41;" [block
julia_flisp.boot:  #fn(copy-list) #fn(map) expand-forms flatten-ex && (true) (false)] expand-condition)
julia_flisp.boot:	  expand-const-decl #13=#fn(";000r1|\x84g5?640|;g5Mc0g6c1326L0c2c3g5N322e4e5g5Mg5N]3341;c0g6c6326@0e4e5c7|N^3341;|;" [#fn(memq)
julia_flisp.boot:  (global local local-def) #fn(for-each) #fn("6000r1e0|31790e1c241;];" [assignment?
julia_flisp.boot:  error "expected assignment after \"const\""]) expand-forms expand-decls (= ::)
julia_flisp.boot:  const] expand-const-decl)
julia_flisp.boot:	  expand-decls #fn(";000r3e0}317B0e1c2c3|c43331530]2]\x8c7g7c5g2|g7q3O2g7M\x8e1}__43;" [list?
julia_flisp.boot:  #fn("6000r1~|L2;" []) reverse assignment-like? function-def? #fn(append)
julia_flisp.boot:  lhs-decls assigned-name all-decl-vars caddr :: decl-var decl #fn(copy-list)
julia_flisp.boot:  error #fn(string) "invalid syntax in \"" "\" declaration"])] expand-decls)
julia_flisp.boot:	  expand-define #fn("?000r1|\x84e0|31F6:0e0|315L0|\x84C6;0e130L15=0e2c3e4|3132g5C6<0c5g5g6ML3;c5g5Mc6c7L1g5NL1c8g631g5M34L3;" [cddr
julia_flisp.boot:  void error "compile error: invalid syntax " print-to-string set! #fn(nconc)
julia_flisp.boot:  lambda #fn(copy-list)] expand-define)
julia_flisp.boot:	  expand-for #fn("?000r3]\x8c7g7c0O2e1e2c3c4c5e6e2c7g7q1e8|313232Q23231c9c:]\x8c;g;c;g2g7g;g8q4O2g;M\x8e1|}32L3;" [#fn("6000r1|F16802|Mc0<;" [outer] outer?)
julia_flisp.boot:  delete-duplicates filter #fn("6000r1c0|31@;" [#fn(underscore-symbol?)])
julia_flisp.boot:  #fn(append) #fn(map) lhs-vars #fn("6000r1~M|31@;" []) butlast break-block
julia_flisp.boot:  loop-exit #fn("P000r2|\x8540~;e030e130e030\x7fM|M31g96:0e2|31540|Mc3c4L1c5g97A0c6c7e8g:3132530_31e9g:g8L2g732L1i2M|N}N32L134|N\x85U0c:c;c<c3c4L1c5c6c=i3323132g;L3L3580c>g;L2c3c4L1c?g6}ML3L1c@g7L2L1c?g7cAcBcCL2g6L3L3L1c5g96=0cDg:L2L1530_31cEcAcBcFL2cAcGcHL2g7cIL1L4L3cJc4g<c?g7cAcBcCL2g6g8L4L3L3cAcBcFL2cAcGcHL2g7cIL1L4L3L3L3L146;" [make-ssavalue
julia_flisp.boot:  gensy cadar #fn(nconc) block #fn(copy-list)
julia_flisp.boot:  #fn(map) #fn("6000r1c0|L2;" [local]) lhs-vars lower-tuple-assignment
julia_flisp.boot:  break-block loop-cont soft-let #fn("7000r1c0||L3;" [=]) scope-block = local
julia_flisp.boot:  call top iterate require-existing-local if not_int core === null _do_while])] expand-for)
julia_flisp.boot:	  expand-forms #fn("9000r1|?17;02c0|Mc132640|;c2e3|M^33g5680g5|41;|Mc4e5|N32K;" [#fn(memq)
julia_flisp.boot:   false meta using import export thismodule toplevel-only)
julia_flisp.boot:  #fn(get) expand-table #fn(map) expand-forms] expand-forms)
julia_flisp.boot:	  expand-function-def #15=#fn("9000r1]\x8c5g5c0g5q1O2|\x84g5Mg6316<0e1c2|NK41;e3|41;" [#fn("7000r1|F16P02c0|Mc13217C02|Mc2<16902~M|\x8441;" [#fn(memq)
julia_flisp.boot:  (tuple block ...) where] just-arglist?) expand-forms -> expand-function-def-] expand-function-def)
julia_flisp.boot:	  expand-function-def- #fn("X000r1|\x84g5F16902g5Mc0<6x0e1g531e2g631g6\x84F16?02c3e4g631c5327G0e6c7c8e9g531c:3331530]2g6\x84m52\x8e1530^g5F16902g5Mc;<g76;0e<g531540c=g7680g5\x84540g5e>|b23216A02g9C17902e?g9316U0e@g9317C0e6c7cAg9c:3331530]2cBg9L2;g9F740|;g9McC\x82)0g617402_cDeEg:32g9NcDcFeGeHg<3232eIe<|31g=32cDcJg<32eKg?31g@MeLgAM31eMgB316;0e<gB31540gBcNeOgC316;0gDgC315D0c;cPcCcQcRL2gCL3L3eIg>g@N32gANeSeTgGgE32eUeVgG32@16N02gGF16E02gGMF16<02eWgG31cX<@32eOgB3117D02gBF16<02c3gBMcY32660^540gBeZe[gIg;gHgFg83541;e6c7c8e9g931c:3341;" [where
julia_flisp.boot:  flatten-where-expr cddr #fn(memq) caadr (call ::) error #fn(string)
julia_flisp.boot:  globalref? valid-name? "invalid function name \"" method call #fn(map)
julia_flisp.boot:  analyze-typevar #fn("9000r1c0|\x84e1e2|3131L3;" [meta arg-name caddr]) filter
julia_flisp.boot:  nospecialize-meta? insert-after-meta #fn("6000r1e0|31680e1|41;|;" [nospecialize-meta?
julia_flisp.boot:  caddr]) lower-destructuring-args check-dotop overlay? #fn("7000r1e0|3116:02e1|b2326;0c2c3|\x84L3;|;" [decl?
julia_flisp.boot:  length= :: |#self#|]) decl? |#self#| core Typeof fix-arglist arglist-unshift
julia_flisp.boot:  any kwarg? caar parameters (curly where) expand-forms method-def-expr] expand-function-def-)
julia_flisp.boot:	  expand-fuse-broadcast #fn("@000r2]]\x8c7c0m62g7c1g7q1O2g7M}]32e2|31g6g8316\\0|\x85D0e3c4c5c6L2g8NL341;e3c4c5c7L2g9g8NL441;|\x8590e3g841;e3c4c5c7L2g9c4c5c8L2c5c9L2g8L4L441;" [#fn("6000r1|F16802|Mc0<;" [fuse] fuse?)
julia_flisp.boot:  has-parameters? reverse cdar] split-kwargs) parameters #fn(map)
julia_flisp.boot:  #fn(copy-list) fuse] make-fuse) length= |.| caddr quote inert $ call top
julia_flisp.boot:  getproperty tuple identifier-name ^ #fn(integer?) (top literal_pow)
julia_flisp.boot:  expand-forms core apply_type Val error #fn(string) "invalid syntax \""
julia_flisp.boot:  deparse "\"" #fn(">000r2e0|31c1<16E02e2}b23216902c3}\x84316X0~Mc4|}Me5c6c6c7c8L2c9c:L2}\x84L4L231L342;~M|}42;" [identifier-name
julia_flisp.boot:  ^ length= #fn(integer?) (top literal_pow) expand-forms call core apply_type
julia_flisp.boot:  top Val] make-fuse-) make-fuse- dotop-named? undotop cddr comparison
julia_flisp.boot:  expand-compare-chain .&& (top andand) |.\|\|| (top oror)] dot-to-fuse)
julia_flisp.boot:  ref-to-view expand-forms call top materialize materialize! broadcasted
julia_flisp.boot:  identity] expand-fuse-broadcast)
julia_flisp.boot:	  expand-generator #fn("D000r3|\x84e0|31Mc1<g86>0e2e0|3131570e2|31c3e0g932e4g:a32680g:M5H0c5c6L1c7c8L2L1c9g:3133g86O0c6c7c:L2e;e0|31\x84g9^_34g;L4540g;c6c7c<L2e;g7g9}g234g<L4e=}6A0c6c7c>L2g=L3540g=41;" [caddr
julia_flisp.boot:  filter cddr #fn(map) length= #fn(nconc) call top product #fn(copy-list)
julia_flisp.boot:  Filter func-for-generator-ranges Generator expand-forms Flatten] expand-generator)
julia_flisp.boot:	  expand-if #8=#fn(";000r1c0|Me1|\x8431c2e3e4|313243;" [#fn(list*)
julia_flisp.boot:								expand-condition
julia_flisp.boot:								expand-forms
julia_flisp.boot:								cddr] expand-if)
julia_flisp.boot:	  expand-let #17=#fn("@000\x8910002000\x8a1000760]m12e0|31e1|31}670c2530_e3g7\x85K0c4c5c6L1c7g831g6L133L25P0]\x8c:g:c8g:g8q2O2g:M\x8e1e9g731g63241;" [caddr
julia_flisp.boot:  let-binds ((hardscope)) expand-forms scope-block #fn(nconc) block #fn(copy-list)
julia_flisp.boot:  scope-block #fn(nconc) block #fn(copy-list) local length= caar =
julia_flisp.boot:  eventually-call? cadar assigned-name error "invalid let syntax"
julia_flisp.boot:  expr-contains-eq caddar local-def decl-var make-ssavalue caadar tuple
julia_flisp.boot:  lhs-vars #fn(map) #fn("6000r1c0|L2;" [local-def])]) reverse] expand-let)
julia_flisp.boot:	  expand-local-or-global-decl #10=#fn("9000r1|\x84C16:02e0|b232640|;e1e2|M|N^3341;" [length=
julia_flisp.boot:  expand-forms expand-decls] expand-local-or-global-decl)
julia_flisp.boot:	  expand-macro-def #7=#fn("B000r1|\x84F16B02|\x84Mc0<16702|\x84\x84C6\xa70e1e2|\x843131e3g5316;0e4c531530]2e6c7c8L1c7c0L1c9c:c;|\x84\x843231L1c<c=c>c?L2L3L1c<c@c>cAL2L3L1cBcCcDg5323135L1cBe2|31313341;eE|b23216602|\x84C6G0e6c8c9c:c;|\x843231L241;e4cF41;" [call
julia_flisp.boot:  remove-empty-parameters cddr has-parameters? error "macros cannot accept keyword arguments"
julia_flisp.boot:  expand-forms #fn(nconc) function #fn(symbol)
julia_flisp.boot:  #fn(string) #\@ :: __source__ core LineNumberNode __module__ Module #fn(copy-list)
julia_flisp.boot:  #fn(map) #fn("7000r1|C6:0c0c1|L3;|;" [meta nospecialize]) length= "invalid macro definition"] expand-macro-def)
julia_flisp.boot:	  expand-ncat #16=#fn("S000\x8910002000\x8a1000770c0m12]]]]]]]]]\x8c6\x8c8\x8c9\x8c:\x8c<g6c1O2c2g6q1m72g8c3O2g9c4g6g9g8q3O2g:c5g6g:q2O2c6g8q1m;2g<c7g6g<q2O2c8m=2c9m>2|\x84e:|31g<Mg@31gAMgB\x8560^540gBe;gAN31e<e=gD326F0e>c?c@eA|31cB3331530]2eCgD316;0e>cD31530]2eEg7g@316L0cFcGL1cH}31g?L1cHgD31345\xc20e<eIgD326?0e>c?cJ31315\xaa0g9Mg@gCg?33g;gF316q0cFcKL1cHe;g:Mg@gCg?33313132cFcGL1cH}31gGL1g=gC31L1cHgD3135\x8e15U0cFcGL1cH}31g>gF31L1g=gC31L1cHgD3135\x8e141;" [((top
julia_flisp.boot:  hvncat)) #fn("6000r1|F16B02|Mc0<17802|Mc1<;" [row nrow] is-row)
julia_flisp.boot:  #fn("7000r1e0~M|32@;" [any] is-1d) #fn("8000r1e0c1`|43;" [foldl #.+] sum)
julia_flisp.boot:  > 1+ row cddr] get-next) #fn(length) 1- #fn(map)
julia_flisp.boot:  #fn("9000r1~M\x7fM|31i2e0i33143;" [1-])
julia_flisp.boot:  #fn("6000r1c0|v2;" [#fn(append)])] get-shape)
julia_flisp.boot:  cdar caar nrow 1+ cadar cddar 1-] get-dims)
julia_flisp.boot:  #fn("6000r1|~x;" [])]) #.car] is-balanced)
julia_flisp.boot:  reverse])] hasrows-flatten) #fn("5000r1|650c0;c1;" [(true) (false)] tf)
julia_flisp.boot:  "misplaced assignment statement in \"" deparse "\"" has-parameters? "unexpected parameters in array expression"
julia_flisp.boot:  expand-forms #fn(nconc) call #fn(copy-list) vararg? "Splatting ... in an hvncat with multiple dimensions is not supported"
julia_flisp.boot:  tuple] expand-ncat)
julia_flisp.boot:	  expand-or #fn("9000r1e0c1|32N]\x8c6g6c2g6q1O2g6M\x8e1g541;" [flatten-ex
julia_flisp.boot:  symbol-like? if make-ssavalue block =])] expand-or)
julia_flisp.boot:	  expand-property-destruct #fn("A000r2e0|a327G0e1c2c3e4e531c63331530]2e7}31660}560e830}g6\x8260_5?0e9g6e:}3132L1c;c<L1c=g731c=c>c?g6q1e@|313231cAg6L2L144;" [length=
julia_flisp.boot:  symbol-like? make-ssavalue sink-assignment expand-forms #fn(nconc) block #fn(copy-list)
julia_flisp.boot:  expand-forms = call top getproperty quote]) cdar unnecessary] expand-property-destruct)
julia_flisp.boot:	  expand-scalar-compare #fn("9000r1e0|c1c2e344;" [comp-accum #fn("7000r2c0|}L3;" [&&])
julia_flisp.boot:  dotop-named?]) compare-one] expand-scalar-compare)
julia_flisp.boot:	  expand-struct-def #11=#fn("=000r1|\x84e0|31e1|31N]\x8c8g8c2g8q1O2g8M\x8e1g7312e3e4c5g6q1c6g7g5q23241;" [caddr
julia_flisp.boot:  expand-forms call-with-values #fn("6000r0e0~41;" [analyze-type-sig])
julia_flisp.boot:  #fn(":000r3e0|}g2~\x7f45;" [struct-def-expr])] expand-struct-def)
julia_flisp.boot:	  expand-table #table(macro #7#  --> #fn(":000r1e0c1c2L1c3L1c4|N313341;" [expand-forms
julia_flisp.boot:  #fn(nconc) call --> #fn(copy-list)])  = #9=#fn("=000r1e0c1|M31e2c3c4g6`c5g631ax3331c6g6`32c7W670c8540c9|\x84e:|3134\x8e141;" [expand-forms
julia_flisp.boot:  #fn(string) expand-update-operator #fn(symbol)
julia_flisp.boot:  #\. .= = caddr] lower-update-op)  elseif #8#  .+= #9#  generator #fn("8000r1e0|312e1|^_43;" [check-no-return
julia_flisp.boot:  expand-generator])  %= #9#  /= #9#  local #10#  >>>= #9#  .^= #9#  typed_comprehension #fn(";000r1e0e1|31c2<16o02e3e4|3131e5c6g6326;0e7c831530]2e9c:g63216A02e;|\x84e4|31\x84g633\x8e117D02c<c=c>L2|\x84e4|31L441;" [expand-forms
julia_flisp.boot:  every #fn("6000r1|F16802|Mc0<;" [=]) lower-comprehension call top collect])  <<= #9#  :: #fn(";000r1e0|b3327;0e1c231530]2e3|\x84317L0c4c5c6L2e7|\x8431e7e8|3131L4;c9e7|42;" [length=
julia_flisp.boot:  error "invalid \"::\" syntax" symbol-like? call core typeassert expand-forms
julia_flisp.boot:  "\"" expand-forms #fn(nconc) call top hcat #fn(copy-list)])  tuple #fn(":000r1e0|a3216C02|\x84F16;02e1|31c2<6O0e3|b2326>0e4e5|\x84N3141;e6c741;e8e9|N326=0e4e5|N3141;e4c:c;L1c<c=L2L1c>|N313341;" [length>
julia_flisp.boot:  caadr parameters length= expand-forms lower-named-tuple error "unexpected semicolon in tuple"
julia_flisp.boot:  any assignment? #fn(nconc) call core tuple #fn(copy-list)])  $= #9#  = #9#  typed_ncat #fn(":000r1|\x84|Ne0g6c1c2L2g5L242;" [expand-ncat
julia_flisp.boot:  top typed_hvncat])  typed_vcat #fn("<000r1|\x84|Ne0g6c1c2L2g5L2c1c3L2g5L2c1c4L2g5L244;" [expand-vcat
julia_flisp.boot:  top typed_vcat typed_hvcat typed_hvcat_rows])  |.\|\|| #fn("7000r1e0_|42;" [expand-fuse-broadcast])  flatten #fn("8000r1e0|\x84]_43;" [expand-generator])  += #9#  .= #fn("8000r1e0|\x84e1|3142;" [expand-fuse-broadcast
julia_flisp.boot:  caddr])  .&& #fn("7000r1e0_|42;" [expand-fuse-broadcast])  string #fn("<000r1e0c1c2L1c3c4L2L1c5c6c7|N32313341;" [expand-forms
julia_flisp.boot:  #fn(nconc) call top string #fn(copy-list)
julia_flisp.boot:  loop-cont)])  abstract #fn("9000r1|\x84e0e1c2g5q1c33241;" [expand-forms
julia_flisp.boot:							     call-with-values
julia_flisp.boot:							     #fn("6000r0e0~41;" [analyze-type-sig])
julia_flisp.boot:							     #fn("8000r3e0|}g243;" [abstract-type-def-expr])])  braces #fn("6000r1e0c141;" [error
julia_flisp.boot:  "{ } vector syntax is discontinued"])  ... #fn("6000r1e0c141;" [error "\"...\" expression outside call"])  global #10#  -> #12#  .//= #9#  |\|\|| #fn("7000r1e0e1|3141;" [expand-forms
julia_flisp.boot:  expand-or])  -= #9#  vcat #19=#fn("E000\x8910004000\x8a1000770c0m12\x8a2000770c1m22\x8a3000770c2m32|Ne3e4g8326F0e5c6c7e8|31c93331530]2e:g831690e5c;41;e<e3c=g8326\x950c>c?g832e3c@g:326O0cAcBL1cCg331cCc>cDg:3231335`0cAcBL1cCg231cAcEL1cCc>cFg:323132L1cCcGg:Q23134\x8e15E0cAcBL1cC}31cCg8313341;" [((top
julia_flisp.boot:  "misplaced assignment statement in \"" deparse "\"" has-parameters? "unexpected semicolon in array expression"
julia_flisp.boot:  expand-forms #fn("6000r1|F16802|Mc0<;" [row])
julia_flisp.boot:  #fn("7000r1e0e1|42;" [any vararg?]) #fn(nconc) call #fn(copy-list)
julia_flisp.boot:  #fn("8000r1c0c1L1c2|3142;" [#fn(nconc) tuple #fn(copy-list)]) tuple #fn(length)
julia_flisp.boot:  #fn(append)] expand-vcat)  ./= #9#  try #18=#fn("B000r1|\x84e0|31e1|31e2|b5326v0e3g5316;0e4c531530]2e1|N31e6c7g7c8>7?0c9g5g6g7L4580c:g5L2c:g8L2L341;e2|b4326q0e6e;g6316S0c<c:g5L2c:c=c>g6c?L1L3g7L3L2L35B0c<c:g5L2c:g7L2L341;e4c@41;" [caddr
julia_flisp.boot:  cadddr length= has-unmatched-symbolic-goto? error "goto from a try/finally block is not permitted"
julia_flisp.boot:  expand-forms tryfinally (false) try scope-block symbol-like? trycatch block
julia_flisp.boot:  = the_exception "invalid \"try\" form"] expand-try)  const #13#  break #fn("5000r1|NF640|;c0;" [(break
julia_flisp.boot:  loop-exit)])  = #fn("a000r1]]]\x8c6\x8c7|\x84m52g6c0O2g7c1O2g6Mg5316?0e2g7Mg5|3241;g5F16902g5Mc3<6>0e4|\x84e5|3142;e6e5|31316T0]\x8c8g8c7g6g8g7q3O2g8M\x8e1g5L1e5|3142;e8g53116902e9g53117D02e:g53117902e;g5316B0e<g5e2e5|313142;g5?6E0e=c>c?e@g531cA3341;g5Mg8cB=6C1g5\x84e5g531e5|31eCg:b23216902g:McD<6V0e=c>cEc>e@g931cFe@g:\x8431cG34cA3331530]2e8g931670g9560eH30g:?17L02e8g:3117A02g:F16902eIg:31670g:560eH30e8g;3117602g;?670g;560eH30cJcKL1g<g9\x8260_5@0e<g<e2g93132L1g=g:\x8260_5@0e<g=e2g:3132L1g>g;\x8260_5@0e<g>e2g;3132L1cLcMcNL2g<g=g>L5L1cOg>L2L146;g8cD=6U0g5Ne5|31ePg9316;0eQg9g:42;eRg9g:42;g8cS=690e=cT41;cUg8cV32690e=cW41;g8cX=6\xce0g5\x84eYg531e5|31g9F16;02eZc[g:32g<690eH30540g9g<6C0c\\g=e2g931L3L1530_g;F16F02e]g;31@16:02eIg;31@g?690eH30540g;g?6C0e<g@e2g;3132L1530_e^c_g=g:q2c`g>gAg=g@q442;g8ca=6\x900eYg531\x85G0e=c>c?e@g531cA3331530]2g5\x84e5g531e5|31ebg931e2cJcKL1ccg<N31cdg<Mg:L3L1c\\g<Mg;L3L13441;cUg8ce32690e=cf41;e=c>c?e@g531cA3341;" [#fn("6000r1|F16_02|Mc0<17U02|Mc1<17K02|Mc2<16A02|\x84F16902|\x84Mc0<;" [call
julia_flisp.boot:  where ::] function-lhs?) #fn("6000r2c0}NK;" [function] assignment-to-function)
julia_flisp.boot:  expand-forms curly expand-unionall-def caddr assignment? #fn("@000r2e0}3116:02~M}\x8431@6@0\x7fM}\x84|Ke1}3142;e2}31660}560e330e4c5c6L1g6}\x8260_5N0c7g6e0}316=0i2M}\x84}32530}L3L1c8c9c:g6q1|3231c;g6L2L13441;" [assignment?
julia_flisp.boot:  caddr symbol-like? make-ssavalue expand-forms #fn(nconc) block = #fn(copy-list)
julia_flisp.boot:  #fn(map) #fn("7000r1c0|~L3;" [=]) unnecessary]) symbol-like? valid-name?
julia_flisp.boot:  globalref? outerref? sink-assignment error #fn(string)
julia_flisp.boot:  ".(" ") = ..." make-ssavalue quoted? #fn(nconc) block call top setproperty!
julia_flisp.boot:  unnecessary has-parameters? expand-property-destruct
julia_flisp.boot:  expand-tuple-destruct typed_hcat "invalid spacing in left side of indexed assignment"
julia_flisp.boot:  ref cddr contains #fn("6000r1|c0<;" [end]) = ssavalue? call-with-values #fn("7000r0e0~\x7f42;" [process-indices])
julia_flisp.boot:  block #fn(copy-list) #fn(map) expand-forms call top setindex! unnecessary])
julia_flisp.boot:  :: remove-argument-side-effects #fn(copy-list) decl (vcat ncat)
julia_flisp.boot:  "use \"(a, b) = ...\" to assign multiple values"])  |'| #fn("8000r1e0c1c2|\x84L341;" [expand-forms
julia_flisp.boot:  dotop-named? expand-fuse-broadcast |.| undotop #fn(nconc) tuple #fn(copy-list)
julia_flisp.boot:  "ccall argument types must be a tuple; try \"(T,)\"" expand-forms lower-ccall
julia_flisp.boot:  any kwarg? lower-kw-call has-parameters? call vararg? #fn(";000r2|\x85P0}\x8540_;c0c1L1c2c3L2L1e4}3133L1;|Me5g6b23216902g6Mc6<6i0}\x85A0c7g6\x84~M|N_3242;c7c0c1L1c2c3L2L1e4}3133g6\x84~M|N_3243;~M|Ng6}K42;" [#fn(nconc)
julia_flisp.boot:  call core tuple reverse length= ... #fn(list*)] tuple-wrap) core
julia_flisp.boot:  _apply_iterate top iterate identifier-name ^ #fn(integer?) literal_pow
julia_flisp.boot:  deparse "\"" expand-forms #fn(nconc) call top typed_hcat #fn(copy-list)])  function #15#  local-def #10#  .*= #9#  .&= #9#  |.\|=| #9#  .= #9#  .= #9#  comprehension #fn(":000r1e0|b2326I0e1c2c3c4L1c5|N3132L241;e6|31c4<16?02e7c8e9|\x8431326;0e:c;31530]2e1c<c=c>L2|\x84L341;" [length>
julia_flisp.boot:  expand-forms comprehension #fn(nconc) generator #fn(copy-list) caadr any #fn("6000r1|c0<;" [:])
julia_flisp.boot:  expand-forms expand-for #fn(map) cadr caddr])  soft-let #fn("7000r1e0|^42;" [expand-let])  .<<= #9#  gc_preserve #fn(">000r1e030e030c1c2g5c3c4L1c5e6|313132L3c2g6e7|\x8431L3c8g5L2g6L5;" [make-ssavalue
julia_flisp.boot:  block = #fn(nconc) gc_preserve_begin #fn(copy-list) cddr expand-forms
julia_flisp.boot:  gc_preserve_end])  ncat #16#  line #fn("5000r1|k02|;" [*current-desugar-loc*])  where #fn("9000r1e0e1|\x84e2|313241;" [expand-forms
julia_flisp.boot:  expand-wheres cddr])  curly #fn("A000r1e0e1|31316F0e2c3c4e5|31c63331530]2e7e8e1|31326F0e2c3c9e5|31c63331530]2e:|31g5Mg5Ng7\x85M0e;c<c=L1c>c?L2L1c@|N313341;e;c<cAL1c<cBL1|\x84L1c@g63133L1c@g7313341;" [has-parameters?
julia_flisp.boot:  extract-implicit-whereparams expand-forms #fn(nconc) call core apply_type #fn(copy-list)
julia_flisp.boot:  has-parameters? error "unexpected semicolon in array expression" expand-forms
julia_flisp.boot:  partially-expand-ref])  <: #fn(":000r1e0c1c2L1c3L1c4|N313341;" [expand-forms
julia_flisp.boot:								  call <: #fn(copy-list)])  .>>>= #9#  >: #fn(":000r1e0c1c2L1c3L1c4|N313341;" [expand-forms
julia_flisp.boot:  #fn(nconc) call >: #fn(copy-list)])  if #8#  *= #9#  |\|=| #9#  .-= #9#  .>>= #9#  lambda #fn(">000r1c0c1L1c2e3|\x8432L1c4e5|b332670c6530_31c4c2e3e7|31323144;" [#fn(nconc)
julia_flisp.boot:  lambda #fn(map) expand-forms #fn(copy-list) length= (()) cddr])  comparison #fn("7000r1e0e1|N3141;" [expand-forms
julia_flisp.boot:  expand-compare-chain])  && #fn("7000r1e0e1|3141;" [expand-forms expand-and])  block #fn("8000r1|N\x8550c0;e1|31A16:02e2|\x8431@690e3|\x8441;c4c5e3|N32K;" [(null)
julia_flisp.boot:  cddr linenum? expand-forms block #fn(map)])  let #17#  $ #fn("6000r1e0c141;" [error
julia_flisp.boot:  caddr expand-forms has-parameters? #fn(nconc) call #fn(copy-list)])  bracescat #fn("6000r1e0c141;" [error
julia_flisp.boot:  call top BroadcastFunction expand-fuse-broadcast])  vect #fn("<000r1e0|N316;0e1c231530]2e3e4|N326F0e1c5c6e7|31c83331530]2e9c:c;L1c<c=L2L1c>|N313341;" [has-parameters?
julia_flisp.boot:  "misplaced assignment statement in \"" deparse "\"" expand-forms #fn(nconc)
julia_flisp.boot:  call top vect #fn(copy-list)])  ^= #9#  primitive #fn(";000r1|\x84e0|31e1e2c3g5q1c4g6q13241;" [caddr
julia_flisp.boot:  expand-forms call-with-values #fn("6000r0e0~41;" [analyze-type-sig])
julia_flisp.boot:  #fn("9000r3e0~|}g244;" [primitive-type-def-expr])])  while #20=#fn("?000r1c0c1c2e3|\x8431c0c4c5e6e7e8|313131L2L3L3L3;" [break-block
julia_flisp.boot:  loop-exit _while expand-condition loop-cont scope-block blockify expand-forms
julia_flisp.boot:  caddr] expand-while)  opaque_closure #fn("J000r1e0e0e1|\x84313131e2g531e0g531g7F16902g7Mc3<670g7580c3g7L2e4g831Ne5g831e0g:31e6e2g:3131e7g;31e8g:31\x84e9g=`326N0c:e1c;c<c=L2L231c>L1`g>g6L6;e?30e1e5g=3131c@e4g=31c3cAg?g@L3L2L132eBcCe1cDc;L1c<c=L2L1cEgA313331eFg<3133c:gBcGc<cHL2g?c<cIL2L4cJgA31g>g6L6;" [caddr
julia_flisp.boot:  expand-forms cadddr block butlast last cddr cdddr caddddr length=
julia_flisp.boot:  _opaque_closure curly core Tuple false make-ssavalue #fn(append) = foldl #fn("8000r2c0c1c2L2|}L4;" [call
julia_flisp.boot:  core UnionAll]) #fn(nconc) #fn(copy-list) reverse call isa TypeofVararg #fn(length)]))
julia_flisp.boot:	  expand-to-thunk- #fn("9000r3e0c1|}g2q341;" [error-wrap #fn("8000r0e0~\x7fi243;" [expand-toplevel-expr])] expand-to-thunk-)
julia_flisp.boot:	  expand-to-thunk-stmt- #fn("9000r3e0e1|31660|5;0c2|c3L1L3}g243;" [expand-to-thunk-
julia_flisp.boot:  toplevel-only-expr? block null] expand-to-thunk-stmt-)
julia_flisp.boot:	  expand-toplevel-expr #fn(";000r3|?17802e0|316G0c1|316;0e2c331530]2|;e4g77=0e5302]k4530]2e6|}g233g7k42;" [toplevel-only-expr?
julia_flisp.boot:  #fn(underscore-symbol?) error "all-underscore identifier used as rvalue"
julia_flisp.boot:  *in-expand* reset-gensyms expand-toplevel-expr--] expand-toplevel-expr)
julia_flisp.boot:	  expand-toplevel-expr-- #fn("=000r3e0|31e1g731650g7;e2g7}g233e3c4__c5e6g831L2L4}g233e7e8g93131A16y02e9e:g931b23216h02e;e:g931\x843116X02e<e:g93131g:F16902g:Mc4<17902e=g:31\x8e16=0e<e:g93141;c>g9L2;" [julia-expand-macroscope
julia_flisp.boot:  toplevel-only-expr? julia-expand0 julia-expand1 lambda scope-block blockify
julia_flisp.boot:  cdadr caddr length= lam:body return? cadadr simple-atom? thunk] expand-toplevel-expr--)
julia_flisp.boot:	  expand-try #18# expand-tuple-destruct
julia_flisp.boot:	  #fn("L000r2]\x8c6g6c0g6q1O2}F16f02|F16_02}Mc1<16U02e2e3}N32@16G02e4}N31@16;02g6M|}N326=0e5e6|}3241;c7k82e8}|32@16502}C17802e9}31660}5_0|F16K02e:e;|313116=02e<e;|31\x8431690e=30560e>30}g7\x8260_5?0e?g7e5}3132L1c@|31eAg9`326Z0e;|31e:g:3116:02cBg:\x8431690g9ax540g9\x8e1540g9e=30_\x8c<cCcDL1cEeAg:`326=0cFg;L2L1530_31cEg831cEcGcHg<g7g;g:q4eIg:31|3331cEeJg<M3131cKg7L2L146;" [#fn("7000r2|\x8550}A;e0|M31640];}\x8540^;e0}M31660}NA;~M|N}N42;" [vararg?] sides-match?)
julia_flisp.boot:  tuple any assignment? has-parameters? expand-forms tuple-to-assignments
julia_flisp.boot:  error #fn(string) "invalid \"...\" on non-final assignment location \"" "\""
julia_flisp.boot:  in-lhs?] in-lhs?) in-lhs? ssavalue? vararg? last eventually-call? gensy
julia_flisp.boot:  make-ssavalue sink-assignment #fn(length) > #fn(underscore-symbol?)
julia_flisp.boot:  #fn(nconc) block #fn(copy-list) local #fn(map)
julia_flisp.boot:  vararg? ... eventually-call? gensy make-ssavalue expand-forms = #fn(nconc)
julia_flisp.boot:  call top rest #fn(copy-list) lower-tuple-assignment indexed_iterate]) iota
julia_flisp.boot:  reverse unnecessary] expand-tuple-destruct)
julia_flisp.boot:	  expand-unionall-def #fn("A000r2|F16802|Mc0<6\x840|\x84e1|31g7\x85P0e2c3c4e5c6c0g6L2}L331c73331530]2c8c9g6L2e:c6g6c;c<L1}L1c=g73133L331L3;e:c>c6|}L3L241;" [curly
julia_flisp.boot:  const-if-global expand-forms #fn(nconc) where #fn(copy-list) const] expand-unionall-def)
julia_flisp.boot:	  expand-update-operator #fn("I000s4g2F16902g2Mc0<6}0e1g231e2g9N31e3g9N31c4c0L1e5g;31L1c6e7g;313133c4c8L1c6g:31e9|}g<g3g435L143;g2F16902g2Mc:<6^0e;g2\x8431e5g231c4c8L1c6g9N31e<|}g9Mg3g:35L143;g2F16F02}c=<16=02c>g2Mc?32@6G0e@cAcBeCg231cD3331530]2e9|}g2g3g445;" [ref
julia_flisp.boot:  partially-expand-ref butlast last #fn(nconc) caddr #fn(copy-list) cdddr block
julia_flisp.boot:  expand-update-operator- :: remove-argument-side-effects
julia_flisp.boot:  expand-update-operator = #fn(memq) (|.| tuple vcat ncat typed_hcat typed_vcat
julia_flisp.boot:  "invalid assignment location \"" deparse "\""] expand-update-operator)
julia_flisp.boot:	  expand-update-operator- #fn("F000r5e0g231g9M}c1<16c02g:F16[02g:Mc2<17F02g:Mc3<16;02e4g:b332@16702e530g;6I0g;c6g9Nc7g;g:L3L132K540g9g;17502g:g2F16902g2Mc8<6O0]\x8c>g>c9g>q1O2g>M\x8e1g=Ng2N32530]2c:c;L1c<g<N31g4\x85C0}g=c=|g=g3L4L35G0}g=c=|c>g=g4ML3g3L4L3L143;" [remove-argument-side-effects
julia_flisp.boot:  .= ref |.| length= make-ssavalue #fn(append) = tuple #fn("9000r2|F6g0e0|M3116:02e0}M31@6G0e1c2c3e4}M31c53331530]2~M|N}N42;];" [ssavalue?
julia_flisp.boot:  #fn(nconc) block #fn(copy-list) call ::] expand-update-operator-)
julia_flisp.boot:	  expand-vcat #19# expand-vector-compare
julia_flisp.boot:	  #fn("9000r1e0|c1c2c344;" [comp-accum #fn("8000r2c0c1|}L4;" [call .&])
julia_flisp.boot:				    #fn("6000r1e0|\x8431680e1|41;e2|41;" [dotop-named?
julia_flisp.boot:  compare-one expand-scalar-compare])] expand-vector-compare)
julia_flisp.boot:	  expand-where #fn("<000r2e0}31g6Mc1c2g7e3g631L3c4c5c6L2g7|L4L3;" [analyze-typevar
julia_flisp.boot:  let = bounds-to-TypeVar call core UnionAll] expand-where)
julia_flisp.boot:	  expand-wheres #fn("8000r2}\x8540|;e0e1|}N32}M42;" [expand-where
julia_flisp.boot:							     expand-wheres] expand-wheres)
julia_flisp.boot:	  expand-while #20# expect-end
julia_flisp.boot:	  #fn("8000r2e0|31g6c1\x8280e2|41;e3g6}42;" [peek-token end take-token
julia_flisp.boot:						     expect-end-error] expect-end)
julia_flisp.boot:	  expect-end-current-line 0 expect-end-error
julia_flisp.boot:	  #fn("?000r2c0|316H0e1c2c3}c4e5c6e7c83741;e1c2c9}c4e5c6e7c:|c93941;" [#fn(eof-object?)
julia_flisp.boot:  error #fn(string) "incomplete: \"" "\" at " current-filename ":"
julia_flisp.boot:  expect-end-current-line " requires end" "\"" " expected \"end\", got \""] expect-end-error)
julia_flisp.boot:	  expect-space-before #fn("9000r2e0|317@0e1c2c3}c43341;];" [ts:space?
julia_flisp.boot:								    "\""] expect-space-before)
julia_flisp.boot:	  expr-contains-eq #fn("7000r2}|<17P02}F16I02e0}31@16>02e1c2|q1}N42;" [quoted?
julia_flisp.boot:  any #fn("7000r1e0~|42;" [expr-contains-eq])] expr-contains-eq)
julia_flisp.boot:	  expr-contains-p #fn("9000\x8920003000\x8a2000770c0m22g2}3116[02|}3117R02}F16K02e1}31@16@02e2c3|g2q2}N42;" [#fn("5000r1];" [])
julia_flisp.boot:  quoted? any #fn("8000r1e0~|\x7f43;" [expr-contains-p])] expr-contains-p)
julia_flisp.boot:	  expr-find-all #fn(">000\x8930004000\x8a3000770c0m32g3}316l0|}316<0g2}31L1530_}?17802e1}31650g8;c2g8c3c4|g2g3q3}N32v3;_;" [#fn("5000r1];" [])
julia_flisp.boot:  quoted? #fn(nconc) #fn(map) #fn("9000r1e0~|\x7fi244;" [expr-find-all])] expr-find-all)
julia_flisp.boot:	  extend-env #fn("8000r3e0}g2`33|K;" [vars-to-env] extend-env)
julia_flisp.boot:	  extract-implicit-whereparams #fn("9000r1]\x8c5g5c0g5q1O2g5Me1|31__43;" [#fn("<000r3|\x85?0e0}31e0g231K;|Me1g7b23216D02g7Mc2<17902g7Mc3<6N0e430~M|Ng8}Kg7Mg8g7\x84L3g2K43;~M|Ng7}Kg243;" [reverse
julia_flisp.boot:  length= <: >: gensy] extract) cddr] extract-implicit-whereparams)
julia_flisp.boot:	  extract-line-file #fn("7000r1|@17502|A650c0;|Mc1<790e2c341;e4|b232690|\x84c5L2;|N;" [(0
julia_flisp.boot:  none) line error "lno is not a line number node" length= none] extract-line-file)
julia_flisp.boot:	  extract-method-prologue #fn("7000r1|F6;0e0c1|N42;_;" [take-while #fn("6000r1|F16B02|Mc0<17802|Mc1<;" [line
julia_flisp.boot:  meta])] extract-method-prologue)
julia_flisp.boot:	  fe #fn("8000r1e0e1|31c2`43;" [expand-toplevel-expr julia-parse none] fe)
julia_flisp.boot:	  fill-missing-argname #fn("8000r2|F16C02|Mc0<16902e1|31A6F0c0}670e2560e330|\x84L3;|;" [::
julia_flisp.boot:  cddr UNUSED gensy] fill-missing-argname)
julia_flisp.boot:	  filter #fn("9000r2]c0|q1m62g6|}_L143;" [#fn("8000r3g2]}F6Q02~}M316?0g2}M_KPNm2530]2}Nm15\x0e/2N;" [] filter-)] filter)
julia_flisp.boot:	  filter-sparams #fn("9000r2]\x8c6g6c0|g6q2O2g6M\x8e1_}42;" [#fn("7000r2}\x8580e0|41;e1e2}31~3217>02e3c4}q1}N326=0\x7fM}M|K}N42;\x7fM|}N42;" [reverse!
julia_flisp.boot:  expr-contains-eq caar any #fn("7000r1e0e1~31|42;" [expr-contains-eq caar])])] filter-sparams)
julia_flisp.boot:	  find-assigned-vars #fn(":000r1]]\x8c5\x8c6g5_O2g6c0g5g6q2O2g6M|312e1g5M41;" [#fn(";000r1|F@17802e0|31640_;|Mc1g5c232640_;g5c3=6c0e4e5|3131g6C6<0~g6~MKO530]2e6|b2327<0\x7fMe7|3141;];g5c8=6v0e4|\x8431\x7fMe7|31312e9g63117O02e:g63117D02e;g63117902c<g631640_;~g6~MKO;c=\x7fM|N42;" [quoted?
julia_flisp.boot:  #fn(memq) (lambda scope-block module toplevel) method decl-var
julia_flisp.boot:  method-expr-name length= caddr = ssavalue? globalref? outerref? #fn(underscore-symbol?)
julia_flisp.boot:  #fn(for-each)] find-assigned-vars-) delete-duplicates] find-assigned-vars)
julia_flisp.boot:	  find-assigned-vars-in-expansion
julia_flisp.boot:  escape hygienic-scope resume-on-escape #fn("7000r1e0|~42;" [find-assigned-vars-in-expansion])
julia_flisp.boot:  function-def? = decl-var* function tuple #fn(append!) filter #.symbol?
julia_flisp.boot:  decl-vars* find-assigned-vars-in-expansion caddr #fn(map)
julia_flisp.boot:  #fn("8000r1e0e1|316:0e2|31530|^42;" [find-assigned-vars-in-expansion
julia_flisp.boot:  #fn("7000r1e0|^42;" [find-assigned-vars-in-expansion])] find-assigned-vars-in-expansion)
julia_flisp.boot:	  find-declared-vars-in-expansion
julia_flisp.boot:  escape hygienic-scope resume-on-escape #fn("8000r1e0|~\x7f43;" [find-declared-vars-in-expansion])
julia_flisp.boot:  #fn(map) decl-var* function-def? #fn(append!)
julia_flisp.boot:  #fn("8000r1e0|~^43;" [find-declared-vars-in-expansion])] find-declared-vars-in-expansion)
julia_flisp.boot:	  find-decls #fn(";000r2]]\x8c6\x8c7g6_O2g7c0|g6g7q3O2g7M}312g6M;" [#fn("7000r1|F@17802e0|31640_;c1|Mc232640_;|M~\x82I0c3|\x8431640_;\x7fe4|\x8431\x7fMKO;c5i2M|N42;" [quoted?
julia_flisp.boot:  #fn(memq) (lambda scope-block module toplevel)
julia_flisp.boot:  #fn(underscore-symbol?) decl-var #fn(for-each)] find-decls-)] find-decls)
julia_flisp.boot:	  find-global-decls #fn("7000r1e0c1|42;" [find-decls global] find-global-decls)
julia_flisp.boot:	  find-local-decls #fn("7000r1e0c1|42;" [find-decls local] find-local-decls)
julia_flisp.boot:	  find-local-def-decls #fn("7000r1e0c1|42;" [find-decls local-def] find-local-def-decls)
julia_flisp.boot:	  find-scope-decl #fn("8000r2e0c1}q1|c243;" [expr-contains-p #fn("6000r1|F16=02|M~<16402|;" [])
julia_flisp.boot:  (lambda scope-block module toplevel)])] find-scope-decl)
julia_flisp.boot:	  find-symbolic-label-defs #fn("8000r2|F@17802e0|31640_;|Mc1\x82;0c2}|\x84]43;c3c4}q1|42;" [quoted?
julia_flisp.boot:  symboliclabel #fn(put!) #fn(for-each) #fn("7000r1e0|~42;" [find-symbolic-label-defs])] find-symbolic-label-defs)
julia_flisp.boot:	  find-symbolic-label-refs #fn("8000r2|F@17802e0|31640_;|Mc1\x82;0c2}|\x84]43;c3c4}q1|42;" [quoted?
julia_flisp.boot:  symbolicgoto #fn(put!) #fn(for-each) #fn("7000r1e0|~42;" [find-symbolic-label-refs])] find-symbolic-label-refs)
julia_flisp.boot:	  first-non-meta #fn("8000r1]\x8c5g5c0g5q1O2g5M\x8e1|N41;" [#fn("7000r1|\x8540^;|Mg5F16902g5Mc0<690~M|N41;g5;" [meta])] first-non-meta)
julia_flisp.boot:	  fits-i8 #fn("7000r1|I16F02e0|b\xb03216:02e1|b\xaf42;" [>= <=] fits-i8)
julia_flisp.boot:	  fix-arglist #fn("9000\x8910002000\x8a1000760]m12e0e1e2|31326;0e3c431530]2c5c6}q1|42;" [any
julia_flisp.boot:  vararg? butlast error "invalid \"...\" on non-final argument"
julia_flisp.boot:  fill-missing-argname caddr ...])] fix-arglist)
julia_flisp.boot:	  fix-function-arg-type #fn("F000r5e0|31e1e2g931g332g4\x8560}5K0c3c4L1c5c6L2L1}L1c7g43134g26Q0c3g:ML1g:\x84L1g;L1c7e8g:3131345A0c3g;L1c7g:N3132e9|31c4c5c:L2c3c4L1c5c:L2L1c7g<3133c3c4L1c5c:L2L1c7c;e2e<|3131g4323133g=L5;" [caddr
julia_flisp.boot:  rename-sig-types cddr #fn(nconc) call core apply_type #fn(copy-list) cdddr
julia_flisp.boot:  caddddr svec #fn(append) cadddr] fix-function-arg-type)
julia_flisp.boot:	  fix-syntactic-unary #fn("7000r1|Mg5c0<17802g5c1<640|;c2|K;" [<: >:
julia_flisp.boot:  call] fix-syntactic-unary)
julia_flisp.boot:	  fix-uint-neg #fn("9000r2|6P0e0}316@0c1c2e3c2}32L3;c1c2}L3;};" [large-number?
julia_flisp.boot:  call - maybe-negate] fix-uint-neg)
julia_flisp.boot:	  flatten-blocks #fn("7000r1e0c1|42;" [flatten-ex block] flatten-blocks)
julia_flisp.boot:	  flatten-ex #fn("9000r2}?640};}Mc0c1c2|q1}N32Q2K;" [#fn(append!)
julia_flisp.boot:							     #fn("7000r1|F16702|M~<6:0e0~|32N;|L1;" [flatten-ex])] flatten-ex)
julia_flisp.boot:	  flatten-where-expr #fn("8000r1]\x8c5g5c0g5q1O2g5M\x8e1|_42;" [#fn(":000r2|F16802|Mc0<6G0~M|\x84c1e2e3|3131}3242;c4c0L1|L1e5}3143;" [where
julia_flisp.boot:  #fn(append!) reverse cddr #fn(nconc) reverse!])] flatten-where-expr)
julia_flisp.boot:	  for-each-isdefined #fn("7000r2}?17802e0}31640^;}F16802}Mc1<680|}\x8441;c2c3|q1}N42;" [quoted?
julia_flisp.boot:  isdefined #fn(for-each) #fn("7000r1e0~|42;" [for-each-isdefined])] for-each-isdefined)
julia_flisp.boot:	  for-generator #f format-file-line
julia_flisp.boot:							       ":"] format-file-line)
julia_flisp.boot:	  format-loc #fn(";000r1e0|31g5Mg5\x84e1g7g6^43;" [extract-line-file
julia_flisp.boot:							   format-file-line] format-loc)
julia_flisp.boot:	  format-syntax-deprecation #fn("@000r5c0c1|c2e3g2g3g433c4}c5>670c55=0c0c6c7}c83446;" [#fn(string)
julia_flisp.boot:  "Deprecated syntax `" "`" format-file-line "." "" #\linefeed "Use `" "` instead."] format-syntax-deprecation)
julia_flisp.boot:	  free-vars #fn("8000r1e0e1|c2303241;" [table.keys free-vars- #fn(table)] free-vars)
julia_flisp.boot:	  free-vars- #fn(":000r2|e0<17802c1|31640};|C6:0c2}|]43;|F16802|Mc3<640};|F16802|Mc4<6=0e5e6|31}42;|F16802|Mc7<6:0e5|\x84}42;|?17802e8|31640};|Mc9\x82P0e:|31c;c<g6}q2e=e>|313132\x8e12};c;c?}q1|N322};" [UNUSED
julia_flisp.boot:  #fn(underscore-symbol?) #fn(put!) outerref break-block free-vars- caddr
julia_flisp.boot:  with-static-parameters quoted? lambda lambda-all-vars #fn(for-each)
julia_flisp.boot:				      #fn(put!)]) free-vars lam:body #fn("7000r1e0|~42;" [free-vars-])] free-vars-)
julia_flisp.boot:	  frontend-depwarn #fn("<000r3e0g7a=6J0e1c2c3c4c5}g23231}g2|46;g7b2=680e6|41;^;" [*depwarn-opt*
julia_flisp.boot:  julia-logmsg 1000 depwarn #fn(symbol) #fn(string) error] frontend-depwarn)
julia_flisp.boot:	  func-for-generator-ranges #fn("F000r4c0e1}32e2g8a3216702g8MC680g8M560e330e4c5c6L1c7g8313231g9g8M\x8260_5\x800e2g8a326P0c5c7c0c8g:3231c9g8Mg9L3L1325X0c5c7c0c:g:3231c9c5c6L1c7g83132g9L3L132|g9\x8290c;c<L2;g;A16v02e2|b33216j02|Mc=<16`02e>|31g9<16S02c?g93116H02e@|\x8431@16<02eAg9|\x8432@650|\x84;g216?02|F16802|McB<6G0eC|^eDcEg3g:3231335\x870g216?02|F16802|McF<6H0eC|\x84]eDcEg3g:3231335[0g3F6T0cGc5cHL1c7c0cIeJcKg332323132|L3530|cLg9c5cHL1c7g;31g<L133L3;" [#fn(map)
julia_flisp.boot:  cadr length= gensy lhs-vars #fn(nconc) tuple #fn(copy-list)
julia_flisp.boot:  caddr #fn(underscore-symbol?) dotop-named? expr-contains-eq generator
julia_flisp.boot:  expand-generator delete-duplicates #fn(append) flatten let block #fn("7000r1c0||L3;" [=])
julia_flisp.boot:  filter #fn("6000r1c0|31@;" [#fn(underscore-symbol?)]) ->] func-for-generator-ranges)
julia_flisp.boot:	  function-def? #fn("7000r1|F16c02|Mc0<17Y02|Mc1<17O02|Mc2<16E02e3|b33216902e4|\x8441;" [function
julia_flisp.boot:  -> = length= eventually-call?] function-def?)
julia_flisp.boot:	  generated-meta? #fn("7000r1e0|b33216B02|Mc1<16802|\x84c2<;" [length=
julia_flisp.boot:  meta generated] generated-meta?)
julia_flisp.boot:	  generated-part- #fn("8000r2|?17B02e0|3117802e1|31640|;e2|316F0}6<0c3e4|31L2;e5|41;|Mc6c7}q1|N32K;" [quoted?
julia_flisp.boot:  function-def? if-generated? $ caddr cadddr #fn(map)
julia_flisp.boot:  #fn("7000r1e0|~42;" [generated-part-])] generated-part-)
julia_flisp.boot:	  generated-version #fn("9000r1c0e1e2|]3231L2;" [block julia-bq-macro
julia_flisp.boot:							 generated-part-] generated-version)
julia_flisp.boot:	  generated_only-meta? #fn("7000r1e0|b23216B02|Mc1<16802|\x84c2<;" [length=
julia_flisp.boot:  meta generated_only] generated_only-meta?)
julia_flisp.boot:	  gensy #fn("8000r0e0\x85P0c1c2c3e43231e4awk42g4e5Kk52g4;e0Me0Nk02;" [*current-gensyms*
julia_flisp.boot:  #fn(symbol) #fn(string) "#s" *gensy-counter* *gensyms*] gensy)
julia_flisp.boot:	  get-defined-vars #fn("7000r1e0~M|3141;" [delete-duplicates] [#21=(#fn("8000r1|?640_;|Mc0<16602|NF6d0|\x84C16702|\x84L117S02|\x84F16E02e1|31C16:02e1|31L117402_;|Mc2\x82?0c3c4~M|N32v2;_;" [define
julia_flisp.boot:	  get-output-string #fn("9000r1c0|31c1|`322e2|31c1|g5322c3g631650c4;g6;" [#fn(io.pos)
julia_flisp.boot:  #fn(io.seek) io.readall #fn(eof-object?) ""] get-output-string)
julia_flisp.boot:	  has-break-or-continue? #fn("8000r1e0c1|c243;" [expr-contains-p #fn("7000r1|F16;02c0|Mc142;" [#fn(memq)
julia_flisp.boot:  (break continue)]) #fn("7000r1|F16;02c0|Mc132@;" [#fn(memq) (for while)])] has-break-or-continue?)
julia_flisp.boot:	  has-dups #fn("7000r1|\x8540^;c0|M|N3217902e1|N41;" [#fn(memq)
julia_flisp.boot:							      has-dups] has-dups)
julia_flisp.boot:	  has-parameters? #fn("6000r1|F16C02|MF16;02e0|31c1<;" [caar parameters] has-parameters?)
julia_flisp.boot:	  has-return? #fn("8000r1e0e1|c243;" [expr-contains-p return? #fn("6000r1e0|31@;" [function-def?])] has-return?)
julia_flisp.boot:	  has-unmatched-symbolic-goto? #fn("<000r1c030c030e1|g5322e2|g6322e3c4c5c6g6q1e7g5313242;" [#fn(table)
julia_flisp.boot:  find-symbolic-label-refs find-symbolic-label-defs any #.not #fn(map)
julia_flisp.boot:  #fn("8000r1c0~|^43;" [#fn(get)]) table.keys] has-unmatched-symbolic-goto?)
julia_flisp.boot:	  identifier-name #fn("6000r1|C640|;e0|31680e1|41;|;" [globalref? caddr] identifier-name)
julia_flisp.boot:	  identity #fn("5000r1|;" [] identity) if-generated?
julia_flisp.boot:	  #fn("7000r1e0|b43216B02|Mc1<16802|\x84c2>;" [length= if (generated)] if-generated?)
julia_flisp.boot:	  in-env? #fn("7000r2}F16F02c0|}M3217:02e1|}N42;" [#fn(assq) in-env?] in-env?)
julia_flisp.boot:	  in-scope? #fn("7000r2e0|}32c1<@;" [var-kind none] in-scope?)
julia_flisp.boot:	  indented-block #fn("9000r2c0e1c2c3}q1|32c432|\x8570c5540c442;" [#fn(string)
julia_flisp.boot:							   deparse]) "\n" ""] indented-block)
julia_flisp.boot:	  index-of #fn("9000r3}\x8540^;|}M\x8250g2;e0|}Ng2aw43;" [index-of] index-of)
julia_flisp.boot:	  initial-operator? #fn(#3# #4# [#table( #t  . #t  . #t  . #t  . #t  . #t   #t  . #t  . #t  . #t   #t   #t  . #t  . #t  . #t  ^ #t  . #t   #t   #t  . #t   #t  . #t  . #t   #t   #t  .>>> #t   #t  . #t   #t   #t  . #t   #t   #t   #t   #t   #t   #t  . #t   #t  . #t  . #t  . #t   #t   #t  .>: #t   #t  . #t   #t  === #t   #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t   #t  . #t  . #t  |.\|>| #t  . #t  . #t  . #t  . #t  . #t  . #t   #t   #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t  >>> #t   #t   #t   #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t   #t  .// #t  . #t   #t   #t   #t   #t  . #t   #t   #t   #t  . #t  . #t  |\\| #t  . #t  . #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t  == #t  . #t  . #t  . #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t  . #t   #t  . #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t  . #t   #t  . #t  . #t  . #t   #t   #t   #t   #t   #t  . #t   #t   #t  . #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t  |.<\|| #t  . #t   #t  . #t   #t   #t   #t  . #t   #t   #t   #t   #t  . #t   #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t  . #t   #t   #t  . #t  .>= #t   #t  . #t   #t   #t  . #t  .<--> #t   #t   #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  << #t  . #t   #t   #t   #t  . #t  . #t   #t   #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t   #t   #t  . #t  . #t  . #t  |.\|| #t   #t   #t  >> #t   #t  . #t  . #t  . #t   #t  . #t  . #t  .& #t  . #t   #t  ./ #t  . #t   #t  . #t   #t   #t  . #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t   #t   #t  . #t   #t   #t   #t   #t  .^ #t   #t  . #t   #t   #t  . #t   #t  . #t   #t  . #t  . #t   #t  . #t   #t  . #t  . #t  .<= #t  . #t  . #t   #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  .<-- #t   #t  . #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t   #t  .<< #t  .--> #t  . #t   #t   #t  . #t   #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t   #t   #t   #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t   #t   #t  . #t  . #t  .> #t   #t   #t   #t   #t   #t  => #t   #t   #t  . #t  . #t   #t  . #t   #t   #t  . #t   #t  . #t  . #t  . #t   #t  . #t  . #t   #t   #t   #t  . #t   #t   #t  . #t  . #t  / #t  . #t   #t  . #t   #t   #t  . #t   #t  . #t  . #t  . #t   #t   #t  . #t  . #t   #t  . #t  . #t   #t  . #t  . #t   #t  . #t   #t  . #t   #t   #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t  . #t  . #t   #t  . #t  . #t   #t   #t  .<: #t   #t   #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t   #t   #t   #t  >= #t  . #t   #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  |.\\| #t   #t   #t   #t   #t   #t   #t   #t   #t   #t  . #t   #t   #t  . #t  . #t   #t  = #t  . #t  . #t   #t   #t  . #t  . #t   #t   #t   #t  . #t   #t   #t  . #t  . #t   #t   #t   #t  . #t   #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t  . #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t   #t   #t  . #t   #t   #t  . #t   #t   #t   #t   #t  . #t   #t  . #t  . #t  * #t   #t   #t  . #t   #t   #t   #t   #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t   #t  . #t   #t  . #t  . #t  . #t  .!== #t   #t   #t   #t   #t  . #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t  . #t   #t  . #t  .= #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t   #t  . #t  . #t  . #t   #t   #t  . #t   #t  . #t  . #t   #t  . #t   #t  . #t   #t  > #t   #t  . #t   #t  . #t   #t   #t  . #t   #t  .+ #t   #t  . #t   #t   #t   #t  . #t  <--> #t   #t  <-- #t  . #t   #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  .++ #t  . #t  . #t   #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t   #t  . #t  .* #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t  . #t   #t  .< #t  . #t   #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t   #t   #t  . #t   #t   #t   #t   #t   #t   #t   #t  . #t  . #t   #t   #t  . #t  . #t   #t   #t  < #t   #t  . #t   #t   #t   #t   #t   #t   #t  >: #t   #t   #t   #t   #t   #t  . #t   #t  - #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t   #t   #t  . #t   #t   #t  . #t  . #t  . #t  . #t  .% #t  . #t   #t  . #t  . #t   #t  . #t  . #t   #t  . #t  . #t   #t   #t   #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t  .. #t  . #t  . #t   #t   #t   #t   #t  . #t   #t  . #t   #t  . #t  . #t   #t   #t  . #t   #t  % #t  . #t   #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t  . #t   #t  . #t   #t  |\|| #t  . #t   #t  . #t  . #t  . #t  . #t  . #t  . #t  .=== #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t   #t   #t  . #t   #t  . #t   #t  .! #t   #t   #t  . #t   #t   #t   #t   #t  . #t  . #t   #t   #t  . #t  .=> #t   #t  . #t   #t   #t  . #t  . #t  // #t  . #t   #t  . #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t   #t   #t  . #t   #t   #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t  . #t  . #t  |\|>| #t   #t   #t   #t  . #t   #t  . #t   #t   #t  . #t   #t  . #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t  . #t   #t   #t  . #t   #t   #t   #t   #t  . #t   #t   #t  .- #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t  !== #t   #t  . #t  .!= #t  . #t  . #t  . #t  . #t   #t  . #t  .== #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t  . #t  . #t  . #t  . #t  != #t  . #t   #t   #t   #t  + #t  . #t  . #t   #t   #t  ~ #t   #t  . #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  .>> #t  . #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t  .~ #t   #t   #t   #t  . #t  . #t   #t   #t   #t   #t   #t   #t   #t  . #t   #t  ++ #t   #t   #t  . #t  . #t  |<\|| #t  . #t  . #t   #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t   #t  . #t  . #t  --> #t  . #t  . #t   #t  . #t   #t   #t   #t   #t   #t   #t   #t   #t   #t  . #t   #t  . #t   #t  . #t  . #t   #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t   #t   #t   #t  <= #t   #t  . #t  . #t  ! #t   #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t  <: #t   #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t  . #t  . #t   #t  . #t  . #t   #t  . #t   #t   #t   #t   #t  . #t)])
julia_flisp.boot:	  initial-reserved-word? #fn("6000r1~|3116?02|c0<16502e1@;" [begin
julia_flisp.boot:  end-symbol] [#fn(#3# #4# [#table(macro #t  continue #t  module #t  baremodule #t  using #t  do #t  import #t  begin #t  if #t  const #t  try #t  function #t  return #t  global #t  break #t  export #t  local #t  quote #t  for #t  struct #t  let #t  while #t)])])
julia_flisp.boot:	  initial-reserved-words (begin while if for try return break continue
julia_flisp.boot:	  insert-after-meta #fn("?000r2}\x8540|;e0c1|N32c2|ML1c3g631c3}31c3e4|ac5g631w323144;" [take-while
julia_flisp.boot:  #fn(nconc) #fn(copy-list) list-tail #fn(length)] insert-after-meta)
julia_flisp.boot:	  invalid-identifier? #fn(#3# #4# [#table(= #t  .*= #t  .+= #t  %= #t  /= #t  .&= #t  |.\|=| #t  >>>= #t  .^= #t  .= #t  .= #t  .<<= #t  <<= #t  $= #t  = #t  |.\|\|| #t  += #t  .= #t  .... #t  .&& #t  .%= #t  |.\\=| #t  .>>>= #t  ... #t  |.'| #t  *= #t  |\|=| #t  .//= #t  .-= #t  .>>= #t  -> #t  ? #t  |\|\|| #t  -= #t  && #t  ./= #t  |\\=| #t  := #t  |.| #t  ^= #t  = #t  //= #t  >>= #t  &= #t)])
julia_flisp.boot:  #fn(eof-object)] io.readall)
julia_flisp.boot:	  io.readlines #fn("7000r1e0e1|42;" [read-all-of io.readline] io.readlines)
julia_flisp.boot:	  iota #fn("7000r1e0e1|42;" [map-int identity] iota) is-prec-arrow?
julia_flisp.boot:	  #fn(#5# #6# [#fn(#3# #4# [#table( #t  . #t  . #t   #t   #t  . #t   #t   #t  . #t  . #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t   #t  .<-- #t  . #t  . #t  . #t   #t  . #t  . #t   #t  .--> #t   #t  . #t   #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t   #t  . #t   #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t   #t   #t   #t   #t  . #t  . #t   #t   #t  . #t   #t   #t  . #t  . #t   #t   #t  . #t  . #t  <--> #t   #t   #t   #t   #t  . #t  . #t  <-- #t   #t  . #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t  . #t   #t   #t  . #t   #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t   #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t   #t  . #t   #t   #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t   #t   #t  . #t   #t   #t  . #t   #t   #t   #t  . #t  . #t  . #t   #t   #t   #t  . #t   #t  . #t   #t   #t  . #t  . #t   #t   #t  . #t   #t  . #t  . #t   #t   #t   #t  . #t   #t   #t  . #t  . #t  . #t   #t   #t   #t  . #t   #t   #t   #t   #t   #t   #t   #t   #t  . #t   #t   #t   #t  . #t  .<--> #t   #t   #t  . #t  . #t   #t   #t  . #t  . #t  --> #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t   #t  . #t   #t  . #t   #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t  . #t   #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t   #t  . #t  . #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t   #t  . #t   #t   #t  . #t   #t  . #t   #t   #t)])])
julia_flisp.boot:	  is-prec-assignment? #fn(#3# #4# [#table(.>>>= #t   #t  = #t  .*= #t  .+= #t  *= #t  .= #t  %= #t  |\|=| #t  /= #t  .-= #t  >>>= #t  = #t  .//= #t   #t  .^= #t  -= #t  .= #t  <<= #t  .<<= #t  .>>= #t  |.\|=| #t  .&= #t  .= #t  ./= #t  . #t  $= #t  = #t  . #t  ~ #t  |\\=| #t  += #t  .= #t  := #t  . #t  .~ #t  ^= #t  = #t  |.\\=| #t  .%= #t  //= #t   #t  >>= #t  &= #t)])
julia_flisp.boot:	  is-prec-bitshift? #fn(#5# #6# [#fn("7000r1c0|c132@@;" [#fn(memq)
julia_flisp.boot:	  is-prec-colon? #fn("7000r1c0|c132@@;" [#fn(memq)
julia_flisp.boot:	  is-prec-comparison? #fn(#5# #6# [#fn(#3# #4# [#table( #t  . #t   #t  . #t   #t   #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  . #t  . #t  . #t  .<= #t  . #t   #t  . #t   #t  . #t  .!== #t   #t   #t   #t  . #t   #t  . #t  . #t  . #t   #t   #t  . #t   #t   #t  . #t  . #t   #t   #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t   #t  . #t  . #t  . #t   #t  .=== #t   #t  . #t  . #t  . #t  . #t  . #t   #t  . #t  .>: #t  . #t   #t   #t  === #t  . #t   #t  . #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t   #t  . #t   #t   #t  . #t  . #t  . #t   #t   #t  . #t  . #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t   #t  . #t   #t  .> #t   #t  . #t  . #t  . #t   #t   #t  . #t  . #t  . #t   #t   #t   #t  > #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t   #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t   #t   #t   #t   #t  in #t   #t  . #t  . #t   #t   #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t   #t   #t   #t  . #t   #t   #t  == #t  . #t  . #t  . #t  . #t  . #t   #t  . #t  . #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t  . #t  . #t   #t   #t   #t  . #t   #t   #t  . #t   #t   #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t   #t   #t   #t  . #t   #t   #t  . #t  !== #t  . #t  .!= #t   #t   #t   #t  . #t  . #t  . #t   #t   #t   #t  . #t  .== #t  . #t   #t   #t   #t   #t  . #t   #t   #t   #t  . #t  . #t   #t  .<: #t  . #t  . #t  . #t  . #t   #t   #t  .< #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t  != #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t   #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t   #t  . #t  . #t  >= #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t  . #t   #t   #t  . #t  . #t   #t  . #t   #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t   #t   #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t  . #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t  . #t  < #t   #t   #t   #t   #t   #t  . #t   #t   #t   #t   #t   #t   #t   #t   #t  >: #t   #t  .>= #t   #t  . #t   #t   #t  . #t   #t   #t  . #t  . #t   #t  . #t  . #t   #t   #t   #t  . #t   #t  . #t   #t   #t  . #t  . #t  . #t  . #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t   #t  . #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t   #t   #t  . #t  . #t   #t  . #t   #t   #t  . #t  . #t   #t  . #t   #t   #t  . #t  . #t  . #t   #t   #t   #t   #t   #t   #t   #t  . #t  . #t  . #t   #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t   #t   #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t   #t  . #t  . #t   #t  . #t  isa #t   #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t  . #t  . #t  . #t  <= #t   #t   #t   #t  . #t  . #t   #t   #t  . #t   #t   #t  . #t  . #t  . #t   #t   #t  . #t  . #t   #t  <: #t  . #t  . #t   #t   #t   #t  . #t   #t   #t  . #t  . #t   #t  . #t   #t   #t   #t   #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t  . #t   #t   #t   #t  . #t  . #t  . #t)])])
julia_flisp.boot:	  is-prec-conditional? #fn("6000r1|c0<;" [?]) is-prec-decl?
julia_flisp.boot:	  #fn("6000r1|c0<;" [::]) is-prec-dot? #fn("6000r1|c0<;" [|.|])
julia_flisp.boot:	  is-prec-lazy-and? #fn("7000r1c0|c132@@;" [#fn(memq) #638=(&& .&&)])
julia_flisp.boot:	  is-prec-lazy-or? #fn("7000r1c0|c132@@;" [#fn(memq) #639=(|\|\|| |.\|\||)])
julia_flisp.boot:	  is-prec-pair? #fn(#5# #6# [#fn("7000r1c0|c132@@;" [#fn(memq) #640=(=>
julia_flisp.boot:	  is-prec-pipe<? #fn(#5# #6# [#fn("7000r1c0|c132@@;" [#fn(memq) #641=(|.<\||
julia_flisp.boot:	  is-prec-pipe>? #fn(#5# #6# [#fn("7000r1c0|c132@@;" [#fn(memq) #642=(|.\|>|
julia_flisp.boot:	  is-prec-plus? #fn(#5# #6# [#fn(#3# #4# [#table(. #t   #t   #t  . #t  . #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t  . #t   #t  + #t   #t  .+ #t   #t   #t   #t   #t  . #t   #t  . #t  . #t  |\|| #t  . #t   #t   #t  . #t  . #t  . #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t   #t   #t   #t   #t  . #t  .++ #t  . #t   #t  . #t  . #t   #t   #t  |.\|| #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t   #t   #t   #t   #t   #t   #t   #t  . #t   #t   #t   #t   #t   #t  . #t   #t  . #t  . #t   #t   #t  . #t   #t  .- #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t  - #t  ++ #t  . #t   #t   #t  . #t   #t  . #t   #t  . #t  $ #t  . #t  . #t   #t   #t  . #t  . #t  . #t  . #t  . #t  . #t)])])
julia_flisp.boot:	  is-prec-power? #fn(#5# #6# [#fn(#3# #4# [#table(. #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t   #t   #t   #t   #t  ^ #t  . #t  . #t   #t  . #t   #t   #t  . #t  . #t   #t  . #t  . #t  . #t   #t   #t   #t   #t   #t  . #t  . #t  . #t  . #t  .^ #t   #t   #t  . #t  . #t  . #t   #t  . #t  . #t   #t   #t   #t  . #t   #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t)])])
julia_flisp.boot:	  is-prec-rational? #fn(#5# #6# [#fn("7000r1c0|c132@@;" [#fn(memq) #643=(//
julia_flisp.boot:	  is-prec-times? #fn(#5# #6# [#fn(#3# #4# [#table(. #t  . #t  . #t   #t  . #t   #t  .% #t  . #t   #t   #t   #t  . #t   #t   #t   #t  . #t  . #t   #t   #t   #t  . #t   #t   #t   #t   #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t   #t  |.\\| #t   #t   #t  . #t  . #t  . #t   #t   #t  / #t  . #t  . #t   #t  . #t   #t  . #t   #t   #t  |\\| #t   #t  . #t  . #t   #t   #t   #t   #t   #t  . #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t  . #t  . #t  . #t   #t  . #t  . #t   #t  . #t  . #t   #t  . #t   #t  .& #t  . #t   #t   #t  . #t  . #t  ./ #t  . #t   #t   #t   #t  . #t  . #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t   #t   #t   #t  . #t   #t  . #t   #t  . #t  . #t   #t  .* #t   #t   #t  . #t   #t   #t   #t  . #t  . #t  * #t   #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t  % #t  . #t  . #t  . #t  . #t   #t   #t  & #t  . #t   #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t)])])
julia_flisp.boot:	  is-var-boxed? #fn("8000r2c0|e1}31M32g616D02e2g63116902e3g631\x8e117V02c0|e1}31\x8432g616D02e2g63116902e3g641;" [#fn(assq)
julia_flisp.boot:  lam:vinfo vinfo:asgn vinfo:capt] is-var-boxed?)
julia_flisp.boot:	  is-word-operator? #fn("9000r1e0c1e2e3|313142;" [every #fn(identifier-start-char?)
julia_flisp.boot:							  string->list
julia_flisp.boot:							  symbol->string] is-word-operator?)
julia_flisp.boot:	  jl-expand-macroscope #fn("7000r1e0c1|q141;" [error-wrap #fn("6000r0e0~41;" [julia-expand-macroscope])] jl-expand-macroscope)
julia_flisp.boot:	  jl-expand-to-thunk #fn("8000r3e0|}g243;" [expand-to-thunk-] jl-expand-to-thunk)
julia_flisp.boot:	  jl-expand-to-thunk-stmt #fn("8000r3e0|}g243;" [expand-to-thunk-stmt-] jl-expand-to-thunk-stmt)
julia_flisp.boot:	  jl-expand-to-thunk-warn #fn("=000r4_\x8c8e0c1g8q1k02c2g9q1c3g3|}g2g8q5c4g:q1tg:302;" [lowering-warning
julia_flisp.boot:  #fn("9000s0~|~MKO;" []) #fn("5000r0~k0;" [lowering-warning])
julia_flisp.boot:  #fn(":000r0~6>0e0\x7fi2i3335;0e1\x7fi2i333c2c3e4i4M31322;" [expand-to-thunk-stmt-
julia_flisp.boot:							      expand-to-thunk-
julia_flisp.boot:							      #fn(for-each)
julia_flisp.boot:							      #fn("6000r1e0|v2;" [julia-logmsg])
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] jl-expand-to-thunk-warn)
julia_flisp.boot:	  jl-parse-all #fn("7000r2e0e1|31}42;" [parse-all- open-input-string] jl-parse-all)
julia_flisp.boot:	  jl-parse-file #fn("6000r1c0|q1c1t;" [#fn("7000r0e0e1~31~42;" [parse-all-
julia_flisp.boot:  open-input-file]) #fn("5000r1^;" [])] jl-parse-file)
julia_flisp.boot:	  jl-parse-one #fn(":000r4e0|31c1g8g2322e2c3}31k22c4g9q1c5g3g8q2c6g:q1tg:302;" [open-input-string
julia_flisp.boot:  #fn(io.seek) current-filename #fn(symbol)
julia_flisp.boot:  #fn("5000r0~k0;" [current-filename]) #fn("8000r0e0c1~\x7fq231g4c2\x7f31K;" [error-wrap
julia_flisp.boot:  #fn("7000r0~6:0e0\x7fe142;e0\x7fe242;" [julia-parse parse-stmts parse-atom])
julia_flisp.boot:  #fn(io.pos)]) #fn("6000r1~302c0|41;" [#fn(raise)])] jl-parse-one)
julia_flisp.boot:	  julia-bq-expand #fn("7000r2e0|}32g6F16902g6Me1<650c2;g6;" [julia-bq-expand-
julia_flisp.boot:  splat-token (error "\"...\" expression outside call")] julia-bq-expand)
julia_flisp.boot:	  julia-bq-expand- #fn("=000r2|C17802e0|31680c1|L2;|?640|;c2|Mc332640|;}`W16802|Mc4<6V0e5|b2326F0e6|\x84316:0c7|\x84\x84L2;|\x84;e8|NK;e9c:|327I0|Mc;\x8280c1|L2;c<c1|L2L2;|Mg6c1=6N0c=c>L1c?c@L2L1cAeB|N}323143;g6c;=6N0c=c>L1c?cCL2L1cAeB|N}323143;g6cD=6O0c=c>L1c?cEL2L1cAeB|}aw323143;g6c4=6O0c=c>L1c?cEL2L1cAeB|}ax323143;c=c>L1c?cEL2L1cAeB|}323143;" [ssavalue?
julia_flisp.boot:  inert #fn(memq) (true false) $ length= vararg? ... splat-token contains #fn("6000r1|F16802|Mc0<;" [$])
julia_flisp.boot:  line copyast #fn(nconc) call core QuoteNode #fn(copy-list) bq-expand-arglist
julia_flisp.boot:  LineNumberNode quote _expr] julia-bq-expand-)
julia_flisp.boot:	  julia-bq-macro #fn("7000r1e0|`42;" [julia-bq-expand] julia-bq-macro)
julia_flisp.boot:	  julia-current-file #fn("5000r0c0;" [none] julia-current-file)
julia_flisp.boot:	  julia-current-line #fn("5000r0`;" [] julia-current-line) julia-expand
julia_flisp.boot:  julia-expand1 julia-expand0 julia-expand-macroscope] julia-expand)
julia_flisp.boot:	  julia-expand-macroscope #fn("8000r1e0e1e2|313141;" [julia-expand-macroscopes-
julia_flisp.boot:							      rename-symbolic-labels
julia_flisp.boot:							      julia-expand-quotes] julia-expand-macroscope)
julia_flisp.boot:	  julia-expand-macroscopes- #fn("9000r1|F740|;|Mc0\x8240|;|Mc1\x8240|;|Mc2\x82B0|\x84e3|31e4g5g642;c5e6|42;" [inert
julia_flisp.boot:  module hygienic-scope caddr resolve-expansion-vars
julia_flisp.boot:  #fn(map) julia-expand-macroscopes-] julia-expand-macroscopes-)
julia_flisp.boot:	  julia-expand-quotes #fn("8000r1|F740|;|Mc0\x8240|;|Mc1\x8240|;|Mc2\x82=0e3e4|\x843141;e5c6|N32740|;|Mc7e3|N32K;" [inert
julia_flisp.boot:  module quote julia-expand-quotes julia-bq-macro contains #fn("6000r1|F16802|Mc0<;" [quote])
julia_flisp.boot:  #fn(map)] julia-expand-quotes)
julia_flisp.boot:	  julia-expand0 #fn("9000r3e0c1g2}L3k02c2g7q1c3|q1c4g8q1tg8302;" [*current-desugar-loc*
julia_flisp.boot:  line #fn("5000r0~k0;" [*current-desugar-loc*])
julia_flisp.boot:  #fn("6000r0c0~q1c1t;" [#fn("6000r0e0~41;" [expand-forms])
julia_flisp.boot:  #fn(string) format-loc *current-desugar-loc*
julia_flisp.boot:  #fn(raise)])]) #fn("6000r1~302c0|41;" [#fn(raise)])] julia-expand0)
julia_flisp.boot:	  julia-expand1 #fn(":000r3e0e1e2e3e4|31313131}g243;" [compact-and-renumber
julia_flisp.boot:							       closure-convert
julia_flisp.boot:							       analyze-variables!
julia_flisp.boot:							       resolve-scopes] julia-expand1)
julia_flisp.boot:	  julia-parse #fn("<000s1c0|316A0e1e2e3|3131}v3;e4|316=0e1e2|31}v3;c5|31640|;e6|a[312]\x8c6g6c7|g6q2O2g6M\x8e1e8|31312c5e8|3131670c940;}\x8570e:540}M|41;" [#fn(string?)
julia_flisp.boot:  julia-parse make-token-stream open-input-string port? #fn(eof-object?)
julia_flisp.boot:  skip-ws-and-comments #fn("7000r1|c0=6B0e1~312\x7fMe2~3141;];" [#\linefeed
julia_flisp.boot:								 take-token
julia_flisp.boot:								 peek-token])
julia_flisp.boot:  peek-token #fn(eof-object) parse-stmts] julia-parse)
julia_flisp.boot:	  juxtapose? #fn("6000r3}D17u02e0}3117k02g2D@16b02g2c1=@16W02}F16O02e2}M3117D02e3}M3117902e4}M31@16\x9502e5|31@16\x8a02e6g231@17902e7g23116s02e8g231@16g02e9g231@16[02c:}31@16902g2c;=@17902e<c=3116:02e4g231@;" [large-number?
julia_flisp.boot:  #\@ block-form? syntactic-unary-op? initial-reserved-word? ts:space?
julia_flisp.boot:  operator? radical-op? closing-token? newline? #fn(string?)
julia_flisp.boot:	  keyword->symbol #fn("=000r1c0|316Q0c1c2|31c3g6`c4g6c5g6313233\x8e141;|;" [#fn(keyword?)
julia_flisp.boot:  #fn(string.dec) #fn(length)] keyword->symbol)
julia_flisp.boot:	  keyword-arg? #fn("6000r1|F16902c0|M41;" [#fn(keyword?)] keyword-arg?)
julia_flisp.boot:	  keywords-introduced-by #fn("7000r1e0e1|32g5F16902g5Mc2<660g5N;_;" [pattern-expand1
julia_flisp.boot:  keywords-introduced-by-patterns varlist] keywords-introduced-by)
julia_flisp.boot:	  keywords-introduced-by-patterns
julia_flisp.boot:	  [pattern-set #table(= (#fn("9000r1e0c1|c2c344;" [plambda-expansion (=
julia_flisp.boot:				 #fn("9000r1e0c1|c2c344;" [plambda-expansion (=
julia_flisp.boot:  (-$ (call name . argl) (:: (call name . argl) _t)) body)
julia_flisp.boot:  #fn(nconc) call #fn(copy-list)]) (__ name argl _t body)])
julia_flisp.boot:				 #fn("9000r1e0c1|c2c344;" [plambda-expansion (=
julia_flisp.boot:							       body)]))  function (#fn("9000r1e0c1|c2c344;" [plambda-expansion
julia_flisp.boot:  #fn("8000r5c0e1e2g33131K;" [varlist safe-llist-keyword-args fix-arglist])
julia_flisp.boot:  #fn("9000r1e0c1|c2c344;" [plambda-expansion (function (-$ (call name . argl)
julia_flisp.boot:							safe-llist-keyword-args
julia_flisp.boot:							fix-arglist])
julia_flisp.boot:  #fn("9000r1e0c1|c2c344;" [plambda-expansion (function (where callspec . wheres)
julia_flisp.boot:	  keywords-method-def-expr #fn("\x82000r5e0g231c1c2e3e4g93232c1c5g932g2Ne6g331e7g<M31g<\x8560_580e8g<31e9g?31680g?\x84540g?e:g@3117902e;g@31690g?L1530_\x8e1\x8e1g?\x8560_5?0c<e=g?M31L2L1g<g?\x8570g<580e>g<31c1c?gB32e8g;31e:gD316:0gD\x84L1530_\x8e1gD\x8570g;580e>g;31e@e:gE326;0eAcB31530]2gE\x8e1c1eCgE32c1eDgE32c1eEgF32e@cFgGq1gH32eGg=31g=NeHcIgAK}32e3cJgLq1}32eK30gD\x8590eL305?0cMcNgDMcO3231c1cPgD32|16802eQ|31cMcN|16@02cRcN|31`32cSW670cT540cUgQ17502cVcUcNeW30313431\x8e1cXcYcZL2c[L1c[L1c\\c]L1c^|C17802e_|316<0c`|L2L1530_31eagQ}c\\cbgQcXcYccL2gQL3L3L1c^gF31c^gP31c^gC31c^g?3135edc\\c]L1c^gK3132cecfcggF31cggP31wL3g:K32g435L1ea|gLgAc\\c]L1c^ehgJ3131cic\\cXL1gQL1c^gI670gH540gG31c^gP\x8560_5H0cXcjckL2cXcYclL2L2L3L131c^c1e=gB3231c^g@3136L2gI6?0emgHgGga33540ga\x8e1L13334L1ea|gLc\\cbe@e9gB32690eK30540encXcYcoL2g>L3L3L1gNL1c^gB31c^g?3134c\\c]L1c^e3epgJ3231c^c1cqgHq1e3e4gJ323231emgHc1crgNgMq2gFgG33c\\c]L1csgOcXcjckL2gH\x8570gN5\\0cXcjctL2gNcucYclL2c\\cvL1c^c1ewgH323132L3L4L3L3L1c^gP\x85q0cxcXcjcyL2gOL3czL1c\\cXL1cjc{L2L1gNL1c^c1e=gB3231c^g@3135L4L1530_31cic\\cXL1gQL1c^gH31c^gP\x8560_560gOL131c^c1e=gB3231c^g@3136L2L13433L13434L1|C770c|530|L136L5;" [cdar
julia_flisp.boot:  #fn(map) #fn("9000r1c0|\x84e1e2|31\x8431L3;" [meta arg-name caddr]) filter
julia_flisp.boot:  nospecialize-meta? #fn("6000r1e0|31680e1|41;|;" [nospecialize-meta? caddr])
julia_flisp.boot:  blockify decl-type last kwarg? vararg? varargexpr? ... arg-name butlast #fn("6000r1e0|31650|\x84;|;" [kwarg?])
julia_flisp.boot:  any error "invalid \"...\" on non-final keyword argument" cadr caddr decl-var
julia_flisp.boot:  extract-method-prologue filter-sparams list #fn("7000r1e0c1|q1~32@;" [any #fn("6000r1|M~M<;" [])])
julia_flisp.boot:  gensy make-ssavalue #fn(symbol) #fn(string) "..." #fn(":000r1c0|c1c2c3L2c4c5L2L3L3;" [::
julia_flisp.boot:  call top pairs core NamedTuple]) undot-name #fn(string.char)
julia_flisp.boot:  #\# "" "#" _ current-julia-module-counter call core ifelse false #fn(nconc)
julia_flisp.boot:  block #fn(copy-list) globalref? method method-def-expr- :: typeof
julia_flisp.boot:  insert-after-meta meta nkw #fn(length) without-generated return top pairs
julia_flisp.boot:  meta #fn(copy-list) filter #fn("7000r1c0|~32@;" [#fn(memq)]) cddr])
julia_flisp.boot:  #fn("E000r2e0|31c1c2c3L2~c4g6L2L4e5|3116>02e6c7|q1\x7f32@6\x880e8|31e930c:c;g9g7L3c<c1c=c>L2g9g8L4c?L1c1c=c@L2cAc=cBL2c4cCL2c4g6L2g8g9L6L3L4g9L4\x8e2540g7c<c1c2cDL2~cEg6L2L4g8}L4;" [decl-var
julia_flisp.boot:  call top getindex inert decl? any #fn("8000r1e0|Me1~3142;" [expr-contains-eq
julia_flisp.boot:  make-ssavalue block = if core isa null throw new TypeError |keyword argument|
julia_flisp.boot:  haskey quote]) = structdiff curly tuple quotify if isempty null kwerr (null)] keywords-method-def-expr)
julia_flisp.boot:	  kw-to-= #fn("6000r1e0|31680c1|NK;|;" [kwarg? =] kw-to-=) kwarg?
julia_flisp.boot:	  #fn("6000r1|F16802|Mc0<;" [kw] kwarg?) lam:argnames #fn("7000r1e0e1|3141;" [llist-vars
julia_flisp.boot:	  lam:vinfo #fn("6000r1e0|41;" [caddr] lam:vinfo) lambda-all-vars
julia_flisp.boot:	  #fn("8000r1c0e1|31e2|3142;" [#fn(append) lam:argnames caddr] lambda-all-vars)
julia_flisp.boot:	  lambda-opt-ignored-exprs #fn(#3# #4# [#table(noinline #t  using #t  local-def #t  copyast #t  boundscheck #t  global #t  gc_preserve_begin #t  core #t  with-static-parameters #t  thismodule #t  quote #t  lambda #t  error #t  gc_preserve_end #t  aliasscope #t  toplevel #t  unnecessary #t  null #t  const-if-global #t  line #t  thunk #t  globalref #t  outerref #t  top #t  true #t  import #t  const #t  export #t  meta #t  inline #t  inert #t  toplevel-only #t  inbounds #t  loopinfo #t  decl #t  ssavalue #t  popaliasscope #t  atomic #t  false #t  isdefined #t  module #t)])
julia_flisp.boot:	  lambda-optimize-vars! #fn("S000r1]]\x8c5\x8c6|Mc0\x8260]580c1c2312g5c330O2g6c4g5q1O2e5|31Me6|31c330c330c330c330\x8c9\x8c;]]]]]]]]\x8c=\x8c>\x8c?\x8c@\x8cA\x8cB\x8cC\x8cDc7c8g:q1g7322g=c9g:g;q2O2g>c:g=q1O2g?c;g:g8q2O2g@c<g:q1O2gAc=g:g;g<q3O2gBc>g:g9q2O2gCc?g;g9q2O2gDc@g?gDg>g;g=g9gCgAgB|g6g@q<O2gDMeA|31312c7cBg<g7q2cCeDg;M31eDg:3132322c7cEg7322|;" [lambda
julia_flisp.boot:  #fn(raise) (assert-failed (eq? (car lam) 'lambda))
julia_flisp.boot:  #fn(table) #fn(":000r2e0|31c1~Mg6326;0c2~Mg642;e3|}32c4~Mg6g7332g7;" [method-expr-name
julia_flisp.boot:  #fn(has?) #fn(get) all-methods-for #fn(put!)] get-methods) lam:vinfo
julia_flisp.boot:  lam:argnames #fn(for-each) #fn("8000r1e0|3116802e1|316;0c2~|M]43;];" [vinfo:capt
julia_flisp.boot:						 #fn(del!)] mark-used)
julia_flisp.boot:				  #fn(del!)] mark-captured)
julia_flisp.boot:  #fn("8000r1c0c1|~q2e2~M31322\x7f|O;" [#fn(for-each)
julia_flisp.boot:  #fn(del!)]) table.keys] leave-loop!) #fn("@000r1|?6C0|C6:0~M|31530]2^;e0|M31640^;|Mc1\x8290\x7fM|\x8441;c2|Mc3326;0e4\x7fM|N42;|Mc5\x82<0\x7fMe6|3141;|Mc7\x82?0\x7fM|\x8431i2M302;c2|Mc8326:0i2M302^;|Mc9\x82:0i2M302];c2|Mc:326[0e;i3M31e4c<\x7fi2q2|N326:0i2M302];i4Mg5312^;|Mc=<17802|Mc><6r0e;i3M31e;i5M31e4\x7fM|N32|Mc=\x82:0i2M30530]2i6Mg6312g7640];i4Mg5312^;|Mc?\x82D0\x7fMe6|3131i7M|\x84312;|Mc@\x82<0i8M|\x84312^;|McA\x82}0eB|b2326o0eC|31eDg5i9326A0i:M|eEi93132550|L1cFcGi;q1g6322i7M|\x8431\x8e1\x8e1530]2^;e4\x7fM|N42;" [lambda-opt-ignored-exprs
julia_flisp.boot:  scope-block #fn(memq) (block call new splatnew new_opaque_closure) eager-any
julia_flisp.boot:  break-block caddr return (break label symbolicgoto) symboliclabel (if elseif
julia_flisp.boot:  _do_while = local method length> method-expr-name local-in? lam:body #fn(for-each)
julia_flisp.boot:  #fn(";000r1c0~Mc1c2e3e4|3131\x843242;" [#fn(for-each)
julia_flisp.boot:						     vinfo:set-never-undef!])
julia_flisp.boot:  vinfo:never-undef cddr #fn(logand) caddr #fn(lognot)])] lambda-optimize-vars!)
julia_flisp.boot:	  lambda-vars #fn(":000r1]\x8c5g5c0g5q1O2g5M||^^342c1c2e3|3142;" [#fn(":000r4|A17502|C640];|F16602|MC6T0g217502g36<0e0c1}c243;~M|N}g2g344;|F16602|MF6\x890e3|Mb23216902e4|31C660^5=0e0c5|Mc6}342c7e4|31316=0~M|N}g2]44;g36<0e0c1}c843;~M|N}]g344;|F6>0e0c9|Mc6}44;|}\x82:0e0c1}42;e0c9|c6}44;" [error
julia_flisp.boot:  "compile error: invalid formal argument "] check-formals)
julia_flisp.boot:  #fn(map) #fn("6000r1|F690e0|M41;|;" [keyword->symbol]) to-proper] lambda-vars)
julia_flisp.boot:	  #fn("6000r1e0|\x8441;" [lambda-vars] lambda:vars) large-number? #fn("7000r1|F16[02|Mc0<16Q02|\x84F16I02|\x84Mc1<16>02c2e3|31c442;" [macrocall
julia_flisp.boot:  core #fn(memq) cadadr (@int128_str @uint128_str @big_str)] large-number?)
julia_flisp.boot:	  last #fn("6000r1|N\x8550|M;e0|N41;" [last] last) last-pair
julia_flisp.boot:	  #fn("6000r1|N?640|;e0|N41;" [last-pair] last-pair) lastcdr #fn("6000r1|?640|;e0|31N;" [last-pair] lastcdr)
julia_flisp.boot:	  let-binds #fn("6000r1|\x84F16902|\x84Mc0<660|\x84N;|\x84L1;" [block] let-binds)
julia_flisp.boot:	  lhs-decls #fn("8000r1e0|31660|L1;|F16802|Mc1<6?0c2c3e4|N32v2;_;" [symdecl?
julia_flisp.boot:  tuple #fn(append) #fn(map) lhs-decls] lhs-decls)
julia_flisp.boot:	  lhs-vars #fn("8000r1e0|316:0e1|31L1;|F16802|Mc2<6?0c3c4e5|N32v2;_;" [symdecl?
julia_flisp.boot:  decl-var tuple #fn(append) #fn(map) lhs-vars] lhs-vars)
julia_flisp.boot:	  lift-toplevel #fn("<000r1_\x8c5]\x8c6g6c0g6g5q2O2g6M|31c1e2g5M31Q2e3c4g8q1c5g7q142;" [#fn("8000r1|?17802e0|31640|;|Mc1~M|N32Kg5Mc2\x82B0\x7fe3g531\x7fMKO2g5\x84;g5;" [quoted?
julia_flisp.boot:  #fn(map) toplevel-butfirst cddr] lift-)
julia_flisp.boot:  #fn(append) reverse call-with-values #fn("7000r0e0c1~42;" [separate #fn("6000r1|F16802|Mc0<;" [thunk])])
julia_flisp.boot:  #fn("8000r2~c0|}32K;" [#fn(append)])] lift-toplevel)
julia_flisp.boot:	  line-number-node #fn("8000r1c0c1|a[31e2L3;" [line #fn(input-port-line)
julia_flisp.boot:						       current-filename] line-number-node)
julia_flisp.boot:  lambda cdddr compile-body cadddr #fn(append) caddr #fn(for-each) linearize] linearize)
julia_flisp.boot:	  linenode-string #fn("9000r1e0|b2326;0c1c2|\x8442;e0|b3326B0c1c3e4|31c5|\x8444;c6;" [length=
julia_flisp.boot:  #fn(string) " around line " " around " caddr ":" ""] linenode-string)
julia_flisp.boot:	  linenum? #fn("6000r1|F16802|Mc0<;" [line] linenum?) list->string
julia_flisp.boot:	  #fn("6000r1c0|v2;" [#fn(string)] list->string) list->vector #fn("6000r1c0|v2;" [#.vector] list->vector)
julia_flisp.boot:	  list-head #fn("9000r2e0}`32640_;|Me1|N}ax32K;" [<= list-head] list-head)
julia_flisp.boot:	  list-ref #fn("7000r2e0|}32M;" [list-tail] list-ref) list-tail
julia_flisp.boot:	  #fn("8000r2e0}`32640|;e1|N}ax42;" [<= list-tail] list-tail) list? #fn("6000r1|A17@02|F16902e0|N41;" [list?] list?)
julia_flisp.boot:	  listify-lambda #fn("A000r1e0|31c1c2L1c1c3L1c4|\x843132L1c3c1c3L1c4c5c6g5M323132c1c3L1c4g5\x843132e7g531c1c3L1c4e8g5313132L5L1c4e9|313144;" [lam:vinfo
julia_flisp.boot:  #fn(nconc) lambda list #fn(copy-list) #fn(map)
julia_flisp.boot:  #fn("6000r1c0|K;" [list]) caddr cadddr cdddr] listify-lambda)
julia_flisp.boot:	  llist-types #fn("7000r1c0e1|42;" [#fn(map) arg-type] llist-types)
julia_flisp.boot:	  llist-vars #fn("9000r1c0e1e2c3|3242;" [#fn(map) arg-name filter #fn("6000r1|F16802|Mc0<@;" [parameters])] llist-vars)
julia_flisp.boot:  #fn(read) load-process #fn(io.close)])])
julia_flisp.boot:  #fn(raise) load-error])] load)
julia_flisp.boot:	  load-process #fn("6000r1e0|41;" [eval] load-process) local-in?
julia_flisp.boot:	  #fn("8000r2c0|e1}31M3217>02c0|e1}31\x8442;" [#fn(assq) lam:vinfo] local-in?)
julia_flisp.boot:	  longest-common-prefix #fn("9000r1c0|31g5`W640_;g5aW650|M;e1e2|M|\x8432e3|31K41;" [#fn(length)
julia_flisp.boot:  longest-common-prefix longest-common-prefix2 cddr] longest-common-prefix)
julia_flisp.boot:	  longest-common-prefix2 #fn("8000r2e0|}_43;" [longest-common-prefix2-] longest-common-prefix2)
julia_flisp.boot:	  longest-common-prefix2- #fn("9000r3e0|`3216C02e0}`3216802|M}M=6@0e1|N}N|Mg2K43;e2g241;" [length>
julia_flisp.boot:  longest-common-prefix2- reverse] longest-common-prefix2-)
julia_flisp.boot:	  lookup #fn("7000r3c0|}32g7660g7N;g2;" [#fn(assq)] lookup) lookup-sym
julia_flisp.boot:								  lookup-sym] lookup-sym)
julia_flisp.boot:	  lower-ccall #fn("<000r5]\x8c9g9c0|}g2g4g9q5O2g9M\x8e1g2g3____46;" [#fn("K000r6|A16602}A@6;0e0c131530]2}A16P02|A17H02|F16A02e2|M3116602|NA@6;0e0c331530]2|A@16902e2|M31g:16602g3A6;0e0c431530]2}\x85\x940c5c6L1e7g231c5c8L1~L1\x7fL1c5c9L1c:c;L2L1c<e7g3313133L1g:6=0c=i231ax530`L1c>i3L2L1e7g431c<g53138L143;}Mg:6:0e?|31540|Mg:16702|NA@6;0e0c@31530]2g<cA\x82Y0i4Mg:660|540|N}Ng2cBcCg332cBg;g432g546;eD30cEg=c9cFcGL2g<g;L4L3g2Kc9cFcHL2g<g=L4i4Mg:660|540|N}Ng>cBg<g332cBg?g432cBg=g53246;" [error
julia_flisp.boot:  #fn(nconc) block reverse! foreigncall call core svec #fn(copy-list)
julia_flisp.boot:  Any #fn(list*) (core Any) make-ssavalue = top cconvert unsafe_convert])] lower-ccall)
julia_flisp.boot:	  lower-comprehension #fn("P000r3e0}312e1}316;0e2c331530]2e430e530e430e430e430e430c6c7g232]\x8c>g>c8g9}g<g7g8g>q6O2e9g2a32680g=M540g:c:c;c<L1c=g8L2L1c6c>g=g233e9g2a32660_5P0c?g:c;c@L1cAcBL2L1cCg=3133L3L1c?g;c@cAcDL2g?L3L3L1c?g<c@cEcFL2g;cAcGL2L4L3L1c?g7c@cAcHL2|g?g;L5L3L1c?g8c@cAcIL2c@cAcJL2g7L3L3L3L1g>MeKg231eKg=3132L1g7L13:L2;" [check-no-return
julia_flisp.boot:  has-break-or-continue? error "break or continue outside loop" make-ssavalue
julia_flisp.boot:  gensy #fn(map) #fn("5000r1e040;" [make-ssavalue])
julia_flisp.boot:  = inbounds true if call top push! setindex! pop add_int for] construct-loops)
julia_flisp.boot:  length= scope-block #fn(nconc) block local #fn("8000r2c0|e1}31L3;" [= caddr])
julia_flisp.boot:  = call top product #fn(copy-list) IteratorSize core isa SizeUnknown
julia_flisp.boot:  _array_for first LinearIndices reverse] lower-comprehension)
julia_flisp.boot:	  lower-define #fn(";000r1]c0m52|?17802e1|31640|;|Mc2\x82<0e3e4|3141;|Mc5\x82K0c6c5L1|\x84L1g5|31L1e7|3144;c8e3|42;" [#fn("=000r1e0|31F6N0e1|31F6=0c2e0|31K570e3|31560e430e5g531e6g531g6\x8550g7;c7g6g7L3c8c9g632K;" [cddr
julia_flisp.boot:  cdddr begin caddr void get-defined-vars lower-define lambda #fn(map)
julia_flisp.boot:  #fn("5000r1e040;" [void])] lambda-body) quoted? define lower-define
julia_flisp.boot:  expand-define lambda #fn(nconc) lastcdr #fn(map)] lower-define)
julia_flisp.boot:	  lower-destructuring-args #fn(";000r1]]\x8c5\x8c6g5c0O2g6c1g5g6q2O2]\x8c7g7c2g6g7q2O2g7M\x8e1|__43;" [#fn("9000r1e0c1|326D0e2c3c4e5|31c63341;|;" [expr-contains-p
julia_flisp.boot:  "invalid argument destructuring syntax \"" deparse "\""] check-lhs)
julia_flisp.boot:  gensy local = decl? length= kwarg? caddr vararg? ...] transform-arg)
julia_flisp.boot:  (null)])] lower-destructuring-args)
julia_flisp.boot:	  lower-kw-call #fn("D000r2e0}316:0e1}31530_e0}31670}N530}e2c3c4L1|L1c5g7313331g8Mg9\x84e6g931c3c7L1g8Ne8c9g;q1c:g:g6q232L143;" [has-parameters?
julia_flisp.boot:  cdar remove-argument-side-effects #fn(nconc) call #fn(copy-list) cddr block
julia_flisp.boot:  call-with-values #fn("7000r0e0e1~42;" [separate kwarg?])
julia_flisp.boot:  #fn("9000r2e0~c1|\x7f32}43;" [lower-kw-call- #fn(append!)])] lower-kw-call)
julia_flisp.boot:	  lower-kw-call- #fn("E000r3]c0m72e1|31660|560e230e230c3c4L1c5g8|\x8260_5;0c6g8|L3L131c6g9e7}c8|q1c9c:]35L3L1e;e<}326A0g7g8g2g9g9345V0c3c=L1c=c>c?L2g8L3L1g9L1g8L1c5g23135L144;" [#fn(">000r4c0c1c2c3L2g2L3c4c1L1|L1c5}3133c4c1L1c1c6c7L2|L3L1g3L1|L1c5}3135L4;" [if
julia_flisp.boot:  call top isempty #fn(nconc) #fn(copy-list) core kwfunc] kwcall-unless-empty)
julia_flisp.boot:  sym-ref? make-ssavalue #fn(nconc) block #fn(copy-list) = lower-named-tuple #fn(":000r1c0c1|c2e3~31c445;" [#fn(string)
julia_flisp.boot:  "keyword argument syntax" every vararg? call core kwfunc] lower-kw-call-)
julia_flisp.boot:	  lower-named-tuple #fn("F000\x8910005000\x8a1000770c0m12\x8a2000770c1m22\x8a3000770c2m32\x8a4000760^m42]]]\x8c9\x8c:\x8c;c3c4c5|32Q2e6g<31g=6?0e7}g=M3131530]\x8e1\x8e12g9c8g2q1O2g:c9O2g;c:O2]\x8c<g<c;g;g:g2g9g<g4g3q7O2g<M\x8e1|__^44;" [#fn("8000r1c0c1|c243;" [#fn(string)
julia_flisp.boot:  kwarg? length= |.| caddr]) has-dups error #fn("9000r1e0|316@0e1c2c3~c43341;|;" [vararg?
julia_flisp.boot:  error #fn(string) "\"...\" expression cannot be used as " " value"] not-vararg)
julia_flisp.boot:  #fn("9000r2|\x8540^;e0e1c2e3|3231e4}3142;" [named-tuple-expr reverse! #fn(map)
julia_flisp.boot:					      quotify reverse] to-nt)
julia_flisp.boot:  deparse "\"" caddr length= |.| quoted-sym? call => named-tuple-expr cadddr
julia_flisp.boot:  vararg? top merge NamedTuple has-parameters? "more than one semicolon in argument list"
julia_flisp.boot:  " \""])] lower-named-tuple)
julia_flisp.boot:	  lower-tuple-assignment #fn(">000r2e030c1c2L1c3g6}L3L1c4]\x8c;g;c5g6g;q2O2g;M\x8e1|a3231g6L144;" [make-ssavalue
julia_flisp.boot:  #fn(nconc) block = #fn(copy-list) #fn("=000r2|\x8540_;e0|M316_0e130c2c3g6L2c4g6c5c6c7L2~}L4L3c4|Mg6L3L4\x8e15D0c4|Mc5c6c7L2~}L4L3\x7fM|N}aw32K;" [eventually-call?
julia_flisp.boot:  gensy block local-def = call core getfield])] lower-tuple-assignment)
julia_flisp.boot:	  lower-update-op #9# lowering-warning
julia_flisp.boot:	  #fn("7000s0e040;" [void]) macrocall-to-atsym #fn("6000r1|F16802|Mc0<650|\x84;|;" [macrocall] macrocall-to-atsym)
julia_flisp.boot:	  macrocall? #fn("6000r1|MC16902e0|M41;" [symbol-syntax] macrocall?)
julia_flisp.boot:	  macroify-call #fn("=000r3}F16802}Mc0<6P0c1c2L1e3}\x8431L1g2L1c4e5}313144;}F16802}Mc6<6E0c6e7|}\x84g233e8}31L3;e9|c1c2L1e3}31L1g2L1c4e:|31313442;" [call
julia_flisp.boot:  #fn(nconc) macrocall macroify-name #fn(copy-list) cddr do macroify-call caddr
julia_flisp.boot:  maybe-docstring parse-space-separated-exprs] macroify-call)
julia_flisp.boot:	  macroify-name #fn("=000s1|C6?0c0c1c2|}Q441;e3|316H0c4|\x84c5e6e7|31\x84}Q3L2L3;e8c1c9e:|31c;3341;" [#fn(symbol)
julia_flisp.boot:  #fn(string) #\@ valid-modref? |.| quote macroify-name caddr error "invalid macro usage \"@("
julia_flisp.boot:  deparse ")\""] macroify-name)
julia_flisp.boot:	  make-assignment #fn("7000r2c0|}L3;" [=] make-assignment)
julia_flisp.boot:	  make-code-emitter #fn("9000r0_c030`_`Z5;" [#fn(table)] make-code-emitter)
julia_flisp.boot:	  make-decl #fn("7000r2c0|}L3;" [::] make-decl)
julia_flisp.boot:	  make-generator-function #fn(">000r4c0}c1c2g23232e3g3c4c5L1c6L1c7g83133L132c8c9|L2c:c4c;L1|L1c7g83133g9L3L3;" [#fn(append)
julia_flisp.boot:  #fn(map) #fn("6000r1|c0\x8270e140;|;" [|#self#| gensy]) insert-after-meta #fn(nconc)
julia_flisp.boot:  meta nospecialize #fn(copy-list) block global function call] make-generator-function)
julia_flisp.boot:	  make-label #fn("5000r1c040;" [#fn(gensym)] make-label) make-lineinfo
julia_flisp.boot:  thismodule |macro expansion|] make-lineinfo)
julia_flisp.boot:	  make-perfect-hash-table #fn(";000r1]\x8c5g5c0O2]\x8c6g6c1g5g6|q3O2g6M\x8e1c2|3141;" [#fn("8000r2e0e1c2|3131}42;" [mod0
julia_flisp.boot:  abs #fn(hash)] $hash-keyword) #fn("=000r1c0b2|T2^32]\x8c6g6c1~|g5\x7fg6q5O2g6M\x8e1i241;" [#fn(vector.alloc)
julia_flisp.boot:  cdar])]) #fn(length)] make-perfect-hash-table)
julia_flisp.boot:	  make-scope #fn("J000\x890000;000\x8a0000760^m02\x8a1000760_m12\x8a2000760_m22\x8a3000760_m32\x8a4000760_m42\x8a5000760_m52\x8a6000760^m62\x8a7000760^m72\x8a8000760^m82\x8a9000760_m92\x8a:000760^m:2|}g2g3g4g5g6g7g8g9g:Z;;" [] make-scope)
julia_flisp.boot:	  make-ssavalue #fn("8000r0c0~ML2~a~MwO2;" [ssavalue] [(0)])
julia_flisp.boot:	  make-system-image #fn("<000r1c0|c1c2c334c4e5e6]k52]k62c7g7g8q2c8g6g5q2c9g9q1tg9302;" [#fn(file)
julia_flisp.boot:  :write :create :truncate (*linefeed* *directory-separator* *argv* that
julia_flisp.boot:				       *print-pretty* *print-width*
julia_flisp.boot:				       *print-readably* *print-level*
julia_flisp.boot:				       *print-length* *os-name*) *print-pretty*
julia_flisp.boot:  *print-readably* #fn("5000r0~k02\x7fk1;" [*print-pretty* *print-readably*])
julia_flisp.boot:  #fn(top-level-value) #fn(string) #fn(memq)
julia_flisp.boot:  #fn(iostream?)]) simple-sort #fn(environment)
julia_flisp.boot:  #fn(write) #fn(nconc) #fn(map) #.list #fn(top-level-value)
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] make-system-image)
julia_flisp.boot:	  make-table #fn(table) make-token-stream
julia_flisp.boot:	  #fn("9000r1^|]^^Z5;" [] make-token-stream) make-var-info #fn("7000r1|c0`L3;" [(core
julia_flisp.boot:  Any)] make-var-info)
julia_flisp.boot:	  map-at #fn(";000r3]\x8c7g7c0g7q1O2g7M|}g2`_45;" [#fn(">000r5g2\x8590e0g441;g2M|g3316:0}g931540g9~M|}g2Ng3awg:g4K45;" [reverse] map-at-)] map-at)
julia_flisp.boot:	  map-cl-convert #fn("=000r8g56I0c0c1}g2g3g4g5g6g7q7|42;c0c2}g2g3g4g6g7q6|42;" [#fn(map)
julia_flisp.boot:  #fn(">000r1e0e1|~\x7fi2i3i416802e2|31i5i63831g5N\x8560g5M;c3c4L1c5g5N31g5ML143;" [lift-toplevel
julia_flisp.boot:  cl-convert toplevel-preserving? #fn(nconc) block #fn(copy-list)])
julia_flisp.boot:  #fn("=000r1e0|~\x7fi2i3^i4i548;" [cl-convert])] map-cl-convert)
julia_flisp.boot:	  map-first #fn("6000r2}\x8540_;|}M31}NK;" [] map-first) map-int
julia_flisp.boot:	  #fn(";000r2e0}`32640_;|`31_K_\x8c7g7g6O2a}axc1g7|q2u2g6;" [<= #fn("7000r1~M\x7f|31_KP2~~MNO;" [])] map-int)
julia_flisp.boot:	  mark-label #fn("8000r2e0|c1}43;" [emit label] mark-label) match
julia_flisp.boot:	  #fn("9000r2e0|}c1}KL143;" [match- __] match) match- #fn("<000r3|C6[0|c0\x8250g2;c1|g232g76?0}g7N>16502g2;|}Kg2K;|J6>0|}3116502g2;|F6\xc70|Mc2\x82>0|\x84}>16502g2;|Mc3\x82D0e4|\x84}g233@16502g2;|Mc5\x82K0e4e6|31}g23316:02|\x84}Kg2K;|Mc7\x82A0e8|N_}L1g2^a46;|Mc9\x82<0}C16502g2;}F16M02|M}M>16C02e:|N}Ng2c;}N3144;|}>16502g2;" [_
julia_flisp.boot:  #fn(assq) -/ -^ match- -- caddr -$ match-alt -s match-seq #fn(length)] match-)
julia_flisp.boot:	  match-alt #fn("=000r6|\x8540^;e0|Mg2Mg333g:16R02e1}g2Ng46>0g4g2MKg:K540g:g5ax3417B02e2|N}g2g3g4g546;" [match-
julia_flisp.boot:  match-seq match-alt] match-alt)
julia_flisp.boot:	  match-seq #fn("D000r4g2740^;|C690|}Kg2K;|\x85;0}\x8550g2;^;|MF16902|MMc0<g86;0e1|M31540|Mg8680|M\x84530^g9F680g9M530_g9c2\x82E0e3c4|N}g2g:`g3g348;g;c5\x82F0e3g9\x84|N}g2g:`g3g348;g;c6\x82F0e3g9\x84|N}g2g:ag3g348;g;c7\x82E0e3g9\x84|N}g2g:`ag348;g;c8\x82C0e9g9N|N}g2g:g346;}F16I02e:|N}Ne;|M}Mg233g3ax44;" [--
julia_flisp.boot:  caddr ... match-star _ -* -+ -? -$ match-alt match-seq match-] match-seq)
julia_flisp.boot:	  match-star #fn(">000r8e0|}g2g3g4g5g6g7_49;" [match-star-] match-star)
julia_flisp.boot:	  match-star- #fn("A000r9e0g5g632640^;g6`W6R0e1}g2g46A0g4e2g831Kg3K540g3g744;e0g5`326c0e3|g2Mg333g=16R02e4|}g2Ng=g4g5axg6axg7axg2Mg8K49;e4|}g2g3g4``g7g83917F02e4|}g2g3g4ag6g7g849;" [>
julia_flisp.boot:  match-seq reverse match- match-star-] match-star-)
julia_flisp.boot:	  maybe-docstring #fn(";000r2e0}b43216<02e1}\x8431c2<6T0e3}31]\x8c7g7c4}|g7q3O2g7M\x8e1e5|31`42;};" [length=
julia_flisp.boot:  called-macro-name @doc cadddr #fn("8000r2e0|31640~;e1|316O0e2}`32640~;e3\x7f312i2Me4\x7f31a42;c5c6~31e7\x7f31L142;" [closing-token?
julia_flisp.boot:  newline? > take-token peek-token #fn(nconc)
julia_flisp.boot:  #fn(copy-list) parse-eq]) peek-token] maybe-docstring)
julia_flisp.boot:	  maybe-negate #fn(":000r2|c0\x82\x870e1}316d0e2}31c3=6C0c4c5c6L2c7L1c8L4;}M}\x84e9}31e:e2}31a32L4;}c;W6C0c4c5c<L2c7L1c=L4;}y;};" [-
julia_flisp.boot:  large-number? cadddr "-170141183460469231731687303715884105728" macrocall
julia_flisp.boot:  string.tail #int64(-9223372036854775808) @int128_str "9223372036854775808"] maybe-negate)
julia_flisp.boot:	  maybe-remove-functionloc! #fn(">000r1e0|31e1e2g532g6F680g6M5H0e1e2|32g7\x8570c3550g7M\x8e1e4g6a326L0]\x8c8g8c5g7g8q2O2g8M\x8e1|31530]2g7;" [extract-method-prologue
julia_flisp.boot:  filter linenum? (line 0 none) length> #fn("7000r1~|\x84\x82:0|e0|31P;\x7fM|N41;" [cddr])] maybe-remove-functionloc!)
julia_flisp.boot:	  maybe-strip-op-suffix #fn("7000r1|C6N0c0|31|g5<17902e1g531640|;g5;|;" [#fn(strip-op-suffix)
julia_flisp.boot:  no-suffix?] maybe-strip-op-suffix)
julia_flisp.boot:	  method-def-expr #fn(";000r5e0e1g23131e2g9316J0e3e4g931312e5|}g9g3g445;e6|}g9g3g445;" [throw-unassigned-kw-args
julia_flisp.boot:  remove-empty-parameters has-parameters? check-kw-args cdar
julia_flisp.boot:  keywords-method-def-expr method-def-expr-] method-def-expr)
julia_flisp.boot:	  method-def-expr- #fn("W000\x8940005000\x8a4000770c0m42\x8c3e1e2g2326_0]\x8c9g9c3g9q1O2g9M\x8e1g2^322e4c5g2q1c6|}g3g4q442;c7c8}32c7c9e:g23132e;c<g:32e=|31660|5C0e>|31670|\x84560c?L1e@g;316H0eAcBcCe@g;31McD3331530]2e@g9316;0eAcE31530]2e1cFg9q1g:326;0eAcG31530]2|16902eH|31@17902eI|31@6F0eAcBcJeK|31cD3331530]2eLg3M31eMeNg3McO336\xb40ePg3M31eQg3M31cRcBeS30cTeU303331eVg@g9g:g>34g3eWg?cXcYcZc[c\\L2g@c]g:K}\x8570c^5<0c]c7c8}32Kg=\x84c_e`g=31L2caL1L8L3L132O2gAL1\x8e1\x8e1\x8e1\x8e1530_ebg231ecg2g3Mg433c7cdg932c7ceg9gA33}\x85q0cfg<cgc[chL2cicgL1c[chL2L1cjekg?313133cgc[chL2L2c_g=L2L5g@L45\xb30cfg<ciclL1cj]\x8cHgHcmgHq1O2gHM\x8e1g9gAc7en}32__3531cgc[chL2cicgL1c[chL2L1cjekc7cogBq1g?32313133cicgL1c[chL2L1cjgA3133c_g=L2L5L133g@L4|C17802ep|316S0ciclL1cjg>31cf|L2L1gCL1cq|L2L145;g>\x87E0ciclL1cjg>31gCL143;gC;" [(core
julia_flisp.boot:  call-with-values #fn("7000r0e0e1~42;" [separate kwarg?])
julia_flisp.boot:							 call-with-values #fn("7000r0e0e1~42;" [separate
julia_flisp.boot:  vararg?]) #fn("?000r2e0~\x7f}i2i3i4Mc1}i2|33i548;" [optional-positional-defs
julia_flisp.boot:  #fn(map) #.car #fn("6000r1c0|31650e1;|;" [#fn(underscore-symbol?) UNUSED])
julia_flisp.boot:  llist-vars filter #fn("6000r1|e0<@;" [UNUSED]) nodot-sym-ref? overlay? null
julia_flisp.boot:  has-dups error #fn(string) "function argument name not unique: \"" "\"" "function static parameter names not unique"
julia_flisp.boot:  sym-ref-or-overlay? valid-name? "invalid function name \"" deparse
julia_flisp.boot:  maybe-remove-functionloc! expr-contains-p if-generated? #fn("6000r1e0|31@;" [function-def?])
julia_flisp.boot:  generated-version non-generated-version
julia_flisp.boot:  #fn(symbol) gensy "#" current-julia-module-counter
julia_flisp.boot:  make-generator-function insert-after-meta meta generated new core
julia_flisp.boot:  GeneratedFunctionStub list nothing inert caddr false llist-types
julia_flisp.boot:  method-lambda-expr #fn("5000r1e040;" [make-ssavalue]) #.cons method call svec
julia_flisp.boot:  #fn(nconc) #fn(copy-list) dots->vararg block #fn(">000r5|\x8590e0g441;~M|N}Ng2N|M}MKg3Ke1}Me2g2Mg33232g4K45;" [reverse!
julia_flisp.boot:  make-assignment replace-vars]) bounds-to-TypeVar #fn("7000r1e0|~42;" [replace-vars])
julia_flisp.boot:  globalref? unnecessary] method-def-expr-)
julia_flisp.boot:	  method-expr-name #fn("9000r1|\x84e0|b23217C02g5F@17:02e1g531@670g5550g5\x84g6F750g6;g6Mc2\x8260g6\x84;g6;" [length=
julia_flisp.boot:  quoted? outerref] method-expr-name)
julia_flisp.boot:	  method-expr-static-parameters #fn(";000r1e0|31g5Mc1\x82T0e2e3e4g5313131c5c6e7c8g6q1g5N3242;_;" [caddr
julia_flisp.boot:  member])] method-expr-static-parameters)
julia_flisp.boot:	  method-lambda-expr #fn("H000r3c0c1|32e2}31c3g7_c4g2c5>670g85v0e6c7g8N32e830c9g8ML1c:g=31c;g>g2L3L1c<c=g>L3L1c:e>g8ac?g=31w323135\x8e2L2L4;" [#fn(map)
julia_flisp.boot:  #fn("7000r1e0|31c1g531650e2;g5;" [arg-name #fn(underscore-symbol?) UNUSED])
julia_flisp.boot:  blockify lambda scope-block (core Any) take-while #fn("7000r1|F16;02c0|Mc142;" [#fn(memq)
julia_flisp.boot:  (line meta)]) make-ssavalue #fn(nconc) #fn(copy-list) = meta ret-type
julia_flisp.boot:  list-tail #fn(length)] method-lambda-expr)
julia_flisp.boot:	  #fn("7000r2||}V}T2x;" [] mod0) module-default-defs #fn("M000r1e0e1|31e2|31g7N\x8560_550g7\x84g8F16902g8Mc3<690g8L1530_g6c4\x8270c5540c4g6c6\x8270c7540c6c8c9c:c;g:L3c<c8L1c=g931c:c>c;L2g6g:L4L133L3c9c:c?g:L3c<c8L1c=g931c:c>c@L2cAc?L2g6g:L5L133L3c9c:c?cBg;cAcCL2L3g:L4c<c8L1c=g931c:c>c@L2cAc?L2g;g6g:L6L133L3L4\x8e1\x8e1\x8e1\x8e1\x8e1\x8e1cD`43;" [jl-expand-to-thunk
julia_flisp.boot:  #fn(copy-list) core include _call_latest top :: Function none] module-default-defs)
julia_flisp.boot:	  named-gensy #fn(":000r1c0c1c2e3c2|3431e3awk32g5;" [#fn(symbol)
julia_flisp.boot:							     *gensy-counter*] named-gensy)
julia_flisp.boot:	  named-tuple-expr #fn(";000r2c0c1c2c3L2c4c5L1c6|3132L3c4c0L1c2c5L2L1c6}3133L3;" [call
julia_flisp.boot:  curly core NamedTuple #fn(nconc) tuple #fn(copy-list)] named-tuple-expr)
julia_flisp.boot:	  negative? #fn("6000r1|`X;" [] negative?) new-call
julia_flisp.boot:  kwarg? error "\"new\" does not accept keyword arguments" num-non-varargs
julia_flisp.boot:  curly #fn(copy-list) make-ssavalue #fn("<000r3}c0>650g2;c1c2c3L2~\x7f>16E02c4}\x7f3216:02c4}i232660}5A0c1c5c6L2i3|awL4g2L4;" [(core
julia_flisp.boot:							false]) iota list-head] new-call)
julia_flisp.boot:	  new-expansion-env-for #fn("?000\x8920003000\x8a2000760^m22e0e1|32|?17J02g2@16B02g7F16902g7Mc2<@640};e3|c432g7F16902g7Mc2<680g7N530_e5c6g9q1c7|g8}q342;" [pattern-expand1
julia_flisp.boot:  vars-introduced-by-patterns varlist find-declared-vars-in-expansion global
julia_flisp.boot:  call-with-values #fn("7000r0e0c1~42;" [separate #.pair?])
julia_flisp.boot:  delete-duplicates #fn(append!) find-declared-vars-in-expansion local
julia_flisp.boot:  find-assigned-vars-in-expansion filter #fn("7000r1c0|M~32@;" [#fn(assq)])
julia_flisp.boot:  pair-with-gensyms #fn(map) #fn("6000r1||K;" [])
julia_flisp.boot:  keywords-introduced-by])] new-expansion-env-for)
julia_flisp.boot:	  newline #fn("8000\x8900001000\x8a0000770e0m02c1|e2322];" [*output-stream*
julia_flisp.boot:	  newline? #fn("6000r1|c0=;" [#\linefeed] newline?) next-token
julia_flisp.boot:	  #fn(":000r2]\x8c6g6c0}|g6q3O2g6M\x8e1^41;" [#fn("C000r1~b2c0\x7fe132]<17402|\\2e2\x7f31c3g53117802g5c4=680e5\x7f41;c6g5316:0c7g5\x7f42;c8c9g532680e5\x7f41;c8c:g5326:0e;\x7f^^43;g5c<=6?0e=\x7f312i2M]41;g5c>=16\xbb02e5\x7f31e2\x7f31c3g731670c?5\xa00e@g7316<0e;\x7f]^335\x8d0eAg7316\x820eB\x7fg632e2\x7f31g8cC<16G02eAg93116<02eDg9cE32@6J0eFcGcHg8g9cIeJ\x7f313531530]2g8\x8e1\x8e1540c?\x8e217\x8a02eAg5316=0eB\x7fe5\x7f3142;cK\x7f31e5\x7f312eLg5316O0eFcGcMcNcOg531b@32cPag6w3441;eFcGcQg5cRag6w3441;" [#fn(skip-ws)
julia_flisp.boot:  whitespace-newline peek-char #fn(eof-object?)
julia_flisp.boot:  #\linefeed read-char #fn(identifier-start-char?)
julia_flisp.boot:  #fn(accum-julia-symbol) #fn(string.find) "()[]{},;\"`@" "0123456789"
julia_flisp.boot:  read-number #\# skip-comment #\. |.| char-numeric? opchar? read-operator ..
julia_flisp.boot:	#\:) error #fn(string) "invalid operator \"" "\"" scolno #fn(input-port-column)
julia_flisp.boot:  default-ignorable-char? "invisible character \\u"
julia_flisp.boot:  #fn(number->string) #fn(fixnum) " near column " "invalid character \"" "\" near column "])] next-token)
julia_flisp.boot:	  no-suffix? #fn(#3# #4# [#table( #t  = #t  .*= #t  .+= #t  .= #t  %= #t  /= #t  .&= #t  |.\|=| #t  >>>= #t  = #t  .^= #t  .= #t  .= #t  . #t  .<<= #t  <<= #t   #t  . #t  :: #t  $= #t  = #t  .. #t  . #t  |.\|\|| #t  . #t  ~ #t  += #t  .= #t  .~ #t  .&& #t  .%= #t  |.\\=| #t  . #t  <: #t   #t  .>>>= #t  >: #t   #t  : #t  ... #t  *= #t   #t  |\|=| #t  .//= #t  .-= #t  .>>= #t  -> #t  |.'| #t   #t  ? #t  -= #t  |\|\|| #t  in #t  && #t  ./= #t   #t  $ #t  . #t   #t  |\\=| #t  := #t  isa #t  |.| #t  . #t  . #t  ^= #t  . #t   #t  = #t  |'| #t  //= #t  >>= #t  &= #t)])
julia_flisp.boot:	  nodot-sym-ref? #fn("7000r1|C17Z02e0|b33216802|Mc1<17D02e0|b23216802|Mc2<;" [length=
julia_flisp.boot:  globalref outerref] nodot-sym-ref?)
julia_flisp.boot:	  non-generated-version #fn("7000r1e0|^42;" [generated-part-] non-generated-version)
julia_flisp.boot:	  non-standalone-symbol-token? #fn(#3# #4# [#table( #t  . #t  . #t  . #t  . #t  . #t   #t  . #t  . #t  <<= #t  . #t   #t   #t  . #t  . #t  . #t  ^ #t  . #t   #t   #t  . #t   #t  . #t  . #t   #t  .&& #t   #t  .>>> #t   #t  . #t   #t   #t  . #t   #t   #t  -> #t   #t   #t   #t   #t  -= #t  . #t   #t  . #t  . #t  . #t   #t   #t  .>: #t   #t  . #t  = #t   #t  === #t   #t  . #t  . #t   #t  . #t  .*= #t   #t   #t   #t  . #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t   #t  . #t  . #t  |.\|>| #t  . #t  . #t  . #t  . #t  . #t  . #t   #t   #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t  >>> #t   #t   #t   #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t   #t  abstract #t  .// #t  . #t   #t   #t   #t   #t  . #t   #t   #t   #t  . #t  . #t  |\\| #t  . #t  . #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t  == #t  . #t  . #t  . #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t  . #t  |\|=| #t   #t  . #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t  . #t  while #t   #t  . #t  using #t  . #t  . #t   #t   #t   #t   #t   #t  . #t   #t   #t  . #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t  |.<\|| #t  . #t   #t  . #t   #t   #t   #t  . #t   #t   #t   #t   #t  . #t   #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t  . #t   #t   #t  . #t  .>= #t   #t  . #t   #t  return #t   #t  . #t  .<--> #t   #t   #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  << #t  . #t  >>>= #t   #t   #t  |.\|\|| #t   #t  . #t  . #t   #t   #t  struct #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t   #t  ./= #t   #t  . #t  . #t  try #t  . #t  |.\|| #t   #t   #t  >> #t   #t  . #t  . #t  . #t   #t  . #t  .= #t  . #t  .& #t  . #t   #t  ./ #t  . #t   #t  . #t   #t   #t  . #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t   #t   #t  .>>>= #t  . #t   #t   #t   #t   #t  .^ #t  do #t   #t  |\\=| #t  . #t   #t   #t  . #t   #t  . #t   #t  . #t  . #t   #t  . #t  /= #t   #t  . #t  . #t  .<= #t  . #t  . #t   #t  . #t  .= #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  .<-- #t   #t  . #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t   #t  .<< #t  .--> #t  . #t   #t  |'| #t   #t  . #t   #t  . #t   #t  . #t   #t   #t   #t  . #t  for #t  . #t   #t   #t   #t  . #t  . #t  .%= #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t   #t   #t  . #t  let #t  . #t  .> #t   #t   #t   #t   #t   #t  => #t   #t   #t  . #t  . #t   #t  . #t   #t   #t  . #t  import #t   #t  . #t  . #t  . #t   #t  . #t  . #t   #t   #t   #t  . #t   #t   #t  . #t  . #t  / #t  . #t   #t  . #t   #t   #t  . #t   #t  //= #t  . #t  . #t  . #t   #t   #t  . #t  . #t   #t  . #t  . #t   #t  . #t  . #t   #t  . #t   #t  . #t   #t   #t   #t   #t   #t  . #t  catch #t  . #t   #t  . #t  . #t  . #t  && #t  . #t   #t  . #t  . #t   #t  . #t  . #t   #t   #t  .<: #t   #t   #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  += #t   #t   #t   #t  >= #t  . #t   #t  . #t  . #t   #t  . #t   #t  . #t  . #t  global #t  . #t  . #t  |.\\| #t   #t   #t   #t   #t   #t  const #t   #t   #t   #t   #t  . #t   #t   #t  . #t  . #t  .&= #t  |.\|=| #t   #t  = #t  . #t  . #t   #t   #t  . #t  . #t   #t   #t   #t  . #t   #t   #t  . #t  end #t  . #t   #t   #t   #t  if #t  : #t  |.'| #t  *= #t  . #t   #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t  & #t  . #t  . #t  . #t   #t   #t  mutable #t   #t  . #t  . #t  . #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t  . #t  continue #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t  . #t  . #t  break #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  .<<= #t   #t  . #t   #t   #t   #t  . #t   #t   #t  . #t   #t   #t  . #t   #t   #t   #t   #t  . #t   #t  . #t  . #t  * #t   #t   #t  $ #t  . #t   #t   #t   #t   #t  ^= #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t   #t   #t  .+= #t   #t   #t   #t  local #t  . #t   #t  . #t  . #t  . #t  .!== #t   #t   #t   #t   #t  . #t  . #t  . #t  .//= #t  . #t  . #t   #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t  . #t   #t  . #t  .= #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t   #t  false #t  . #t  . #t  . #t   #t   #t  . #t   #t  . #t  . #t   #t  . #t   #t  . #t   #t  > #t  elseif #t   #t  . #t   #t  . #t   #t   #t  . #t   #t  .+ #t   #t  . #t   #t   #t   #t  . #t  <--> #t   #t  <-- #t  . #t   #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  .++ #t  . #t  . #t   #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t  >>= #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t   #t  . #t  .* #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t  . #t   #t  .< #t  . #t   #t  . #t  . #t   #t  . #t   #t  quote #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  .... #t  . #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t   #t   #t  . #t   #t   #t   #t  function #t  .= #t   #t   #t   #t   #t  . #t  . #t   #t   #t  . #t  . #t   #t   #t  < #t   #t  . #t   #t   #t   #t   #t   #t   #t  >: #t   #t   #t   #t   #t   #t  . #t   #t  - #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t   #t   #t  . #t   #t   #t  . #t  macro #t  . #t  . #t  . #t  %= #t  . #t  .% #t   #t  . #t  . #t   #t  = #t  . #t  . #t   #t  . #t  . #t   #t   #t   #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t  .. #t  . #t  . #t   #t   #t   #t   #t  . #t   #t  . #t   #t  . #t  . #t   #t   #t  . #t   #t  % #t  . #t   #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t  export #t   #t  . #t   #t  . #t   #t  |\|| #t  . #t   #t  . #t  . #t  else #t  . #t  . #t  |\|\|| #t  . #t  . #t  .=== #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t   #t  finally #t   #t  . #t   #t  . #t   #t  .! #t   #t   #t  . #t   #t   #t   #t   #t  . #t  . #t   #t   #t  . #t  .=> #t   #t  . #t   #t   #t  . #t  . #t  // #t  . #t   #t  . #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t  . #t   #t  . #t  .^= #t  . #t  . #t   #t   #t  . #t   #t   #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t  . #t  . #t  |\|>| #t   #t   #t   #t  . #t   #t  . #t   #t   #t  . #t   #t  . #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t  . #t   #t   #t  . #t   #t   #t   #t   #t  . #t   #t   #t  .- #t  |.\\=| #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t  .>>= #t  !== #t  ? #t   #t  . #t  .!= #t  . #t  . #t  . #t  . #t   #t  . #t  .== #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t  . #t  . #t  = #t  . #t  . #t  != #t  . #t   #t   #t   #t  + #t  :: #t  . #t  true #t  . #t   #t   #t   #t  ~ #t  . #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t  ... #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  .>> #t  . #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t  .~ #t   #t   #t   #t  . #t  . #t   #t   #t   #t   #t   #t   #t   #t  . #t   #t  ++ #t   #t  .-= #t   #t  . #t  . #t  |<\|| #t  . #t  . #t   #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t  := #t   #t   #t   #t  . #t   #t  primitive #t  . #t  . #t  --> #t  . #t  . #t   #t  . #t   #t   #t   #t  $= #t   #t   #t   #t   #t   #t   #t  . #t   #t  . #t   #t  . #t  . #t   #t  baremodule #t   #t  begin #t   #t   #t  . #t  &= #t  . #t   #t  . #t  . #t   #t   #t   #t  <= #t   #t  . #t  . #t  ! #t   #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t  <: #t   #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t  . #t  . #t   #t  . #t  . #t   #t  |.| #t  . #t   #t   #t   #t   #t  module #t  . #t)])
julia_flisp.boot:	  nospecialize-meta? #fn("9000\x8910002000\x8a1000760^m12}6<0e0|b332590e1|b23216E02|Mc2<16;02c3|\x84c442;" [length=
julia_flisp.boot:  length> meta #fn(memq) (nospecialize specialize)] nospecialize-meta?)
julia_flisp.boot:	  not-eof-1 #fn("6000r1c0|31690e1c241;|;" [#fn(eof-object?) error "incomplete: invalid character literal"] not-eof-1)
julia_flisp.boot:	  not-eof-for #fn("9000r2c0}316U0e1|g7c2=670c35@0g7c4=670c5530^\x8e141;};" [#fn(eof-object?)
julia_flisp.boot:  #\" "incomplete: invalid string syntax"] not-eof-for)
julia_flisp.boot:	  #fn("7000r2e0}|42;" [reverse!-] nreconc) num-non-varargs #fn("7000r1e0c1|42;" [count
julia_flisp.boot:  #fn("6000r1e0|31@;" [vararg?])] num-non-varargs)
julia_flisp.boot:	  oct-within-uint128? #fn(";000r1c0|`32c1=6;0e2|a32530|e3`e4g5c53242;" [#fn(string.char)
julia_flisp.boot:  #\- string.tail >= compare-num-strings "0o3777777777777777777777777777777777777777777"] oct-within-uint128?)
julia_flisp.boot:	  odd? #fn("6000r1e0|31@;" [even?] odd?) op-chars
julia_flisp.boot:	  (#176=#\-
julia_flisp.boot:	  op-or-sufchar? #fn("6000r1c0|3117802e1|41;" [#fn(op-suffix-char?)
julia_flisp.boot:						       opchar?] op-or-sufchar?)
julia_flisp.boot:	  open-input-file #fn("7000r1c0|c142;" [#fn(file) :read] open-input-file)
julia_flisp.boot:	  open-input-string #fn("8000r1c030c1g5|322c2g5`322g5;" [#fn(buffer)
julia_flisp.boot:								 #fn(io.seek)] open-input-string)
julia_flisp.boot:	  open-output-file #fn("8000r1c0|c1c243;" [#fn(file) :write :create] open-output-file)
julia_flisp.boot:	  open-output-string #fn("5000r0c040;" [#fn(buffer)] open-output-string)
julia_flisp.boot:	  open-string-output-port #fn("9000r0c030e1g4c2g4q142;" [#fn(buffer)
julia_flisp.boot:								 values #fn("6000r0c0~41;" [#fn(io.tostring!)])] open-string-output-port)
julia_flisp.boot:	  operator-precedence #fn("8000r1c0e1e2|31`43;" [#fn(get) prec-table
julia_flisp.boot:							 maybe-strip-op-suffix] operator-precedence)
julia_flisp.boot:	  operator? #fn(#5# #6# [#fn(#3# #4# [#table( #t  . #t  . #t  . #t  . #t  . #t   #t  . #t  . #t  <<= #t  . #t   #t   #t  . #t  . #t  . #t  ^ #t  . #t   #t   #t  . #t   #t  . #t  . #t   #t  .&& #t   #t  .>>> #t   #t  . #t   #t   #t  . #t   #t   #t  -> #t   #t   #t   #t   #t  -= #t  . #t   #t  . #t  . #t  . #t   #t   #t  .>: #t   #t  . #t  = #t   #t  === #t   #t  . #t  . #t   #t  . #t  .*= #t   #t   #t   #t  . #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t   #t  . #t  . #t  |.\|>| #t  . #t  . #t  . #t  . #t  . #t  . #t   #t   #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t  >>> #t   #t   #t   #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t   #t  .// #t  . #t   #t   #t   #t   #t  . #t   #t   #t   #t  . #t  . #t  |\\| #t  . #t  . #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t  == #t  . #t  . #t  . #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t  . #t  |\|=| #t   #t  . #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t   #t  . #t   #t  . #t  . #t  . #t   #t   #t   #t   #t   #t  . #t   #t   #t  . #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t  |.<\|| #t  . #t   #t  . #t   #t   #t   #t  . #t   #t   #t   #t   #t  . #t   #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t  . #t   #t   #t  . #t  .>= #t   #t  . #t   #t   #t  . #t  .<--> #t   #t   #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  << #t  . #t  >>>= #t   #t   #t  |.\|\|| #t   #t  . #t  . #t   #t   #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t   #t  ./= #t   #t  . #t  . #t  . #t  |.\|| #t   #t   #t  >> #t   #t  . #t  . #t  . #t   #t  . #t  .= #t  . #t  .& #t  . #t   #t  ./ #t  . #t   #t  . #t   #t   #t  . #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t   #t   #t  .>>>= #t  . #t   #t   #t   #t   #t  .^ #t   #t  |\\=| #t  . #t   #t   #t  . #t   #t  . #t   #t  . #t  . #t   #t  . #t  /= #t   #t  . #t  . #t  .<= #t  . #t  . #t   #t  . #t  .= #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  .<-- #t   #t  . #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t   #t  .<< #t  .--> #t  . #t   #t  |'| #t   #t  . #t   #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t   #t   #t   #t  . #t  . #t  .%= #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t   #t   #t  . #t  . #t  .> #t   #t   #t   #t   #t   #t  => #t   #t   #t  . #t  . #t   #t  . #t   #t   #t  . #t   #t  . #t  . #t  . #t   #t  . #t  . #t   #t   #t   #t  . #t   #t   #t  . #t  . #t  / #t  . #t   #t  . #t   #t   #t  . #t   #t  //= #t  . #t  . #t  . #t   #t   #t  . #t  . #t   #t  . #t  . #t   #t  . #t  . #t   #t  . #t   #t  . #t   #t   #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t  . #t  && #t  . #t   #t  . #t  . #t   #t  . #t  . #t   #t   #t  .<: #t   #t   #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  += #t   #t   #t   #t  >= #t  . #t   #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  |.\\| #t   #t   #t   #t   #t   #t   #t   #t   #t   #t  . #t   #t   #t  . #t  . #t  .&= #t  |.\|=| #t   #t  = #t  . #t  . #t   #t   #t  . #t  . #t   #t   #t   #t  . #t   #t   #t  . #t  . #t   #t   #t   #t  : #t  |.'| #t  *= #t  . #t   #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t  & #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t  . #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  .<<= #t   #t  . #t   #t   #t   #t  . #t   #t   #t  . #t   #t   #t  . #t   #t   #t   #t   #t  . #t   #t  . #t  . #t  * #t   #t   #t  $ #t  . #t   #t   #t   #t   #t  ^= #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t   #t   #t  .+= #t   #t   #t   #t  . #t   #t  . #t  . #t  . #t  .!== #t   #t   #t   #t   #t  . #t  . #t  . #t  .//= #t  . #t  . #t   #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t  . #t   #t  . #t  .= #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t   #t  . #t  . #t  . #t   #t   #t  . #t   #t  . #t  . #t   #t  . #t   #t  . #t   #t  > #t   #t  . #t   #t  . #t   #t   #t  . #t   #t  .+ #t   #t  . #t   #t   #t   #t  . #t  <--> #t   #t  <-- #t  . #t   #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  .++ #t  . #t  . #t   #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t  >>= #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t   #t  . #t  .* #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t  . #t   #t  .< #t  . #t   #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t   #t   #t  . #t   #t   #t   #t  .= #t   #t   #t   #t   #t  . #t  . #t   #t   #t  . #t  . #t   #t   #t  < #t   #t  . #t   #t   #t   #t   #t   #t   #t  >: #t   #t   #t   #t   #t   #t  . #t   #t  - #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t   #t   #t  . #t   #t   #t  . #t  . #t  . #t  . #t  %= #t  . #t  .% #t   #t  . #t  . #t   #t  = #t  . #t  . #t   #t  . #t  . #t   #t   #t   #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t  .. #t  . #t  . #t   #t   #t   #t   #t  . #t   #t  . #t   #t  . #t  . #t   #t   #t  . #t   #t  % #t  . #t   #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t  . #t   #t  . #t   #t  |\|| #t  . #t   #t  . #t  . #t  . #t  . #t  |\|\|| #t  . #t  . #t  .=== #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t   #t  . #t  . #t  . #t   #t   #t  . #t   #t  . #t   #t  .! #t   #t   #t  . #t   #t   #t   #t   #t  . #t  . #t   #t   #t  . #t  .=> #t   #t  . #t   #t   #t  . #t  . #t  // #t  . #t   #t  . #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t  . #t   #t  . #t  .^= #t  . #t  . #t   #t   #t  . #t   #t   #t  . #t  . #t  . #t   #t   #t   #t  . #t  . #t  . #t  . #t  |\|>| #t   #t   #t   #t  . #t   #t  . #t   #t   #t  . #t   #t  . #t  . #t  . #t   #t  . #t  . #t   #t   #t  . #t  . #t  . #t   #t   #t  . #t   #t   #t   #t   #t  . #t   #t   #t  .- #t  |.\\=| #t  . #t  . #t  . #t   #t   #t   #t   #t  . #t   #t   #t  . #t  .>>= #t  !== #t  ? #t   #t  . #t  .!= #t  . #t  . #t  . #t  . #t   #t  . #t  .== #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t  . #t  . #t  = #t  . #t  . #t  != #t  . #t   #t   #t   #t  + #t  :: #t  . #t  . #t   #t   #t   #t  ~ #t  . #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t   #t  ... #t   #t  . #t  . #t   #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  .>> #t  . #t   #t   #t  . #t  . #t  . #t  . #t   #t   #t  . #t   #t  .~ #t   #t   #t   #t  . #t  . #t   #t   #t   #t   #t   #t   #t   #t  . #t   #t  ++ #t   #t  .-= #t   #t  . #t  . #t  |<\|| #t  . #t  . #t   #t   #t  . #t   #t  . #t  . #t  . #t  . #t   #t  := #t   #t   #t   #t  . #t   #t  . #t  . #t  --> #t  . #t  . #t   #t  . #t   #t   #t   #t  $= #t   #t   #t   #t   #t   #t   #t  . #t   #t  . #t   #t  . #t  . #t   #t   #t   #t   #t  . #t  &= #t  . #t   #t  . #t  . #t   #t   #t   #t  <= #t   #t  . #t  . #t  ! #t   #t   #t   #t  . #t  . #t  . #t   #t  . #t   #t  . #t   #t  . #t  <: #t   #t  . #t  . #t   #t  . #t   #t  . #t  . #t  . #t  . #t  . #t   #t  . #t   #t   #t  . #t  . #t   #t  . #t  . #t   #t  |.| #t  . #t   #t   #t   #t   #t  . #t)])])
julia_flisp.boot:	  operators (-> |'| |.'| ... <: >: + - ! ~        .+ .- .! .~ .
julia_flisp.boot:		     . . . . . . = += -= = *= /= //= |\\=| ^= = %= <<=
julia_flisp.boot:		     >>= >>>= |\|=| &= =    .= .+= .-= .= .*= ./= .//= |.\\=|
julia_flisp.boot:		           --> <-- <--> . . . . . . . . . . .
julia_flisp.boot:		     . . .--> .<-- .<--> |\|\|| |.\|\|| && .&& > < >=  <= 
julia_flisp.boot:	  optional-positional-defs #fn("@000r8e0e1g53131c2c3L1c4c5c6g2g3}g4g<|q6e7c8g331313231e9|}g6g5g735L143;" [without-generated
julia_flisp.boot:  extract-method-prologue #fn(nconc) block #fn(copy-list)
julia_flisp.boot:  list-head filter-sparams list list-tail any #fn("7000r1e0c1~q1|42;" [contains
julia_flisp.boot:  #fn(nconc) block #fn(copy-list) call arg-name #fn(map) method-def-expr-])
julia_flisp.boot:  iota #fn(length) method-def-expr-] optional-positional-defs)
julia_flisp.boot:	  #fn("6000r1|F16802|Mc0<;" [overlay] overlay?) pair-with-gensyms #fn("7000r1c0c1|42;" [#fn(map)
julia_flisp.boot:  #fn("7000r1|F640|;|e0|31K;" [named-gensy])] pair-with-gensyms)
julia_flisp.boot:	  parameters-to-block #fn("A000r1|F16802|Mc0<6\xd70e1c2|32|NF16902e3|\x8431670|\x84530^e4g5a32640_;e4g5b2326G0e5g5\x8431g7\x8550g7;g6g7K;e4g5b3326\x800g5\x84e6g531g7F16902g7Mc0<6d0e5g731e5g831g916Q02g:16J02c7g6690g6L1530_g:Mg9K42;^;^;e8|31L1;" [parameters
julia_flisp.boot:  filter #fn("6000r1e0|31@;" [linenum?]) linenum? length= parameters-to-block
julia_flisp.boot:  caddr #fn(append) kw-to-=] parameters-to-block)
julia_flisp.boot:	  parse-Nary #fn("?000r6e0|31g4g:316F0g56<0g3e1|31L2;g3L1;]\x8c;g;c2g2g3|g4g;g5}q7O2g;M\x8e1e3g:g2326E0g56<0e1|31L1530_5O0g56D0e1|31}|31g<L2\x8e1580}|31L1]e4|3143;" [require-token
julia_flisp.boot:  line-number-node #fn(":000r3e0g2~327Q0|A17=02|NF17502}@6:0\x7fe1|31K;|M;e2i2312c3e4i2313117M02i3e4i2313117>02e0e4i231~326@0i4M|^e4i23143;i516:02e5|M31@6R0e6i231i4Mc7i6i231g7|33^e4i23143;i4Mi6i231|K^e4i23143;" [memv
julia_flisp.boot:  reverse! take-token #fn(eof-object?) peek-token linenum? line-number-node #fn(list*)])
julia_flisp.boot:  memv peek-token] parse-Nary)
julia_flisp.boot:	  parse-all- #fn("8000r2c0|q1c1}|q2c2g6q1tg6302;" [#fn("6000r0c0~41;" [#fn(io.close)])
julia_flisp.boot:							   #fn("9000r0e0c1~31k02c2g4q1c3\x7fq1c4g5q1tg5302;" [current-filename
julia_flisp.boot:  #fn(symbol) #fn("5000r0~k0;" [current-filename])
julia_flisp.boot:  #fn(";000r0e0~31]\x8c5g5c1~g4g5q3O2g5M\x8e1_41;" [make-token-stream #fn(">000r1e0c1~q131g5F6L0c2e3c4g5c5c6~31e7L3|3331K;e0c8\x7fq131c9g6316;0c2e3|31K;g6F16902g6Mc:<g76:0c6~31540g5c4g6c5g8e7L3|33g76<0c2e3g931K;i2Mg941;" [error-wrap
julia_flisp.boot:  #fn("6000r0e0~312c1~41;" [skip-ws-and-comments
julia_flisp.boot:			    #fn(input-port-line)]) toplevel reverse! #fn(list*)
julia_flisp.boot:  line #fn(input-port-line) current-filename #fn("6000r0e0~41;" [julia-parse])
julia_flisp.boot:  #fn(eof-object?) error])]) #fn("6000r1~302c0|41;" [#fn(raise)])])
julia_flisp.boot:							   #fn("6000r1~302c0|41;" [#fn(raise)])] parse-all-)
julia_flisp.boot:	  parse-and #fn(":000r1e0|31e1|31e2g6316D0e3|312g6g5e4|31L3;g5;" [parse-comparison
julia_flisp.boot:  peek-token is-prec-lazy-and? take-token parse-and] parse-and)
julia_flisp.boot:	  parse-arglist #fn(">000\x8920003000\x8a2000760^m22e0e1e2e3]k02^k12]k22]k32c4g7g8g9g:q4c5|}g2q3c6g;q1tg;302;" [range-colon-enabled
julia_flisp.boot:  space-sensitive where-enabled whitespace-newline #fn("5000r0~k02\x7fk12i2k22i3k3;" [range-colon-enabled
julia_flisp.boot:  space-sensitive where-enabled whitespace-newline])
julia_flisp.boot:  #fn(";000r0]\x8c4g4c0~\x7fg4i2q4O2g4M\x8e1_41;" [#fn("A000r1e0~31g5\x7f=6O0e1~312\x7fc2=6<0e3e4|3141;e4|41;g5c5=6\x840e1~312e0~312e6~31i2M_31\x7fc2=6>0e3e7|3131570e7|31c8c9L1c:i3690g6L1530_31c:g73133g8K;e;~31e0~31g7c<=6B0e1~312i2Mg6|K41;g7c5=6<0i2Mg6|K41;g7\x7f=6<0i2Mg6|K41;g7c=\x82O0e>~c=322e1~312i2Me?~g632|K41;g7c@=17802g7cA=6A0eBcCcDg7cE3341;eBcCcF\x7fcG3341;" [require-token
julia_flisp.boot:  take-token #\) to-kws reverse! #\; line-number-node reverse #fn(nconc)
julia_flisp.boot:  parameters #fn(copy-list) parse-eq* #\, for expect-space-before
julia_flisp.boot:  parse-generator #\] #\} error #fn(string) "unexpected \"" "\" in argument list"
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] parse-arglist)
julia_flisp.boot:	  parse-array #fn("C000r5]]]]]]]\x8c9\x8c:\x8c;\x8c<\x8c=\x8c>\x8c?g9c0O2g:c1O2g;c2O2g<c3g<q1O2g=c4g9g;q2O2g>c5g=g>q2O2g?c6g>g<g9g;g?g:q6O2e7g4k72c8g@q1c9g?|}g2g3q5c:gAq1tgA302;" [#fn("7000r2|e0}31K;" [reverse] fix)
julia_flisp.boot:  #fn("9000r3}aX650g2;~M|e0}31|g2K43;" [1-] ncons)
julia_flisp.boot:  #fn("8000r2e0|a32650|M;}aW6:0~Mc1|42;\x7fMc2e3}31|43;" [length= row nrow 1-] fix-level)
julia_flisp.boot:  cddr 1- 1+] collapse-level) #fn("R000r8\x8c1\x8c2\x8c3\x8c4]]c0g3g4g2}~q5m<2c1g7g5}\x7fg3q5m=2g617;02e2|31c3=670c3570e4|31g>g5=6\x990e5|312}~Mg4Mg3Mx}Me6g3M3133O2g4M`W6S0e7}MMa326=0i2Mc8}MM42;i2Mc9}MM42;g4MaW6=0i2Mc:}MM42;i3Mc;g4M}MM43;g>g?c3=6\xb10g617802e5|312e2|31e<g3M`3216802g@c==6A0e>c?c@cA3231530]2g3M`W16D02eBg@c=cCg5c3L432@6;0g<g@31530]2g=g@312i4M|}Mg2Mg3Mg4Mg5^g748;g?c==6\xf80g617802e5|312e<g3M`3216802eD|316;0e>cE31530]2e2|31g2MA@16@02g2M16802g3MaW6d0g@c3=660]5U0cFg@3117802g@c==7A0e>c?cGcH3231530^530^gA6O0}i5M}M31O2g4}MN\x8560`550g4MO5?0g<g@312g=g@312i4M|}Mg2Mg3Mg4Mg5^gA48;g?cI=690e>cJ41;eBg?cK326A0e>c?cLg>cM3341;g?cC=6a0e7}MMa3216702}MNA6F0e5|312eN|eO}M31g543;e>cP41;g7@16B02}MMF16902eD|31@6f0e>c?cQg5cRg5cS=670cT540cUcVg5cWeXeO}M3131g>cM3:31530]2eY|31}g@}MMK}MNKO2cZ}MM31b2W6X0g2M\x8590g2]O5H0g2M7A0e>c?c[cH3231530]530]\x8e12i4M|}Mg2M`g4Mg5^^48;" [#fn(":000r1~e0~M31O2\x7fe1\x7fM~M32O2i2MA16B02~Mb2W16802|c2=@690i2^O530]2i3i4Mai3M~M33O;" [1+
julia_flisp.boot:  max #\;] process-semicolon) #fn(":000r1~@16B02e0|c1c2\x7fc3L432@6B0i2i3M_i4Mi2M33O;];" [memv
julia_flisp.boot:  #\; for #\linefeed] restore-lower-dim-lists) peek-token #\linefeed
julia_flisp.boot:  require-token take-token 1+ length= vect hcat vcat ncat > #\; error #fn(string)
julia_flisp.boot:  #fn(eof-object?) "cannot mix space and ;; separators in an array expression, "
julia_flisp.boot:   #\}) "unexpected \"" "\"" parse-comprehension caar "invalid comprehension syntax"
julia_flisp.boot:  #\] #\[ #\{ " " "\"; got \"" deparse parse-eq* #fn(length)
julia_flisp.boot:  "cannot mix space and \";;\" separators in an array expression, "] parse-array-inner)
julia_flisp.boot:  end-symbol #fn("5000r0~k0;" [end-symbol])
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] parse-array)
julia_flisp.boot:	  parse-arrow #fn(";000r1e0|31e1|31e2g6316Y0e3|312g6c4\x82>0g6g5e5|31L3;c6g6g5e5|31L4;g5;" [parse-or
julia_flisp.boot:  peek-token is-prec-arrow? take-token --> parse-arrow call] parse-arrow)
julia_flisp.boot:	  parse-assignment #fn("=000r2}|31e0|31e1g731750g6;e2|312g7c3<17802g7c4<6k0e516C02e6|3116902e7|31@6B0e8|g7e6|31332g6;c9g7g6e:|}32L4;g7c;\x82L0c<|a[31e=g7g6e:|}32L3g842;g7g6e:|}32L3;" [peek-token
julia_flisp.boot:  is-prec-assignment? take-token ~ .~ space-sensitive ts:space?
julia_flisp.boot:  space-before-next-token? ts:put-back! call parse-assignment = #fn(input-port-line)
julia_flisp.boot:  short-form-function-loc] parse-assignment)
julia_flisp.boot:	  parse-atom #fn("O000\x8910002000\x8a1000760]m12e0|31g6c1\x82\xc00e2|312e3|a[31g7c4=@16I02c5g731@16=02e6|a[31c7=6=0e3|a[312g7;e830]\x8c9g9c9g8|g9q3O2g9M\x8e1g7312e:c;g83131e<g931g:aW6:0c=g9`42;g:`W690e>c?41;e>c@41;g6cA\x82\xa00e2|312eB|31eCg73116A02g7C@17802eD|31650cA;eD|31690e>cE41;g7cF=690e>cG41;cHeI^kI2cJg9q1cK|q1cLg:q1tg:302\x8e1\x8e1L2;g6cM\x8290e>cN41;g6C6\x1d0}6o0eOg6316C0e>cPcQg6cR3331530]2eCg6316F0e>cPcSe2|31cR3331530]530]2e2|312g6cT<16b02|b3[17602|`[6H0eB|31cU=16902eD|31@5<0e6|a[31cU=6\x810eB|312e2|312eV|cU32eB|31g8C16E02eWg831@16902eD|31@6C0e>cPcXg7cY3331530]2cZg741;g6c[\x8250c\\;g6c]\x8250c^;g6;g6c_=6?0e2|312e`|}42;g6ca=6L0e2|312eb|cceI33g7\x8550cd;g7;g6ce=6\xbc0e2|312e0|31cf=6;0e2|312cg;eb|cfeI33g7\x8550cg;g7Mg8ch=6B0cicjL1ckg7N3142;g8cl=6F0cmcicnL1ckg7N3132L2;g8co=6B0cicjL1ckg7N3142;cicmL1ckg7N3142;g6cU=6c0e2|312ep|cU^33eqg7a326G0cicrL1ckesctg7323142;g7M;g6cu=6^0e2|312evew]kv2^kw2cxg7g8q2cy|q1czg9q1tg9302;g6c{=6O0e2|312c|c}c~L2e\x7f|31eV|c{32L4;c\x80g63117A02g6D17902e\x81g631680e2|41;eCg6316D0e>cPcSe2|31cR3341;e>cPc\x82e2|31cR3341;" [require-token
julia_flisp.boot:  |'| take-token read-char #\\ #fn(eof-object?) peek-char #\'
julia_flisp.boot:  open-output-string #fn(":000r1|c0=7x0|c1=6;0e2c331530]2e4e5|31~322|c6=6E0e4e5e7\x7fa[3131~32530]2i2Me7\x7fa[3141;];" [#\'
julia_flisp.boot:  #\" error "invalid character literal" write-char not-eof-1 #\\ read-char])
julia_flisp.boot:  unescape-string #fn(io.tostring!) string-length #fn(string.char) error "invalid empty character literal"
julia_flisp.boot:  "character literal contains multiple characters" : peek-token closing-token?
julia_flisp.boot:  end-symbol #fn("5000r0~k0;" [end-symbol])
julia_flisp.boot:  #fn("7000r0e0~^42;" [parse-atom]) #fn("6000r1~302c0|41;" [#fn(raise)]) = "unexpected \"=\""
julia_flisp.boot:  invalid-identifier? #fn(string) #634# #635# "unexpected \"" var #\"
julia_flisp.boot:  parse-raw-literal operator? "suffix not allowed after `var\"" "\"`" #fn(symbol)
julia_flisp.boot:  true (true) false (false) #\( parse-paren #\[ parse-cat #\] (vect)
julia_flisp.boot:  #\{ #\} (braces) vect #fn(nconc) braces #fn(copy-list) hcat bracescat row
julia_flisp.boot:  comprehension parse-string-literal length> string filter #fn("6000r1c0|3116:02c1|31`W@;" [#fn(string?)
julia_flisp.boot:  #fn(length)]) #\@ space-sensitive whitespace-newline #fn("5000r0~k02\x7fk1;" [space-sensitive
julia_flisp.boot:  whitespace-newline]) #fn("?000r0e0~31e1~31e2~312e3~316U0e4~c5c6L1e7g531L1g4L1c8e9~31313442;e:~g5]33e;~g6g443;" [line-number-node
julia_flisp.boot:  parse-macro-name peek-token ts:space? maybe-docstring #fn(nconc) macrocall
julia_flisp.boot:  macroify-name #fn(copy-list) parse-space-separated-exprs parse-call-chain
julia_flisp.boot:  macroify-call]) #fn("6000r1~302c0|41;" [#fn(raise)])
julia_flisp.boot:  #\` macrocall core @cmd line-number-node #fn(string?) large-number? "invalid syntax: \""] parse-atom)
julia_flisp.boot:	  parse-atsym #fn("8000r1e0|31g5c1=6B0e2|312e3e4|3141;e5|41;" [peek-token
julia_flisp.boot:  #\@ take-token macroify-name parse-macro-name parse-unary-prefix] parse-atsym)
julia_flisp.boot:	  parse-block #fn("<000\x8910002000\x8a1000770e0m12e1|}c2c3c4]46;" [parse-eq
julia_flisp.boot:  parse-Nary (#\linefeed
julia_flisp.boot:					       (end else elseif catch finally)])] parse-block)
julia_flisp.boot:	  parse-call #fn("9000r1e0|31e1|e2|31g543;" [peek-token
julia_flisp.boot:						     parse-call-with-initial-ex
julia_flisp.boot:						     parse-unary-prefix] parse-call)
julia_flisp.boot:	  parse-call-arglist #fn("9000r2e0]k02c1g6q1c2|}q2c3g7q1tg7302;" [for-generator
julia_flisp.boot:  #fn("5000r0~k0;" [for-generator]) #fn("7000r0e0~\x7f42;" [parse-arglist])
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] parse-call-arglist)
julia_flisp.boot:	  parse-call-chain #fn(":000r3]\x8c7g7c0|g2g7q3O2g7M\x8e1}41;" [#fn("P000r1e0~31e116E02e2~3116;02e3g5c43217I02|D17802e5|3116802g5c6=640|;g5g6c6=6q0e7~|g5332e8~312e9~c:32e;c<g7q1c=~|g7q332\x8e1\x7f6;0c>c?g742;i2Mg741;g6c@=6\x0a0e7~|g5332e8~312eAeA]kA2cBg8q1cC~g7q2cDg9q1tg9302\x8e1\x8e1\x7f6:0cE|g8L3;g8\x85=0i2McF|L241;g8Mg9cG=6H0i2McHcF|c>eIg8N323341;g9cJ=6B0i2McHcK|g8N3341;g9cL=6B0i2McHcM|g8N3341;g9cN=6B0i2McHcO|g8N3341;g9cP=6B0i2McHcQ|g8N3341;eRcS41;g6cT=6J1e7~|g5332e8~312i2Me0~31c6=6r0e2~316G0e7~cT|cUcVL2L3c633530]2e8~312cT|cWcXL1cYe9~c:323132L35\xea0e0~31cZ=6o0e8~312e0~31c[=6;0eRc\\315R0e2~316;0eRc]315A0cT|cUe^~^32L2L35\xa20e0~31c_\x82Q0e8~312e^~31cT|c`c_g8L2L2L3\x8e15y0e^~^32g8F16902g8Mca<6U0cWcaL1cT|cUg8\x84L2L3L1cYebg83131335=0cT|cUg8L2L3\x8e141;g6cc=6h0e2~317^0e8~312ed~a[ce]33i2Mg7cc\x82:0g7|L2590cEg7|L341;|;g6cf=690eRcg41;g6ch=6o0e7~|g5332e8~312e9~ci32\x7f6F0cE|cWcjL1cYg73132L3;i2McHck|g73341;e3g6cl326\xe20|C17802em|3116D02en|31@16902e2~31@6\xbb0eo~31e8~312ep~g532e0~31eq|erg53132g9C17A02g9D17902e5g93116E02eng931@16902e2~31@6Y0i2Mcag:g7g8g9C6>0cse8~3131570e8~31L541;i2Mcag:g7g8L441;|;|;" [peek-token
julia_flisp.boot:  space-sensitive ts:space? memv (#\(
julia_flisp.boot:				  #\" #\`) large-number? #\( disallow-space
julia_flisp.boot:  take-token parse-call-arglist #\) call-with-values #fn("7000r0e0c1~42;" [separate
julia_flisp.boot:  #fn(";000r2e0~31c1\x82W0e2~312c1c3c4L1\x7fL1c5|31c5}3134e6~31L3;c3c4L1\x7fL1c5i23143;" [peek-token
julia_flisp.boot:  do take-token #fn(nconc) call #fn(copy-list) parse-do])
julia_flisp.boot:  #fn(map) #fn("8000r1|F16802|Mc0<6A0c1c2L1c3|N3142;|;" [kw #fn(nconc) = #fn(copy-list)])
julia_flisp.boot:  #\[ end-symbol #fn("5000r0~k0;" [end-symbol])
julia_flisp.boot:  #fn("8000r0e0~c1\x7f43;" [parse-cat #\]])
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)]) call ref vect #fn(list*) =-to-kw hcat
julia_flisp.boot:  error "unknown parse-cat result (internal error)" |.| quote || #fn(nconc)
julia_flisp.boot:  tuple #fn(copy-list) : #\linefeed "newline not allowed after \":\" used for quoting"
julia_flisp.boot:  "whitespace not allowed after \":\" used for quoting" parse-atom $ inert
julia_flisp.boot:  macrocall cddr |'| read-operator #\' |.'| "the \".'\" operator is discontinued"
julia_flisp.boot:			#\`) valid-modref? operator? line-number-node
julia_flisp.boot:  parse-raw-literal macroify-name macsuffix #fn(string)])] parse-call-chain)
julia_flisp.boot:	  parse-call-with-initial-ex #fn("8000r3e0g23117;02c1g2c232690e3|}42;e4|}^43;" [initial-reserved-word?
julia_flisp.boot:  #fn(memq) (mutable primitive abstract) parse-resword parse-call-chain] parse-call-with-initial-ex)
julia_flisp.boot:	  parse-cat #fn("?000r3e0e1e2e3e4]k02]k12]k22^k32]k42c5g7g8g9g:g;q5c6|}g2q3c7g<q1tg<302;" [range-colon-enabled
julia_flisp.boot:  space-sensitive where-enabled whitespace-newline for-generator #fn("5000r0~k02\x7fk12i2k22i3k32i4k4;" [range-colon-enabled
julia_flisp.boot:  space-sensitive where-enabled whitespace-newline for-generator])
julia_flisp.boot:  #fn("<000r0e0~31\x7f=6:0e1~312_;e2~31e3~31g5c4=17702g5\x7f=6;0e5~g4\x7f43;g5c6\x82I0e7~c6322e1~312e8~g4\x7f43;g5c9=6^0e1~312e:e3~31c4\x7fL2326;0e5~g4\x7f43;e;~g4\x7f]i245;e;~g4\x7f^i245;" [require-token
julia_flisp.boot:  take-token parse-eq* peek-token #\, parse-vect for expect-space-before
julia_flisp.boot:  parse-comprehension #\linefeed memv parse-array])
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] parse-cat)
julia_flisp.boot:	  parse-chain #fn(";000r3]\x8c7g7c0|g2g7}q4O2g7M\x8e1}|31L141;" [#fn(":000r1e0~31g5\x7f<780e1|41;e2~31e3~312e416M02g616F02c5g5e63216902e7~31@6B0e8~g5g6332e1|41;i2Mi3~31|K41;" [peek-token
julia_flisp.boot:  reverse! ts:space? take-token space-sensitive #fn(memq)
julia_flisp.boot:  unary-and-binary-ops space-before-next-token? ts:put-back!])] parse-chain)
julia_flisp.boot:	  parse-comma #fn("9000r1]\x8c5g5c0|g5q2O2g5M\x8e1e1|31L1]e2|3143;" [#fn("9000r3g2c0=7K0|NF17502}@6;0c1e2|31K;|M;e3~312e4~31c5\x82>0\x7fM|^e4~3143;\x7fMe6~31|K^e4~3143;" [#\,
julia_flisp.boot:  tuple reverse! take-token peek-token = parse-pair]) parse-pair peek-token] parse-comma)
julia_flisp.boot:	  parse-comma-separated #fn(":000r2]\x8c6g6c0}|g6q3O2g6M\x8e1_41;" [#fn("9000r1~\x7f31e0\x7f31g6c1=6B0e2\x7f312i2Mg5|K41;e3g5|K41;" [peek-token
julia_flisp.boot:  #\, take-token reverse!])] parse-comma-separated)
julia_flisp.boot:	  parse-comma-separated-assignments
julia_flisp.boot:	  #fn("7000r1e0|e142;" [parse-comma-separated parse-eq*] parse-comma-separated-assignments)
julia_flisp.boot:	  parse-comma-separated-iters #fn("9000r1]\x8c5g5c0|g5q2O2g5M\x8e1_41;" [#fn("9000r1e0~31e1~31g6c2=6A0e3~312\x7fMg5|K41;e4g5|K41;" [parse-iteration-spec
julia_flisp.boot:  peek-token #\, take-token reverse!])] parse-comma-separated-iters)
julia_flisp.boot:	  parse-comparison #fn("9000r1]\x8c5g5c0|g5q2O2g5M\x8e1e1|31]42;" [#fn("<000r2e0~31e1g6316b0e2~312}6D0\x7fMc3|g6e4~31L4^42;\x7fMc5|g6e4~31L232^42;}640|;e6|b4326d0e7|31|\x84e8|31g7c9<17802g7c:<6;0g7g8g9L3;c;g7g8g9L4;|;" [peek-token
julia_flisp.boot:  is-prec-comparison? take-token comparison parse-pipe< #fn(append) length=
julia_flisp.boot:  caddr cadddr <: >: call]) parse-pipe<] parse-comparison)
julia_flisp.boot:	  parse-comprehension #fn(";000r3e0e1]k02^k12c2g7g8q2c3|}g2q3c4g9q1tg9302;" [whitespace-newline
julia_flisp.boot:  space-sensitive #fn("5000r0~k02\x7fk1;" [whitespace-newline space-sensitive])
julia_flisp.boot:  #fn(":000r0e0~\x7f32e1~31i2=7C0e2c3c4i2c53331570e6~312c7g4L2;" [parse-generator
julia_flisp.boot:								  require-token
julia_flisp.boot:								  take-token
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] parse-comprehension)
julia_flisp.boot:	  parse-cond #fn("@000r1e0|31e1|31c2\x82\x150e3|317;0e4c531530]2e6|312e7]k72c8g6q1c9|q1c:g7q1tg7302\x8e1\x8e1e3|317;0e4c;31530]\x8e12e<^k<2c=g6q1c>|q1c?g7q1tg7302\x8e1\x8e1e1|31c@<7;0e4cA31530]2e3|317;0e4cB31530]2e6|312e7]k72cCg7q1cD|q1cEg8q1tg8302\x8e1\x8e1e3|317;0e4cF31530]\x8e12cGg5g6eH|31L4;g5;" [parse-arrow
julia_flisp.boot:  peek-token ? ts:space? error "space required before \"?\" operator"
julia_flisp.boot:  take-token whitespace-newline #fn("5000r0~k0;" [whitespace-newline])
julia_flisp.boot:  #fn("9000r0e0^k02c1g4q1c2~q1c3g5q1tg5302;" [range-colon-enabled #fn("5000r0~k0;" [range-colon-enabled])
julia_flisp.boot:					      #fn("6000r0e0~41;" [require-token])
julia_flisp.boot:  range-colon-enabled #fn("5000r0~k0;" [range-colon-enabled])
julia_flisp.boot:  #fn("6000r0e0~41;" [parse-eq*]) #fn("6000r1~302c0|41;" [#fn(raise)]) : "colon expected in \"?\" expression"
julia_flisp.boot:  #fn("5000r0~k0;" [whitespace-newline]) #fn("6000r0e0~41;" [require-token])
julia_flisp.boot:  if parse-eq*] parse-cond)
julia_flisp.boot:	  parse-decl #fn("8000r1e0|e1|3142;" [parse-decl-with-initial-ex
julia_flisp.boot:					      parse-call] parse-decl)
julia_flisp.boot:	  parse-decl-with-initial-ex #fn("9000r2]\x8c6g6c0|g6q2O2g6M\x8e1}41;" [#fn("<000r1e0~31g5g6c1=6I0e2~312\x7fMg5|e3~e432L341;g6c5=6N0e2~312e6~31c5|e7e8~31g732L3;|;" [peek-token
julia_flisp.boot:  :: take-token parse-where parse-call -> line-number-node add-line-number
julia_flisp.boot:  parse-eq*])] parse-decl-with-initial-ex)
julia_flisp.boot:	  parse-def #fn("<000r3e0|31}16902e1g73117902e2g7316C0e3c4c5g7c633315:0e7|g7^33}16;02e8|31c9<6F0e:|312c9g8e;|31L3540g8e8|31c<\x82:0e=|g942;g9;" [parse-unary-prefix
julia_flisp.boot:  reserved-word? initial-reserved-word? error #fn(string) "invalid name \"" "\""
julia_flisp.boot:  parse-call-chain peek-token :: take-token parse-call where parse-where-chain] parse-def)
julia_flisp.boot:	  parse-do #fn("9000r1e0c1|a[31k02c2g5q1c3|q1c4g6q1tg6302;" [expect-end-current-line
julia_flisp.boot:  #fn(input-port-line) #fn("5000r0~k0;" [expect-end-current-line])
julia_flisp.boot:  #fn("A000r0e0e1e2e3e4e5]k02^k12]k22^k32^k42^k52c6g4g5g6g7g8g9q6c7~q1c8g:q1tg:302;" [range-colon-enabled
julia_flisp.boot:  space-sensitive where-enabled for-generator end-symbol whitespace-newline #fn("5000r0~k02\x7fk12i2k22i3k32i4k42i5k5;" [range-colon-enabled
julia_flisp.boot:  space-sensitive where-enabled for-generator end-symbol whitespace-newline])
julia_flisp.boot:  peek-token (#\linefeed
julia_flisp.boot:	      #\;) parse-comma-separated parse-range -> #fn(nconc) tuple #fn(copy-list)
julia_flisp.boot:  parse-block expect-end do]) #fn("6000r1~302c0|41;" [#fn(raise)])])
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] parse-do)
julia_flisp.boot:	  parse-docstring #fn("<000r2e0|31}|31e1|g73216N02]\x8c8g8c2|g8q2O2g8M\x8e1e3|31`326E0c4c5c6L2g6g7}|31L5;g7;" [line-number-node
julia_flisp.boot:  doc-string-literal? #fn("7000r2e0|31640^;e1|316K0}aW640^;e2~312\x7fMe3~31a42;];" [closing-token?
julia_flisp.boot:  newline? take-token peek-token]) peek-token macrocall core @doc] parse-docstring)
julia_flisp.boot:	  parse-eq #fn("7000r1e0|e142;" [parse-assignment parse-comma] parse-eq)
julia_flisp.boot:	  parse-eq* #fn(";000r1e0|31e1|31g5D17B02g5C16:02e2g531@6x0e3|312e0|31g7c4=17L02g7c5=17B02g7c6=17802g7c7=650g5;e8|g5g6332e9|e:42;e9|e:42;" [peek-token
julia_flisp.boot:  ts:space? non-standalone-symbol-token? take-token #\,
julia_flisp.boot:  #\) #\} #\] ts:put-back! parse-assignment parse-pair] parse-eq*)
julia_flisp.boot:	  parse-expr #fn("9000r1e0|e1e2c344;" [parse-with-chains parse-term
julia_flisp.boot:					       is-prec-plus? (+ ++)] parse-expr)
julia_flisp.boot:	  parse-factor #fn("9000r1e0|31e1|e2|31g543;" [peek-token
julia_flisp.boot:						       parse-factor-with-initial-ex
julia_flisp.boot:						       parse-unary-prefix] parse-factor)
julia_flisp.boot:	  parse-factor-after #fn(";000r1e0|31e1|31e2g6316F0e3|312c4g6g5e5|31L4;g5;" [parse-juxtapose
julia_flisp.boot:  peek-token is-prec-power? take-token call parse-factor-after] parse-factor-after)
julia_flisp.boot:	  parse-factor-with-initial-ex #fn("<000\x8920003000\x8a2000760^m22e0|e1|}g23332e2|31e3g8316F0e4|312c5g8g7e6|31L4;g7;" [parse-decl-with-initial-ex
julia_flisp.boot:  parse-call-with-initial-ex peek-token is-prec-power? take-token call
julia_flisp.boot:  parse-factor-after] parse-factor-with-initial-ex)
julia_flisp.boot:	  parse-generator #fn("=000r2e0|31e1|31c2\x82R0e3|312c4c5L1e6|31L1c7g63133L1540g6e1|31c8\x82[0e9|c8322e3|312c:c4c;L1e<|}32L1c7g73133L2;c4c;L1}L1c7g73143;" [parse-comma-separated-iters
julia_flisp.boot:  peek-token if take-token #fn(nconc) filter parse-cond #fn(copy-list) for
julia_flisp.boot:  expect-space-before flatten generator parse-generator] parse-generator)
julia_flisp.boot:	  parse-import #fn(":000r3e0|}32e1|31c2\x82j0g2@16702}c3<6G0e4c5c6e7g731c83331530]2e9|312c2g7e:|31L3;g7;" [parse-import-path
julia_flisp.boot:  peek-token as using error #fn(string) "invalid syntax \"using "
julia_flisp.boot:  deparse-import-path " as ...\"" take-token parse-atsym] parse-import)
julia_flisp.boot:	  parse-import-dots #fn("9000r1]\x8c5g5c0|g5q2O2g5M\x8e1_e1|3142;" [#fn(";000r2}c0\x82I0e1~312\x7fMc2c0|32e3~3142;}c4\x82K0e1~312\x7fMc2c0c0|33e3~3142;}c5\x82M0e1~312\x7fMc2c0c0c0|34e3~3142;}c6\x82O0e1~312\x7fMc2c0c0c0c0|35e3~3142;e7~31|K;" [|.|
julia_flisp.boot:  take-token #fn(list*) peek-token .. ... .... parse-atsym]) require-token] parse-import-dots)
julia_flisp.boot:	  parse-import-path #fn(":000r2]\x8c6g6c0}|g6q3O2g6M\x8e1e1|3141;" [#fn(";000r1e0|M317B0e1c2c3~c43331530]2e5\x7f31g5c6\x82S0e7\x7f|Mg5332e8\x7f312i2Me9e:\x7f3131|K41;e;g5c<3217902c=g5316;0c6e>|31K;c?c2g531`a33c@=6O0e8\x7f312i2McAc?c2g531a3231|K41;c6e>|31K;" [symbol-or-interpolate?
julia_flisp.boot:  error #fn(string) "invalid \"" "\" statement: expected identifier" peek-token
julia_flisp.boot:  |.| disallow-space take-token unquote parse-atsym memv (#\linefeed
julia_flisp.boot:  #fn(eof-object?) reverse #fn(string.sub) "." #fn(symbol)]) parse-import-dots] parse-import-path)
julia_flisp.boot:	  parse-imports #fn("B000r2e0|}^33e1|31g7c2<16g02e3|31@16\\02g6F16902g6Mc4<@17H02e5c6c7}c8e9g631c:3531g817802g7c;=6<0e<|312^530]g9660_5`0e=|c>}g8q232e1|31c2\x82F0e5c6c?}c@cAcB3531540g:\x8e1g86H0}cCc2L1g6L1cDg:3133L2;}cE<16A02g6F16902g6Mc4<6H0e5c6cFeGg6\x8431cH3331530]2cI}g6g:43;" [parse-import
julia_flisp.boot:  peek-token : ts:space? as error #fn(string) "invalid syntax \"" " " deparse
julia_flisp.boot:  ":\"" #\, take-token parse-comma-separated
julia_flisp.boot:  #fn("8000r1e0|~\x7f43;" [parse-import]) "\":\" in \"" "\" syntax can only be used "
julia_flisp.boot:  #fn(nconc) #fn(copy-list) using "invalid syntax \"using " deparse-import-path
julia_flisp.boot:  " as ...\"" #fn(list*)] parse-imports)
julia_flisp.boot:	  parse-interpolate #fn("A000r1|a[e0g531c1g6316c0e2|31e0g531e3g831680e4|41;e5c6c7g7c8g8c9g7c:3741;g6c;=6[0e<g5312e=|31e2|31g8c>=6;0e4|312g7;e5c?41;e5c6c@g6cA3341;" [peek-char
julia_flisp.boot:  #fn(identifier-start-char?) require-token ends-interpolated-atom? take-token
julia_flisp.boot:  " ends with invalid character \"" "\"; use \"$(" ")\" instead." #\( read-char
julia_flisp.boot:  parse-eq* #\) "invalid interpolation syntax"
julia_flisp.boot:  "invalid interpolation syntax: \"$" "\""] parse-interpolate)
julia_flisp.boot:	  parse-iteration-spec #fn("=000r1]c0m52e1e2]k12^k22c3g6g7q2c4|q1c5g8q1tg8302\x8e1\x8e2g6c6\x82U0g5|31c7g7c832670g65;0c6e9|31L2\x8e1540g6\x8e1g5|31c7g7c8326D0e:|312c;g6e9|31L3;e<c=41;" [#fn("7000r1e0|31e116902e2g5316>0e3|312e0|41;g5;" [peek-token
julia_flisp.boot:  for-generator newline? take-token] peek-token-) space-sensitive
julia_flisp.boot:  whitespace-newline #fn("5000r0~k02\x7fk1;" [space-sensitive
julia_flisp.boot:					      whitespace-newline])
julia_flisp.boot:  #fn("6000r0e0~41;" [parse-pipe<]) #fn("6000r1~302c0|41;" [#fn(raise)]) outer
julia_flisp.boot:  #fn(memq) (= in ) parse-pipe< take-token = error "invalid iteration specification"] parse-iteration-spec)
julia_flisp.boot:	  parse-juxtapose #fn(":000r1e0|31]\x8c6g6c1|g6q2O2g6M\x8e1g5g5L142;" [parse-unary
julia_flisp.boot:  #fn("<000r2e0~31e1~|g6336Z0e2g6316:0e3~31570e4~31\x7fMc5c6|g7L4g7}K42;e7}a32650}M;c8c5c6e9}3143;" [peek-token
julia_flisp.boot:  juxtapose? radical-op? parse-unary parse-factor call * length= #fn(list*)
julia_flisp.boot:  reverse])] parse-juxtapose)
julia_flisp.boot:	  parse-macro-name #fn(":000r1e0|31e1|c2g533\x8e12e3e4]k32^k42c5g5g6q2c6|q1c7g7q1tg7302;" [peek-token
julia_flisp.boot:  disallow-space @ space-sensitive whitespace-newline #fn("5000r0~k02\x7fk1;" [space-sensitive
julia_flisp.boot:  whitespace-newline]) #fn("7000r0e0~31c1\x82;0e2~312c3;e4~^42;" [peek-token |.|
julia_flisp.boot:								  take-token
julia_flisp.boot:								  parse-atom])
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] parse-macro-name)
julia_flisp.boot:	  parse-or #fn(":000r1e0|31e1|31e2g6316D0e3|312g6g5e4|31L3;g5;" [parse-and
julia_flisp.boot:  peek-token is-prec-lazy-or? take-token parse-or] parse-or)
julia_flisp.boot:	  parse-pair #fn(";000r1e0|31e1|31e2g6316F0e3|312c4g6g5e5|31L4;g5;" [parse-cond
julia_flisp.boot:  peek-token is-prec-pair? take-token call parse-pair] parse-pair)
julia_flisp.boot:	  parse-paren #fn("8000\x8910002000\x8a1000760]m12e0|}32M;" [parse-paren-] parse-paren)
julia_flisp.boot:	  parse-paren- #fn("=000r2e0e1e2e3]k02^k12]k22]k32c4g6g7g8g9q4c5|}q2c6g:q1tg:302;" [range-colon-enabled
julia_flisp.boot:  space-sensitive where-enabled whitespace-newline #fn("5000r0~k02\x7fk12i2k22i3k3;" [range-colon-enabled
julia_flisp.boot:  space-sensitive where-enabled whitespace-newline])
julia_flisp.boot:  #fn("D000r0e0~31g4c1=6;0e2~312c3;e4g4316\x820e2~31e0~31c1=7C0e5c6c7g5c83331570e2~312\x7f6P0e9g5316C0e5c6c7g5c83331530]530]2g5^K;\x7f@16j02g4c:<16`02e;~31e2~3116;02e0~31c1=17B02e<~c:g53316402^\x8e16;0e2~312c=;g4c>=6J0e?~]^e@~c13234g5g5McA<K;eB~31e0~31g6c1=6K0e2~312eCg531670g5]K;g5^K;g6cD=6K0e2~312e?~^]e@~c132g535]K;g6c>=6P0e?~^eCg531e@~c1]33g535eCg531K;g6cE\x82f0eF~cE322e2~312eG~g532e0~31c1=6:0e2~31580e5cH312g7^K;e5cI41;" [require-token
julia_flisp.boot:  #\) take-token ((tuple) . #t) syntactic-op? error #fn(string)
julia_flisp.boot:  "invalid identifier name \"" "\"" invalid-identifier? :: ts:space?
julia_flisp.boot:  ts:put-back! (:: . #f) #\; arglist-to-tuple parse-arglist tuple parse-eq*
julia_flisp.boot:  vararg? #\, for expect-space-before parse-generator "expected \")\"" "missing comma or ) in argument list"])
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] parse-paren-)
julia_flisp.boot:	  parse-pipe< #fn(";000r1e0|31e1|31e2g6316F0e3|312c4g6g5e5|31L4;g5;" [parse-pipe>
julia_flisp.boot:  peek-token is-prec-pipe<? take-token call parse-pipe<] parse-pipe<)
julia_flisp.boot:	  parse-pipe> #fn("9000r1]\x8c5g5c0|g5q2O2g5M\x8e1e1|31e2|3142;" [#fn(":000r2e0}316M0e1~312\x7fMc2}|e3~31L4e4~3142;|;" [is-prec-pipe>?
julia_flisp.boot:  take-token call parse-range peek-token]) parse-range peek-token] parse-pipe>)
julia_flisp.boot:	  parse-range #fn("9000r1]\x8c5g5c0|g5q2O2g5M\x8e1e1|31]42;" [#fn("@000r2e0~31e1~31}16D02e2g63116902g6c3<@6E0e4~312c5g6|e6~31L4;e716802g6c3<6\xeb0e4~312e816@02g716902e9~31@6>0e:~c3g7332|;e;e0~31316F0e<c=c>e?|31c@33315L0eAe0~31316;0e<cB31570e6~31e1~31@16B02g8cC<17802g8cD<6G0e<c=cEg8cFg8cG3531530]2}6A0\x7fMc5g6|g8L4^42;\x7fMcH|g8L132]42;g6cI\x82>0e4~312cI|L2;|;" [peek-token
julia_flisp.boot:  ts:space? is-prec-colon? : take-token call parse-expr range-colon-enabled
julia_flisp.boot:  space-sensitive space-before-next-token? ts:put-back! closing-token? error #fn(string)
julia_flisp.boot:  < > "\":" "\" found instead of \"" ":\"" #fn(append) ...]) parse-expr] parse-range)
julia_flisp.boot:	  parse-rational #fn("9000r1]\x8c5g5c0|g5q2O2g5M\x8e1e1|31e2|3142;" [#fn(":000r2e0}316M0e1~312\x7fMc2}|e3~31L4e4~3142;|;" [is-prec-rational?
julia_flisp.boot:  take-token call parse-shift peek-token]) parse-shift peek-token] parse-rational)
julia_flisp.boot:	  parse-raw-literal #fn("8000r2e0|}]33M;" [parse-string-literal] parse-raw-literal)
julia_flisp.boot:	  parse-resword #fn("9000r2e0c1|a[31k02c2g6q1c3}|q2c4g7q1tg7302;" [expect-end-current-line
julia_flisp.boot:  #fn(input-port-line) #fn("5000r0~k0;" [expect-end-current-line])
julia_flisp.boot:  #fn("A000r0e0e1e2e3e4e5]k02^k12]k22^k32^k42^k52c6g4g5g6g7g8g9q6c7~\x7fq2c8g:q1tg:302;" [range-colon-enabled
julia_flisp.boot:  space-sensitive where-enabled for-generator end-symbol whitespace-newline #fn("5000r0~k02\x7fk12i2k22i3k32i4k42i5k5;" [range-colon-enabled
julia_flisp.boot:  space-sensitive where-enabled for-generator end-symbol whitespace-newline])
julia_flisp.boot:  (begin quote) skip-ws-and-comments line-number-node parse-block #fn("7000r1e0|e142;" [parse-docstring
julia_flisp.boot:  parse-eq]) expect-end length> linenum? #fn(list*) block cddr quote while
julia_flisp.boot:  parse-cond #fn(append) for parse-comma-separated-iters length= let memv
julia_flisp.boot:  peek-token (#\linefeed
julia_flisp.boot:	      #\;) parse-comma-separated-assignments
julia_flisp.boot:  #fn(eof-object?) (#\linefeed
julia_flisp.boot:  "missing condition in \"if\" at " current-filename ":" #fn(input-port-line)
julia_flisp.boot:  elseif require-token (else elseif) (block) take-token end "missing condition in \"elseif\" at "
julia_flisp.boot:  parse-resword else if "use \"elseif\" instead of \"else if\"" "unexpected \""
julia_flisp.boot:  "\"" (global local) const parse-eq tuple = global local "expected assignment after \"const\""
julia_flisp.boot:  (function macro) #\( parse-def function symbol-or-interpolate?
julia_flisp.boot:  "expected \"end\" in definition of " " \"" unwrap-where valid-1arg-func-sig?
julia_flisp.boot:  rewrap-where "expected \"(\" in " " definition" valid-func-sig? "ambiguous signature in "
julia_flisp.boot:  " definition. Try adding a comma if this is a 1-argument anonymous function."
julia_flisp.boot:  add-line-number abstract type parse-call-chain parse-subtype-spec
julia_flisp.boot:  take-lineendings "abstract type" struct parse-struct-def mutable primitive
julia_flisp.boot:  space-sensitive whitespace-newline #fn("5000r0~k02\x7fk1;" [space-sensitive
julia_flisp.boot:							      whitespace-newline])
julia_flisp.boot:  #fn("6000r0e0~41;" [parse-subtype-spec])
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)]) #fn("5000r0~k02\x7fk1;" [space-sensitive
julia_flisp.boot:								whitespace-newline])
julia_flisp.boot:  #fn("6000r0e0~41;" [parse-cond]) #fn("6000r1~302c0|41;" [#fn(raise)]) "primitive type"
julia_flisp.boot:  try (catch finally) #fn("I000r4e0~312|c1\x82f0c2c3\x7fg217502c4}17C02g3670c4580e5c631g3690g3L1530_45;|c7<16502}@651e8e9~31c:32e9~31c;=6:0e0~31530]2c<e=~31c>326B0i2Me=~31c?^g344;e@~31g8660^570eA~31g8@16e02g:C17]02eBg:b23216902g:McC<17E02e5cDcEeFg:31cG3331e=~31cH\x82>0cIe@~31L2570eJ~31i2Me=~31g;17602g:@670g<5d0cKcIL1g9L1g:L1cLeBg<b23216:02eMg<\x8431660_550g<N3134g;670g:540c4g344;|cH<16602g3@6V0e=~31c7\x8270c?570eJ~31i2Me=~31}g2g844;eN|c342;" [take-token
julia_flisp.boot:  peek-token (#\linefeed
julia_flisp.boot:	      #\;) #\; #fn(memq) require-token (end finally) (block)
julia_flisp.boot:  line-number-node parse-eq* length= $ #fn(string)
julia_flisp.boot:  "invalid syntax \"catch " deparse "\"" finally block parse-block #fn(nconc)
julia_flisp.boot:  #fn(copy-list) linenum? expect-end-error]) return #\linefeed closing-token?
julia_flisp.boot:  (null) (break continue) end-symbol (#\linefeed
julia_flisp.boot:  parse-unary-prefix #fn("7000r1e0|e142;" [parse-docstring parse-eq])
julia_flisp.boot:  reserved-word? "invalid module name \"" module (true) (false)
julia_flisp.boot:  #fn(nconc) #fn(copy-list) export #fn(map) macrocall-to-atsym
julia_flisp.boot:  parse-comma-separated every "invalid \"export\" statement" (import using)
julia_flisp.boot:  parse-imports do "invalid \"do\" syntax" "unhandled reserved word"])
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])]) #fn("6000r1~302c0|41;" [#fn(raise)])] parse-resword)
julia_flisp.boot:	  parse-shift #fn("9000r1]\x8c5g5c0|g5q2O2g5M\x8e1e1|31e2|3142;" [#fn(":000r2e0}316M0e1~312\x7fMc2}|e3~31L4e4~3142;|;" [is-prec-bitshift?
julia_flisp.boot:  take-token call parse-unary-subtype peek-token]) parse-unary-subtype
julia_flisp.boot:  peek-token] parse-shift)
julia_flisp.boot:	  parse-space-separated-exprs #fn(":000r1e0e1]k02^k12c2g5g6q2c3|q1c4g7q1tg7302;" [space-sensitive
julia_flisp.boot:  whitespace-newline #fn("5000r0~k02\x7fk1;" [space-sensitive
julia_flisp.boot:					      whitespace-newline])
julia_flisp.boot:  #fn("9000r0]\x8c4g4c0~g4q2O2g4M\x8e1_41;" [#fn("9000r1e0e1~313117P02e2e1~313117B02e316;02e1~31c4<680e5|41;e6~31e1~31g6c7=6;0e5g5|K41;\x7fMg5|K41;" [closing-token?
julia_flisp.boot:  peek-token newline? for-generator for reverse! parse-eq #\linefeed])])
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] parse-space-separated-exprs)
julia_flisp.boot:	  parse-stmts #fn(";000r1e0|c1c2c3c4^36e5|31c6g63117A02g6c7=17702g6^<7C0e8c9c:g6c;3331530]\x8e12g5;" [parse-Nary
julia_flisp.boot:  #fn("7000r1e0|e142;" [parse-docstring parse-eq])
julia_flisp.boot:  (#\;) toplevel #fn("6000r1|c0=;" [#\linefeed]) peek-token #fn(eof-object?)
julia_flisp.boot:  #\linefeed error #fn(string) "extra token \"" "\" after end of expression"] parse-stmts)
julia_flisp.boot:	  parse-string-literal #fn("?000r3|a[e0g731}=6k0e0e1g73131}=6U0e2e3e4e5e6b2e1g731|}g235g2323132560c7L15C0e5e6`g7|}g235g232g2650g8;e8g841;" [peek-char
julia_flisp.boot:  take-char map-first strip-leading-newline
julia_flisp.boot:  dedent-triplequoted-string strip-escaped-newline
julia_flisp.boot:  parse-string-literal- "" unescape-parsed-string-literal] parse-string-literal)
julia_flisp.boot:	  parse-string-literal- #fn("=000r5]\x8c9g9c0g3|g9}g4g2q6O2g9M\x8e1e1}31e230_`44;" [#fn("B000r4|~=6Y0g3\x7fX6E0i2Me0i331}g2g3aw44;e1c2}31g2K41;g3aW6U0i47<0e3c4}32530]2e3~}322i2M|}g2`44;g3b2W6m0i47<0e3c4}32530]2e3~}322i47<0e3c4}32530]2e3~}322i2M|}g2`44;|c4=6\x9f0i46[0]\x8c8g8c5g8~i3}i2g2q6O2g8M\x8e1ae6~e0i3313242;e6~e0i33132e3c4}322g8c7=6>0i2Mg8}g2`44;e3g8}322i2Me0i331}g2`44;|c8=16602i4@6j0e9i531c:g8316;0c;g8L2540g8i2Me0i331e<30c=g9c2}31g233`44;|c7=6a0e>i331c?=6;0e0i331530]2e3c?}322i2Me0i331}g2`44;e3e6~|32}322i2Me0i331}g2`44;" [read-char
julia_flisp.boot:  reverse #fn(io.tostring!) write-char #\\
julia_flisp.boot:  not-eof-for read-char #fn(io.write) string.rep "\\" div odd? write-char])
julia_flisp.boot:  not-eof-for #\return #\$ parse-interpolate #fn(string?) string
julia_flisp.boot:  open-output-string #fn(list*) peek-char #\linefeed]) read-char
julia_flisp.boot:  open-output-string] parse-string-literal-)
julia_flisp.boot:	  parse-struct-def #fn("<000r3e0e1|31316F0e2c3c4e5|31c63331530]2e7|31c8}670c9540c:g7e;|31L4e<|g2322;" [reserved-word?
julia_flisp.boot:  peek-token error #fn(string) "invalid type name \"" take-token "\""
julia_flisp.boot:  parse-subtype-spec struct (true) (false) parse-block expect-end] parse-struct-def)
julia_flisp.boot:	  parse-subtype-spec #fn("6000r1e0|41;" [parse-comparison] parse-subtype-spec)
julia_flisp.boot:	  parse-term #fn("9000r1e0|e1e2c344;" [parse-with-chains parse-rational
julia_flisp.boot:					       is-prec-times? (*)] parse-term)
julia_flisp.boot:	  parse-unary #fn("=000r1e0|31e1|31e2g5316\xe20e3|312g5c4<17802g5c5<6\xba0e6|a[31e7g73116902e8g73117D02g7c9=16:02e:|a[316~0e;|a[g7c9=g5c4<33e<e=|31c>3217<02e?e=|31316N0e@|eAg5g832g6332cBg5eC|31L3;g8;eD|g5]g644;eD|g5eEg531g644;eC|41;" [require-token
julia_flisp.boot:  ts:space? initial-operator? take-token - + peek-char char? char-numeric? #\.
julia_flisp.boot:  read-char read-number memv peek-token (#\[
julia_flisp.boot:					 #\{) is-prec-power? ts:put-back!
julia_flisp.boot:  maybe-negate call parse-factor parse-unary-call unary-op?] parse-unary)
julia_flisp.boot:	  parse-unary-call #fn(">000r4e0|31e1g83117C02e2g83117802g8c3<6F0e4}316<0c5e6}31L2;};g8c7=17@02g2@16802g8c8=6A0e9|}g3332e:|41;g8c8=6\x820e;|312e<|31c=|a[31e>|]32g;N6T0g96<0e?g:}c843;e@|eA}eBg;M31K3142;eA}e@|g;M32L241;g27@0eCcDcE}cF3341;eG|31eA}g9L241;" [peek-token
julia_flisp.boot:  closing-token? newline? = dotop? |.| undotop #\{
julia_flisp.boot:  #\( ts:put-back! parse-factor take-token ts:space? #fn(input-port-line)
julia_flisp.boot:  parse-paren- disallowed-space-error parse-factor-with-initial-ex
julia_flisp.boot:  fix-syntactic-unary tuple-to-arglist error #fn(string) "\"" "\" is not a unary operator"
julia_flisp.boot:  parse-unary] parse-unary-call)
julia_flisp.boot:	  parse-unary-prefix #fn("9000r1e0|31e1g5316\x840e2|312c3g5c43216K02e0|31e5g63117902e6g631\x8e1650g5;c3g5c7326>0g5e8|e932L2;g5e:|31L2;e;|41;" [peek-token
julia_flisp.boot:  syntactic-unary-op? take-token #fn(memq) (& $) closing-token? newline? (& ::)
julia_flisp.boot:  parse-where parse-call parse-unary-prefix parse-atom] parse-unary-prefix)
julia_flisp.boot:	  parse-unary-subtype #fn(";000r1e0|31e1|31g5c2<17802g5c3<6\xa80e4|312e5|31e6g73117C02e7g73117802g7c8<650g5;g7c9=17802g7c:=6D0e;|g5g6332e<|e=42;e<|e=32g8F16902g8Mc><690g5g8NK;g5g8L2;e<|e=42;" [require-token
julia_flisp.boot:  ts:space? <: >: take-token peek-token closing-token? newline? = #\{
julia_flisp.boot:  #\( ts:put-back! parse-where parse-juxtapose tuple] parse-unary-subtype)
julia_flisp.boot:	  parse-vect #fn(":000r3]\x8c7g7c0|g2g7q3O2g7M\x8e1_}42;" [#fn(">000r2e0~31g6\x7f=6C0e1~312c2e3}|K31K;g6g7c4=6\x8d0e1~312e0~31\x7f=6C0e1~312c2e3}|K31K;e0~31c5=6S0e6~\x7f32c7c2L1c8g831c8e3|3131}L144;i2M}|Ke9~3142;g7c5=6e0e0~31\x7f=6:0i2M|}42;e:~\x7f32c7c2L1c8g831c8e3|3131}L144;e;g7c<326A0e=c>c?g6c@3341;e=cA41;" [require-token
julia_flisp.boot:  take-token vect reverse #\, #\; parse-arglist #fn(nconc)
julia_flisp.boot:  #fn(copy-list) parse-eq* parse-call-arglist memv (#\]
julia_flisp.boot:  "\"" "missing separator in array expression"])] parse-vect)
julia_flisp.boot:	  parse-where #fn("8000r2}|31e016;02e1|31c2<6:0e3|g642;g6;" [where-enabled
julia_flisp.boot:  peek-token where parse-where-chain] parse-where)
julia_flisp.boot:	  parse-where-chain #fn("9000r2e0^k02c1g6q1c2|}q2c3g7q1tg7302;" [where-enabled
julia_flisp.boot:  #fn("5000r0~k0;" [where-enabled]) #fn("9000r0]\x8c4g4c0~g4q2O2g4M\x8e1\x7fc142;" [#fn(":000r2}c0\x82l0e1~312e2~31\x7fMg6F16902g6Mc3<6?0c4c0|g6N33590c0|g6L3e5~3142;|;" [where
julia_flisp.boot:  take-token parse-comparison braces #fn(list*) peek-token]) where])
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] parse-where-chain)
julia_flisp.boot:	  parse-with-chains #fn("<000r4]\x8c8g8c0|g2g3g8}q5O2g8M\x8e1}|3141;" [#fn("?000r1e0~31\x7fg531740|;e1~31e2~312e316M02g616F02c4g5e53216902e6~31@6>0e7~g5g6332|;c4g5i2326J0i3Mc8c9g5|e:~i4g5333441;i3Mc9g5|i4~31L441;" [peek-token
julia_flisp.boot:  ts:space? take-token space-sensitive #fn(memq)
julia_flisp.boot:  unary-and-binary-ops space-before-next-token? ts:put-back! #fn(list*) call
julia_flisp.boot:  parse-chain])] parse-with-chains)
julia_flisp.boot:	  parser-depwarn #fn("?000r3|D660|5E0c0e1|31660|550|a[31e2e3e4}g2g8g7]35g8g743;" [#fn(input-port-line)
julia_flisp.boot:  port? current-filename frontend-depwarn format-syntax-deprecation] parser-depwarn)
julia_flisp.boot:	  partially-expand-ref #fn("@000r1|\x84e0|31g5F16;02e1c2g632g7690e330540g5g76?0c4g8g5L3L1530_e5c6g8g6q2c7g9g8q242;" [cddr
julia_flisp.boot:  contains #fn("6000r1|c0<17702|c1<;" [begin end]) make-ssavalue =
julia_flisp.boot:  call-with-values #fn("7000r0e0~\x7f42;" [process-indices])
julia_flisp.boot:								block #fn(copy-list)
julia_flisp.boot:								getindex])] partially-expand-ref)
julia_flisp.boot:	  pattern-expand #fn("=000r2}F@17;02c0}Mc132640};e2|}32g6}\x82`0c3|q1}Mc4\x82L0c5c4c6g7}\x8432c6g7e7}313243;c6g7}42;e8|g642;" [#fn(memq)
julia_flisp.boot:  (quote varlist inert) apply-patterns #fn("7000r1|F740|;e0~|42;" [pattern-expand])
julia_flisp.boot:  lambda #fn(list*) #fn(map) cddr pattern-expand] pattern-expand)
julia_flisp.boot:	  pattern-expand1 #fn("8000r2}F@17;02c0}Mc132640};e2|}32g6}\x8240};e3|g642;" [#fn(memq)
julia_flisp.boot:  'inert apply-patterns pattern-expand] pattern-expand1)
julia_flisp.boot:	  pattern-replace #fn("8000r2}F@17;02c0}Mc132640};e2|}32g6}\x82=0c3c4|q1}42;g6;" [#fn(memq)
julia_flisp.boot:  'inert apply-patterns #fn(map) #fn("7000r1|F740|;e0~|42;" [pattern-replace])] pattern-replace)
julia_flisp.boot:	  peek-char #fn("7000\x8900001000\x8a0000770e0m02c1|41;" [*input-stream*
julia_flisp.boot:								  #fn(io.peekc)] peek-char)
julia_flisp.boot:	  peek-token #fn("9000r1|b3[17J02|`[17B02|`e0|a[|32\\2|`[;" [next-token] peek-token)
julia_flisp.boot:	  plambda-expansion #fn("9000r4e0|}32g86C0g2c1c2g8q1g332v2;^;" [match
julia_flisp.boot:  #fn(map) #fn("7000r1c0|~3217502c1N;" [#fn(assq) (0 . #f)])] plambda-expansion)
julia_flisp.boot:	  port-eof? #fn("6000r1c0|41;" [#fn(io.eof?)] port-eof?) port?
julia_flisp.boot:	  prec-arrow (                           
julia_flisp.boot:		            --> <-- <--> . . . . . . . . . . .
julia_flisp.boot:		      . . .--> .<-- .<-->)
julia_flisp.boot:	  prec-assignment (= += -= = *= /= //= |\\=| ^= = %= <<= >>= >>>= |\|=|
julia_flisp.boot:			   &= =    .= .+= .-= .= .*= ./= .//= |.\\=| .^=
julia_flisp.boot:	  prec-bitshift #636# prec-colon
julia_flisp.boot:	  #637# prec-comparison (in isa > < >=  <=  == ===  !=  !==   
julia_flisp.boot:	  prec-conditional (?) prec-decl (::) prec-dot (|.|) prec-lazy-and #638#
julia_flisp.boot:	  prec-lazy-or #639# prec-names
julia_flisp.boot:	  (prec-assignment prec-pair prec-conditional prec-arrow prec-lazy-or
julia_flisp.boot:	   prec-lazy-and prec-comparison prec-pipe< prec-pipe> prec-colon
julia_flisp.boot:	   prec-plus prec-times prec-rational prec-bitshift prec-power
julia_flisp.boot:	   prec-decl prec-dot)
julia_flisp.boot:	  prec-pair #640# prec-pipe< #641# prec-pipe> #642# prec-plus
julia_flisp.boot:	  ($ + -   |\||     ++                     
julia_flisp.boot:	                             .+ .- . . |.\||
julia_flisp.boot:	  prec-power (^                           
julia_flisp.boot:	  prec-rational #643# prec-table
julia_flisp.boot:	  #table( 7  . 4  . 7  . 11  . 7  . 7   11  . 7  . 7  <<= 1  . 4   4   4  . 4  . 12  . 4  ^ 15  . 15   11   7  . 7   12  . 4  . 12   7  .&& 6   7  .>>> 14   12  . 7   7   7  . 7   7   12   11   7   7   1  -= 1  . 7   7  . 7  . 7  . 7   7   15  .>: 7   4  . 10  = 1   7  === 7   7  . 7  . 7   12  . 4  .*= 1   11   7   12  . 7   15   11  . 4  . 7   7  . 7  . 11   15  . 7  . 7  |.\|>| 9  . 11  . 4  . 11  . 4  . 7  . 4   4   11  . 7  . 12   12  . 11   7  . 7   7  . 12   15  . 11  . 15  . 11  . 7   15   7   7  . 15  . 4  . 7   7  . 7   7  >>> 14   11   4   7  . 4   7  . 4   12   4   4  . 7  . 4   12  .// 13  . 7   11   4   7   7  . 4   4   12   7  . 7  . 4  |\\| 12  . 7  . 4   12   7   4   4   12   4   7   7   7   7  == 7  . 4  . 4  . 7   7  . 7  . 4  . 7   11  . 12   4   7  . 4  |\|=| 1   7  . 4   4   11   7   7   7   4   4   11   4   7   7   15   7  . 11   7  . 7  . 4  . 15   11   7   11   7   4   7   12  . 7   7   7  . 7  . 7  . 7  . 4   12   4   4   4  |.<\|| 8  . 7   11  . 11   7   12   12  . 7   7   4   4   7  . 4   4  . 4   4  . 7   11   7   4  . 4  . 12  . 12   7   11  . 12  .>= 7   7  . 7   7   7  . 7  .<--> 4   7   4  . 4  . 7  . 11  . 4   11  . 15   4   7   12  . 7  << 14  . 7  >>>= 1   4   15  |.\|\|| 5   12  . 11  . 11   4   7   7  . 7   7  . 7  . 12  . 4  . 11   15   7   11   4  . 7   12   7  . 7   4  ./= 1   7  . 11  . 7  . 7  |.\|| 11   15   7  >> 14   7  . 7  . 7  . 7   11  . 11  .= 1  . 7  .& 12  . 7   11  ./ 12  . 12   15  . 7   7   11  . 4  . 4  . 4  . 7  . 12   4   7  . 15   4   1   4  .>>>= 1  . 4   7   7   7   4  .^ 15   7  |\\=| 1  . 4   7   4  . 7   4  . 4   7  . 7  . 7   4  . 7  /= 1   10  . 15  . 11  .<= 7  . 7  . 15   15  . 7  .= 1  . 4  . 4  . 7  . 12  . 7  . 12   4  .<-- 4   7  . 7  . 7   7  . 7   11  . 7   12  . 7   10  .<< 14  .--> 4  . 7   12   7  . 7   7  . 7   7  . 4   7   7   4  . 7  . 12   7   4   11  . 7  . 12  .%= 1  . 12  . 4   7  . 7   7   4   12  . 12   12   7  . 12  . 12  .> 7   4   4   15   7   7  => 2   7   12  . 4  . 7   7  . 7   4  . 7   15  . 4  . 12  . 7   7  . 7  . 15   12   7  . 4   7   12  in 7  . 12  . 7  / 12  . 12   11  . 4   12   11  . 11   7  //= 1  . 7  . 7  . 7   4   7  . 4  . 4   4  . 4  . 7   4  . 7  . 7   11  . 4   7  . 11   7   7   12   7   7  . 12  . 4   7  . 7  . 4  . 12  && 6  . 4   4  . 4  . 7   7  . 4  . 7   4   7  .<: 7   12   4  . 7  . 4  . 12   4   7   7   7  . 7  . 1   12  . 7  . 11  . 7  . 11  . 15  . 4   15  . 4   7   7   12  += 1   12   11   11  >= 7  . 7  . 7   11  . 12   7  . 7   7  . 7  . 15  . 4  . 4  |.\\| 12   11   15   7   4   7   4   11   12   15  . 7   7   7  . 12  . 7  .&= 1  |.\|=| 1   4  = 1  . 4  . 4   7   4  . 4  . 11   11   7   7  . 7   7   7  . 4  . 10   7   7   7  : 10  *= 1  . 7   4   7  . 11  . 7  . 7   4  . 7  . 7  . 11  & 12  . 15  . 4  . 7   11   1   7  . 4  . 11  . 4  . 7  . 7   7  . 7  . 7   4   7  . 11  . 7  . 7   4  . 7  . 7  . 7   7  . 4  . 4  . 4  . 4   7   7  . 4  . 7  . 12  . 4  . 4   4  . 4   12  . 7  . 12  . 12  . 7  .<<= 1   15  . 12   12   11   7  . 7   7   12  . 7   7   12  . 4   10   7   4   15  . 7   7  . 12  . 15  * 12   11   7  $ 11  . 7   12   7   7   4  ^= 1  . 4  . 7  . 12  . 11  . 11  . 7  . 11   7   7  .+= 1   7   15   12  . 7   4  . 10  . 1  . 4  .!== 7   4   7   4   12  . 7  . 4  . 12  .//= 1  . 12  . 4   7   12  . 4   4  . 7  . 4  . 7  . 7  . 10   4   12  . 12   15  . 7   7  . 4  .= 1   7   12  . 7  . 7  . 7   15   12   7   7   4  . 7  . 7  . 4   7   12  . 7   7  . 15  . 4   4  . 7   4  . 11   7  > 7   12  . 7   4  . 7   11   7  . 10   4  .+ 11   12  . 7   15   4   4  . 7  <--> 4   7  <-- 4  . 7   15  . 7  . 12   7  . 11   7   4   11  . 4  .++ 11  . 12  . 4   7  . 7   12  . 10  . 15   12   7  . 12  . 4  >>= 1   7  . 4   7  . 7  . 7  . 12  . 7  . 11   4   7   12  . 7  . 12   7   4  . 7  . 7  . 11  . 15   4   7   7  . 4  . 11   7  . 7  .* 12  . 4   7  . 7   4  . 7   4  . 4  . 7  . 7   7   12   4   7  . 15   10   7  . 7  . 7   7  .< 7  . 12   4  . 7  . 15   7  . 7   7  . 4  . 4  . 7  . 15  . 4  . 4   7  . 7   7   7  . 7  . 11  . 12   7  . 7   4   7   4   7  . 7  . 4  . 12  . 12   4   7  . 4   4  . 11   4  . 4   12  . 4  . 7  . 7   7   12  . 7   12   7   7  .= 1   7   7   4   7  . 7  . 7   12   4  . 4  . 4   4   11  < 7   4  . 4   7   11   4   7   7   4   7  >: 7   7   4   4   4  . 11   12  - 11  . 7   12   7   4   7  . 12   15   7  . 11   4   7  . 12   7   7  . 7  . 7  . 7  . 7  %= 1  . 7  .% 12   7  . 4  . 7   4  = 1  . 4  . 4   7  . 7  . 4   4   7   7   7  . 4   7  . 4   7  . 4  . 7  . 7  . 7  . 7  . 4  . 1  . 4  . 7  . 4   11  . 7   7   7   7  . 7  . 12  . 7  . 12   12   7  .. 10  . 4  . 12   7   11   4   11  . 4   15  . 4   12  . 11  . 4   4   4  . 4   7  % 12  . 7   7   12  . 12  . 7   11  . 12  . 7  . 7  . 12   4   12  . 15   4  . 12   7  . 15   7  |\|| 11  . 11   4  . 12  . 15  . 11  . 4  |\|\|| 5  . 7  . 4  .=== 7   7  . 15  . 7  . 7   7  . 7  . 7  . 4   4  . 7  . 12  . 12   11   4  . 12   7  . 7   4   11   7  . 4   11   7   12   7  . 11  . 7   7   7  . 7  .=> 2   4  . 12   7   7  . 4  . 4  // 13   7  . 7  . 7  . 12   7  . 7   12  . 15  . 7  . 7  . 7   4  . 15   7  . 7  .^= 1  . 4  . 7   4   11  . 7   7   7  . 11  . 4  . 11   4   4   7  . 4  . 12  . 15  . 7  |\|>| 9   7   7   7  . 7   12  . 4   7   7  . 7   4  . 15  . 7  . 7   7  . 15  . 12   4   12  . 7  . 7  . 4   7   7  . 4   11   4   7   12  . 7   7   12  |.\\=| 1  . 4  . 7  . 7  .- 11   4   7   4   7  . 11   15   7  . 7  .>>= 1  !== 7  ? 3   4  . 4  .!= 7  . 7  . 12  . 12  . 7   7  . 4  .== 7  . 7   7  . 11  . 11  . 4  . 7   7   15  . 7  . 4  . 7  = 1  . 7  . 12  != 7  . 7   7   7   4  + 11  :: 16  . 4  . 7   7   7  ~ 1   12  . 7  . 7   7  . 7   11  . 11  . 7   7  . 7  . 7  . 7  . 4   7   7   7  . 7  . 11   4  . 11  . 12  . 15  . 7  . 12   7  . 4   7  . 12   4  . 7  . 7  . 12  . 7  .>> 14  . 7   7   12  . 12  . 7  . 7  . 7   4   4  . 4   7  .~ 1   4   7   12  . 7  . 4   4   4   4   7   11   4   7  . 7   10  ++ 11   12  .-= 1   4  . 4  . 7  |<\|| 8  . 15  . 12   4   7  . 7   11  . 7  . 4  . 7  . 7   7  := 1   12   10   7  . 7   7  . 7  . 4  --> 4  . 7  . 7   7  . 7   4   12   15  $= 1   4   4   7   7   7   4  . 7   11  . 11   7  . 7  . 7   7   7   7   7  isa 7  . 7  &= 1  . 7   4  . 4  . 7   4   7   4  <= 7   15  . 4  . 4   4   7   7  . 7  . 11  . 12   7  . 7   12  . 7   11  . 7  <: 7   4  . 4  . 7   12  . 7   7  . 11  . 12  . 7  . 7  . 7   12  . 4   7   7  . 7  . 7   4  . 11  . 12   4  |.| 17  . 12   7   15   7   4  . 7)
julia_flisp.boot:	  prec-times (* /   % &      |\\|               
julia_flisp.boot:	  prepare-lambda! #fn(";000r1c0c1e2e3|31Mc4e5|313132322e6|41;" [#fn(for-each)
julia_flisp.boot:  #fn("7000r1e0|]42;" [vinfo:set-asgn!]) list-tail lam:vinfo #fn(length)
julia_flisp.boot:  lam:args lambda-optimize-vars!] prepare-lambda!)
julia_flisp.boot:	  primitive-type-def-expr #fn(":000r4e0c1g2q1c2}|g3q342;" [call-with-values
julia_flisp.boot:								   #fn("6000r0e0~41;" [sparam-name-bounds])
julia_flisp.boot:  global const scope-block #fn(nconc) local-def #fn(copy-list)
julia_flisp.boot:  #fn(map) #fn("6000r1c0|L2;" [local]) #fn("9000r2e0|e1}]3242;" [make-assignment
julia_flisp.boot:								 bounds-to-TypeVar])
julia_flisp.boot:  toplevel-only primitive_type = call core _primitivetype thismodule inert svec
julia_flisp.boot:  _setsuper! _typebody! if && isdefined outerref _equiv_typedef null])] primitive-type-def-expr)
julia_flisp.boot:	  princ #fn(";000s0e0^k02c1g5q1c2|q1c3g6q1tg6302;" [*print-readably* #fn("5000r0~k0;" [*print-readably*])
julia_flisp.boot:							    #fn("7000r0c0c1~42;" [#fn(for-each)
julia_flisp.boot:	  print #fn("9000s0c0c1|42;" [#fn(for-each)
julia_flisp.boot:	  print-exception #fn("=000r1|F16D02|Mc0<16:02e1|b4326P0e2c3|\x84c4e5|31c6352e7e8|31315!0|F16D02|Mc9<16:02e1|b4326N0e2|\x84c:e8|31c;342e7e5|31315\xea0|F16@02|Mc<<16602|NF6?0e2c=|\x84c>335\xc60|F16802|Mc?<6B0e2c@312e2|NQ25\xa70|F16802|McA<6G0eBe5|31312e2cC|\x84325\x830eD|3116:02e1|b2326c0e7|M312e2cE312|\x84cFg53117602g5C670e2540e7g531\x8e15>0e2cG312e7|312e2eH41;" [type-error
julia_flisp.boot:  bounds-error ": index " " out of bounds for " unbound-error "eval: variable "
julia_flisp.boot:  " has no value" error "error: " load-error print-exception "in file " list?
julia_flisp.boot:  ": " #fn(string?) "*** Unhandled exception: " *linefeed*] print-exception)
julia_flisp.boot:	  print-stack-trace #fn("?000r1]]\x8c5\x8c6g5c0g5q1O2g6c1g5q1O2e2e3|e4670b5540b43231e5e6c7c8c9303232`\x8c9c:c;g9g6g8q3g742;" [#fn("=000r3c0|31g2Kc1|31c1}31\x82?0c2c3c4g7L341;c5|31`e6c7g83131c8g8~}g7q4u;" [#fn(function:name)
julia_flisp.boot:  #fn(function:code) #fn(raise) thrown-value ffound #fn(function:vals) 1- #fn(length)
julia_flisp.boot:  #fn("8000r1e0~|[316>0\x7fM~|[i2i343;];" [closure?])] find-in-f)
julia_flisp.boot:  #fn(";000r2c0~|}q3c1tg66I0c2e3c4c5e6g63132c73241;c8;" [#fn("8000r0c0c1~\x7fq2i2322^;" [#fn(for-each)
julia_flisp.boot:  #fn("8000r1~M|\x7f_43;" [])]) #fn("6000r1|F16B02|Mc0<16802|\x84c1<680e2|41;c3|41;" [thrown-value
julia_flisp.boot:							 "/" lambda] fn-name)
julia_flisp.boot:  reverse! list-tail *interactive* filter closure? #fn(map)
julia_flisp.boot:  #fn("6000r1|E16802c0|41;" [#fn(top-level-value)])
julia_flisp.boot:  #fn(environment) #fn(for-each) #fn("8000r1e0c1~Mc2332e3\x7fM|`[i232e4|31NK312e5302~~MawO;" [princ
julia_flisp.boot:  "#" " " print vector->list newline])] print-stack-trace)
julia_flisp.boot:	  print-to-string #fn("8000r1c030c1|g5322c2g541;" [#fn(buffer)
julia_flisp.boot:							   #fn(io.tostring!)] print-to-string)
julia_flisp.boot:						    #fn(eof-object?)] printable?)
julia_flisp.boot:	  prn #fn("9000r1e0e1k02c2g5q1c3|q1c4g6q1tg6302\x8e1\x8e12|;" [*output-stream*
julia_flisp.boot:  *stderr* #fn("5000r0~k0;" [*output-stream*])
julia_flisp.boot:	  process-indices #fn(":000r2]\x8c6g6c0g6|q2O2g6M\x8e1}a___45;" [#fn("B000r5|\x85C0e0e1g431e1g23142;|M|NAg9F16902g9Mc2<6\x940e3g9\x84316X0~M|N}awg2g9\x84g3Kc2e4g9\x84\x7f}g3g:35L2g4K45;e530~M|N}awc6g;e4g9\x84\x7f}g3g:35L3g2Kg;g3Kc2g;L2g4K45;~M|N}awg2g3e4g9\x7f}g3g:35g4K45;" [values
julia_flisp.boot:  reverse ... symbol-like? replace-beginend make-ssavalue =])] process-indices)
julia_flisp.boot:	  profile #fn("<000r1c0|31c1~|```KK332c2|c3~|\x7fg5q442;" [#fn(top-level-value)
julia_flisp.boot:								   #fn(set-top-level-value!)
julia_flisp.boot:	  profile-e #fn("8000r1e0c1c2|q142;" [with-exception-catcher
julia_flisp.boot:  prn]) #fn("6000r0e0~41;" [profile])] profile-e)
julia_flisp.boot:	  quote-value #fn("6000r1e0|31640|;c1|L2;" [self-evaluating? quote] quote-value)
julia_flisp.boot:	  quoted-sym? #fn("7000r1e0|b23216C02c1|Mc23216602|\x84C;" [length= #fn(memq)
julia_flisp.boot:								    'inert] quoted-sym?)
julia_flisp.boot:	  quotify #fn("6000r1c0|L2;" [quote] quotify) radical-op?
julia_flisp.boot:	  range-colon-enabled #t read-all
julia_flisp.boot:	  #fn("7000r1e0c1|42;" [read-all-of #fn(read)] read-all) read-all-of #fn(":000r2]\x8c6g6c0}g6|q3O2g6M\x8e1_|}3142;" [#fn("8000r2c0~31680e1|41;\x7fM}|Ki2~3142;" [#fn(io.eof?)
julia_flisp.boot:  reverse!])] read-all-of)
julia_flisp.boot:	  read-char #fn("7000\x8900001000\x8a0000770e0m02c1|41;" [*input-stream*
julia_flisp.boot:								  #fn(io.getc)] read-char)
julia_flisp.boot:	  read-number #fn("Y000r3e030e1^^^\x8c8]]]c2|g7q2m<2c3|g7q2m=2c4|g7g8q3m>2g26=0e5c6g732530]2}6=0e5c7g7325\x960e8|31c9=6\x850e5e:|31g7322]m;2g<c;316>0^m;2g8e<O5]0g<c=316>0^m;2g8e>O5H0g<c?316>0^m;2g8e@O530^580g<c7312g>g;]322e8|31c7=6\xb40e:|312eAe8|31316{0e8|31c7=7d0eBg731eCcDcEg?c7e8|31cFe8|31cG=670cH540cI3631\x8e1530]2cJ|c7325V0e5c7g7322g>^]322g8Me<\x8280]m:530]2g=30530]2e8|31g?cK=17802g?cL=g:16@02g@17902eCcM3117M02g8Me<<16502g@17;02eNg?cO326\xc60e:|312e8|31gAc6=17802gAcP=cQgA31@16J02e1gA3117?02gAcR=17502gB6x0g?cS=m92g@m:2e5g?g7322gB6C0e:|312e5c6g7325=0e5e:|31g7322g>]^322g=30590cJ|g?32\x8e1\x8e1530]2eTg?3116m02g8Me@<17L02g8Me><17A02g8Me<<16602g:@16D02e1g?3117902cUg?316I0eCcDcVeBg731g?cF3431530]\x8e1\x8e12eBg731g8Me<\x8270b@5N0g8Me>\x8270b85A0g8Me@\x8270b2540b:eWg216A02g@b:W@16602g:@6<0cXg?a32540g?g@g933c7eYg?31=16Y02e8|31cQgB31@16F02cUgB3117;02eNgBcZ32\x8e16C0eCcDc[g?c\\3331530]2g:6B0e]gAg?322e^gA41;g8Me<\x82C0e_g2e`gAg?b43342;g8Me>\x82A0e_g2eagAg?3242;g8Me@\x82B0e_g2e`gAg?a3342;g96B0e]gAg?322ebgA41;gA6\\0ccgA3116;02edgAce326C0cfcgchL2ciL1g?L4;gA;ejg?316C0cfcgchL2ciL1g?L4;cfcgckL2ciL1g?L4;" [open-output-string
julia_flisp.boot:  char-numeric? #fn("8000r1e0~31g5|=16?02e1e2~31\x7f322];" [peek-char
julia_flisp.boot:							    write-char
julia_flisp.boot:							    read-char] allow)
julia_flisp.boot:  #fn(":000r0e0~31c1=6`0e2~312e3e0~31316:0c4~c142;e5c6c7e8\x7f31c1c93441;];" [peek-char
julia_flisp.boot:  #\. read-char dot-opchar? #fn(io.ungetc) error #fn(string)
julia_flisp.boot:  "invalid numeric constant \"" get-output-string "\""] disallow-dot)
julia_flisp.boot:  #fn(";000r2e0~31|@16>02}16802g6c1=6H0e2c3c4e5\x7f31g6c63431530]2e7g6i2M~}34g7c8>@16L02c9g731@16@02e:g7\x7f3216402];" [peek-char
julia_flisp.boot:  #\_ error #fn(string) "invalid numeric constant \"" get-output-string "\""
julia_flisp.boot:  accum-digits "" #fn(eof-object?) display] read-digs) write-char #\-
julia_flisp.boot:  #\. peek-char #\0 read-char #\x char-hex? #\o char-oct? #\b char-bin?
julia_flisp.boot:  dot-opchar? get-output-string error #fn(string) "invalid syntax \"" "\"" #\'
julia_flisp.boot:  #\ #fn(eof-object?) #\+ #\f char? #fn(identifier-start-char?)
julia_flisp.boot:  "invalid numeric constant \"" string-to-number #fn(string.sub)
julia_flisp.boot:  string-lastchar (#\(
julia_flisp.boot:  numchk double fix-uint-neg sized-uint-literal sized-uint-oct-literal float #fn(integer?)
julia_flisp.boot:  > #int64(9223372036854775807) macrocall core @int128_str null within-int128?
julia_flisp.boot:  @big_str] read-number)
julia_flisp.boot:	  read-operator #fn("=000\x8920003000\x8a2000760^m22}c0=16;02e1|31c0=6;0e2c331530]2c4e1|313117=02e5e1|3131@6<0c6c7}3141;]\x8c7g7c8|g2}g7q4O2g7M\x8e1c7}31e1|31^33c6g741;" [#\*
julia_flisp.boot:  peek-char error "use \"x^y\" instead of \"x**y\" for exponentiation, and \"x...\" instead of \"**x\" for splatting."
julia_flisp.boot:  #fn(eof-object?) op-or-sufchar? #fn(string->normsymbol)
julia_flisp.boot:  #fn(string) #fn("=000r3c0}31640|;c1}31g2670g75>0g717802e2}316\x150c3|}32e4g831e5g93117\xe502g9c6<17802g9c7<16A02e8c3c9g8c:333117\xbe02g9c;<17802g9c<<16`02e=~3116V02e>~31c?=c@~cA32217A02e8c3c9g8c:333117x02g9cB<17802g9cC<16M02e=~3116C02e>~31cA=c@~cA32217E02\x7f16?02i2cD=16502g76G0e=~312i3Mg8e>~31g743;|;|;" [#fn(eof-object?)
julia_flisp.boot:  #fn(op-suffix-char?) opchar? #fn(string) string->symbol operator? <--- .<---
julia_flisp.boot:  error "invalid operator \"" "\"" -- .-- read-char peek-char #\>
julia_flisp.boot:  #fn(io.ungetc) #\- <- .<- #\'])] read-operator)
julia_flisp.boot:	  ref-to-view #fn(">000r1|F16802|Mc0<6z0e1|31e2g5N31e3g5N31c4c5L1c6c7L2L1e8g731L1c9e:g7313134c4c;L1c9g631g8L143;e<|b33216802|Mc=<6D0c5c6c>L2|\x84e8|31L4;|;" [ref
julia_flisp.boot:  partially-expand-ref butlast last #fn(nconc) call top dotview caddr #fn(copy-list)
julia_flisp.boot:  cdddr block length= |.| dotgetproperty] ref-to-view)
julia_flisp.boot:	  remove-argument-side-effects #fn("<000\x8910002000\x8a1000760^m12|F760|_K;_\x8c6]\x8c7g7c0g7}g6q3O2|Mc1g7M|N32Ke2g6M31K;" [#fn(":000r1e0|31640|;|Mc1<17802|Mc2<6=0|M~M|\x8431L2;|Mc3<17>02\x7f16802|Mc4<6B0|M|\x84~Me5|3131L3;|Mc6\x82G0c7c6L1c8c9~M|N323142;|Mc:\x82J0e;|]32i2e<g5Ni2M32O2g5M;e=30i2c4g5|L3i2MKO2g5;" [effect-free?
julia_flisp.boot:  ... & kw = caddr parameters #fn(nconc) #fn(copy-list)
julia_flisp.boot:  #fn(map) tuple remove-argument-side-effects revappend make-ssavalue] arg-to-temp)
julia_flisp.boot:  #fn(map) reverse] remove-argument-side-effects)
julia_flisp.boot:	  remove-empty-parameters #fn("6000r1e0|3116902e1|31A650|N;|;" [has-parameters?
julia_flisp.boot:  cdar] remove-empty-parameters)
julia_flisp.boot:	  rename-sig-types #fn(";000r2e0e130e2g7c3c4}q1L1332c5g7_Z3\x8e1|42;" [pattern-replace
julia_flisp.boot:  make-table table-set! call #fn("9000r1e0c1|c2~q1c344;" [plambda-expansion (call
julia_flisp.boot:  (core (-/ Typeof)) name) #fn("8000r2c0~}|43;" [#fn(get)]) (__ name)])
julia_flisp.boot:  pattern-set] rename-sig-types)
julia_flisp.boot:	  rename-symbolic-labels #fn("8000r1e0|c130_43;" [rename-symbolic-labels-
julia_flisp.boot:							  #fn(table)] rename-symbolic-labels)
julia_flisp.boot:	  rename-symbolic-labels- #fn("B000r3|F@17802e0|31640|;|Mc1\x82Q0}g2L2|\x84e2|31c1e3|\x84c430g733g9L3;|Mc5<16702g2A@6?0c5e3|\x84g2Q3L2;|Mc6<17802|Mc7<6z0|\x84g2A17702g7C@670g75:0c8}g7^33g8670g8580e9g731g87>0c:}g7g933530]2|Mg9L2;|Mc;c<}g2q2|N32K;" [quoted?
julia_flisp.boot:  hygienic-scope caddr rename-symbolic-labels-
julia_flisp.boot:  #fn(table) escape symbolicgoto symboliclabel #fn(get) named-gensy #fn(put!)
julia_flisp.boot:  #fn(map) #fn("8000r1e0|~\x7f43;" [rename-symbolic-labels-])] rename-symbolic-labels-)
julia_flisp.boot:	  renumber-assigned-ssavalues #fn(";000r1e0c1|e233g5\x8540|;c330c4c5g6q1g5322]\x8c7g7c6g6g7q2O2g7M\x8e1|41;" [expr-find-all
julia_flisp.boot:  #fn(for-each) #fn("8000r1c0~|e13043;" [#fn(put!) make-ssavalue])
julia_flisp.boot:  ssavalue #fn(get) #fn(map)])] renumber-assigned-ssavalues)
julia_flisp.boot:	  renumber-lambda #fn("I000r3e0e1|31|\x84\x8570c2540c3}g234g7`[g7a[g7b2[g7b3[g7b4[]]]]\x8c>\x8c?\x8c@e4|31g8O2c5e6|31M31m=2g>e7c8c9e6|31M3231O2g?e7e:|3131O2g@c;g>g?g@g;g<q5O2g@Me1|3131e6|31e<c=|\x84gBMgB\x84c5gAN31e>gB31L4gAg9g:L641;" [compact-ir
julia_flisp.boot:  lam:body |top-level scope| none cdddr #fn(length) lam:vinfo symbol-to-idx-map
julia_flisp.boot:  slot static_parameter outerref nospecialize-meta? #fn(nconc) meta #fn(copy-list)
julia_flisp.boot:  #fn(memq) (goto enter) #fn(list*) gotoifnot caddr lambda renumber-lambda none
julia_flisp.boot:  foreigncall tuple-call? expr-contains-p #fn("6000r1e0|3117802e1|41;" [ssavalue?
julia_flisp.boot:  slot?]) "ccall function name and library expression cannot reference local variables"] renumber-stuff)
julia_flisp.boot:  listify-lambda lambda last] renumber-lambda)
julia_flisp.boot:  "> " #fn(io.flush) *output-stream* #fn("5000r0c040;" [#fn(read)])
julia_flisp.boot:  #fn("6000r1c0e1312c2|41;" [#fn(io.discardbuffer) *input-stream* #fn(raise)])
julia_flisp.boot:  #fn(io.eof?) *input-stream* load-process print that] prompt)
julia_flisp.boot:					  #fn("6000r1e0|312];" [top-level-exception-handler])
julia_flisp.boot:	  replace-beginend #fn("<000r5|c0\x82>0e1}g2g3g444;|c2\x82>0e3}g2g3g444;|?17802e4|31640|;|Mc5\x82K0c6c5e7|\x84}g2g3g435e8|3143;|Mc9c:}g2g3g4q4|N32K;" [end
julia_flisp.boot:  end-val begin begin-val quoted? ref #fn(list*) replace-beginend cddr #fn(map)
julia_flisp.boot:  #fn(":000r1e0|~\x7fi2i345;" [replace-beginend])] replace-beginend)
julia_flisp.boot:	  replace-vars #fn("8000r2|C6:0e0|}|43;|F@17802e1|31640|;c2|Mc332640|;|Mc4c5}q1|N32K;" [lookup
julia_flisp.boot:  quoted? #fn(memq) (-> function scope-block)
julia_flisp.boot:  #fn(map) #fn("7000r1e0|~42;" [replace-vars])] replace-vars)
julia_flisp.boot:	  require-token #fn("8000r1|b3[17C02|`[17;02e0|a[|32c1g531690e2c341;e4g5316>0e5|312e6|41;|b3[7:0|`g5\\530]2g5;" [next-token
julia_flisp.boot:  #fn(eof-object?) error "incomplete: premature end of input" newline?
julia_flisp.boot:  take-token require-token] require-token)
julia_flisp.boot:	  reserved-word? #fn(#3# #4# [#table(macro #t  continue #t  catch #t  using #t  if #t  function #t  else #t  global #t  return #t  elseif #t  finally #t  local #t  quote #t  for #t  let #t  true #t  baremodule #t  do #t  import #t  begin #t  const #t  try #t  export #t  break #t  end #t  false #t  struct #t  module #t  while #t)])
julia_flisp.boot:	  reserved-words (begin while if for try return break continue function
julia_flisp.boot:	  reset-gensyms #fn("5000r0e0k1;" [*gensyms* *current-gensyms*] reset-gensyms)
julia_flisp.boot:	  resolve-expansion-vars #fn(";000r2e0|_}_^]46;" [resolve-expansion-vars-with-new-env] resolve-expansion-vars)
julia_flisp.boot:	  resolve-expansion-vars- #fn("P000r5|c0<17S02|c1<17J02|c2<17A02|c3<17802c4|31640|;|C6P0c5|}32g9660g9N;g26:0c6g2|L3;|;|F@17802e7|31640|;|Mg9c8=640|;g9c9=6Y0g3\x8590e:|\x8441;g3Mg:Mg:\x84g3Ne;|\x84g;g<g=g445;g9c<=6x0|\x84g:C640|;e=g:316S0c<c>e?g:\x8431e;e@g:31}g2g3g435L3L2;c<e;g:}g2g3g435L2;cAg9cB326:0cCe?|42;g9cD=640|;g9cE=640|;g9cF=640|;g9cG=6]0cG|\x84eHe@|31}g2g3g435cCcI}g2g3g4q4eJ|3132L4;g9cK=6G0cKcCcLg4}g2g3q4|N32K;g9cM=6X0cMeNeO|\x8431}g2g3g435e;e@|31}g2g3g435L3;cAg9cP326\x8e0|\x84F16D02eQ|3116:02eR|b2326T0|MeN|\x84}g2g3g435e;e@|31}g2g3g435L3;cS|ML1cTcCcU}g2g3g4q4|N323142;g9cV=6\xfa0eR|b232740|;|\x84F16;02eW|31cX<6\xab0|\x84eRg:b23216602g:\x84g;6;0e@g:31550g:\x84cVcScXL1cTg;6R0g46B0eHg;}g2g3g435580e?g;31L1530_31eHg<}g2g3g435L133e;e@|31}g2g3g435L3;cVg46B0eH|\x84}g2g3g435580e?|\x8431e;e@|31}g2g3g435L3;g9cY=6t0eZ|}32eHe@|31g:g2g3g435e[|31cYcSc\\L1cTcCc]g:g2g3g4}q5g<323132g;L3;g9c^=6P0}g2L2g3K|\x84e@|31e;g;}g<g:g4]46;g9c_=6G0|McCc`}g2g3g4q4|N32K;|McCca}g2g3g4q4|N32K;" [begin
julia_flisp.boot:  end ccall cglobal #fn(underscore-symbol?)
julia_flisp.boot:  #fn(assq) globalref quoted? ssavalue escape julia-expand-macroscopes-
julia_flisp.boot:  resolve-expansion-vars-with-new-env global assignment? = unescape caddr #fn(memq)
julia_flisp.boot:  #fn(map) macrocall symboliclabel symbolicgoto struct resolve-expansion-vars-
julia_flisp.boot:  resolve-expansion-vars- caddr resolve-expansion-vars-with-new-env]) cadddr
julia_flisp.boot:								 resolve-expansion-vars-])
julia_flisp.boot:  -> resolve-in-function-lhs tuple-wrap-arrow-sig (= function) function-def?
julia_flisp.boot:  length> #fn(nconc) #fn(copy-list) #fn(":000r1e0|~\x7fi2i345;" [resolve-expansion-vars-with-new-env])
julia_flisp.boot:  kw caadr :: let new-expansion-env-for let-binds block #fn("<000r1e0|316Y0e1e2e1|\x84`32~\x7fi2i335\x84e2e3|31i4\x7fi2i33542;|;" [assignment?
julia_flisp.boot:  make-assignment resolve-expansion-vars- caddr]) hygienic-scope tuple #fn("<000r1e0|316L0c1e2|\x8431e3e4|31~\x7fi2i335L3;e3|~\x7fi2i345;" [assignment?
julia_flisp.boot:  = unescape resolve-expansion-vars-with-new-env caddr])
julia_flisp.boot:  #fn(":000r1e0|~\x7fi2i345;" [resolve-expansion-vars-with-new-env])] resolve-expansion-vars-)
julia_flisp.boot:	  resolve-expansion-vars-with-new-env
julia_flisp.boot:	  #fn("<000\x8950006000\x8a5000760^m52e0||F16802|Mc1<660}5:0e2|}g533g2g3g445;" [resolve-expansion-vars-
julia_flisp.boot:  let new-expansion-env-for] resolve-expansion-vars-with-new-env)
julia_flisp.boot:	  resolve-in-function-lhs #fn("@000r5]]c0}g2g3g4q4m92c1}g2g3g4q4m:2|Mg;c2=6R0c3c2L1g9|\x8431L1c4c5g:e6|31323143;g;c7=6[0e8|b2326=0c7g:|\x8431L2;c7g9|\x8431g:e9|3131L3;g;c:=6Y0c3c:L1g:|\x8431L1c4c5c;}g2g3q3e6|31323143;g;c<=6N0c3c<L1c4c5c=}g2g3q3|N323142;g:|41;" [#fn(":000r1e0|~\x7fi2i345;" [resolve-in-function-lhs] recur)
julia_flisp.boot:  #fn(":000r1e0|~\x7fi2i345;" [resolve-expansion-vars-with-new-env] other)
julia_flisp.boot:  where #fn(nconc) #fn(copy-list) #fn(map) cddr :: length= caddr call #fn(":000r1e0|~\x7fi2]45;" [resolve-expansion-vars-with-new-env])
julia_flisp.boot:  tuple #fn(":000r1e0|~\x7fi2]45;" [resolve-expansion-vars-with-new-env])] resolve-in-function-lhs)
julia_flisp.boot:	  resolve-scopes #fn("7000r1e0|^42;" [resolve-scopes-] resolve-scopes)
julia_flisp.boot:	  resolve-scopes- #fn("v000\x8920004000\x8a2000760_m22\x8a3000760^m32\x8c3|C6I0]\x8c8g8c0|g8q2O2g8M\x8e1}41;|F@17E02e1|3117;02c2|Mc332640|;|Mc4\x82;0e5|\x84312|;c2|Mc6326<0e5|\x84312c7;|Mc8\x82J0e9|\x84}327;0e:c;31530]2c7;|Mc<<17802|Mc=<650c7;|Mc>\x82\x990e?c@eA}3132eBe?cCcDeEg8323231eF30cGcHL1cIg:cJcJcKcLL2cMcNL2cKcOL2cKcPL2L5L2L3L1cQcDcR}g:q2g93231g:L144;|McS\x82H0c2eT|\x84}32cU32650cV;cW;|McX\x82[0eY|31eZe[|31e\\|g8__g2_}3732cX|\x84e]|31g9L4;|Mc^\x82l2|\x84e_}31eYg931g:A16;02|e[g931<e]g931e`g831eag831ebg831ecg831g:A16E02ed}3117;02eeg8c=32g:A16q02gA@16i02eeg8c<32gB7:0ef}315Q0gB\x84cW>660]5D0gB\x84cV>660^570ef}31\x8e1e?cgg?g@q2g>32g;670gC530_e?g;670ch5;0ci}gBg=q3gC32eBcjg@gE3231ckg<}q2gGgF31gGg?31cDelgH32cDelgI32cjemgFgH32gJ32cjemg?gI32gK32g;@16y02g:A16q02gB@16i02gA@16a02e?cn}g=q2gC32gNF6J0co30cpcqgOq1gN322gO\x8e1530^\x8e1cpcrg?g@g:}q4g=322g:F16;02|e[g931<6A0cpcsg:q1g@32530]2cpct}q1g@gEL2322g96J0eug931cje]g931gLgM33O530]2eveweZg8e\\g9_cjgFg?32g=_cjcDcxgHgJ33cDcxgIgK3332}gB16602g:AgAg;670gD570ey}31gN3;_g3M3431czcDc{gL32cDc|gM323242;|Mc}\x8290e:c~41;|Mc\x7f\x82G0c\x7f|\x84eZe]|31}_g3M34L3;|Mc\x80\x82U0cGc\x80L1eZ|\x84}eu|31g3M34L1cQeu|313143;|Mc\x81<16:02e\x82|b2326W0c\x81eZ|\x84}32eZe]|31}32eZe\x83|31}e\x84|3133L4;|McI<16`02|\x84C16X02}16R02e\x85e_}3131A16C02e\x86|\x84}3216702e\x87aW6\xa00|\x84e\x88g3M31g9M`W690e\x8930550g9Mg9\x84c\x8a\x8290e\x8b30550g9\x84e\x8cc\x8dc\x8ec\x8fc\x90g;g:3231g;g:c\x90c\x91g8c\x92c\x93c\x94g8c\x95c\x96g8c\x97c\x98g8c\x993=36\x8e1\x8e1\x8e1\x8e1530]2|McDc\x9ag3}q2|N32K;" [#fn("9000r1|6\x8f0c0~e1|3132640~;c0~e2|3132680c3~L2;c4~e5|3132g5660g5N;c0~e6|3132640~;c0~e7|3132640~;\x7fMe8|3141;c9~31640~;c3~L2;" [#fn(memq)
julia_flisp.boot:  scope:sp scope:prev #fn(underscore-symbol?)]) quoted? #fn(memq)
julia_flisp.boot:  (toplevel symbolicgoto symboliclabel toplevel-only) global check-valid-name
julia_flisp.boot:  (local local-def) (null) require-existing-local in-scope? error "no outer local variable declaration exists for \"for outer\""
julia_flisp.boot:  length= string-split #fn(string) "#"]) all-local-names delete-duplicates #fn("6000r1|c0<@;" [||])
julia_flisp.boot:  #fn(map) unmangled-name make-ssavalue #fn(nconc) block = call core apply_type
julia_flisp.boot:  top Dict Symbol Any #fn(copy-list) #fn("=000r1e0|~32c1c2g5L2c3c4c5L2\x7fg5c6|L2L5L3;" [resolve-scopes-
julia_flisp.boot:  if isdefined call top setindex! quote]) islocal var-kind (global none) (false)
julia_flisp.boot:  (true) lambda lam:argnames resolve-scopes- lam:body make-scope caddr
julia_flisp.boot:  scope-block scope:lam find-global-decls find-assigned-vars
julia_flisp.boot:  find-local-def-decls find-local-decls scope:hard? find-scope-decl scope:soft?
julia_flisp.boot:  var-kind (none static-parameter) scope:implicit-globals
julia_flisp.boot:  defined-julia-global]) #fn(append) #fn("8000r1e0c1~\x7fq2|42;" [filter #fn("7000r1c0|~3217902e1|\x7f42;" [#fn(memq)
julia_flisp.boot:  in-scope?])]) named-gensy diff #fn("8000r1c0|e1~313217802e2|3116H02e3|~32c4<16:02c0|\x7f32@;" [#fn(memq)
julia_flisp.boot:  scope:implicit-globals defined-julia-global var-kind none])
julia_flisp.boot:  #fn(table) #fn(for-each) #fn("8000r1c0~|]43;" [#fn(put!)])
julia_flisp.boot:  error #fn(string) "variable \"" "\" declared both local and global" var-kind
julia_flisp.boot:  #fn("7000r1c0c1~q1|42;" [#fn(for-each) #fn("9000r1e0|~32c1\x82@0e2c3c4|c53341;];" [var-kind
julia_flisp.boot:  static-parameter error #fn(string) "local variable name \""
julia_flisp.boot:  "\" conflicts with a static parameter"])]) cddr insert-after-meta blockify #.cons
julia_flisp.boot:  scope:implicit-globals #fn(append!) #fn("6000r1c0|L2;" [local])
julia_flisp.boot:  #fn("6000r1c0|L2;" [local-def]) module "\"module\" expression not at top level"
julia_flisp.boot:  break-block with-static-parameters method length> cadddr
julia_flisp.boot:  method-expr-static-parameters lam:args warn-var?! *scopewarn-opt*
julia_flisp.boot:  extract-line-file julia-current-line none julia-current-file lowering-warning
julia_flisp.boot:  #fn(":000r1e0|31680~|O530]2e1|\x7f_~M44;" [linenum? resolve-scopes-])] resolve-scopes-)
julia_flisp.boot:	  resume-on-escape #fn("9000r3}F@17802e0}31640_;c1}Mc232640_;}Mc3\x82>0e4|}\x84g2aw43;}Mc5\x82K0g2`W680|}\x8441;e4|}\x84g2ax43;e6c7|g2q2_}N43;" [quoted?
julia_flisp.boot:  #fn(memq) (lambda module toplevel) hygienic-scope resume-on-escape escape
julia_flisp.boot:  foldl #fn(":000r2c0}e1~|\x7f3342;" [#fn(append!) resume-on-escape])] resume-on-escape)
julia_flisp.boot:	  #fn("7000r2e0}|42;" [reverse-] revappend) reverse #fn("7000r1e0_|42;" [reverse-] reverse)
julia_flisp.boot:	  reverse! #fn("7000r1e0_|42;" [reverse!-] reverse!) reverse!-
julia_flisp.boot:	  #fn("8000r2]}F6B02}N}|}m02P2m15\x1d/2|;" [] reverse!-) reverse- #fn("7000r2}\x8540|;e0}M|K}N42;" [reverse-] reverse-)
julia_flisp.boot:	  rewrap-where #fn("8000r2}F16802}Mc0<6C0c0e1|}\x8432e2}31L3;|;" [where
julia_flisp.boot:  rewrap-where caddr] rewrap-where)
julia_flisp.boot:	  rewrite-ctor #fn(">000r5]\x8c9g9c0}g2g9g3g4q5O2e1e230e3g;c4c5}g9q2c6}g9q2L2332e3g;c7c8}g9q2c9}g9q2L2332c:g;_Z3\x8e1e1e230e3g=c;c<L1332c:g=_Z3\x8e1|3242;" [#fn("B000r3e0e130e2g8c3c4~}g2\x7fi2i3i4q7c5~g2\x7fi2}i3i4q7L2332c6g8_Z3\x8e1|42;" [pattern-replace
julia_flisp.boot:  make-table table-set! call #fn("?000r1e0c1|c2~\x7fi2i3i4i5i6q7c344;" [plambda-expansion
julia_flisp.boot:  (call (-/ new) . args) #fn(">000r2e0~\x7fi2i3c1c2i4\x7fi2q3}32i5i647;" [new-call
julia_flisp.boot:  #fn("?000r1e0c1|c2~\x7fi2i3i4i5i6q7c344;" [plambda-expansion (call (curly (-/
julia_flisp.boot:  new) . p) . args) #fn(">000r3e0~}\x7fi2c1c2i3i4\x7fq3g232i5i647;" [new-call
julia_flisp.boot:					     (__ p args)]) pattern-set] ctor-body)
julia_flisp.boot:  pattern-replace make-table table-set! function #fn(":000r1e0c1|c2~\x7fq2c344;" [plambda-expansion
julia_flisp.boot:  (function (-$ (call name . sig) (:: (call name . sig) _t)) body)
julia_flisp.boot:  #fn(";000r5e0}~\x7fMg2g4^46;" [ctor-def])
julia_flisp.boot:  (__ name sig _t body)]) #fn(":000r1e0c1|c2~\x7fq2c344;" [plambda-expansion (function
julia_flisp.boot:  (where (-$ (call name . sig) (:: (call name . sig) _t)) . wheres) body)
julia_flisp.boot:							   #fn(";000r6e0}~\x7fMg2g5g446;" [ctor-def])
julia_flisp.boot:  = #fn(":000r1e0c1|c2~\x7fq2c344;" [plambda-expansion (= (-$ (call name . sig)
julia_flisp.boot:				     #fn(";000r5e0}~\x7fMg2g4^46;" [ctor-def])
julia_flisp.boot:  #fn(":000r1e0c1|c2~\x7fq2c344;" [plambda-expansion (= (where (-$ (call name . sig)
julia_flisp.boot:				   #fn(";000r6e0}~\x7fMg2g5g446;" [ctor-def])
julia_flisp.boot:				   (__ name sig _t wheres body)]) pattern-set
julia_flisp.boot:  where #fn("9000r1e0c1|c2c344;" [plambda-expansion (where (where . rest1) . rest2)
julia_flisp.boot:				  #fn("6000r3e0|41;" [flatten-where-expr])
julia_flisp.boot:				  (__ rest1 rest2)])] rewrite-ctor)
julia_flisp.boot:	  rm-linenums #fn("9000r1|?640|;c0e1|Mc2\x82<0e3c4|32530|42;" [#fn(map)
julia_flisp.boot:  rm-linenums parameters filter #fn("6000r1e0|31@;" [linenum?])] rm-linenums)
julia_flisp.boot:	  safe-arg-names #fn("9000\x8910002000\x8a1000760^m12c0c1c2}q1|32v2;" [#fn(nconc)
julia_flisp.boot:  #fn(map) #fn("8000r1e0|31~g5F16E02g5MF16<02e1g531c2<\x82B0~6;0e3g531L1;g5;_;" [try-arg-name
julia_flisp.boot:  caar escape cadar])] safe-arg-names)
julia_flisp.boot:	  safe-field-names #fn("7000r2e0c1}q1|326:0c2c3|42;c2c4|42;" [any #fn("7000r1e0c1|q1~42;" [contains
julia_flisp.boot:  #fn("6000r1|c0\x8270e140;|;" [_ gensy])] safe-field-names)
julia_flisp.boot:	  safe-llist-keyword-args #fn("<000r1c0c1c2e3c4|3232Q2e3c5g532c6e7g6^32e7g6]32e8|]3243;" [#fn(nconc)
julia_flisp.boot:  #fn("6000r1e0|31@;" [vararg?]) #fn(append) safe-arg-names
julia_flisp.boot:  safe-llist-positional-args] safe-llist-keyword-args)
julia_flisp.boot:	  safe-llist-positional-args #fn("9000\x8910002000\x8a1000760^m12e0c1|q1c2}q142;" [call-with-values
julia_flisp.boot:  #fn(";000r2e0c1}c1c2c3|32Q232~42;" [safe-arg-names #fn(append)
julia_flisp.boot:				      #fn("7000r1e0e1|42;" [filter vararg?])])] safe-llist-positional-args)
julia_flisp.boot:	  scolno #fn("8000r1c0c1c2|3142;" [#fn(string) " near column " #fn(input-port-column)] scolno)
julia_flisp.boot:	  scope:implicit-globals #fn("6000r1|b9[;" [] scope:implicit-globals)
julia_flisp.boot:	  scope:warn-vars #fn("6000r1|b:[;" [] scope:warn-vars) scopenest
julia_flisp.boot:	  self-argname #fn("7000r1e0|b33216802|Mc1<670|\x84L1;_;" [length= ::] self-argname)
julia_flisp.boot:	  self-evaluating? #fn("7000r1|?16602|C@17K02c0|3116A02|C16:02|c1|31<;" [#fn(constant?)
julia_flisp.boot:  #fn(top-level-value)] self-evaluating?)
julia_flisp.boot:	  separate #fn(":000r2]c0m62g6|}_L1_L144;" [#fn("9000r4g2g3K]}F6Z02|}M316?0g2}M_KPNm25<0g3}M_KPNm32}Nm15\x05/2e0g8MNg8NN42;" [values] separate-)] separate)
julia_flisp.boot:	  set-bit #fn("8000r3g2690c0|}42;c1|c2}3142;" [#fn(logior)
julia_flisp.boot:						       #fn(lognot)] set-bit)
julia_flisp.boot:	  set-lineno! #fn("6000r2e0|31}O;" [cddddr] set-lineno!) set-syntax!
julia_flisp.boot:				 *syntax-environment*] set-syntax!)
julia_flisp.boot:	  short-form-function-loc #fn(";000r2e0|\x84316I0c1|\x84e2e3|31c4}e5L332L3;|;" [eventually-call?
julia_flisp.boot:  = add-line-number caddr line current-filename] short-form-function-loc)
julia_flisp.boot:	  show-profiles #fn("@000r0]]]\x8c4\x8c6g4`O2e0c1e2~3132m52g6b4e3c4c5c6c4c7g532K32Q2wO2e8e9c:g6Mc;33c<322e=302e8e9c>g6Mc;33c?322e=302c@cAg4g6q2eBeCc4cDg5323131322e8e9c>g6Mc;33c?322e=302e8e9cEg6Mc;33cFcGg4M31332e=40;" [filter
julia_flisp.boot:  newline "--------" "------     --------------------    -------------------"
julia_flisp.boot:  #fn(for-each) #fn(";000r1~~M|\x84wO2e0e1c2e3|3131\x7fMc433e1c2e5|3131b;c433e1c2|M31bHc433|\x84342e640;" [princ
julia_flisp.boot:  string.rpad #fn(string) cadddr #\space caddr newline]) reverse simple-sort #fn("7000r1e0e1|3141;" [reverse
julia_flisp.boot:  to-proper]) "Total   " "           " #fn(string)] [#644#])
julia_flisp.boot:	  simple-atom? #fn("7000r1|D17c02c0|3117Y02e1|3117O02|F16;02c2|Mc33217;02c4|31c5<;" [#fn(string?)
julia_flisp.boot:  #fn(typeof) julia_value] simple-atom?)
julia_flisp.boot:	  simple-sort #fn("9000r1|A17602|NA640|;|Me0c1g5|q2c2g5q142;" [call-with-values
julia_flisp.boot:  #fn("9000r2c0e1|31~L1e1}3143;" [#fn(nconc) simple-sort])] simple-sort)
julia_flisp.boot:	  simple-string-literal? #fn("6000r1c0|41;" [#fn(string?)] simple-string-literal?)
julia_flisp.boot:	  sink-assignment #fn(";000r2}F16802}Mc0<6V0e1}N31c2c0L1c3e1g6N3131c4|g6ML3L143;c4|}L3;" [block
julia_flisp.boot:  reverse #fn(nconc) #fn(copy-list) =] sink-assignment)
julia_flisp.boot:	  sized-uint-literal #fn(";000r3c0}`32c1=670b4540b3c2}31g7xg2T2awe3g8b8326?0e4|}322e5|41;e3g8b@326?0e4|}322e6|41;e3g8bP326?0e4|}322e7|41;e3g8bp326?0e4|}322e8|41;e3g8c9326B0c:c;c<L2c=L1}L4;c:c;c>L2c=L1}L4;" [#fn(string.char)
julia_flisp.boot:  #\- #fn(length) <= numchk uint8 uint16 uint32 uint64 128 macrocall core
julia_flisp.boot:  @uint128_str null @big_str] sized-uint-literal)
julia_flisp.boot:	  sized-uint-oct-literal #fn("9000r2c0}c1326;0e2|}b343;|6_0|c3X680e4|41;|c5X680e6|41;|c7X680e8|41;e9|41;}c:>6;0e;|}32530]2e<}316B0c=c>c?L2c@L1}L4;c=c>cAL2c@L1}L4;" [#fn(string.find)
julia_flisp.boot:  "o0" sized-uint-literal 256 uint8 65536 uint16 4294967296 uint32 uint64 "0o"
julia_flisp.boot:  numchk oct-within-uint128? macrocall core @uint128_str null @big_str] sized-uint-oct-literal)
julia_flisp.boot:	  skip-comment #fn("8000r1]\x8c5g5c0g5q1O2e1|312e2|31c3=6@0e1|312g5M|a42;e4|41;" [#fn(":000r2e0|31c1g631690e2c341;g6c4=6`0e5|31g7c6=6L0e0|312e7}a326;0~M|}ax42;];~M|}42;g6c6=6P0~M|e5|31c4=6>0e0|312}aw530}42;~M|}42;" [read-char
julia_flisp.boot:  #fn(eof-object?) error "incomplete: unterminated multi-line comment #= ... =#"
julia_flisp.boot:  #\= peek-char #\# >] skip-multiline-comment) read-char peek-char #\=
julia_flisp.boot:  skip-to-eol] skip-comment)
julia_flisp.boot:	  skip-to-eol #fn("7000r1e0|31c1g531650g5;g5c2=650g5;e3|312e4|41;" [peek-char
julia_flisp.boot:  #fn(eof-object?) #\linefeed read-char skip-to-eol] skip-to-eol)
julia_flisp.boot:	  skip-ws-and-comments #fn("7000r1c0|]322e1|31c2=6@0e3|312e4|31530]2];" [#fn(skip-ws)
julia_flisp.boot:  peek-char #\# skip-comment skip-ws-and-comments] skip-ws-and-comments)
julia_flisp.boot:	  space-before-next-token? #fn("8000r1c0|a[^3217=02c1e2|a[31=;" [#fn(skip-ws)
julia_flisp.boot:  #\linefeed peek-char] space-before-next-token?)
julia_flisp.boot:	  space-sensitive #f sparam-name-bounds
julia_flisp.boot:	  #fn("9000r1c0e1|32e2c0c3g532g542;" [#fn(map) analyze-typevar values
julia_flisp.boot:					      #.car] sparam-name-bounds)
julia_flisp.boot:	  splat-token (__splat__) splice-form?
julia_flisp.boot:	  #fn("7000r1|F16X02|Mc0<17N02|Mc1<17D02|Mc2<16:02e3|b23217702|c2<;" [unquote-splicing
julia_flisp.boot:  unquote-nsplicing unquote length>] splice-form?)
julia_flisp.boot:	  string->list #fn("9000r1]\x8c5g5c0|g5q2O2g5M\x8e1c1|31_42;" [#fn(":000r2|`W640};c0~|32\x7fMg6c1~g632}K42;" [#fn(string.dec)
julia_flisp.boot:  #fn(string.char)]) #fn(sizeof)] string->list)
julia_flisp.boot:	  string->symbol #fn(symbol) string-append
julia_flisp.boot:	  #fn(string) string-lastchar #fn(":000r1c0|c1|c2|313242;" [#fn(string.char)
julia_flisp.boot:								    #fn(length)] string-lastchar)
julia_flisp.boot:	  string-length #fn(string.count) string-replace
julia_flisp.boot:	  #fn("8000r3e0e1|}32g242;" [string.join string-split] string-replace)
julia_flisp.boot:	  string-split #fn("9000r2e0|}`_44;" [string-split-] string-split)
julia_flisp.boot:	  string-split- #fn("=000r4c0|}g233g86M0e1|}g8c2}31wc3|g2g833g3K44;e4c3|g2c2|3133g3K41;" [#fn(string.find)
julia_flisp.boot:  string-split- #fn(sizeof) #fn(string.sub) reverse] string-split-)
julia_flisp.boot:	  string-to-number #fn(";000r3g26E0e0c1e2c3|32}3231580c1|}32g716U02g7c4W17802g7c5W6@0e6c7c8|c93341;g7;" [float
julia_flisp.boot:  #fn(string->number) string.map #fn("6000r1|c0=650c1;|;" [#\f
julia_flisp.boot:							   #\e]) +inf.0 -inf.0
julia_flisp.boot:  error #fn(string) "overflow in numeric constant \"" "\""] string-to-number)
julia_flisp.boot:  #fn(buffer) #fn(io.write) #fn(for-each)
julia_flisp.boot:	  strip-escaped-newline #fn("7000r2}640|;c0c1|42;" [#fn(map)
julia_flisp.boot:  strip-escaped-newline-])] strip-escaped-newline)
julia_flisp.boot:	  strip-escaped-newline- #fn("<000r1e0|31e130]\x8c7g7c2g5g6g7q3O2g7M^312c3g641;" [open-input-string
julia_flisp.boot:  open-output-string #fn("9000r1e0~31c1g53117\x7f02|6]0g5c2=7D0e3c4\x7f322e3g5\x7f325;0c5~q1k6302i2M^41;g5c4=690i2M]41;e3g5\x7f322i2M^41;" [read-char
julia_flisp.boot:  #fn(eof-object?) #\linefeed write-char #\\
julia_flisp.boot:  #fn("7000r0e0e1~31c2326=0e3~312e440;];" [memv peek-char (#\space
julia_flisp.boot:							   #\tab) take-char
julia_flisp.boot:					   loop-] loop-) loop-] loop)
julia_flisp.boot:  #fn(io.tostring!)] strip-escaped-newline-)
julia_flisp.boot:	  strip-leading-0s #fn("9000r1]\x8c5g5c0|g5q2O2c1|`32c2=6?0c3c2g5Ma3142;g5M`41;" [#fn("7000r1c0~|32c1=6:0\x7fM|aw41;e2~|42;" [#fn(string.char)
julia_flisp.boot:  #\- #fn(string)] strip-leading-0s)
julia_flisp.boot:	  strip-leading-newline #fn("8000r1c0|31e1g5`3216<02c2|`32c3=690e4|a42;e1g5a3216J02c2|`32c5=16<02c2|a32c3=6:0e4|b242;|;" [#fn(sizeof)
julia_flisp.boot:  > #fn(string.char) #\linefeed string.tail #\return] strip-leading-newline)
julia_flisp.boot:	  struct-def-expr #fn(";000r5e0c1}q1c2|g2g3g4q442;" [call-with-values
julia_flisp.boot:							     #fn("6000r0e0~41;" [sparam-name-bounds])
julia_flisp.boot:							     #fn(";000r2e0~|}\x7fe1i231i346;" [struct-def-expr-
julia_flisp.boot:  flatten-blocks])] struct-def-expr)
julia_flisp.boot:	  struct-def-expr- #fn("=000r6e0c1g4q1c2g4|}g2g5g3q642;" [call-with-values
julia_flisp.boot:  #fn("6000r1|C17802e0|41;" [eventually-decl?])])
julia_flisp.boot:  reverse filter #fn("6000r1e0|31@;" [effect-free?]) linenum? decl-var
julia_flisp.boot:  decl-type default-inner-ctors min ctors-min-initialized
julia_flisp.boot:  #fn(length) make-ssavalue has-dups error #fn(string)
julia_flisp.boot:  "duplicate field name: \"" "\" is not unique" #fn(for-each)
julia_flisp.boot:  #fn(nconc) block global const scope-block hardscope local-def #fn(copy-list)
julia_flisp.boot:  #fn("6000r1c0|L2;" [local]) #fn("9000r2e0|e1}]3242;" [make-assignment
julia_flisp.boot:							bounds-to-TypeVar])
julia_flisp.boot:  toplevel-only struct outerref = call core _structtype thismodule inert svec
julia_flisp.boot:  quote body]) quote parameters _typebody! null #fn(":000r1e0|~\x7fi2i345;" [rewrite-ctor])
julia_flisp.boot:  #fn("9000r2}A17S02}Me0g6Mc1|K3216A02~Mc2g6N|32}N42;" [expr-contains-eq list
julia_flisp.boot:  default-outer-ctor])] struct-def-expr-)
julia_flisp.boot:	  sym-dot? #fn("7000r1e0|b33216C02|Mc1<16902e2|\x8441;" [length= |.|
julia_flisp.boot:								 symbol-like?] sym-dot?)
julia_flisp.boot:	  sym-ref-or-overlay? #fn("6000r1e0|3117802e1|41;" [overlay? sym-ref?] sym-ref-or-overlay?)
julia_flisp.boot:	  sym-ref? #fn("7000r1e0|3117\x7f02e1|b33216s02|Mc2<16i02|\x84?17902e3|\x843116V02e4|31F16K02c5e4|31Mc63216:02e4|31\x84C;" [nodot-sym-ref?
julia_flisp.boot:  length= |.| sym-ref? caddr #fn(memq) 'inert] sym-ref?)
julia_flisp.boot:	  symbol->string #fn("6000r1c0|41;" [#fn(string)] symbol->string)
julia_flisp.boot:	  symbol-like? #fn("6000r1|C17802e0|41;" [ssavalue?] symbol-like?)
julia_flisp.boot:	  symbol-or-interpolate? #fn("6000r1|C17?02|F16802c0|M<;" [$] symbol-or-interpolate?)
julia_flisp.boot:	  symbol-syntax #fn("8000r1c0e1|^43;" [#fn(get)
julia_flisp.boot:					       *syntax-environment*] symbol-syntax)
julia_flisp.boot:	  symbol-to-idx-map #fn(":000r1c030]\x8c6g6c1g5g6q2O2g6M\x8e1|a322g5;" [#fn(table)
julia_flisp.boot:  #fn("8000r2|F6E0c0~|M}332\x7fM|N}aw42;];" [#fn(put!)])] symbol-to-idx-map)
julia_flisp.boot:	  symdecl? #fn("6000r1|C17802e0|41;" [decl?] symdecl?) syntactic-op?
julia_flisp.boot:	  #fn(#3# #4# [#table(.>>>= #t  = #t  .*= #t  ... #t  .+= #t  *= #t  -> #t  %= #t  |\|=| #t  /= #t  .-= #t  >>>= #t  .^= #t  .//= #t  .= #t  |\|\|| #t  -= #t  .<<= #t  <<= #t  && #t  .>>= #t  |.\|=| #t  .&= #t  .= #t  ./= #t  $= #t  = #t  |.\|\|| #t  |\\=| #t  += #t  .= #t  := #t  |.| #t  .&& #t  ^= #t  = #t  |.\\=| #t  .%= #t  //= #t  >>= #t  &= #t)])
julia_flisp.boot:	  syntactic-operators (&& |\|\|| = += -= *= /= //= |\\=| ^= = %= <<=
julia_flisp.boot:			       >>= >>>= |\|=| &= = .&& |.\|\|| .= .+= .-= .*=
julia_flisp.boot:			       .&= .= := $= |.| ... ->)
julia_flisp.boot:	  syntactic-unary-op? #fn("7000r1c0|c132@@;" [#fn(memq)
julia_flisp.boot:	  syntactic-unary-operators #645# syntax-deprecation
julia_flisp.boot:	  #fn(">000r3e0g231g7Mg7\x84e1e2|}g9g8^35g242;" [extract-line-file
julia_flisp.boot:							 deprecation-message
julia_flisp.boot:							 format-syntax-deprecation] syntax-deprecation)
julia_flisp.boot:	  table-ref #fn(get) table-set!
julia_flisp.boot:	  take-char #fn("6000r1e0|312|;" [read-char] take-char)
julia_flisp.boot:	  take-lineendings #fn("7000r1e0|31e1g53117802g5c2=6>0e3|312e4|41;|;" [peek-token
julia_flisp.boot:  newline? #\; take-token take-lineendings] take-lineendings)
julia_flisp.boot:	  take-token #fn("8000r1|b3[|b3^\\217;02|`[|`^\\2;" [] take-token)
julia_flisp.boot:	  take-while #fn("8000r2}\x8540_;|}M316=0}Me0|}N32K;_;" [take-while] take-while)
julia_flisp.boot:	  throw-unassigned-kw-args #fn(";000r1]]\x8c5\x8c6g5c0O2g6c1g5g6q2O2e2|316E0c3c4g6Me5|3132K|NK;|;" [#fn(":000r1c0c1c2L2c0c1c3L2c4|L2L3L3;" [call
julia_flisp.boot:  core throw UndefKeywordError inert] throw-unassigned)
julia_flisp.boot:  kw decl-var nospecialize-meta? meta caddr] to-kw) has-parameters? parameters
julia_flisp.boot:  #fn(map) cdar] throw-unassigned-kw-args)
julia_flisp.boot:	  to-kws #fn("7000r1c0e1|42;" [#fn(map) =-to-kw] to-kws) to-proper
julia_flisp.boot:	  #fn("7000r1|\x8540|;|?660|L1;|Me0|N31K;" [to-proper] to-proper)
julia_flisp.boot:	  top-level-exception-handler #fn("9000r1e0e1k02c2g5q1c3|q1c4g6q1tg6302;" [*output-stream*
julia_flisp.boot:  *stderr* #fn("5000r0~k0;" [*output-stream*])
julia_flisp.boot:  #fn("6000r0e0~312e1c23041;" [print-exception print-stack-trace #fn(stacktrace)])
julia_flisp.boot:  #fn("6000r1~302c0|41;" [#fn(raise)])] top-level-exception-handler)
julia_flisp.boot:	  toplevel-only-expr? #fn("7000r1|F16U02c0|Mc13217H02c0|Mc23216;02e3c4|N42;" [#fn(memq)
julia_flisp.boot:  every #.symbol?] toplevel-only-expr?)
julia_flisp.boot:	  toplevel-preserving? #fn("7000r1|F16;02c0|Mc142;" [#fn(memq)
julia_flisp.boot:								 tryfinally)] toplevel-preserving?)
julia_flisp.boot:	  trans-op |.'| triplequoted-string-indentation
julia_flisp.boot:	  #fn("9000r1e0c1c2c3|32Q241;" [longest-common-prefix
julia_flisp.boot:  triplequoted-string-indentation-])] triplequoted-string-indentation)
julia_flisp.boot:	  triplequoted-string-indentation-
julia_flisp.boot:	  #fn(":000r1e0|31]\x8c6g6c1g6g5q2O2g6M\x8e1e2g531`__44;" [open-input-string
julia_flisp.boot:  read-char #fn(eof-object?) memv (#\space
julia_flisp.boot:				   #\tab) reverse]) read-char] triplequoted-string-indentation-)
julia_flisp.boot:	  try-arg-name #fn("8000r1|C660|L1;|?640_;|Mg5c0=6E0e1|b232640_;e2|\x8441;c3g5c432690e2|\x8441;g5c5=660|L1;g5c6=690e2|\x8441;g5c7=6G0e8|]326<0e2e9|3141;_;_;" [::
julia_flisp.boot:  length= try-arg-name #fn(memq) (... kw =) escape hygienic-scope meta
julia_flisp.boot:  nospecialize-meta? caddr] try-arg-name)
julia_flisp.boot:	  ts:put-back! #fn("7000r3|b3[690e0c141;|b3}\\2|b4g2\\;" [error "too many pushed-back tokens (internal error)"] ts:put-back!)
julia_flisp.boot:	  ts:space? #fn("7000r1||b3[670b4540b2[;" [] ts:space?) tuple-call?
julia_flisp.boot:	  #fn("7000r1e0|a3216B02|Mc1<16802|\x84c2>;" [length> call (core tuple)] tuple-call?)
julia_flisp.boot:	  tuple-to-arglist #fn("8000r1|Mc0\x82;0c1e2|N42;|Mc3\x82w0e4|a32640_;e4|b2326;0e2|\x8431L1;e4|b3326H0c5e2e6|3131L2e2|\x8431L2;e7c841;e2|31L1;" [tuple
julia_flisp.boot:  #fn(map) =-to-kw block length= parameters caddr error "more than one semicolon in argument list"] tuple-to-arglist)
julia_flisp.boot:	  tuple-to-assignments #fn(";000r2]\x8c6g6c0g6q1O2g6M\x8e1||}N___46;" [#fn("F000r6|\x85g0c0c1L1c2e3g33131c2e3g43131c4c0c5L1c2e3g5313132L2L144;|Mg2\x8560_550g2Me6g:3116p02g;F@17C02e7g;3117802g;c8>16R02e9c:g:q1g2N32@16?02e9c;g;q1}32@6R0~M|Ng:}Kg2Ne<g:g;32g3Kg4g;g5K46;e=g:316\xba0|N\x85\xa50e>g:\x8431690e?30560e@30c0c1L1c2e3g33131cAg<c0c5L1c2g23132L3L1c2e3g43131cAg:\x84g<L3L1c4c0c5L1c2e3g53131cBg<L2L133L2L146;eCcDcEg:\x84cF3341;e=g;316\x930e@30c0c1L1c2e3g33131e<g<g;\x8432L1c2e3g43131cAc0c5L1c2|3132g<L3L1c4c0c5L1c2e3g53131cBg<L2L133L2L146;e>g:31690e?30560e@30~M|Ng:}Kg2Ng<C6I0cGe<g<g;32cHg<L2g3335=0e<g<g;32g3Ke<g:g<32g4Kg<g5K46;" [#fn(nconc)
julia_flisp.boot:  block #fn(copy-list) reverse unnecessary tuple symbol-like? quoted? (null)
julia_flisp.boot:  contains #fn("7000r1e0|~42;" [eq-sym?])
julia_flisp.boot:  #fn("7000r1e0|~42;" [eq-sym?]) make-assignment vararg? eventually-call? gensy
julia_flisp.boot:  make-ssavalue = ... error #fn(string) "invalid \"...\" on non-final assignment location \""
julia_flisp.boot:  "\"" #fn(list*) local-def])] tuple-to-assignments)
julia_flisp.boot:	  tuple-wrap-arrow-sig #fn(":000r1|?680c0|L2;|Mc1\x82L0c2c1L1e3|\x8431L1c4e5|313143;|Mc0\x8240|;|Mc6\x82=0c6e7|\x8431L2;c0|L2;" [tuple
julia_flisp.boot:  where #fn(nconc) tuple-wrap-arrow-arglist
julia_flisp.boot:  #fn(copy-list) cddr escape tuple-wrap-arrow-sig] tuple-wrap-arrow-sig)
julia_flisp.boot:	  type-for-closure #fn("J000r3e030c1c2___`_L4c3c4|L2c5|L2c6g7c7c8c9L2c:L1c;|L2c7c8c<L2L2c=c7L1c8c<L2L1c>c?e@}323133c7c8c<L2L2cAL1cB}31L9L3c6cC|L2g7L3c7c8cDL2|g2L4c7c8cEL2|c=c7L1c8c<L2L1c>c?cF}323133L4cGcHL1L2L8L4L2L1;" [make-ssavalue
julia_flisp.boot:  #fn(nconc) #fn(copy-list) #fn(map) quotify false #fn(length) outerref
julia_flisp.boot:  _setsuper! _typebody! #fn("5000r1c0;" [(core Box)]) return null] type-for-closure)
julia_flisp.boot:	  type-for-closure-parameterized #fn("M000r6c0}31e130c2c3___`_L4c4c5L1c6|L2L1c7|L2L1c8c9c:}g23331c;g;c<c=c>L2c?L1c@|L2c4c<L1c=cAL2L1c8}3133c4c<L1c=cAL2L1c8c9eBg3323133c<c=cAL2L2cCL1c0g331L9L3L1c;cD|L2g;L3L1c<c=cEL2|g5L4L1c<c=cFL2|c4c<L1c=cAL2L1c8g43133L4L1cGcHL1L2L139L4L2L1;" [#fn(length)
julia_flisp.boot:  make-ssavalue thunk lambda #fn(nconc) block global const #fn(copy-list)
julia_flisp.boot:  _typebody! return null] type-for-closure-parameterized)
julia_flisp.boot:	  typedef-expr-name #fn("6000r1|?640|;|Mc0<17802|Mc1<690e2|\x8441;|;" [curly
julia_flisp.boot:  <: typedef-expr-name] typedef-expr-name)
julia_flisp.boot:	  typedef-expr-tvars #fn("6000r1|?640_;|Mc0\x8290e1|\x8441;|Mc2\x8280e3|41;_;" [<:
julia_flisp.boot:  typedef-expr-tvars curly cddr] typedef-expr-tvars)
julia_flisp.boot:	  typevar-expr-name #fn("6000r1e0|31M;" [analyze-typevar] typevar-expr-name)
julia_flisp.boot:	  typevar-names #fn("8000r1c0c1c2|32v2;" [#fn(nconc)
julia_flisp.boot:						  #fn("6000r1c0|q1c1t;" [#fn("6000r0e0~31L1;" [typevar-expr-name])
julia_flisp.boot:  #fn("5000r1_;" [])])] typevar-names)
julia_flisp.boot:	  unary-and-binary-op? #fn("7000r1c0|c132@@;" [#fn(memq)
julia_flisp.boot:						       #646=($ & ~ + -    .+
julia_flisp.boot:							     .- . . .)])
julia_flisp.boot:	  unary-and-binary-ops #646# unary-op?
julia_flisp.boot:	  #fn(#3# #4# [#table(>: #t  . #t  . #t  ! #t  .! #t   #t  .+ #t  . #t  ~ #t   #t  . #t  - #t  . #t  .~ #t  . #t   #t   #t  .- #t   #t  <: #t  + #t   #t   #t  . #t)])
julia_flisp.boot:	  unary-ops (<: >: + - ! ~        .+ .- .! .~ . . . . . .
julia_flisp.boot:	  undot-name #fn("6000r1|F16802|Mc0<690e1|31\x84;|;" [|.| caddr] undot-name)
julia_flisp.boot:  #647=#\. #fn(raise) (assert-failed (eqv? (string.char str 0)
julia_flisp.boot:	  unescape-parsed-string-literal #fn("8000r1e0e1e2|43;" [map-at even?
julia_flisp.boot:								 unescape-string] unescape-parsed-string-literal)
julia_flisp.boot:	  unescape-string #fn("8000r1e0c1c2|q142;" [with-exception-catcher
julia_flisp.boot:							      open-input-string
julia_flisp.boot:							      #\"])] unescape-string)
julia_flisp.boot:	  unmangled-name #fn(":000r1|c0\x8240|;c1|31c2g5`32c3=6C0c4e5e6g5c7323141;|;" [||
julia_flisp.boot:  #fn(string) #fn(string.char) #\# #fn(symbol) last string-split "#"] unmangled-name)
julia_flisp.boot:	  unwrap-where #fn("6000r1|F16802|Mc0<690e1|\x8441;|;" [where
julia_flisp.boot:								unwrap-where] unwrap-where)
julia_flisp.boot:	  valid-1arg-func-sig? #fn("7000r1|C17S02|F16L02|Mc0<16B02|\x84C17:02e1|b242;" [::
julia_flisp.boot:  length=] valid-1arg-func-sig?)
julia_flisp.boot:	  valid-func-sig? #fn("7000r2}F16\x9502}Mc0<17\x8b02}Mc1<17\x8102|16802}Mc2<17q02|16802}Mc3<17a02}Mc4<16A02}\x84F16902}\x84Mc0<17D02}Mc5<16:02e6|}\x8442;" [call
julia_flisp.boot:  tuple block ... :: where valid-func-sig?] valid-func-sig?)
julia_flisp.boot:	  valid-ir-argument? #fn("7000r1e0|3117I02|C17B02|F16;02c1|Mc242;" [simple-atom?
julia_flisp.boot:	     boundscheck)] valid-ir-argument?)
julia_flisp.boot:	  valid-ir-return? #fn("7000r1e0|3117B02|F16;02c1|Mc242;" [valid-ir-argument?
julia_flisp.boot:								   #fn(memq) (lambda)] valid-ir-return?)
julia_flisp.boot:	  valid-ir-rvalue? #fn("7000r2e0|3117S02e1}3117I02|C16B02}F16;02c2}Mc342;" [ssavalue?
julia_flisp.boot:  valid-ir-argument? #fn(memq) (new splatnew the_exception isdefined call
julia_flisp.boot:				copyast new_opaque_closure)] valid-ir-rvalue?)
julia_flisp.boot:	  valid-modref? #fn("7000r1e0|b33216p02|Mc1<16f02e2|31F16[02e2|31Mc3<16M02e2|31\x84C16A02|\x84C17902e4|\x8441;" [length=
julia_flisp.boot:  |.| caddr quote valid-modref?] valid-modref?)
julia_flisp.boot:	  valid-name? #fn("7000r1c0|c132@;" [#fn(memq) (ccall cglobal)] valid-name?)
julia_flisp.boot:	  values #fn("8000s0|F16602|NA650|M;~|K;" [] [#648#]) var-info-for
julia_flisp.boot:	  #fn(assq) var-kind #fn(":000\x8920003000\x8a2000760^m22}6\xca0c0|e1}313216502c217\xb402c0|e3}313216502c417\x9e02c0|e5}313216h02g216W02e6e7}3131A16H02e8}31@17=02e8e8}3131@670c9540c:17U02c0|e;}313216502c<17?02e=|e8}31g243;c9;" [#fn(memq)
julia_flisp.boot:  scope:prev none global scope:sp static-parameter var-kind] var-kind)
julia_flisp.boot:	  vararg-op ... vararg-type-expr?
julia_flisp.boot:  length> curly vararg-type-expr? where] vararg-type-expr?)
julia_flisp.boot:	  #fn("7000r1|F16F02|Mc0<16<02e1e2|3141;" [:: vararg-type-expr? caddr] varargexpr?)
julia_flisp.boot:	  vars-introduced-by-patterns [pattern-set #table(macro (#fn("9000r1e0c1|c2c344;" [plambda-expansion
julia_flisp.boot:  (macro (call name . argl) body) #fn("9000r4c0c1c2L1c3g23132g3L3;" [-> #fn(nconc)
julia_flisp.boot:  tuple #fn(copy-list)]) (__ name argl body)]))  abstract (#fn("9000r1e0c1|c2c344;" [plambda-expansion
julia_flisp.boot:  (abstract spec) #fn(";000r2e0}31e1}31c2c3e4g631e4g631Ke5g73143;" [typedef-expr-name
julia_flisp.boot:								    typedef-expr-tvars
julia_flisp.boot:								    typevar-names])
julia_flisp.boot:  (__ spec)]))  = (#fn("9000r1e0c1|c2c344;" [plambda-expansion (= (call (curly
julia_flisp.boot:		   #fn("9000r1e0c1|c2c344;" [plambda-expansion (= (-$ (call
julia_flisp.boot:		   #fn("9000r1e0c1|c2c344;" [plambda-expansion (= (where
julia_flisp.boot:		   #fn("9000r1e0c1|c2c344;" [plambda-expansion (= (curly ex . vars)
julia_flisp.boot:  typevar-names]) (__ ex vars rhs)]))  function (#fn("9000r1e0c1|c2c344;" [plambda-expansion
julia_flisp.boot:					safe-llist-positional-args fix-arglist
julia_flisp.boot:					typevar-names])
julia_flisp.boot:						 #fn("9000r1e0c1|c2c344;" [plambda-expansion
julia_flisp.boot:  (function (-$ (call name . argl) (:: (call name . argl) _t)) body)
julia_flisp.boot:  #fn(":000r5c0e1e2c3e4}31g2323131K;" [varlist safe-llist-positional-args
julia_flisp.boot:				       fix-arglist #fn(append) self-argname])
julia_flisp.boot:						 #fn("9000r1e0c1|c2c344;" [plambda-expansion
julia_flisp.boot:  #fn(";000r4e0e1c2}g3L332c3c4g8F16902g8Mc3<680g8N530_e5g23132K;" [pattern-expand1
julia_flisp.boot:								   vars-introduced-by-patterns
julia_flisp.boot:								   typevar-names])
julia_flisp.boot:						 #fn("9000r1e0c1|c2c344;" [plambda-expansion
julia_flisp.boot:  (function (tuple . args) body) #fn("9000r3c0c1c2L1c3}3132g2L3;" [-> #fn(nconc)
julia_flisp.boot:								   tuple #fn(copy-list)])
julia_flisp.boot:  (__ args body)]))  try (#fn("9000r1e0c1|c2c344;" [plambda-expansion (try tryb
julia_flisp.boot:			  #fn("9000r1e0c1|c2c344;" [plambda-expansion (try tryb
julia_flisp.boot:						    (__ tryb var catchb)]))  primitive (#fn("9000r1e0c1|c2c344;" [plambda-expansion
julia_flisp.boot:  (primitive spec nb) #fn(";000r3e0}31e1}31c2c3e4g731e4g731Ke5g83143;" [typedef-expr-name
julia_flisp.boot:  typedef-expr-tvars #fn(list*) varlist unescape typevar-names])
julia_flisp.boot:  (__ spec nb)]))  -> (#fn("9000r1e0c1|c2c344;" [plambda-expansion (-> a b)
julia_flisp.boot:  varlist safe-llist-positional-args fix-arglist])
julia_flisp.boot:						 (__ a b)]))  where (#fn("9000r1e0c1|c2c344;" [plambda-expansion
julia_flisp.boot:  (where ex . vars) #fn("7000r3c0e1g231K;" [varlist typevar-names])
julia_flisp.boot:  (__ ex vars)]))  let (#fn("9000r1e0c1|c2c344;" [plambda-expansion (let binds
julia_flisp.boot:  decl? decl-var length= caar = cadar eventually-call? julia-expand0 none
julia_flisp.boot:  caadar tuple #fn(append) #fn(map) lhs-vars]) let-binds])
julia_flisp.boot:						  (__ binds ex)]))  struct (#fn("9000r1e0c1|c2c344;" [plambda-expansion
julia_flisp.boot:  (struct mut spec body) #fn("<000r4e0g231e1g231c2c3e4g831e4g831Kc5e6g93144;" [typedef-expr-name
julia_flisp.boot:  typedef-expr-tvars #fn(list*) varlist unescape (new . new) typevar-names])
julia_flisp.boot:	  vars-to-env #fn(":000r3c0c1}g2q2|e2c3|313143;" [#fn(map)
julia_flisp.boot:  #fn(memq)]) iota #fn(length)] vars-to-env)
julia_flisp.boot:	  vector->list #fn("<000r1c0|31_\x8c6ag5c1g6|g5q3u2g6M;" [#fn(length)
julia_flisp.boot:								  #fn("8000r1~\x7fi2|x[~MKO;" [])] vector->list)
julia_flisp.boot:	  vector-length #fn(length) vector-ref #.aref vector-set! #.aset! vinfo
julia_flisp.boot:	  #650# vinfo:name #.car vinfo:never-undef
julia_flisp.boot:	  #fn("8000r1`c0e1|31b432X;" [#fn(logand) caddr] vinfo:never-undef)
julia_flisp.boot:	  vinfo:not-capt #fn(":000r1|M|\x84c0e1|31c2b53132L3;" [#fn(logand)
julia_flisp.boot:								caddr #fn(lognot)] vinfo:not-capt)
julia_flisp.boot:	  vinfo:set-asgn! #fn("9000r2e0|31e1e2|31b2}33O;" [cddr set-bit caddr] vinfo:set-asgn!)
julia_flisp.boot:	  vinfo:set-called! #fn("9000r2e0|31e1e2|31bp}33O;" [cddr set-bit caddr] vinfo:set-called!)
julia_flisp.boot:	  vinfo:set-capt! #fn("9000r2e0|31e1e2|31a}33O;" [cddr set-bit caddr] vinfo:set-capt!)
julia_flisp.boot:	  vinfo:set-never-undef! #fn("9000r2e0|31e1e2|31b4}33O;" [cddr set-bit
julia_flisp.boot:								  caddr] vinfo:set-never-undef!)
julia_flisp.boot:	  vinfo:set-read! #fn("9000r2e0|31e1e2|31b8}33O;" [cddr set-bit caddr] vinfo:set-read!)
julia_flisp.boot:	  vinfo:set-sa! #fn("9000r2e0|31e1e2|31b@}33O;" [cddr set-bit caddr] vinfo:set-sa!)
julia_flisp.boot:	  vinfo:set-type! #fn("6000r2|N}O;" [] vinfo:set-type!) vinfo:sym #.car
julia_flisp.boot:	  #fn("5000r0];" [] void) warn-var?! #fn("9000r2}16]02e0}31g616:02c1g6|326<0c2g6|322];e3|e4}3142;" [scope:warn-vars
julia_flisp.boot:  #fn(has?) #fn(del!) warn-var?! scope:prev] warn-var?!)
julia_flisp.boot:	  where-enabled #t whitespace-newline #f
julia_flisp.boot:	  with-exception-catcher #fn("7000r2c0}q1c1|q1t;" [#fn("5000r0~40;" [])
julia_flisp.boot:							   #fn("6000r1~|41;" [])] with-exception-catcher)
julia_flisp.boot:	  with-wheres #fn("9000r2}F6C0c0c1L1|L1c2}3143;|;" [#fn(nconc) where #fn(copy-list)] with-wheres)
julia_flisp.boot:	  within-int128? #fn("9000r1c0|`32c1=6?0e2`e3|c43242;e2`e3|c53242;" [#fn(string.char)
julia_flisp.boot:  #\- >= compare-num-strings "-170141183460469231731687303715884105728"
julia_flisp.boot:  "170141183460469231731687303715884105727"] within-int128?)
julia_flisp.boot:	  without-generated #fn("7000r1e0c1|42;" [filter #fn("6000r1e0|3117802e1|31@;" [generated-meta?
julia_flisp.boot:  generated_only-meta?])] without-generated)
julia_flisp.boot:	  write-char #fn("8000\x8910002000\x8a1000770e0m12c1}|42;" [*output-stream*
julia_flisp.boot:								    #fn(io.putc)] write-char)
julia_flisp.boot:	  zero-width-space? #fn("7000r1e0|c142;" [memv (#\
julia_flisp.boot:							#\)] zero-width-space?)
julia_locks.h:// The JL_LOCK* and JL_UNLOCK* macros are no-op for non-threading build
julia_locks.h:    jl_thread_t owner = jl_atomic_load_relaxed(&lock->owner);
julia_locks.h:        lock->count++;
julia_locks.h:        if (owner == (jl_thread_t)0 && jl_atomic_cmpswap(&lock->owner, &owner, self)) {
julia_locks.h:            lock->count = 1;
julia_locks.h:            jl_gc_safepoint_(ct->ptls);
julia_locks.h:        owner = jl_atomic_load_relaxed(&lock->owner);
julia_locks.h:    // a non-safepoint from this function. The 0 arguments guarantees that we do
julia_locks.h:    jl_ptls_t ptls = jl_current_task->ptls;
julia_locks.h:    small_arraylist_t *locks = &ptls->locks;
julia_locks.h:    uint32_t len = locks->len;
julia_locks.h:    if (__unlikely(len >= locks->max)) {
julia_locks.h:        locks->len = len + 1;
julia_locks.h:    locks->items[len] = (void*)lock;
julia_locks.h:    jl_ptls_t ptls = jl_current_task->ptls;
julia_locks.h:    assert(ptls->locks.len > 0);
julia_locks.h:    ptls->locks.len--;
julia_locks.h:        jl_current_task->ptls->defer_signal++;  \
julia_locks.h:        if (--jl_current_task->ptls->defer_signal == 0) {       \
julia_locks.h:            jl_sigint_safepoint(jl_current_task->ptls);         \
julia_locks.h:    jl_thread_t owner = jl_atomic_load_acquire(&lock->owner);
julia_locks.h:        lock->count++;
julia_locks.h:    if (owner == (jl_thread_t)0 && jl_atomic_cmpswap(&lock->owner, &owner, self)) {
julia_locks.h:        lock->count = 1;
julia_locks.h:    assert(jl_atomic_load_relaxed(&lock->owner) == jl_thread_self() &&
julia_locks.h:    if (--lock->count == 0) {
julia_locks.h:        jl_atomic_store_release(&lock->owner, (jl_thread_t)0);
julia_locks.h:    jl_atomic_store_relaxed(&lock->owner, (jl_thread_t)0);
julia_locks.h:    lock->count = 0;
julia_internal.h:// this will smash stack-unwind too
julia_internal.h:// wipe out the call-stack unwind capability beyond this function
julia_internal.h:// per nongnu libunwind: "x86_64 ABI specifies that end of call-chain is marked with a NULL RBP or undefined return address"
julia_internal.h://--------------------------------------------------
julia_internal.h:// number of cycles since power-on
julia_internal.h:    // The frequency is fixed, typically in the range 1-50MHz.  It can be
julia_internal.h:    // This returns a time-base, which is not always precisely a cycle-count.
julia_internal.h:// Global *atomic* integers controlling *process-wide* measurement of compilation time.
julia_internal.h:            jl_atomic_store_relaxed(dstpa + n - i - 1, jl_atomic_load_relaxed(srcpa + n - i - 1));
julia_internal.h:// -- gc.c -- //
julia_internal.h:// pools are 16376 bytes large (GC_POOL_SZ - GC_PAGE_OFFSET)
julia_internal.h:    // 16 pools at 8-byte spacing
julia_internal.h:    // the 8-byte aligned pools are only used for Strings
julia_internal.h:    // 8 pools at 16-byte spacing
julia_internal.h:    // sz = (div.(pg-8, rng).16)*16; hcat(sz, (pg-8).sz, pg .- (pg-8).sz.*sz)'
julia_internal.h:    // rng = 60:-4:32 (8 pools)
julia_internal.h:    // rng = 30:-2:16 (8 pools)
julia_internal.h:    // rng = 15:-1:8 (8 pools)
julia_internal.h:// [searchsortedfirst(jl_gc_sizeclasses, i) - 1 for i = 0:16:jl_gc_sizeclasses[end]]
julia_internal.h:        return (sz + 7)/8 - 1 + N;
julia_internal.h:#define GC_MAX_SZCLASS (2032-sizeof(void*))
julia_internal.h:        jl_gc_pool_t *p = &ptls->heap.norm_pools[pool_id];
julia_internal.h:        v = jl_gc_pool_alloc(ptls, (char*)p - (char*)ptls, osize);
julia_internal.h:    o->header = tag | GC_OLD_MARKED;
julia_internal.h:    if (__unlikely(jl_astaggedvalue(bnd)->bits.gc == 3 &&
julia_internal.h:                   (jl_astaggedvalue(val)->bits.gc & 1) == 0))
julia_internal.h:    if (__unlikely(jl_astaggedvalue(parent)->bits.gc & 1)) {
julia_internal.h:        gc_setmark_buf(ct->ptls, bufptr, 3, minsz);
julia_internal.h:     if (dt->layout->first_ptr >= 0) {
julia_internal.h:        jl_value_t *nullp = ((jl_value_t**)v)[dt->layout->first_ptr];
julia_internal.h:// -- helper types -- //
julia_internal.h:// -- functions -- //
julia_internal.h:JL_DLLEXPORT jl_datatype_t *jl_wrap_Type(jl_value_t *t);  // x -> Type{x}
julia_internal.h:    jl_value_t *T = ((jl_vararg_t*)v)->T;
julia_internal.h:    return ((jl_vararg_t*)v)->N;
julia_internal.h:    if (!vm->N)
julia_internal.h:    if (jl_is_long(vm->N))
julia_internal.h:    size_t l = jl_svec_len(t->parameters);
julia_internal.h:    return (l>0 && jl_is_vararg(jl_tparam(t,l-1)));
julia_internal.h:    size_t l = jl_svec_len(t->parameters);
julia_internal.h:    return jl_vararg_kind(jl_tparam(t,l-1));
julia_internal.h:// -- init.c -- //
julia_internal.h:    int8_t state = jl_atomic_load_relaxed(&ct->ptls->gc_state);
julia_internal.h:    jl_atomic_store_release(&ct->ptls->gc_state, JL_GC_STATE_WAITING);
julia_internal.h:    jl_atomic_store_release(&ct->ptls->gc_state, state);
julia_internal.h://--------------------------------------------------
julia_internal.h:// ordered from the inner-most frame to the outermost. We store them in a
julia_internal.h://   * Signal safety: For signal-based exceptions such as StackOverflowError
julia_internal.h:// 1. A single instruction pointer to native code, not GC-managed.
julia_internal.h://   e[0]  JL_BT_NON_PTR_ENTRY  - Special marker to distinguish extended entries
julia_internal.h://   e[1]  descriptor           - A bit packed uintptr_t containing a tag and
julia_internal.h://                                the number of GC- managed and non-managed values
julia_internal.h://   e[2+j]                     - GC managed data
julia_internal.h://   e[2+ngc+i]                 - Non-GC-managed data
julia_internal.h://   0:2     ngc     Number of GC-managed pointers for this frame entry
julia_internal.h://   3:5     nptr    Number of non-GC-managed buffer elements
julia_internal.h://   10:...  header  Entry-specific header data
julia_internal.h:        jl_value_t* jlvalue; // Pointer to GC-managed value
julia_internal.h:#define JL_BT_NON_PTR_ENTRY (((uintptr_t)0)-1)
julia_internal.h:// than the actual size of 3-4 for an interpreter frame)
julia_internal.h:// Return `i`th GC-managed pointer for extended backtrace entry
julia_internal.h://------------------------------
julia_internal.h://--------------------------------------------------
julia_internal.h:    return jl_excstack_raw(stack)[itr-1].jlvalue;
julia_internal.h:    return jl_excstack_raw(stack)[itr-2].uintptr;
julia_internal.h:    return jl_excstack_raw(stack) + itr-2 - jl_excstack_bt_size(stack, itr);
julia_internal.h:// Exception stack iteration (start at itr=stack->top, stop at itr=0)
julia_internal.h:    return itr-2 - jl_excstack_bt_size(stack, itr);
julia_internal.h://--------------------------------------------------
julia_internal.h:// for a small amount of thread-local randomness
julia_internal.h:    *unbias = UINT64_MAX - ((UINT64_MAX % max) + 1);
julia_internal.h:// -- Runtime intrinsics -- //
julia_internal.h:    return ety == (jl_value_t*)jl_any_type || (jl_is_concrete_type(ety) && !jl_is_layout_opaque(((jl_datatype_t*)ety)->layout));
julia_internal.h:// -- synchronization utilities -- //
julia_internal.h:// -- smallintset.c -- //
julia_internal.h:// -- typemap.c -- //
julia_internal.h:// -- simplevector.c -- //
julia_internal.h:// * JL_GCC_IGNORE_START(-Wclobbered) - gcc misidentifies some variables which
julia_internal.h:// uprobes.h.gen on systems with DTrace, is auto-generated to include
llvm-late-gc-lowering.cpp:#include "llvm-version.h"
llvm-late-gc-lowering.cpp:#include <llvm-c/Core.h>
llvm-late-gc-lowering.cpp:#include <llvm-c/Types.h>
llvm-late-gc-lowering.cpp:#include "llvm-pass-helpers.h"
llvm-late-gc-lowering.cpp:   that at every safepoint, any live gc-tracked pointer (i.e. for which there is
llvm-late-gc-lowering.cpp:        - Any Def of a gc-tracked pointer. In general Defs are the results of
llvm-late-gc-lowering.cpp:        - Any use of a gc-tracked or derived pointer. As described in the
llvm-late-gc-lowering.cpp:        - Any safepoint
llvm-late-gc-lowering.cpp:         iii. Values that are now live-out from the basic block (i.e. they are
llvm-late-gc-lowering.cpp:              actually live-out and make the appropriate additions to the live
llvm-late-gc-lowering.cpp:      equivalent to doing graph coloring on the interference graph - the graph
llvm-late-gc-lowering.cpp:      simultaneously live at a safepoint - which we computed in the previous
llvm-late-gc-lowering.cpp:      entirely chordal due to some non-SSA corner cases. However, using the same
llvm-late-gc-lowering.cpp:      the gc-frame, or re-use slots not assigned at that particular location
llvm-late-gc-lowering.cpp:      safepoints, but some other path - e.g. the error path does). However,
llvm-late-gc-lowering.cpp:      happen due to the non-ssa corner cases), the store is inserted right after
llvm-late-gc-lowering.cpp:      do not dominate the block (so can't really consider them live-in), nor
llvm-late-gc-lowering.cpp:      with vectors of gc-tracked pointers. For the purposes of most of the
llvm-late-gc-lowering.cpp:      a gc-tracked value and an argument selector. We simply assign a single
llvm-late-gc-lowering.cpp:    int TopmostSafepoint = -1;
llvm-late-gc-lowering.cpp:    // (-1 means an externally rooted value and -2 means a globally/permanently rooted value),
llvm-late-gc-lowering.cpp:    // A value that can be refined to -2 never need any rooting or write barrier.
llvm-late-gc-lowering.cpp:    // A value that can be refined to -1 don't need local root but still need write barrier.
llvm-late-gc-lowering.cpp:    // Reverse mapping index -> safepoint
llvm-late-gc-lowering.cpp:    // Those values that - if live out from our parent basic block - are live
llvm-late-gc-lowering.cpp:    State(Function &F) : F(&F), DT(nullptr), MaxPtrNumber(-1), MaxSafepointNumber(-1) {}
llvm-late-gc-lowering.cpp:    return V->getType()->getPointerAddressSpace();
llvm-late-gc-lowering.cpp:    PointerType *PT = dyn_cast<PointerType>(V->getType()->getScalarType());
llvm-late-gc-lowering.cpp:    return PT && PT->getAddressSpace() == AddressSpace::Tracked;
llvm-late-gc-lowering.cpp:    unsigned AS = PTy->getAddressSpace();
llvm-late-gc-lowering.cpp:            if (T->getPointerAddressSpace() != AddressSpace::Tracked)
llvm-late-gc-lowering.cpp:        for (Type *ElT : T->subtypes()) {
llvm-late-gc-lowering.cpp:            count *= cast<ArrayType>(T)->getNumElements();
llvm-late-gc-lowering.cpp:            ElementCount EC = cast<VectorType>(T)->getElementCount();
llvm-late-gc-lowering.cpp:            count *= cast<VectorType>(T)->getNumElements();
llvm-late-gc-lowering.cpp:        return ST->getNumElements();
llvm-late-gc-lowering.cpp:        return AT->getNumElements();
llvm-late-gc-lowering.cpp:        ElementCount EC = cast<VectorType>(T)->getElementCount();
llvm-late-gc-lowering.cpp:        return cast<VectorType>(T)->getNumElements();
llvm-late-gc-lowering.cpp:        if (T->getPointerAddressSpace() == AddressSpace::Tracked)
llvm-late-gc-lowering.cpp:    int fld_idx = -1;
llvm-late-gc-lowering.cpp:            if (CurrentV->getType()->isPointerTy()) {
llvm-late-gc-lowering.cpp:        //   assert(fld_idx == -1 ? CurrentV->getType()->isPointerTy() : CurrentV->getType()->isVectorPointerTy());
llvm-late-gc-lowering.cpp:            CurrentV = cast<BitCastInst>(CurrentV)->getOperand(0);
llvm-late-gc-lowering.cpp:            Value *NewV = cast<AddrSpaceCastInst>(CurrentV)->getOperand(0);
llvm-late-gc-lowering.cpp:            CurrentV = GEP->getOperand(0);
llvm-late-gc-lowering.cpp:            if (fld_idx != -1 && !isa<VectorType>(CurrentV->getType())) {
llvm-late-gc-lowering.cpp:                fld_idx = -1;
llvm-late-gc-lowering.cpp:            assert(CurrentV->getType()->isPointerTy() && fld_idx == -1);
llvm-late-gc-lowering.cpp:            auto IdxOp = cast<ConstantInt>(EEI->getIndexOperand());
llvm-late-gc-lowering.cpp:            fld_idx = IdxOp->getLimitedValue(INT_MAX);
llvm-late-gc-lowering.cpp:            CurrentV = EEI->getVectorOperand();
llvm-late-gc-lowering.cpp:            if (auto PtrT = dyn_cast<PointerType>(LI->getType()->getScalarType())) {
llvm-late-gc-lowering.cpp:                if (PtrT->getAddressSpace() == AddressSpace::Loaded) {
llvm-late-gc-lowering.cpp:                    CurrentV = LI->getPointerOperand();
llvm-late-gc-lowering.cpp:                    fld_idx = -1;
llvm-late-gc-lowering.cpp:                    if (!isSpecialPtr(CurrentV->getType())) {
llvm-late-gc-lowering.cpp:                        // it is--just pick something simple.
llvm-late-gc-lowering.cpp:                        CurrentV = ConstantPointerNull::get(Type::getInt8PtrTy(V->getContext()));
llvm-late-gc-lowering.cpp:            if (II->getIntrinsicID() == Intrinsic::masked_load ||
llvm-late-gc-lowering.cpp:                II->getIntrinsicID() == Intrinsic::masked_gather) {
llvm-late-gc-lowering.cpp:                if (auto VTy = dyn_cast<VectorType>(II->getType())) {
llvm-late-gc-lowering.cpp:                    if (auto PtrT = dyn_cast<PointerType>(VTy->getElementType())) {
llvm-late-gc-lowering.cpp:                        if (PtrT->getAddressSpace() == AddressSpace::Loaded) {
llvm-late-gc-lowering.cpp:                            Value *Mask = II->getOperand(2);
llvm-late-gc-lowering.cpp:                            Value *Passthrough = II->getOperand(3);
llvm-late-gc-lowering.cpp:                            if (!isa<Constant>(Mask) || !cast<Constant>(Mask)->isAllOnesValue()) {
llvm-late-gc-lowering.cpp:                            CurrentV = II->getOperand(0);
llvm-late-gc-lowering.cpp:                            if (II->getIntrinsicID() == Intrinsic::masked_load) {
llvm-late-gc-lowering.cpp:                                fld_idx = -1;
llvm-late-gc-lowering.cpp:                                if (!isSpecialPtr(CurrentV->getType())) {
llvm-late-gc-lowering.cpp:                                    CurrentV = ConstantPointerNull::get(Type::getInt8PtrTy(V->getContext()));
llvm-late-gc-lowering.cpp:                                if (auto VTy2 = dyn_cast<VectorType>(CurrentV->getType())) {
llvm-late-gc-lowering.cpp:                                    if (!isSpecialPtr(VTy2->getElementType())) {
llvm-late-gc-lowering.cpp:                                        CurrentV = ConstantPointerNull::get(Type::getInt8PtrTy(V->getContext()));
llvm-late-gc-lowering.cpp:                                        fld_idx = -1;
llvm-late-gc-lowering.cpp:    if (isa<PointerType>(V->getType())) {
llvm-late-gc-lowering.cpp:        assert(ValExpr.second == -1);
llvm-late-gc-lowering.cpp:    else if (ValExpr.second != -1) {
llvm-late-gc-lowering.cpp:        auto Tracked = TrackCompositeType(V->getType());
llvm-late-gc-lowering.cpp:        auto IdxsNotVec = Idxs.slice(0, Idxs.size() - 1);
llvm-late-gc-lowering.cpp:        Type *FinalT = ExtractValueInst::getIndexedType(V->getType(), IdxsNotVec);
llvm-late-gc-lowering.cpp:        if (T->getAddressSpace() != AddressSpace::Tracked) {
llvm-late-gc-lowering.cpp:                    ConstantInt::get(Type::getInt32Ty(V->getContext()), Idxs.back()),
llvm-late-gc-lowering.cpp:    unsigned Idx = -1;
llvm-late-gc-lowering.cpp:    if (!isa<PointerType>(Val->getType())) {
llvm-late-gc-lowering.cpp:    if (isa<PointerType>(SI->getType()) ?
llvm-late-gc-lowering.cpp:        // already visited here--nothing to do
llvm-late-gc-lowering.cpp:    if (auto VTy = dyn_cast<VectorType>(SI->getType())) {
llvm-late-gc-lowering.cpp:        ElementCount EC = VTy->getElementCount();
llvm-late-gc-lowering.cpp:        Numbers.resize(EC.getKnownMinValue(), -1);
llvm-late-gc-lowering.cpp:        Numbers.resize(VTy->getNumElements(), -1);
llvm-late-gc-lowering.cpp:        assert(isa<PointerType>(SI->getType()) && "unimplemented");
llvm-late-gc-lowering.cpp:    Value *TrueBase = MaybeExtractScalar(S, FindBaseValue(S, SI->getTrueValue(), false), SI);
llvm-late-gc-lowering.cpp:    Value *FalseBase = MaybeExtractScalar(S, FindBaseValue(S, SI->getFalseValue(), false), SI);
llvm-late-gc-lowering.cpp:    if (!isa<PointerType>(TrueBase->getType())) {
llvm-late-gc-lowering.cpp:    if (!isa<PointerType>(FalseBase->getType())) {
llvm-late-gc-lowering.cpp:    if (isa<PointerType>(SI->getType()) ?
llvm-late-gc-lowering.cpp:        if (isa<PointerType>(TrueBase->getType()))
llvm-late-gc-lowering.cpp:        if (isa<PointerType>(FalseBase->getType()))
llvm-late-gc-lowering.cpp:        Value *Cond = SI->getCondition();
llvm-late-gc-lowering.cpp:        if (isa<VectorType>(Cond->getType())) {
llvm-late-gc-lowering.cpp:                    ConstantInt::get(Type::getInt32Ty(Cond->getContext()), i),
llvm-late-gc-lowering.cpp:        if (FalseElem->getType() != TrueElem->getType())
llvm-late-gc-lowering.cpp:            FalseElem = new BitCastInst(FalseElem, TrueElem->getType(), "", SI);
llvm-late-gc-lowering.cpp:        if (isa<PointerType>(SI->getType()))
llvm-late-gc-lowering.cpp:    if (auto VTy = dyn_cast<FixedVectorType>(SI->getType())) {
llvm-late-gc-lowering.cpp:            ElementCount EC = VTy->getElementCount();
llvm-late-gc-lowering.cpp:            Numbers.resize(VTy->getNumElements(), Number);
llvm-late-gc-lowering.cpp:    if (!isa<PointerType>(SI->getType()))
llvm-late-gc-lowering.cpp:    if (isa<PointerType>(Phi->getType()) ?
llvm-late-gc-lowering.cpp:    if (auto VTy = dyn_cast<FixedVectorType>(Phi->getType())) {
llvm-late-gc-lowering.cpp:        NumRoots = VTy->getNumElements();
llvm-late-gc-lowering.cpp:        assert(isa<PointerType>(Phi->getType()) && "unimplemented");
llvm-late-gc-lowering.cpp:        PHINode *lift = PHINode::Create(T_prjlvalue, Phi->getNumIncomingValues(), "gclift", Phi);
llvm-late-gc-lowering.cpp:        if (!isa<VectorType>(Phi->getType()))
llvm-late-gc-lowering.cpp:    if (!isa<PointerType>(Phi->getType()))
llvm-late-gc-lowering.cpp:    for (unsigned i = 0; i < Phi->getNumIncomingValues(); ++i) {
llvm-late-gc-lowering.cpp:        Value *Incoming = Phi->getIncomingValue(i);
llvm-late-gc-lowering.cpp:        BasicBlock *IncomingBB = Phi->getIncomingBlock(i);
llvm-late-gc-lowering.cpp:        Instruction *Terminator = IncomingBB->getTerminator();
llvm-late-gc-lowering.cpp:        if (!isa<PointerType>(Base->getType())) {
llvm-late-gc-lowering.cpp:            if (isa<PointerType>(Base->getType()))
llvm-late-gc-lowering.cpp:            if (BaseElem->getType() != T_prjlvalue)
llvm-late-gc-lowering.cpp:            lift->addIncoming(BaseElem, IncomingBB);
llvm-late-gc-lowering.cpp:        return it->second;
llvm-late-gc-lowering.cpp:        Number = -2;
llvm-late-gc-lowering.cpp:        Number = -1;
llvm-late-gc-lowering.cpp:    } else if (!isSpecialPtr(CurrentV->getType())) {
llvm-late-gc-lowering.cpp:        Number = -1;
llvm-late-gc-lowering.cpp:        assert((CurrentV->getType()->isPointerTy() && isTrackedValue(CurrentV)));
llvm-late-gc-lowering.cpp:    assert(isSpecialPtr(V->getType()));
llvm-late-gc-lowering.cpp:    if (CurrentV.second == -1) {
llvm-late-gc-lowering.cpp:    if (isa<PointerType>(CurrentV->getType())) {
llvm-late-gc-lowering.cpp:            return std::vector<int>({it->second});
llvm-late-gc-lowering.cpp:            return it->second;
llvm-late-gc-lowering.cpp:    auto tracked = CountTrackedPointers(CurrentV->getType());
llvm-late-gc-lowering.cpp:        Numbers.resize(tracked.count, -1);
llvm-late-gc-lowering.cpp:        std::vector<int> Numbers1 = NumberAll(S, SVI->getOperand(0));
llvm-late-gc-lowering.cpp:        std::vector<int> Numbers2 = NumberAll(S, SVI->getOperand(1));
llvm-late-gc-lowering.cpp:        auto Mask = SVI->getShuffleMask();
llvm-late-gc-lowering.cpp:            assert(idx != -1 && "Undef tracked value is invalid");
llvm-late-gc-lowering.cpp:                Numbers.push_back(Numbers2.at(idx - Numbers1.size()));
llvm-late-gc-lowering.cpp:        // TODO: handle non-constant: LiftInsertElement(S, IEI)
llvm-late-gc-lowering.cpp:        unsigned idx = cast<ConstantInt>(IEI->getOperand(2))->getZExtValue();
llvm-late-gc-lowering.cpp:        Numbers = NumberAll(S, IEI->getOperand(0));
llvm-late-gc-lowering.cpp:        int ElNumber = Number(S, IEI->getOperand(1));
llvm-late-gc-lowering.cpp:        Numbers = NumberAll(S, IVI->getAggregateOperand());
llvm-late-gc-lowering.cpp:        auto Tracked = TrackCompositeType(IVI->getType());
llvm-late-gc-lowering.cpp:        std::vector<int> InsertNumbers = NumberAll(S, IVI->getInsertedValueOperand());
llvm-late-gc-lowering.cpp:        auto Idxs = IVI->getIndices();
llvm-late-gc-lowering.cpp:        auto BaseNumbers = NumberAll(S, EVI->getAggregateOperand());
llvm-late-gc-lowering.cpp:        auto Tracked = TrackCompositeType(EVI->getAggregateOperand()->getType());
llvm-late-gc-lowering.cpp:        auto Idxs = EVI->getIndices();
llvm-late-gc-lowering.cpp:        assert(CountTrackedPointers(EVI->getType()).count == Numbers.size());
llvm-late-gc-lowering.cpp:            CurrentV->print(errs());
llvm-late-gc-lowering.cpp:        if (isa<PointerType>(CurrentV->getType())) {
llvm-late-gc-lowering.cpp:    if (isa<PointerType>(CurrentV->getType())) {
llvm-late-gc-lowering.cpp:    if (isa<PointerType>(V->getType())) {
llvm-late-gc-lowering.cpp:            return std::vector<int>({it->second});
llvm-late-gc-lowering.cpp:            return it->second;
llvm-late-gc-lowering.cpp:    auto tracked = CountTrackedPointers(V->getType());
llvm-late-gc-lowering.cpp:    int Number = -1;
llvm-late-gc-lowering.cpp:    if (isa<PointerType>(CurrentV.first->getType())) {
llvm-late-gc-lowering.cpp:        // Base turned out to be a single pointer--number it
llvm-late-gc-lowering.cpp:        assert(CurrentV.second == -1);
llvm-late-gc-lowering.cpp:        // Base turned out to be an aggregate--get all numbers for it, then sub-select
llvm-late-gc-lowering.cpp:        if (CurrentV.second != -1) {
llvm-late-gc-lowering.cpp:            assert(!isa<PointerType>(V->getType()));
llvm-late-gc-lowering.cpp:        if (isa<PointerType>(V->getType())) {
llvm-late-gc-lowering.cpp:    Type *RT = Def->getType();
llvm-late-gc-lowering.cpp:    if (isa<PointerType>(V->getType())) {
llvm-late-gc-lowering.cpp:        if (isSpecialPtr(V->getType())) {
llvm-late-gc-lowering.cpp:    for (Use &VU : V->uses()) {
llvm-late-gc-lowering.cpp:        S.ReversePtrNumbering[Idx]->printAsOperand(dbgs());
llvm-late-gc-lowering.cpp:    while (TBAA->getNumOperands() > 1) {
llvm-late-gc-lowering.cpp:        TBAA = cast<MDNode>(TBAA->getOperand(1).get());
llvm-late-gc-lowering.cpp:        auto str = cast<MDString>(TBAA->getOperand(0))->getString();
llvm-late-gc-lowering.cpp:    if (LI->getMetadata(LLVMContext::MD_invariant_load))
llvm-late-gc-lowering.cpp:    MDNode *TBAA = LI->getMetadata(LLVMContext::MD_tbaa);
llvm-late-gc-lowering.cpp:    return gv->isConstant() || gv->getMetadata("julia.constgv");
llvm-late-gc-lowering.cpp:    v = v->stripInBoundsOffsets();
llvm-late-gc-lowering.cpp:        return (CE->getOpcode() == Instruction::IntToPtr &&
llvm-late-gc-lowering.cpp:                isa<ConstantData>(CE->getOperand(0)));
llvm-late-gc-lowering.cpp:        return (isLoadFromConstGV(SL->getTrueValue(), task_local, seen) &&
llvm-late-gc-lowering.cpp:                isLoadFromConstGV(SL->getFalseValue(), task_local, seen));
llvm-late-gc-lowering.cpp:        else if (seen->count(Phi))
llvm-late-gc-lowering.cpp:            seen->insert(Phi);
llvm-late-gc-lowering.cpp:        auto n = Phi->getNumIncomingValues();
llvm-late-gc-lowering.cpp:            if (!isLoadFromConstGV(Phi->getIncomingValue(i), task_local, seen)) {
llvm-late-gc-lowering.cpp:        auto callee = call->getCalledFunction();
llvm-late-gc-lowering.cpp:        if (callee && callee->getName() == "julia.typeof") {
llvm-late-gc-lowering.cpp:        if (callee && callee->getName() == "julia.get_pgcstack") {
llvm-late-gc-lowering.cpp:    auto load_base = LI->getPointerOperand()->stripInBoundsOffsets();
llvm-late-gc-lowering.cpp:    if (isTBAA(LI->getMetadata(LLVMContext::MD_tbaa),
llvm-late-gc-lowering.cpp:    MDNode *md = LI->getMetadata(LLVMContext::MD_align);
llvm-late-gc-lowering.cpp:    return mdconst::extract<ConstantInt>(md->getOperand(0))->getLimitedValue();
llvm-late-gc-lowering.cpp:    if (isSpecialPtr(V->getType()))
llvm-late-gc-lowering.cpp:        return LooksLikeFrameRef(cast<GetElementPtrInst>(V)->getOperand(0));
llvm-late-gc-lowering.cpp:    // that does not dominate the PHI node may be externally rooted (i.e. can be refined to -1)
llvm-late-gc-lowering.cpp:    auto nIncoming = Phi->getNumIncomingValues();
llvm-late-gc-lowering.cpp:        RefinedPtr[i] = Number(S, Phi->getIncomingValue(i));
llvm-late-gc-lowering.cpp:    for (auto &kv: S->Refinements) {
llvm-late-gc-lowering.cpp:        dbgs() << "Refinements for " << Num << "  --  ";
llvm-late-gc-lowering.cpp:        auto V = S->ReversePtrNumbering[Num];
llvm-late-gc-lowering.cpp:            auto R = S->ReversePtrNumbering[refine];
llvm-late-gc-lowering.cpp:    //   Values may either be obviously externally rooted (e.g. arguments) - (this is indicated by a
llvm-late-gc-lowering.cpp:    //   value of -1 or -2 in the refinement map), or may be externally rooted by refinement to other
llvm-late-gc-lowering.cpp:    //     - Has no refinements (all obiviously externally rooted values are annotated by -1/-2 in the
llvm-late-gc-lowering.cpp:    //     - Recursively reaches a not-externally rooted value through its refinements
llvm-late-gc-lowering.cpp:        if (it == S.Refinements.end() || it->second.empty()) {
llvm-late-gc-lowering.cpp:                if (refine == -2) {
llvm-late-gc-lowering.cpp:                else if (refine == -1) {
llvm-late-gc-lowering.cpp:            // For permanently rooted values, set their refinements simply to `{-2}`
llvm-late-gc-lowering.cpp:            kv.second[0] = -2;
llvm-late-gc-lowering.cpp:            // For externally rooted values, set their refinements simply to `{-1}`
llvm-late-gc-lowering.cpp:            kv.second[0] = -1;
llvm-late-gc-lowering.cpp:            // remove all externally rooted values from their refinements (replace with -1)
llvm-late-gc-lowering.cpp:            // No need to handle -2 specially since it won't make a difference.
llvm-late-gc-lowering.cpp:                refine = -1;
llvm-late-gc-lowering.cpp:    // we can also relax non-dominating (invalid) refinements to the refinements of those values
llvm-late-gc-lowering.cpp:        // Not sure if `Num` can be `-1`
llvm-late-gc-lowering.cpp:                if (S.DT->dominates(inst, Phi))
llvm-late-gc-lowering.cpp:                j--;
llvm-late-gc-lowering.cpp:                // Non-dominating refinement
llvm-late-gc-lowering.cpp:                if (it != S.Refinements.end() && !it->second.empty()) {
llvm-late-gc-lowering.cpp:                    auto &NewRefinedPtr = it->second;
llvm-late-gc-lowering.cpp:                        RefinedPtr[i - k] = NewRefinedPtr[k];
llvm-late-gc-lowering.cpp:                    i = i - k;
llvm-late-gc-lowering.cpp:                        RefinedPtr.append(it->second.begin() + k, it->second.end());
llvm-late-gc-lowering.cpp:                // Invalid - Remove All refinements
llvm-late-gc-lowering.cpp:                        II->getIntrinsicID() == Intrinsic::lifetime_start ||
llvm-late-gc-lowering.cpp:                        II->getIntrinsicID() == Intrinsic::lifetime_end) {
llvm-late-gc-lowering.cpp:                    if (II->getIntrinsicID() == Intrinsic::masked_load ||
llvm-late-gc-lowering.cpp:                        II->getIntrinsicID() == Intrinsic::masked_gather) {
llvm-late-gc-lowering.cpp:                        if (auto VTy = dyn_cast<VectorType>(II->getType())) {
llvm-late-gc-lowering.cpp:                            if (auto PtrT = dyn_cast<PointerType>(VTy->getElementType())) {
llvm-late-gc-lowering.cpp:                                    // LLVM sometimes tries to materialize these operations with undefined pointers in our non-integral address space.
llvm-late-gc-lowering.cpp:                                    Value *passthru = II->getArgOperand(3);
llvm-late-gc-lowering.cpp:                                        II->setArgOperand(3, Constant::getNullValue(passthru->getType()));
llvm-late-gc-lowering.cpp:                                    if (PtrT->getAddressSpace() == AddressSpace::Loaded) {
llvm-late-gc-lowering.cpp:                auto callee = CI->getCalledFunction();
llvm-late-gc-lowering.cpp:                    MaybeNoteDef(S, BBS, CI, BBS.Safepoints, SmallVector<int, 1>{-2});
llvm-late-gc-lowering.cpp:                if (CI->hasStructRetAttr()) {
llvm-late-gc-lowering.cpp:                    Type *ElT = (CI->arg_begin()[0])->getType()->getPointerElementType();
llvm-late-gc-lowering.cpp:                        AllocaInst *SRet = dyn_cast<AllocaInst>((CI->arg_begin()[0])->stripInBoundsOffsets());
llvm-late-gc-lowering.cpp:                            if (!(SRet->isStaticAlloca() && isa<PointerType>(ElT) && ElT->getPointerAddressSpace() == AddressSpace::Tracked)) {
llvm-late-gc-lowering.cpp:                                    S.ArrayAllocas[SRet] = tracked.count * cast<ConstantInt>(SRet->getArraySize())->getZExtValue();
llvm-late-gc-lowering.cpp:                                    Value *arg1 = (CI->arg_begin()[1])->stripInBoundsOffsets();
llvm-late-gc-lowering.cpp:                                        for (Value *V : Phi->incoming_values()) {
llvm-late-gc-lowering.cpp:                                            if (AllocaInst *Alloca = dyn_cast<AllocaInst>(V->stripInBoundsOffsets())) {
llvm-late-gc-lowering.cpp:                                                llvm_dump(V->stripInBoundsOffsets());
llvm-late-gc-lowering.cpp:                                    Type *ElT = SRet_gc->getAllocatedType();
llvm-late-gc-lowering.cpp:                                    if (!(SRet_gc->isStaticAlloca() && isa<PointerType>(ElT) && ElT->getPointerAddressSpace() == AddressSpace::Tracked)) {
llvm-late-gc-lowering.cpp:                                        S.ArrayAllocas[SRet_gc] = tracked.count * cast<ConstantInt>(SRet_gc->getArraySize())->getZExtValue();
llvm-late-gc-lowering.cpp:                if (CI->canReturnTwice()) {
llvm-late-gc-lowering.cpp:                        for (Use &U : CI->arg_operands()) {
llvm-late-gc-lowering.cpp:                            if (isa<PointerType>(V->getType())) {
llvm-late-gc-lowering.cpp:                                if (isSpecialPtr(V->getType())) {
llvm-late-gc-lowering.cpp:                        callee == pgcstack_getter || callee->getName() == XSTR(jl_egal__unboxed) ||
llvm-late-gc-lowering.cpp:                        callee->getName() == XSTR(jl_lock_value) || callee->getName() == XSTR(jl_unlock_value) ||
llvm-late-gc-lowering.cpp:                        callee == write_barrier_func || callee->getName() == "memcmp") {
llvm-late-gc-lowering.cpp:                    if (callee->hasFnAttribute(Attribute::ReadNone) ||
llvm-late-gc-lowering.cpp:                        callee->hasFnAttribute(Attribute::ReadOnly) ||
llvm-late-gc-lowering.cpp:                        callee->hasFnAttribute(Attribute::ArgMemOnly)) {
llvm-late-gc-lowering.cpp:                if (isa<IntrinsicInst>(CI) || CI->hasFnAttr(Attribute::ArgMemOnly) ||
llvm-late-gc-lowering.cpp:                    CI->hasFnAttr(Attribute::ReadNone) || CI->hasFnAttr(Attribute::ReadOnly)) {
llvm-late-gc-lowering.cpp:                for (Use &U : CI->arg_operands()) {
llvm-late-gc-lowering.cpp:                    if (isa<Constant>(V) || !isa<PointerType>(V->getType()) ||
llvm-late-gc-lowering.cpp:                    V = V->stripPointerCasts();
llvm-late-gc-lowering.cpp:                Type *Ty = LI->getType()->getScalarType();
llvm-late-gc-lowering.cpp:                if (isLoadFromImmut(LI) && isSpecialPtr(LI->getPointerOperand()->getType())) {
llvm-late-gc-lowering.cpp:                    RefinedPtr.push_back(Number(S, LI->getPointerOperand()));
llvm-late-gc-lowering.cpp:                } else if (LI->getType()->isPointerTy() &&
llvm-late-gc-lowering.cpp:                        LooksLikeFrameRef(LI->getPointerOperand())) {
llvm-late-gc-lowering.cpp:                    RefinedPtr.push_back(-1);
llvm-late-gc-lowering.cpp:                    RefinedPtr.push_back(task_local ? -1 : -2);
llvm-late-gc-lowering.cpp:                if (!Ty->isPointerTy() || Ty->getPointerAddressSpace() != AddressSpace::Loaded) {
llvm-late-gc-lowering.cpp:                Type *Ty = LI->getNewValOperand()->getType()->getScalarType();
llvm-late-gc-lowering.cpp:                if (!Ty->isPointerTy() || Ty->getPointerAddressSpace() != AddressSpace::Loaded) {
llvm-late-gc-lowering.cpp:                Type *Ty = LI->getType()->getScalarType();
llvm-late-gc-lowering.cpp:                if (!Ty->isPointerTy() || Ty->getPointerAddressSpace() != AddressSpace::Loaded) {
llvm-late-gc-lowering.cpp:                auto tracked = CountTrackedPointers(SI->getType());
llvm-late-gc-lowering.cpp:                    if (isa<PointerType>(SI->getType())) {
llvm-late-gc-lowering.cpp:                            Number(S, SI->getTrueValue()),
llvm-late-gc-lowering.cpp:                            Number(S, SI->getFalseValue())
llvm-late-gc-lowering.cpp:                auto tracked = CountTrackedPointers(Phi->getType());
llvm-late-gc-lowering.cpp:                    if (isa<PointerType>(Phi->getType()))
llvm-late-gc-lowering.cpp:                    if (isa<PointerType>(Phi->getType())) {
llvm-late-gc-lowering.cpp:                    unsigned nIncoming = Phi->getNumIncomingValues();
llvm-late-gc-lowering.cpp:                        BBState &IncomingBBS = S.BBStates[Phi->getIncomingBlock(i)];
llvm-late-gc-lowering.cpp:                        NoteUse(S, IncomingBBS, Phi->getIncomingValue(i), IncomingBBS.PhiOuts);
llvm-late-gc-lowering.cpp:                    auto origin = ASCI->getPointerOperand()->stripPointerCasts();
llvm-late-gc-lowering.cpp:                            RefinedPtr.push_back(task_local ? -1 : -2);
llvm-late-gc-lowering.cpp:                Type *ElT = AI->getAllocatedType();
llvm-late-gc-lowering.cpp:                if (AI->isStaticAlloca() && isa<PointerType>(ElT) && ElT->getPointerAddressSpace() == AddressSpace::Tracked) {
llvm-late-gc-lowering.cpp:        // Pre-seed the dataflow variables;
llvm-late-gc-lowering.cpp:    Type *T_int32 = Type::getInt32Ty(V->getContext());
llvm-late-gc-lowering.cpp:        assert(T->isPointerTy());
llvm-late-gc-lowering.cpp:        // since we're doing stack operations, it should be safe do this non-atomically
llvm-late-gc-lowering.cpp:        cast<LoadInst>(V)->setOrdering(AtomicOrdering::NotAtomic);
llvm-late-gc-lowering.cpp:    else if (isa<PointerType>(V->getType())) {
llvm-late-gc-lowering.cpp:        auto IdxsNotVec = Idxs.slice(0, Idxs.size() - 1);
llvm-late-gc-lowering.cpp:        Type *FinalT = ExtractValueInst::getIndexedType(V->getType(), IdxsNotVec);
llvm-late-gc-lowering.cpp:                    ConstantInt::get(Type::getInt32Ty(V->getContext()), Idxs.back())));
llvm-late-gc-lowering.cpp:    Type *T_int32 = Type::getInt32Ty(STy->getContext());
llvm-late-gc-lowering.cpp:        auto offset = getFieldOffset(irbuilder.GetInsertBlock()->getModule()->getDataLayout(),
llvm-late-gc-lowering.cpp:        Type *ET = Dst->getType()->getPointerElementType(); // Dst has type `[n x {}*]*`
llvm-late-gc-lowering.cpp:        shadowStore->setOrdering(AtomicOrdering::NotAtomic);
llvm-late-gc-lowering.cpp:        // TODO: shadowStore->setMetadata(LLVMContext::MD_tbaa, tbaa_gcframe);
llvm-late-gc-lowering.cpp:    //Value *Dst = MI->getRawDest()->stripInBoundsOffsets();
llvm-late-gc-lowering.cpp:    //    Type *STy = AI->getAllocatedType();
llvm-late-gc-lowering.cpp:    //    if (!AI->isStaticAlloca() || (isa<PointerType>(STy) && STy->getPointerAddressSpace() == AddressSpace::Tracked) || S.ArrayAllocas.count(AI))
llvm-late-gc-lowering.cpp:    //    unsigned nroots = tracked.count * cast<ConstantInt>(AI->getArraySize())->getZExtValue();
llvm-late-gc-lowering.cpp:    //            //assert(MI->getLength() == DL.getTypeAllocSize(AI->getAllocatedType()) && !AI->isArrayAllocation()); // XXX: handle partial copy
llvm-late-gc-lowering.cpp:    //            Value *Src = MI->getSource();
llvm-late-gc-lowering.cpp:    //            Src = new BitCastInst(Src, STy->getPointerTo(MI->getSourceAddressSpace()), "", MI);
llvm-late-gc-lowering.cpp:    Value *PtrBase = I->getPointerOperand()->stripInBoundsOffsets();
llvm-late-gc-lowering.cpp:    auto tracked = CountTrackedPointers(I->getValueOperand()->getType());
llvm-late-gc-lowering.cpp:        Type *STy = AI->getAllocatedType();
llvm-late-gc-lowering.cpp:        if (!AI->isStaticAlloca() || (isa<PointerType>(STy) && STy->getPointerAddressSpace() == AddressSpace::Tracked) || S.ArrayAllocas.count(AI))
llvm-late-gc-lowering.cpp:                S.ArrayAllocas[AI] = tracked.count * cast<ConstantInt>(AI->getArraySize())->getZExtValue();
llvm-late-gc-lowering.cpp:        return; // assume it is rooted--TODO: should we be more conservative?
llvm-late-gc-lowering.cpp:    //Value *Src = I->getValueOperand();
llvm-late-gc-lowering.cpp:    //unsigned count = TrackWithShadow(Src, Src->getType(), false, AI, MI, TODO which slots are we actually clobbering?);
llvm-late-gc-lowering.cpp: * LiveIn[BB] = UpExposedUses[BB]  (LiveOut[BB] - Defs[BB])
llvm-late-gc-lowering.cpp:            // changed - Let's get it working first though.
llvm-late-gc-lowering.cpp:                MaybeResize(BBS, BBS.LiveOut.size() - 1);
llvm-late-gc-lowering.cpp:        if (it.first->getParent()->getName() == BBName) {
llvm-late-gc-lowering.cpp:                S.ReversePtrNumbering[Idx]->printAsOperand(dbgs());
llvm-late-gc-lowering.cpp:        BasicBlock *BB = Safepoint->getParent();
llvm-late-gc-lowering.cpp:                if (!S.DT->dominates(it2.first, Safepoint))
llvm-late-gc-lowering.cpp:                for (const User *U : it2.first->users()) {
llvm-late-gc-lowering.cpp:                    if (S.DT->dominates(cast<Instruction>(U), Safepoint)) {
llvm-late-gc-lowering.cpp: * - depending on definition) perfect elimination ordering, in such a way that
llvm-late-gc-lowering.cpp:        int NextElement = -1;
llvm-late-gc-lowering.cpp:        while (NextElement == -1 && !Levels.empty()) {
llvm-late-gc-lowering.cpp:            while (NextElement == -1 && !LastLevel.empty()) {
llvm-late-gc-lowering.cpp:        if (NextElement == -1)
llvm-late-gc-lowering.cpp:        // Make sure not to try to re-use this later.
llvm-late-gc-lowering.cpp:        Elements[NextElement].weight = (unsigned)-1;
llvm-late-gc-lowering.cpp:            // Already processed. Don't re-enqueue
llvm-late-gc-lowering.cpp:            if (NElement.weight == (unsigned)-1)
llvm-late-gc-lowering.cpp:            Levels[NElement.weight][NElement.pos] = -1;
llvm-late-gc-lowering.cpp:            NElement.pos = Levels[NElement.weight].size()-1;
llvm-late-gc-lowering.cpp:        if (Colors[i] == -1)
llvm-late-gc-lowering.cpp:        S.ReversePtrNumbering.at(i)->printAsOperand(dbgs());
llvm-late-gc-lowering.cpp:    Colors.resize(S.MaxPtrNumber + 1, -1);
llvm-late-gc-lowering.cpp:            if (Colors[Idx] == -1)
llvm-late-gc-lowering.cpp:    int MaxAssignedColor = -1;
llvm-late-gc-lowering.cpp:    while ((ActiveElement = Ordering.next()) != -1) {
llvm-late-gc-lowering.cpp:        if (Colors[ActiveElement] != -1)
llvm-late-gc-lowering.cpp:            if (NeighborColor == -1)
llvm-late-gc-lowering.cpp:            UsedColors[NeighborColor - PreAssignedColors] = 1;
llvm-late-gc-lowering.cpp:    auto TV = cast<PointerType>(V->getType());
llvm-late-gc-lowering.cpp:    auto cast = builder.CreateBitCast(V, T->getPointerTo(TV->getAddressSpace()));
llvm-late-gc-lowering.cpp:    return builder.CreateInBoundsGEP(T, cast, ConstantInt::get(T_size, -1));
llvm-late-gc-lowering.cpp:    load->setOrdering(AtomicOrdering::Unordered);
llvm-late-gc-lowering.cpp:    load->setMetadata(LLVMContext::MD_tbaa, tbaa_tag);
llvm-late-gc-lowering.cpp:    MDBuilder MDB(load->getContext());
llvm-late-gc-lowering.cpp:    load->setMetadata(LLVMContext::MD_range, MDB.createRange(NonNullInt, NullInt));
llvm-late-gc-lowering.cpp:// This is not a problem on 4.0+ since that transformation (in loop-idiom) is disabled
llvm-late-gc-lowering.cpp:    auto it = S->AllPtrNumbering.find(V);
llvm-late-gc-lowering.cpp:    if (it == S->AllPtrNumbering.end())
llvm-late-gc-lowering.cpp:    auto rit = S->Refinements.find(it->second);
llvm-late-gc-lowering.cpp:    return rit != S->Refinements.end() && !rit->second.empty() ? &rit->second : nullptr;
llvm-late-gc-lowering.cpp:        return RefinePtr->size() == 1 && (*RefinePtr)[0] == -2;
llvm-late-gc-lowering.cpp:    auto it = S->AllPtrNumbering.find(From);
llvm-late-gc-lowering.cpp:    if (it == S->AllPtrNumbering.end())
llvm-late-gc-lowering.cpp:    auto Num = it->second;
llvm-late-gc-lowering.cpp:    S->AllPtrNumbering.erase(it);
llvm-late-gc-lowering.cpp:        S->AllPtrNumbering[To] = Num;
llvm-late-gc-lowering.cpp:    return MDBuilder(Tag->getContext()).createMutableTBAAAccessTag(Tag);
llvm-late-gc-lowering.cpp:        T_pprjlvalue = T_prjlvalue->getPointerTo();
llvm-late-gc-lowering.cpp:            if (I->getMetadata(LLVMContext::MD_invariant_load))
llvm-late-gc-lowering.cpp:                I->setMetadata(LLVMContext::MD_invariant_load, NULL);
llvm-late-gc-lowering.cpp:            if (MDNode *TBAA = I->getMetadata(LLVMContext::MD_tbaa)) {
llvm-late-gc-lowering.cpp:                if (TBAA->getNumOperands() == 4 && isTBAA(TBAA, {"jtbaa_const"})) {
llvm-late-gc-lowering.cpp:                        I->setMetadata(LLVMContext::MD_tbaa, MutableTBAA);
llvm-late-gc-lowering.cpp:            CallingConv::ID CC = CI->getCallingConv();
llvm-late-gc-lowering.cpp:            Value *callee = CI->getCalledOperand();
llvm-late-gc-lowering.cpp:                auto *obj = CI->getOperand(0);
llvm-late-gc-lowering.cpp:                ASCI->takeName(CI);
llvm-late-gc-lowering.cpp:                CI->replaceAllUsesWith(ASCI);
llvm-late-gc-lowering.cpp:                assert(CI->getNumArgOperands() == 3);
llvm-late-gc-lowering.cpp:                builder.SetCurrentDebugLocation(CI->getDebugLoc());
llvm-late-gc-lowering.cpp:                        CI->getArgOperand(0),
llvm-late-gc-lowering.cpp:                            CI->getArgOperand(1),
llvm-late-gc-lowering.cpp:                            allocBytesIntrinsic->getFunctionType()->getParamType(1),
llvm-late-gc-lowering.cpp:                newI->takeName(CI);
llvm-late-gc-lowering.cpp:                auto tag = CI->getArgOperand(2)->stripPointerCastsAndAliases();
llvm-late-gc-lowering.cpp:                    if (C->getOpcode() == Instruction::IntToPtr) {
llvm-late-gc-lowering.cpp:                        tag = C->getOperand(0);
llvm-late-gc-lowering.cpp:                        Type *T_int64 = Type::getInt64Ty(LI->getContext());
llvm-late-gc-lowering.cpp:                        LI->setMetadata(LLVMContext::MD_align,
llvm-late-gc-lowering.cpp:                                        MDNode::get(LI->getContext(), { op }));
llvm-late-gc-lowering.cpp:                auto tag_type = tag->getType();
llvm-late-gc-lowering.cpp:                if (tag_type->isPointerTy()) {
llvm-late-gc-lowering.cpp:                    auto &DL = CI->getModule()->getDataLayout();
llvm-late-gc-lowering.cpp:                    auto align = tag->getPointerAlignment(DL).value();
llvm-late-gc-lowering.cpp:                        // non-integral pointer. This relies on stripping the
llvm-late-gc-lowering.cpp:                        // non-integralness from datalayout before this pass
llvm-late-gc-lowering.cpp:                store->setOrdering(AtomicOrdering::Unordered);
llvm-late-gc-lowering.cpp:                store->setMetadata(LLVMContext::MD_tbaa, tbaa_tag);
llvm-late-gc-lowering.cpp:                CI->replaceAllUsesWith(newI);
llvm-late-gc-lowering.cpp:                assert(CI->getNumArgOperands() == 1);
llvm-late-gc-lowering.cpp:                builder.SetCurrentDebugLocation(CI->getDebugLoc());
llvm-late-gc-lowering.cpp:                auto tag = EmitLoadTag(builder, CI->getArgOperand(0));
llvm-late-gc-lowering.cpp:                typ->takeName(CI);
llvm-late-gc-lowering.cpp:                CI->replaceAllUsesWith(typ);
llvm-late-gc-lowering.cpp:                assert(CI->getNumArgOperands() >= 1);
llvm-late-gc-lowering.cpp:                size_t nargs = CI->getNumArgOperands();
llvm-late-gc-lowering.cpp:                    nframeargs -= 1;
llvm-late-gc-lowering.cpp:                    nframeargs -= 2;
llvm-late-gc-lowering.cpp:                auto arg_it = CI->arg_begin();
llvm-late-gc-lowering.cpp:                assert(arg_it != CI->arg_end());
llvm-late-gc-lowering.cpp:                    assert(arg_it != CI->arg_end());
llvm-late-gc-lowering.cpp:                for (; arg_it != CI->arg_end(); ++arg_it) {
llvm-late-gc-lowering.cpp:                Value *newFptr = Builder.CreateBitCast(callee, FTy->getPointerTo());
llvm-late-gc-lowering.cpp:                NewCall->setTailCallKind(CI->getTailCallKind());
llvm-late-gc-lowering.cpp:                auto old_attrs = CI->getAttributes();
llvm-late-gc-lowering.cpp:                NewCall->setAttributes(AttributeList::get(CI->getContext(),
llvm-late-gc-lowering.cpp:                NewCall->copyMetadata(*CI);
llvm-late-gc-lowering.cpp:                CI->replaceAllUsesWith(NewCall);
llvm-late-gc-lowering.cpp:            } else if (CI->getNumArgOperands() == CI->getNumOperands()) {
llvm-late-gc-lowering.cpp:                NewCall->takeName(CI);
llvm-late-gc-lowering.cpp:                NewCall->copyMetadata(*CI);
llvm-late-gc-lowering.cpp:                CI->replaceAllUsesWith(NewCall);
llvm-late-gc-lowering.cpp:            if (!CI->use_empty()) {
llvm-late-gc-lowering.cpp:                CI->replaceAllUsesWith(UndefValue::get(CI->getType()));
llvm-late-gc-lowering.cpp:            it = CI->eraseFromParent();
llvm-late-gc-lowering.cpp:        auto parent = CI->getArgOperand(0);
llvm-late-gc-lowering.cpp:        if (std::all_of(CI->op_begin() + 1, CI->op_end(),
llvm-late-gc-lowering.cpp:            CI->eraseFromParent();
llvm-late-gc-lowering.cpp:        builder.SetCurrentDebugLocation(CI->getDebugLoc());
llvm-late-gc-lowering.cpp:        for (unsigned i = 1; i < CI->getNumArgOperands(); i++) {
llvm-late-gc-lowering.cpp:            Value *child = CI->getArgOperand(i);
llvm-late-gc-lowering.cpp:        MDBuilder MDB(parent->getContext());
llvm-late-gc-lowering.cpp:        CI->eraseFromParent();
llvm-late-gc-lowering.cpp:        Frame->eraseFromParent();
llvm-late-gc-lowering.cpp:        Frame->setOperand(0, ConstantInt::get(T_int32, maxframeargs));
llvm-late-gc-lowering.cpp:        if (BB == &S.F->getEntryBlock()) {
llvm-late-gc-lowering.cpp:    if (Val->getType() != T_prjlvalue)
llvm-late-gc-lowering.cpp:    int MaxColor = -1;
llvm-late-gc-lowering.cpp:    if (MaxColor != -1 || !S.Allocas.empty() || !S.ArrayAllocas.empty() || !S.TrackedStores.empty()) {
llvm-late-gc-lowering.cpp:        gcframe->insertBefore(&*F->getEntryBlock().begin());
llvm-late-gc-lowering.cpp:        pushGcframe->insertAfter(pgcstack);
llvm-late-gc-lowering.cpp:            unsigned align = AI->getAlignment() / sizeof(void*); // TODO: use DataLayout pointer size
llvm-late-gc-lowering.cpp:            assert(align <= 16 / sizeof(void*) && "Alignment exceeds llvm-final-gc-lowering abilities");
llvm-late-gc-lowering.cpp:                {gcframe, ConstantInt::get(T_int32, AllocaSlot - 2)});
llvm-late-gc-lowering.cpp:            slotAddress->insertAfter(gcframe);
llvm-late-gc-lowering.cpp:            slotAddress->takeName(AI);
llvm-late-gc-lowering.cpp:                if ((II->getIntrinsicID() != Intrinsic::lifetime_start &&
llvm-late-gc-lowering.cpp:                            II->getIntrinsicID() != Intrinsic::lifetime_end))
llvm-late-gc-lowering.cpp:                II->eraseFromParent();
llvm-late-gc-lowering.cpp:            if (slotAddress->getType() != AI->getType()) {
llvm-late-gc-lowering.cpp:                auto BCI  = new BitCastInst(slotAddress, AI->getType());
llvm-late-gc-lowering.cpp:                BCI->insertAfter(slotAddress);
llvm-late-gc-lowering.cpp:            AI->replaceAllUsesWith(slotAddress);
llvm-late-gc-lowering.cpp:            AI->eraseFromParent();
llvm-late-gc-lowering.cpp:            auto ns = cast<ConstantInt>(AI->getArraySize())->getZExtValue();
llvm-late-gc-lowering.cpp:            auto Base = SI->getValueOperand();
llvm-late-gc-lowering.cpp:            //auto Tracked = TrackCompositeType(Base->getType());
llvm-late-gc-lowering.cpp:                    {gcframe, ConstantInt::get(T_int32, AllocaSlot - 2)});
llvm-late-gc-lowering.cpp:                slotAddress->insertAfter(gcframe);
llvm-late-gc-lowering.cpp:                auto ValExpr = std::make_pair(Base, isa<PointerType>(Base->getType()) ? -1 : i);
llvm-late-gc-lowering.cpp:                if (Elem->getType() != T_prjlvalue)
llvm-late-gc-lowering.cpp:                // TODO: shadowStore->setMetadata(LLVMContext::MD_tbaa, tbaa_gcframe);
llvm-late-gc-lowering.cpp:        auto NRoots = ConstantInt::get(T_int32, MaxColor + 1 + AllocaSlot - 2);
llvm-late-gc-lowering.cpp:        gcframe->setArgOperand(0, NRoots);
llvm-late-gc-lowering.cpp:        pushGcframe->setArgOperand(1, NRoots);
llvm-late-gc-lowering.cpp:        PlaceGCFrameStores(S, AllocaSlot - 2, Colors, gcframe);
llvm-late-gc-lowering.cpp:        for(Function::iterator I = F->begin(), E = F->end(); I != E; ++I) {
llvm-late-gc-lowering.cpp:            if (isa<ReturnInst>(I->getTerminator())) {
llvm-late-gc-lowering.cpp:                popGcframe->insertBefore(I->getTerminator());
llvm-late-gc-lowering.cpp:    // Initialize platform-agnostic references.
llvm-late-gc-lowering.cpp:    unwrap(PM)->add(createLateLowerGCFramePass());
win32_ucontext.c:    char *stack_top = (char*)ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size;
win32_ucontext.c:    stack_top -= 0x20; // shadow stack
win32_ucontext.c:        while (fs0->Next != (PEXCEPTION_REGISTRATION_RECORD)0xFFFFFFFF)
win32_ucontext.c:            fs0 = fs0->Next;
win32_ucontext.c:        UnHandler = fs0->Handler;
win32_ucontext.c:    stack_top -= 0x20;
win32_ucontext.c:    stack_top -= sizeof(void*);
win32_ucontext.c:    stack_top -= sizeof(void*); // stack space for ret
win32_ucontext.c:    _JUMP_BUFFER *jmpbuf = (_JUMP_BUFFER*)&ucp->uc_mcontext;
win32_ucontext.c:    jmpbuf->Rip = (unsigned long long)func;
win32_ucontext.c:    jmpbuf->Rsp = (unsigned long long)stack_top;
win32_ucontext.c:    jmpbuf->Rbp = 0;
win32_ucontext.c:    jmpbuf->Frame = 0; // SEH frame
win32_ucontext.c:    jmpbuf->Eip = (unsigned long)func;
win32_ucontext.c:    jmpbuf->Esp = (unsigned long)stack_top;
win32_ucontext.c:    jmpbuf->Ebp = 0;
win32_ucontext.c:    jmpbuf->Registration = (unsigned long)&Registration[0]; // SEH frame
llvmcalltest.cpp:#include "llvm-version.h"
llvmcalltest.cpp:#include "llvm/Config/llvm-config.h"
llvmcalltest.cpp:    Type *TrackedTy = PointerType::get(AnyTy->getElementType(), AddressSpace::Tracked);
llvmcalltest.cpp:    Builder.CreateRet(&*F->arg_begin());
llvmcalltest.cpp:    M->print(os, NULL);
llvmcalltest.cpp:    M->print(os, NULL);
timing.h:    assert(block->running);
timing.h:    block->running = 0;
timing.h:    block->total += t - block->t0;
timing.h:    assert(!block->running);
timing.h:    block->running = 1;
timing.h:    block->t0 = t;
timing.h:    block->owner = owner;
timing.h:    block->total = 0;
timing.h:    block->running = 0;
timing.h:    jl_timing_block_t **prevp = &ct->ptls->timing_stack;
timing.h:    block->prev = *prevp;
timing.h:    if (block->prev)
timing.h:        _jl_timing_block_stop(block->prev, t);
timing.h:    jl_timing_data[block->owner] += block->total;
timing.h:    jl_timing_block_t **pcur = &ct->ptls->timing_stack;
timing.h:    *pcur = block->prev;
timing.h:    if (block->prev)
timing.h:        _jl_timing_block_start(block->prev, t);
intrinsics.h:    /*  same-type comparisons */ \
julia-parser.scm:(define (add-dots ops) (append! ops (map (lambda (op) (symbol (string "." op))) ops)))
julia-parser.scm:(define prec-assignment
julia-parser.scm:  (append! (add-dots '(= += -= = *= /= //= |\\=| ^= = %= <<= >>= >>>= |\|=| &= =   ))
julia-parser.scm:           (add-dots '(~))
julia-parser.scm:;; comma - higher than assignment outside parentheses, lower when inside
julia-parser.scm:(define prec-pair (add-dots '(=>)))
julia-parser.scm:(define prec-conditional '(?))
julia-parser.scm:(define prec-arrow       (add-dots '(                                                                                                                                                  --> <-- <-->)))
julia-parser.scm:(define prec-lazy-or     (add-dots '(|\|\||)))
julia-parser.scm:(define prec-lazy-and    (add-dots '(&&)))
julia-parser.scm:(define prec-comparison
julia-parser.scm:           (add-dots '(> < >=  <=  == ===  !=  !==                                                                                                                                                                                                                                                                                 <: >:))))
julia-parser.scm:(define prec-pipe<       '(|.<\|| |<\||))
julia-parser.scm:(define prec-pipe>       '(|.\|>| |\|>|))
julia-parser.scm:(define prec-colon       (append! '(: |..|) (add-dots '(     ))))
julia-parser.scm:(define prec-plus        (append! '($)
julia-parser.scm:                          (add-dots '(+ -   |\||     |++|                                               ))))
julia-parser.scm:(define prec-times       (add-dots '(* /   % &      |\\|                                                                    )))
julia-parser.scm:(define prec-rational    (add-dots '(//)))
julia-parser.scm:(define prec-bitshift    (add-dots '(<< >> >>>)))
julia-parser.scm:(define prec-power       (add-dots '(^                              )))
julia-parser.scm:(define prec-decl        '(|::|))
julia-parser.scm:(define prec-dot         '(|.|))
julia-parser.scm:(define prec-names '(prec-assignment
julia-parser.scm:                     prec-pair prec-conditional prec-arrow prec-lazy-or prec-lazy-and prec-comparison
julia-parser.scm:                     prec-pipe< prec-pipe> prec-colon prec-plus prec-times prec-rational prec-bitshift
julia-parser.scm:                     prec-power prec-decl prec-dot))
julia-parser.scm:(define trans-op (string->symbol ".'"))
julia-parser.scm:(define ctrans-op (string->symbol "'"))
julia-parser.scm:(define vararg-op (string->symbol "..."))
julia-parser.scm:  ;; construct a length-specialized membership tester
julia-parser.scm:           (for-each (lambda (x) (put! t x #t)) l)
julia-parser.scm:(define no-suffix? (Set (append prec-assignment prec-conditional prec-lazy-or prec-lazy-and
julia-parser.scm:                                prec-colon prec-decl prec-dot
julia-parser.scm:                                '(-> |<:| |>:| in isa $)
julia-parser.scm:                                (list ctrans-op trans-op vararg-op))))
julia-parser.scm:(define (maybe-strip-op-suffix op)
julia-parser.scm:      (let ((op_ (strip-op-suffix op)))
julia-parser.scm:        (if (or (eq? op op_) (no-suffix? op_))
julia-parser.scm:    (if (every no-suffix? l)
julia-parser.scm:        (lambda (op) (S (maybe-strip-op-suffix op))))))
julia-parser.scm:;; for each prec-x generate an is-prec-x? procedure
julia-parser.scm:(for-each (lambda (name)
julia-parser.scm:            (eval `(define ,(symbol (string "is-" name "?")) (SuffSet ,name))))
julia-parser.scm:          prec-names)
julia-parser.scm:;; hash table of binary operators -> precedence
julia-parser.scm:(define prec-table (let ((t (table)))
julia-parser.scm:                             (for-each (lambda (x) (put! t x prec)) (car L))
julia-parser.scm:                     (pushprec (map eval prec-names) 1)
julia-parser.scm:(define (operator-precedence op) (get prec-table
julia-parser.scm:                                      (maybe-strip-op-suffix op)
julia-parser.scm:(define unary-ops (append! '(|<:| |>:|)
julia-parser.scm:                           (add-dots '(+ - ! ~       ))))
julia-parser.scm:(define unary-op? (Set unary-ops))
julia-parser.scm:(define radical-op? (Set '(  )))
julia-parser.scm:(define unary-and-binary-ops (append! '($ & ~)
julia-parser.scm:                                      (add-dots '(+ -   ))))
julia-parser.scm:(define unary-and-binary-op? (Set unary-and-binary-ops))
julia-parser.scm:(define syntactic-operators
julia-parser.scm:  (append! (add-dots '(&& |\|\|| = += -= *= /= //= |\\=| ^= = %= <<= >>= >>>= |\|=| &= =))
julia-parser.scm:           '(:= $= |.| ... ->)))
julia-parser.scm:(define syntactic-unary-operators '($ & |::|))
julia-parser.scm:(define syntactic-op? (Set syntactic-operators))
julia-parser.scm:(define syntactic-unary-op? (Set syntactic-unary-operators))
julia-parser.scm:(define (symbol-or-interpolate? ex)
julia-parser.scm:(define (is-word-operator? op)
julia-parser.scm:  (every identifier-start-char? (string->list (symbol->string op))))
julia-parser.scm:  (filter (lambda (x) (not (is-word-operator? x)))
julia-parser.scm:          (delete-duplicates
julia-parser.scm:           (list* '-> ctrans-op trans-op vararg-op
julia-parser.scm:                  (append unary-ops (apply append (map eval prec-names)))))))
julia-parser.scm:(define op-chars
julia-parser.scm:  (delete-duplicates
julia-parser.scm:          (map string->list (map symbol->string operators)))))
julia-parser.scm:(define opchar? (Set op-chars))
julia-parser.scm:(define dot-operators (filter (lambda (o)
julia-parser.scm:(define dotop? (SuffSet dot-operators))
julia-parser.scm:(define dot-opchar? (Set
julia-parser.scm:                     (delete-duplicates
julia-parser.scm:                           (cons `|..| dot-operators)))))
julia-parser.scm:(define initial-reserved-words '(begin while if for try return break continue
julia-parser.scm:(define initial-reserved-word?
julia-parser.scm:  (let ((reserved? (Set initial-reserved-words)))
julia-parser.scm:                     (not (and (eq? s 'begin) end-symbol)))))) ; begin == firstindex inside [...]
julia-parser.scm:(define reserved-words (append initial-reserved-words '(end else elseif catch finally true false))) ;; todo: make this more complete
julia-parser.scm:(define reserved-word? (Set reserved-words))
julia-parser.scm:(define closing-token?
julia-parser.scm:      (or (and (eq? tok 'end) (not end-symbol))
julia-parser.scm:          (eof-object? tok)))))
julia-parser.scm:(define range-colon-enabled #t)
julia-parser.scm:; in space-sensitive mode "x -y" is 2 expressions, not a subtraction
julia-parser.scm:(define space-sensitive #f)
julia-parser.scm:(define for-generator #f)
julia-parser.scm:(define end-symbol #f)
julia-parser.scm:(define whitespace-newline #f)
julia-parser.scm:(define where-enabled #t)
julia-parser.scm:(define current-filename 'none)
julia-parser.scm:(define-macro (with-normal-context . body)
julia-parser.scm:  `(with-bindings ((range-colon-enabled #t)
julia-parser.scm:                   (space-sensitive #f)
julia-parser.scm:                   (where-enabled #t)
julia-parser.scm:                   (for-generator #f)
julia-parser.scm:                   (end-symbol #f)
julia-parser.scm:                   (whitespace-newline #f))
julia-parser.scm:(define-macro (without-range-colon . body)
julia-parser.scm:  `(with-bindings ((range-colon-enabled #f))
julia-parser.scm:(define-macro (with-space-sensitive . body)
julia-parser.scm:  `(with-bindings ((space-sensitive #t)
julia-parser.scm:                   (whitespace-newline #f))
julia-parser.scm:(define-macro (with-end-symbol . body)
julia-parser.scm:  `(with-bindings ((end-symbol #t))
julia-parser.scm:(define-macro (with-whitespace-newline . body)
julia-parser.scm:  `(with-bindings ((whitespace-newline #t))
julia-parser.scm:;; --- lexer ---
julia-parser.scm:(define (skip-to-eol port)
julia-parser.scm:  (let ((c (peek-char port)))
julia-parser.scm:    (cond ((eof-object? c)    c)
julia-parser.scm:          (else               (read-char port)
julia-parser.scm:                              (skip-to-eol port)))))
julia-parser.scm:(define (op-or-sufchar? c) (or (op-suffix-char? c) (opchar? c)))
julia-parser.scm:(define (read-operator port c0 (postfix? #f))
julia-parser.scm:  (if (and (eqv? c0 #\*) (eqv? (peek-char port) #\*))
julia-parser.scm:  (if (or (eof-object? (peek-char port)) (not (op-or-sufchar? (peek-char port))))
julia-parser.scm:      (string->normsymbol (string c0)) ; 1-char operator
julia-parser.scm:                            (c   (peek-char port))
julia-parser.scm:                            (in-suffix? #f))
julia-parser.scm:                   (if (eof-object? c)
julia-parser.scm:                       (let ((sufchar? (op-suffix-char? c)))
julia-parser.scm:                         (if (if in-suffix?
julia-parser.scm:                                    (opsym (string->symbol newop)))
julia-parser.scm:                                       (and (or (eq? opsym '<---) (eq? opsym '.<---))
julia-parser.scm:                                       ;; -- is not an operator but --> is
julia-parser.scm:                                       (and (or (eq? opsym '--) (eq? opsym '.--))
julia-parser.scm:                                            (read-char port)
julia-parser.scm:                                            (or (begin0 (eqv? (peek-char port) #\>)
julia-parser.scm:                                                        (io.ungetc port #\-))
julia-parser.scm:                                       ;; <- is not an operator but <-- and <--> are
julia-parser.scm:                                       (and (or (eq? opsym '<-) (eq? opsym '.<-))
julia-parser.scm:                                            (read-char port)
julia-parser.scm:                                            (begin0 (eqv? (peek-char port) #\-)
julia-parser.scm:                                                    (io.ungetc port #\-)))
julia-parser.scm:                                   (begin (read-char port)
julia-parser.scm:                                          (loop newop (peek-char port) sufchar?))
julia-parser.scm:        (string->normsymbol str))))
julia-parser.scm:(define (accum-digits c pred port _-digit-sep)
julia-parser.scm:    (if (and _-digit-sep (eqv? c #\_))
julia-parser.scm:        (begin (read-char port)
julia-parser.scm:               (let ((c (peek-char port)))
julia-parser.scm:                 (if (and (not (eof-object? c)) (pred c))
julia-parser.scm:                       (list->string (reverse str))))))
julia-parser.scm:        (if (and (not (eof-object? c)) (pred c))
julia-parser.scm:            (begin (read-char port)
julia-parser.scm:                   (loop (cons c str) (peek-char port)))
julia-parser.scm:            (list->string (reverse str))))))
julia-parser.scm:(define (char-hex? c)
julia-parser.scm:  (or (char-numeric? c)
julia-parser.scm:(define (char-oct? c)
julia-parser.scm:(define (char-bin? c)
julia-parser.scm:(define (string-to-number s r is-float32)
julia-parser.scm:  (let ((ans (if is-float32
julia-parser.scm:                 (float (string->number
julia-parser.scm:                 (string->number s r))))
julia-parser.scm:         (if (or (= ans +inf.0) (= ans -inf.0))
julia-parser.scm:(define (string-lastchar s)
julia-parser.scm:(define (read-number port leadingdot neg)
julia-parser.scm:  (let ((str  (open-output-string))
julia-parser.scm:        (pred char-numeric?)
julia-parser.scm:        (is-float32-literal #f)
julia-parser.scm:        (is-hex-float-literal #f)
julia-parser.scm:      (let ((c (peek-char port)))
julia-parser.scm:             (begin (write-char (read-char port) str) #t))))
julia-parser.scm:    (define (disallow-dot)
julia-parser.scm:      (if (eqv? (peek-char port) #\.)
julia-parser.scm:          (begin (read-char port)
julia-parser.scm:                 (if (dot-opchar? (peek-char port))
julia-parser.scm:                                    (get-output-string str) #\. "\""))))))
julia-parser.scm:    (define (read-digs lz _-digit-sep)
julia-parser.scm:      (let ((c (peek-char port)))
julia-parser.scm:        (if (and (not lz) _-digit-sep (eqv? c #\_))
julia-parser.scm:                           (get-output-string str) c "\"")))
julia-parser.scm:        (let ((d (accum-digits c pred port _-digit-sep)))
julia-parser.scm:               (not (eof-object? d))
julia-parser.scm:    (if neg (write-char #\- str))
julia-parser.scm:        (write-char #\. str)
julia-parser.scm:        (if (eqv? (peek-char port) #\0)
julia-parser.scm:            (begin (write-char (read-char port) str)
julia-parser.scm:                                 (set! pred char-hex?)))
julia-parser.scm:                                 (set! pred char-oct?)))
julia-parser.scm:                                 (set! pred char-bin?)))))
julia-parser.scm:    (read-digs leadingzero #t)
julia-parser.scm:    (if (eqv? (peek-char port) #\.)
julia-parser.scm:        (begin (read-char port)
julia-parser.scm:               (if (dot-opchar? (peek-char port))
julia-parser.scm:                     (if (not (eqv? (peek-char port) #\.))
julia-parser.scm:                         (let ((num (get-output-string str)))
julia-parser.scm:                           (error (string "invalid syntax \"" num #\. (peek-char port) "\""
julia-parser.scm:                                          (if (eqv? (peek-char port) #\')
julia-parser.scm:                   (begin (write-char #\. str)
julia-parser.scm:                          (read-digs #f #t)
julia-parser.scm:                          (if (eq? pred char-hex?)
julia-parser.scm:                              (set! is-hex-float-literal #t))
julia-parser.scm:                          (disallow-dot)))))
julia-parser.scm:    (let* ((c    (peek-char port))
julia-parser.scm:      (if (or (and is-hex-float-literal (or ispP (error "hex float literal must contain \"p\" or \"P\"")))
julia-parser.scm:              (and (eq? pred char-hex?) ispP)
julia-parser.scm:          (begin (read-char port)
julia-parser.scm:                 (let* ((d (peek-char port))
julia-parser.scm:                        (is-minus-sign (or (eqv? d #\-) (eqv? d #\u2212))))
julia-parser.scm:                   (if (and (not (eof-object? d))
julia-parser.scm:                            (or (char-numeric? d) (eqv? d #\+) is-minus-sign))
julia-parser.scm:                       (begin (set! is-float32-literal (eqv? c #\f))
julia-parser.scm:                              (set! is-hex-float-literal ispP)
julia-parser.scm:                              (write-char c str)
julia-parser.scm:                              (if is-minus-sign
julia-parser.scm:                                  (begin (read-char port)
julia-parser.scm:                                         (write-char #\- str))
julia-parser.scm:                                  (write-char (read-char port) str))
julia-parser.scm:                              (read-digs #t #f)
julia-parser.scm:                              (disallow-dot))
julia-parser.scm:               (or (eq? pred char-bin?) (eq? pred char-oct?)
julia-parser.scm:                   (and (eq? pred char-hex?) (not is-hex-float-literal)))
julia-parser.scm:               (or (char-numeric? c)
julia-parser.scm:                   (identifier-start-char? c)))
julia-parser.scm:                         (get-output-string str) c "\""))))
julia-parser.scm:    (let* ((s (get-output-string str))
julia-parser.scm:           (r (cond ((eq? pred char-hex?) 16)
julia-parser.scm:                    ((eq? pred char-oct?) 8)
julia-parser.scm:                    ((eq? pred char-bin?) 2)
julia-parser.scm:           (n (string-to-number
julia-parser.scm:               ;; for an unsigned literal starting with -, remove the - and
julia-parser.scm:               ;; parse instead as a call to unary -
julia-parser.scm:               (if (and neg (not (= r 10)) (not is-hex-float-literal))
julia-parser.scm:               r is-float32-literal)))
julia-parser.scm:      (if (and (eqv? #\. (string-lastchar s))
julia-parser.scm:               (let ((nxt (peek-char port)))
julia-parser.scm:                 (and (not (eof-object? nxt))
julia-parser.scm:                      (or (identifier-start-char? nxt)
julia-parser.scm:      (cond (is-hex-float-literal (numchk n s) (double n))
julia-parser.scm:            ((eq? pred char-hex?) (fix-uint-neg neg (sized-uint-literal n s 4)))
julia-parser.scm:            ((eq? pred char-oct?) (fix-uint-neg neg (sized-uint-oct-literal n s)))
julia-parser.scm:            ((eq? pred char-bin?) (fix-uint-neg neg (sized-uint-literal n s 1)))
julia-parser.scm:            (is-float32-literal   (numchk n s) (float n))
julia-parser.scm:            ((within-int128? s) `(macrocall (core @int128_str) (null) ,s))
julia-parser.scm:(define (fix-uint-neg neg n)
julia-parser.scm:      (if (large-number? n)
julia-parser.scm:          `(call - ,(maybe-negate '- n))
julia-parser.scm:          `(call - ,n))
julia-parser.scm:(define (sized-uint-literal n s b)
julia-parser.scm:  (let* ((i (if (eqv? (string.char s 0) #\-) 4 3))
julia-parser.scm:         (l (+ (* (- (length s) i) b) 1)))
julia-parser.scm:(define (sized-uint-oct-literal n s)
julia-parser.scm:      (sized-uint-literal n s 3)
julia-parser.scm:                 (if (oct-within-uint128? s)
julia-parser.scm:(define (strip-leading-0s s)
julia-parser.scm:  (if (eqv? (string.char s 0) #\-)
julia-parser.scm:      (string #\- (loop 1))
julia-parser.scm:(define (compare-num-strings s1 s2)
julia-parser.scm:  (let ((s1 (strip-leading-0s s1))
julia-parser.scm:        (s2 (strip-leading-0s s2)))
julia-parser.scm:    (if (= (string-length s1) (string-length s2))
julia-parser.scm:        (compare (string-length s1) (string-length s2)))))
julia-parser.scm:(define (oct-within-uint128? s)
julia-parser.scm:  (let ((s (if (eqv? (string.char s 0) #\-)
julia-parser.scm:    (>= 0 (compare-num-strings s "0o3777777777777777777777777777777777777777777"))))
julia-parser.scm:(define (within-int128? s)
julia-parser.scm:  (if (eqv? (string.char s 0) #\-)
julia-parser.scm:      (>= 0 (compare-num-strings s "-170141183460469231731687303715884105728"))
julia-parser.scm:      (>= 0 (compare-num-strings s "170141183460469231731687303715884105727"))))
julia-parser.scm:(define (large-number? t)
julia-parser.scm:(define (skip-comment port)
julia-parser.scm:  (define (skip-multiline-comment port count)
julia-parser.scm:    (let ((c (read-char port)))
julia-parser.scm:      (if (eof-object? c)
julia-parser.scm:          (error "incomplete: unterminated multi-line comment #= ... =#") ; NOTE: changing this may affect code in base/client.jl
julia-parser.scm:                     (let ((c (peek-char port)))
julia-parser.scm:                             (read-char port)
julia-parser.scm:                                 (skip-multiline-comment port (- count 1))))
julia-parser.scm:                           (skip-multiline-comment port count)))
julia-parser.scm:                         (skip-multiline-comment port
julia-parser.scm:                                                 (if (eqv? (peek-char port) #\=)
julia-parser.scm:                                                     (begin (read-char port)
julia-parser.scm:                         (skip-multiline-comment port count)))))))
julia-parser.scm:  (read-char port) ; read # that was already peeked
julia-parser.scm:  (if (eqv? (peek-char port) #\=)
julia-parser.scm:      (begin (read-char port) ; read initial =
julia-parser.scm:             (skip-multiline-comment port 1))
julia-parser.scm:      (skip-to-eol port)))
julia-parser.scm:(define (skip-ws-and-comments port)
julia-parser.scm:  (skip-ws port #t)
julia-parser.scm:  (if (eqv? (peek-char port) #\#)
julia-parser.scm:      (begin (skip-comment port)
julia-parser.scm:             (skip-ws-and-comments port)))
julia-parser.scm:(define (zero-width-space? c)
julia-parser.scm:(define (default-ignorable-char? c)
julia-parser.scm:  (or (zero-width-space? c)
julia-parser.scm:(define (scolno port) (string " near column " (input-port-column port)))
julia-parser.scm:(define (next-token port s)
julia-parser.scm:  (let loop ((comment-induced-whitespace #f))
julia-parser.scm:    (aset! s 2 (or (eq? (skip-ws port whitespace-newline) #t)
julia-parser.scm:                   comment-induced-whitespace))
julia-parser.scm:    (let ((c (peek-char port)))
julia-parser.scm:      (cond ((or (eof-object? c) (eqv? c #\newline))  (read-char port))
julia-parser.scm:            ((identifier-start-char? c)     (accum-julia-symbol c port))
julia-parser.scm:            ((string.find "()[]{},;\"`@" c) (read-char port))
julia-parser.scm:            ((string.find "0123456789" c)   (read-number port #f #f))
julia-parser.scm:            ((eqv? c #\#)                   (skip-comment port) (loop #t))
julia-parser.scm:                  (let ((c (read-char port))
julia-parser.scm:                        (nextc (peek-char port)))
julia-parser.scm:                    (cond ((eof-object? nextc)
julia-parser.scm:                          ((char-numeric? nextc)
julia-parser.scm:                           (read-number port #t #f))
julia-parser.scm:                           (let* ((op (read-operator port c))
julia-parser.scm:                                  (nx (peek-char port)))
julia-parser.scm:            ((opchar? c)  (read-operator port (read-char port)))
julia-parser.scm:              (let ((cn (input-port-column port)))
julia-parser.scm:                (read-char port)
julia-parser.scm:                (if (default-ignorable-char? c)
julia-parser.scm:                    (error (string "invisible character \\u" (number->string (fixnum c) 16) " near column " (+ 1 cn)))
julia-parser.scm:;; --- token stream ---
julia-parser.scm:(define (make-token-stream s) (vector #f s #t #f #f))
julia-parser.scm:(define-macro (ts:port s)       `(aref ,s 1))
julia-parser.scm:(define-macro (ts:last-tok s)   `(aref ,s 0))
julia-parser.scm:(define-macro (ts:set-tok! s t) `(aset! ,s 0 ,t))
julia-parser.scm:(define-macro (ts:pbtok s)      `(aref ,s 3))
julia-parser.scm:(define (ts:put-back! s t spc)
julia-parser.scm:      (error "too many pushed-back tokens (internal error)")
julia-parser.scm:(define (peek-token s)
julia-parser.scm:      (ts:last-tok s)
julia-parser.scm:      (begin (ts:set-tok! s (next-token (ts:port s) s))
julia-parser.scm:             (ts:last-tok s))))
julia-parser.scm:(define (require-token s)
julia-parser.scm:  (let ((t (or (ts:pbtok s) (ts:last-tok s) (next-token (ts:port s) s))))
julia-parser.scm:    (if (eof-object? t)
julia-parser.scm:            (begin (take-token s)
julia-parser.scm:                   (require-token s))
julia-parser.scm:            (begin (if (not (ts:pbtok s)) (ts:set-tok! s t))
julia-parser.scm:(define (take-token s)
julia-parser.scm:   (begin0 (ts:last-tok s)
julia-parser.scm:           (ts:set-tok! s #f))))
julia-parser.scm:(define (space-before-next-token? s)
julia-parser.scm:  (or (skip-ws (ts:port s) #f) (eqv? #\newline (peek-char (ts:port s)))))
julia-parser.scm:;; --- misc ---
julia-parser.scm:; Log a syntax deprecation, attributing it to current-filename and the line
julia-parser.scm:(define (parser-depwarn s what instead)
julia-parser.scm:  (let ((line (if (number? s) s (input-port-line (if (port? s) s (ts:port s)))))
julia-parser.scm:        (file current-filename))
julia-parser.scm:    (frontend-depwarn (format-syntax-deprecation what instead file line #t) file line)))
julia-parser.scm:;; --- parser ---
julia-parser.scm:;; parse left-to-right binary operator
julia-parser.scm:(define-macro (parse-LtoR s down ops)
julia-parser.scm:              (t  (peek-token ,s)))
julia-parser.scm:         (begin (take-token ,s)
julia-parser.scm:                (loop (list 'call t ex (,down ,s)) (peek-token ,s)))
julia-parser.scm:;; parse right-to-left binary operator
julia-parser.scm:(define-macro (parse-RtoL s down ops syntactic self)
julia-parser.scm:          (t  (peek-token ,s)))
julia-parser.scm:         (begin (take-token ,s)
julia-parser.scm:(define (line-number-node s)
julia-parser.scm:  `(line ,(input-port-line (ts:port s)) ,current-filename))
julia-parser.scm:(define (parse-Nary s down ops head closer? add-linenums)
julia-parser.scm:  (let ((t (require-token s)))
julia-parser.scm:        (if add-linenums    ;; empty block
julia-parser.scm:            (list head (line-number-node s))
julia-parser.scm:                        (if add-linenums
julia-parser.scm:                            (list (line-number-node s))
julia-parser.scm:                        (if add-linenums
julia-parser.scm:                            (let ((loc (line-number-node s)))
julia-parser.scm:                              ;; note: line-number must happen before (down s)
julia-parser.scm:                   (t (peek-token s)))
julia-parser.scm:              (begin (take-token s)
julia-parser.scm:                     (if (or (eof-object? (peek-token s))
julia-parser.scm:                             (closer? (peek-token s))
julia-parser.scm:                             (memv (peek-token s) ops))
julia-parser.scm:                         (loop ex #f (peek-token s))
julia-parser.scm:                         (if (and add-linenums
julia-parser.scm:                             (let ((loc (line-number-node s)))
julia-parser.scm:                               (loop (list* (down s) loc ex) #f (peek-token s)))
julia-parser.scm:                             (loop (cons (down s) ex) #f (peek-token s))))))))))
julia-parser.scm:;; the principal non-terminals follow, in increasing precedence order
julia-parser.scm:(define (parse-block s (down parse-eq))
julia-parser.scm:  (parse-Nary s down '(#\newline #\;) 'block
julia-parser.scm:(define (parse-stmts s)
julia-parser.scm:  (let ((ex (parse-Nary s (lambda (s) (parse-docstring s parse-eq))
julia-parser.scm:    (let ((t (peek-token s)))
julia-parser.scm:      (if (not (or (eof-object? t) (eqv? t #\newline) (eq? t #f)))
julia-parser.scm:(define (parse-eq s) (parse-assignment s parse-comma))
julia-parser.scm:(define non-standalone-symbol-token?
julia-parser.scm:  (Set (append operators reserved-words '(.... mutable primitive abstract))))
julia-parser.scm:; parse-eq* is used where commas are special, for example in an argument list
julia-parser.scm:(define (parse-eq* s)
julia-parser.scm:  (let* ((t   (peek-token s))
julia-parser.scm:    (if (or (number? t) (and (symbol? t) (not (non-standalone-symbol-token? t))))
julia-parser.scm:        (begin (take-token s)
julia-parser.scm:               (let ((nxt (peek-token s)))
julia-parser.scm:                     (begin (ts:put-back! s t spc)
julia-parser.scm:                            (parse-assignment s parse-pair)))))
julia-parser.scm:        (parse-assignment s parse-pair))))
julia-parser.scm:(define (eventually-call? ex)
julia-parser.scm:                (eventually-call? (cadr ex))))))
julia-parser.scm:(define (add-line-number blk linenode)
julia-parser.scm:(define (short-form-function-loc ex lno)
julia-parser.scm:  (if (eventually-call? (cadr ex))
julia-parser.scm:      `(= ,(cadr ex) ,(add-line-number (caddr ex) `(line ,lno ,current-filename)))
julia-parser.scm:(define (parse-assignment s down)
julia-parser.scm:         (t  (peek-token s)))
julia-parser.scm:    (if (not (is-prec-assignment? t))
julia-parser.scm:          (take-token s)
julia-parser.scm:          (cond ((or (eq? t '~) (eq? t '|.~|)) ;; ~ is the only non-syntactic assignment-precedence operators
julia-parser.scm:                 (if (and space-sensitive (ts:space? s)
julia-parser.scm:                          (not (space-before-next-token? s)))
julia-parser.scm:                     (begin (ts:put-back! s t (ts:space? s))
julia-parser.scm:                     (list 'call t ex (parse-assignment s down))))
julia-parser.scm:                 ;; insert line/file for short-form function defs, otherwise leave alone
julia-parser.scm:                 (let ((lno (input-port-line (ts:port s))))
julia-parser.scm:                   (short-form-function-loc
julia-parser.scm:                    (list t ex (parse-assignment s down)) lno)))
julia-parser.scm:                 (list t ex (parse-assignment s down))))))))
julia-parser.scm:; parse-comma is needed for commas outside parens, for example a = b,c
julia-parser.scm:(define (parse-comma s)
julia-parser.scm:  (let loop ((ex     (list (parse-pair s)))
julia-parser.scm:             (t      (peek-token s)))
julia-parser.scm:        (begin (take-token s)
julia-parser.scm:               (if (eq? (peek-token s) '=) ;; allow x, = ...
julia-parser.scm:                   (loop ex #f (peek-token s))
julia-parser.scm:                   (loop (cons (parse-pair s) ex) #f (peek-token s)))))))
julia-parser.scm:(define (parse-pair s) (parse-RtoL s parse-cond is-prec-pair? #f parse-pair))
julia-parser.scm:(define (parse-cond s)
julia-parser.scm:  (let ((ex (parse-arrow s)))
julia-parser.scm:    (cond ((eq? (peek-token s) '?)
julia-parser.scm:                  (take-token s) ; take the ?
julia-parser.scm:                  (let ((t (with-whitespace-newline (without-range-colon (require-token s)))))
julia-parser.scm:                  (let ((then (without-range-colon (parse-eq* s))))
julia-parser.scm:                    (if (not (eq? (peek-token s) ':))
julia-parser.scm:                    (take-token s) ; take the :
julia-parser.scm:                    (let ((t (with-whitespace-newline (require-token s))))
julia-parser.scm:                    (list 'if ex then (parse-eq* s)))))
julia-parser.scm:(define (parse-arrow s) (parse-RtoL s parse-or         is-prec-arrow? (eq? t '-->) parse-arrow))
julia-parser.scm:(define (parse-or s)    (parse-RtoL s parse-and        is-prec-lazy-or? #t parse-or))
julia-parser.scm:(define (parse-and s)   (parse-RtoL s parse-comparison is-prec-lazy-and? #t parse-and))
julia-parser.scm:(define (parse-comparison s)
julia-parser.scm:  (let loop ((ex (parse-pipe< s))
julia-parser.scm:    (let ((t (peek-token s)))
julia-parser.scm:      (cond ((is-prec-comparison? t)
julia-parser.scm:             (begin (take-token s)
julia-parser.scm:                        (loop (list 'comparison ex t (parse-pipe< s)) #f)
julia-parser.scm:                        (loop (append ex (list t (parse-pipe< s))) #f))))
julia-parser.scm:(define (parse-pipe< s) (parse-RtoL s parse-pipe> is-prec-pipe<? #f parse-pipe<))
julia-parser.scm:(define (parse-pipe> s) (parse-LtoR s parse-range is-prec-pipe>?))
julia-parser.scm:(define (parse-range s)
julia-parser.scm:  (let loop ((ex     (parse-expr s))
julia-parser.scm:    (let* ((t   (peek-token s))
julia-parser.scm:      (cond ((and first? (is-prec-colon? t) (not (eq? t ':)))
julia-parser.scm:             (take-token s)
julia-parser.scm:             `(call ,t ,ex ,(parse-expr s)))
julia-parser.scm:            ((and range-colon-enabled (eq? t ':))
julia-parser.scm:             (take-token s)
julia-parser.scm:             (if (and space-sensitive spc
julia-parser.scm:                      (not (space-before-next-token? s)))
julia-parser.scm:                 (begin (ts:put-back! s ': spc)
julia-parser.scm:                        (cond ((closing-token? (peek-token s))
julia-parser.scm:                              ((newline? (peek-token s))
julia-parser.scm:                               (parse-expr s)))))
julia-parser.scm:             (take-token s)
julia-parser.scm:(define (parse-chain s down op)
julia-parser.scm:    (let ((t (peek-token s)))
julia-parser.scm:            (take-token s)
julia-parser.scm:            (cond ((and space-sensitive spc (memq t unary-and-binary-ops)
julia-parser.scm:                        (not (space-before-next-token? s)))
julia-parser.scm:                   ;; here we have "x -y"
julia-parser.scm:                   (ts:put-back! s t spc)
julia-parser.scm:(define (parse-with-chains s down ops chain-ops)
julia-parser.scm:    (let ((t (peek-token s)))
julia-parser.scm:            (take-token s)
julia-parser.scm:            (cond ((and space-sensitive spc (memq t unary-and-binary-ops)
julia-parser.scm:                        (not (space-before-next-token? s)))
julia-parser.scm:                   ;; here we have "x -y"
julia-parser.scm:                   (ts:put-back! s t spc)
julia-parser.scm:                  ((memq t chain-ops)
julia-parser.scm:                                (parse-chain s down t))))
julia-parser.scm:(define (parse-expr s)     (parse-with-chains s parse-term          is-prec-plus?  '(+ ++)))
julia-parser.scm:(define (parse-term s)     (parse-with-chains s parse-rational      is-prec-times? '(*)))
julia-parser.scm:(define (parse-rational s) (parse-LtoR        s parse-shift         is-prec-rational?))
julia-parser.scm:(define (parse-shift s)    (parse-LtoR        s parse-unary-subtype is-prec-bitshift?))
julia-parser.scm:(define (parse-unary-subtype s)
julia-parser.scm:  (let* ((op  (require-token s))
julia-parser.scm:        (begin (take-token s)
julia-parser.scm:               (let ((next (peek-token s)))
julia-parser.scm:                 (cond ((or (closing-token? next) (newline? next) (eq? next '=))
julia-parser.scm:                        (ts:put-back! s op spc)
julia-parser.scm:                        (parse-where s parse-juxtapose))
julia-parser.scm:                        (let ((arg (parse-where s parse-juxtapose)))
julia-parser.scm:        (parse-where s parse-juxtapose))))
julia-parser.scm:(define (parse-where-chain s first)
julia-parser.scm:  (with-bindings ((where-enabled #f))
julia-parser.scm:         (begin (take-token s)
julia-parser.scm:                (let ((var (parse-comparison s)))
julia-parser.scm:                        (peek-token s))))
julia-parser.scm:(define (parse-where s down)
julia-parser.scm:    (if (and where-enabled
julia-parser.scm:             (eq? (peek-token s) 'where))
julia-parser.scm:        (parse-where-chain s ex)
julia-parser.scm:           (large-number? expr)
julia-parser.scm:                (not (and (pair? expr) (or (block-form? (car expr))
julia-parser.scm:                                           (syntactic-unary-op? (car expr))
julia-parser.scm:                                           (initial-reserved-word? (car expr))))))
julia-parser.scm:       (or (not (operator? t)) (radical-op? t))
julia-parser.scm:       (not (closing-token? t))
julia-parser.scm:       (not (initial-reserved-word? t))
julia-parser.scm:(define (parse-juxtapose s)
julia-parser.scm:  (let ((first (parse-unary s)))
julia-parser.scm:      (let ((next (peek-token s)))
julia-parser.scm:              (let ((next (if (radical-op? next) (parse-unary s) (parse-factor s))))
julia-parser.scm:(define (maybe-negate op num)
julia-parser.scm:  (if (eq? op '-)
julia-parser.scm:      (if (large-number? num)
julia-parser.scm:          (if (eqv? (cadddr num) "-170141183460469231731687303715884105728")
julia-parser.scm:          (if (= num -9223372036854775808)
julia-parser.scm:              (- num)))
julia-parser.scm:;; operators handled by parse-unary at the start of an expression
julia-parser.scm:(define initial-operator?
julia-parser.scm:  (Set (diff operators (append '(: |'| |.'| ?) syntactic-unary-operators syntactic-operators))))
julia-parser.scm:(define (parse-unary s)
julia-parser.scm:  (let* ((op  (require-token s))
julia-parser.scm:    (if (initial-operator? op)
julia-parser.scm:          (take-token s)
julia-parser.scm:          (if (or (eq? op '-) (eq? op '+))
julia-parser.scm:              (let ((nch (peek-char (ts:port s))))
julia-parser.scm:                (if (or (and (char? nch) (char-numeric? nch))
julia-parser.scm:                        (and (eqv? nch #\.) (read-char (ts:port s))))
julia-parser.scm:                    (let ((num (read-number (ts:port s) (eqv? nch #\.) (eq? op '-))))
julia-parser.scm:                      (if (or (memv (peek-token s) '(#\[ #\{))
julia-parser.scm:                              (is-prec-power? (peek-token s)))
julia-parser.scm:                          ;; unary negation; -2^x parsed as (- (^ 2 x)).
julia-parser.scm:                          (begin (ts:put-back! s (maybe-negate op num) spc)
julia-parser.scm:                                 (list 'call op (parse-factor s)))
julia-parser.scm:                    (parse-unary-call s op #t spc)))
julia-parser.scm:              (parse-unary-call s op (unary-op? op) spc)))
julia-parser.scm:        (parse-factor s))))
julia-parser.scm:(define (fix-syntactic-unary e)
julia-parser.scm:(define (parse-unary-call s op un spc)
julia-parser.scm:  (let ((next (peek-token s)))
julia-parser.scm:    (cond ((or (closing-token? next) (newline? next) (eq? next '=))
julia-parser.scm:           (ts:put-back! s op spc)
julia-parser.scm:           (parse-factor s))
julia-parser.scm:           (take-token s)
julia-parser.scm:                  (lno    (input-port-line (ts:port s)))
julia-parser.scm:                  (parens (parse-paren- s #t)))
julia-parser.scm:                     (disallowed-space-error lno op #\( )
julia-parser.scm:                     (parse-factor-with-initial-ex
julia-parser.scm:                      (fix-syntactic-unary (cons op (tuple-to-arglist (car parens))))))
julia-parser.scm:                 (fix-syntactic-unary
julia-parser.scm:                  (list op (parse-factor-with-initial-ex s (car parens)))))))
julia-parser.scm:           (let ((arg  (parse-unary s)))
julia-parser.scm:             (fix-syntactic-unary (list op arg)))))))
julia-parser.scm:(define block-form? (Set '(block quote if for while let function macro abstract primitive struct
julia-parser.scm:;; -2^3 is parsed as -(2^3), so call parse-decl for the first argument,
julia-parser.scm:;; and parse-unary from then on (to handle 2^-3)
julia-parser.scm:(define (parse-factor s)
julia-parser.scm:  (let ((nxt (peek-token s)))
julia-parser.scm:    (parse-factor-with-initial-ex s (parse-unary-prefix s) nxt)))
julia-parser.scm:(define (parse-factor-with-initial-ex s ex0 (tok #f))
julia-parser.scm:  (let* ((ex (parse-decl-with-initial-ex s (parse-call-with-initial-ex s ex0 tok)))
julia-parser.scm:         (t  (peek-token s)))
julia-parser.scm:    (if (is-prec-power? t)
julia-parser.scm:        (begin (take-token s)
julia-parser.scm:               (list 'call t ex (parse-factor-after s)))
julia-parser.scm:(define (parse-factor-after s) (parse-RtoL s parse-juxtapose is-prec-power? #f parse-factor-after))
julia-parser.scm:(define (parse-decl s)
julia-parser.scm:  (parse-decl-with-initial-ex s (parse-call s)))
julia-parser.scm:(define (parse-decl-with-initial-ex s ex)
julia-parser.scm:    (let ((t (peek-token s)))
julia-parser.scm:        ((|::|) (take-token s)
julia-parser.scm:         (loop (list t ex (parse-where s parse-call))))
julia-parser.scm:        ((->)   (take-token s)
julia-parser.scm:         ;; -> is unusual: it binds tightly on the left and
julia-parser.scm:         (let ((lno (line-number-node s)))
julia-parser.scm:           `(-> ,ex ,(add-line-number (parse-eq* s) lno))))
julia-parser.scm:(define (parse-call s)
julia-parser.scm:  (let ((nxt (peek-token s)))
julia-parser.scm:    (parse-call-with-initial-ex s (parse-unary-prefix s) nxt)))
julia-parser.scm:(define (parse-call-with-initial-ex s ex tok)
julia-parser.scm:  (if (or (initial-reserved-word? tok) (memq tok '(mutable primitive abstract)))
julia-parser.scm:      (parse-resword s ex)
julia-parser.scm:      (parse-call-chain s ex #f)))
julia-parser.scm:(define (parse-unary-prefix s)
julia-parser.scm:  (let ((op (peek-token s)))
julia-parser.scm:    (if (syntactic-unary-op? op)
julia-parser.scm:        (begin (take-token s)
julia-parser.scm:                           (let ((next (peek-token s)))
julia-parser.scm:                             (or (closing-token? next) (newline? next))))
julia-parser.scm:                     ((memq op '(& |::|))  (list op (parse-where s parse-call)))
julia-parser.scm:                     (else                 (list op (parse-unary-prefix s)))))
julia-parser.scm:        (parse-atom s))))
julia-parser.scm:(define (parse-def s is-func anon)
julia-parser.scm:  (let* ((ex  (parse-unary-prefix s))
julia-parser.scm:         (sig (if (or (and is-func (reserved-word? ex)) (initial-reserved-word? ex))
julia-parser.scm:                  (parse-call-chain s ex #f)))
julia-parser.scm:         (decl-sig
julia-parser.scm:          (if (and is-func (eq? (peek-token s) '|::|))
julia-parser.scm:              (begin (take-token s)
julia-parser.scm:                     `(|::| ,sig ,(parse-call s)))
julia-parser.scm:    (if (eq? (peek-token s) 'where)
julia-parser.scm:        (parse-where-chain s decl-sig)
julia-parser.scm:        decl-sig)))
julia-parser.scm:(define (disallowed-space-error lno ex t)
julia-parser.scm:                 current-filename ":" lno)))
julia-parser.scm:(define (disallow-space s ex t)
julia-parser.scm:      (disallowed-space-error (input-port-line (ts:port s)) ex t)))
julia-parser.scm:(define (parse-call-chain s ex macrocall?)
julia-parser.scm:    (let ((t (peek-token s)))
julia-parser.scm:      (if (or (and space-sensitive (ts:space? s)
julia-parser.scm:                       (large-number? ex))
julia-parser.scm:             (disallow-space s ex t)
julia-parser.scm:             (take-token s)
julia-parser.scm:             (let ((c (let ((al (parse-call-arglist s #\) )))
julia-parser.scm:                         (if (eq? (peek-token s) 'do)
julia-parser.scm:                               (take-token s)
julia-parser.scm:                               `(do (call ,ex ,@params ,@args) ,(parse-do s)))
julia-parser.scm:             (disallow-space s ex t)
julia-parser.scm:             (take-token s)
julia-parser.scm:             (let* ((es end-symbol)
julia-parser.scm:                    (al (with-end-symbol (parse-cat s #\] es))))
julia-parser.scm:                         ((vect)  (loop (list* 'ref ex (map =-to-kw (cdr al)))))
julia-parser.scm:                         (else (error "unknown parse-cat result (internal error)")))))))
julia-parser.scm:             (disallow-space s ex t)
julia-parser.scm:             (take-token s)
julia-parser.scm:              (cond ((eqv? (peek-token s) #\()
julia-parser.scm:                           (disallow-space s `(|.| ,ex (quote ||)) #\())
julia-parser.scm:                       (take-token s)
julia-parser.scm:                       `(|.| ,ex (tuple ,@(parse-call-arglist s #\) )))))
julia-parser.scm:                    ((eqv? (peek-token s) ':)
julia-parser.scm:                       (take-token s)
julia-parser.scm:                       (cond ((eqv? (peek-token s) #\newline)
julia-parser.scm:                             ((ts:space? s) ;; uses side effect of previous peek-token
julia-parser.scm:                             (else `(|.| ,ex (quote ,(parse-atom s #f)))))))
julia-parser.scm:                    ((eq? (peek-token s) '$)
julia-parser.scm:                     (take-token s)
julia-parser.scm:                     (let ((dollarex (parse-atom s)))
julia-parser.scm:                     (let ((name (parse-atom s #f)))
julia-parser.scm:                   (take-token s)
julia-parser.scm:                   (let ((t (read-operator (ts:port s) #\' #t)))
julia-parser.scm:             (disallow-space s ex t)
julia-parser.scm:             (take-token s)
julia-parser.scm:             (let ((args (parse-call-arglist s #\} )))
julia-parser.scm:             (if (and (or (symbol? ex) (valid-modref? ex))
julia-parser.scm:                 (let* ((startloc  (line-number-node s))
julia-parser.scm:                        (macstr (begin (take-token s)
julia-parser.scm:                                       (parse-raw-literal s t)))
julia-parser.scm:                        (nxt (peek-token s))
julia-parser.scm:                        (macname (macroify-name ex (macsuffix t))))
julia-parser.scm:                   (if (and (or (symbol? nxt) (number? nxt) (large-number? nxt)) (not (operator? nxt))
julia-parser.scm:                                              (string (take-token s))
julia-parser.scm:                                              (take-token s))))
julia-parser.scm:(define expect-end-current-line 0)
julia-parser.scm:(define (expect-end s word)
julia-parser.scm:  (let ((t (peek-token s)))
julia-parser.scm:        (take-token s)
julia-parser.scm:        (expect-end-error t word))))
julia-parser.scm:(define (expect-end-error t word)
julia-parser.scm:  (if (eof-object? t)
julia-parser.scm:                     current-filename ":" expect-end-current-line
julia-parser.scm:                     current-filename ":" expect-end-current-line
julia-parser.scm:(define (parse-subtype-spec s)
julia-parser.scm:  (parse-comparison s))
julia-parser.scm:(define (valid-func-sig? paren sig)
julia-parser.scm:                (valid-func-sig? paren (cadr sig))))))
julia-parser.scm:(define (valid-1arg-func-sig? sig)
julia-parser.scm:(define (unwrap-where x)
julia-parser.scm:      (unwrap-where (cadr x))
julia-parser.scm:(define (rewrap-where x w)
julia-parser.scm:      (list 'where (rewrap-where x (cadr w)) (caddr w))
julia-parser.scm:(define (parse-struct-def s mut? word)
julia-parser.scm:  (if (reserved-word? (peek-token s))
julia-parser.scm:      (error (string "invalid type name \"" (take-token s) "\"")))
julia-parser.scm:  (let ((sig (parse-subtype-spec s)))
julia-parser.scm:    (begin0 (list 'struct (if mut? '(true) '(false)) sig (parse-block s))
julia-parser.scm:            (expect-end s word))))
julia-parser.scm:(define (take-lineendings s)
julia-parser.scm:  (let ((nt (peek-token s)))
julia-parser.scm:        (begin (take-token s)
julia-parser.scm:               (take-lineendings s))
julia-parser.scm:(define (parse-resword s word)
julia-parser.scm:  (with-bindings
julia-parser.scm:   ((expect-end-current-line (input-port-line (ts:port s))))
julia-parser.scm:   (with-normal-context
julia-parser.scm:        (let ((loc  (begin (skip-ws-and-comments (ts:port s))
julia-parser.scm:                           (line-number-node s)))
julia-parser.scm:              (blk  (parse-block s (lambda (s) (parse-docstring s parse-eq)))))
julia-parser.scm:          (expect-end s word)
julia-parser.scm:       ((while)  (begin0 (list 'while (parse-cond s) (append (parse-block s) (list (line-number-node s))))
julia-parser.scm:                         (expect-end s word)))
julia-parser.scm:        (let* ((ranges (parse-comma-separated-iters s))
julia-parser.scm:               (body   (parse-block s)))
julia-parser.scm:          (expect-end s word)
julia-parser.scm:                ,(append body (list (line-number-node s))))))
julia-parser.scm:        (let ((binds (if (memv (peek-token s) '(#\newline #\;))
julia-parser.scm:                         (parse-comma-separated-assignments s))))
julia-parser.scm:          (if (not (or (eof-object? (peek-token s))
julia-parser.scm:                       (memv (peek-token s) '(#\newline #\; end))))
julia-parser.scm:          (let* ((ex (begin0 (parse-block s)
julia-parser.scm:                             (expect-end s word)))
julia-parser.scm:        (if (newline? (peek-token s))
julia-parser.scm:            (error (string "missing condition in \"if\" at " current-filename
julia-parser.scm:                           ":" (- (input-port-line (ts:port s)) 1))))
julia-parser.scm:        (let* ((lno (line-number-node s))  ;; line number for elseif condition
julia-parser.scm:               (test (parse-cond s))
julia-parser.scm:               (then (if (memq (require-token s) '(else elseif))
julia-parser.scm:                         (parse-block s)))
julia-parser.scm:               (nxt  (require-token s)))
julia-parser.scm:          (take-token s)
julia-parser.scm:             (if (newline? (peek-token s))
julia-parser.scm:                 (error (string "missing condition in \"elseif\" at " current-filename
julia-parser.scm:                                ":" (- (input-port-line (ts:port s)) 1))))
julia-parser.scm:                     ,(parse-resword s 'elseif)))
julia-parser.scm:             (if (eq? (peek-token s) 'if)
julia-parser.scm:             (begin0 (list word test then (parse-block s))
julia-parser.scm:                     (expect-end s 'if)))
julia-parser.scm:        (let* ((const (and (eq? (peek-token s) 'const)
julia-parser.scm:                           (take-token s)))
julia-parser.scm:               (assgn (parse-eq s))
julia-parser.scm:        (let ((assgn (parse-eq s)))
julia-parser.scm:        (let* ((loc   (line-number-node s))
julia-parser.scm:               (paren (eqv? (require-token s) #\())
julia-parser.scm:               (sig   (parse-def s (eq? word 'function) paren)))
julia-parser.scm:          (if (and (not paren) (symbol-or-interpolate? sig))
julia-parser.scm:              (begin (if (not (eq? (require-token s) 'end))
julia-parser.scm:                     (take-token s)
julia-parser.scm:              (let* ((usig (unwrap-where sig))
julia-parser.scm:                     (def  (if (or (valid-1arg-func-sig? usig)
julia-parser.scm:                                        (valid-1arg-func-sig? (cadr usig))))
julia-parser.scm:                                   (rewrap-where `(tuple ,usig) sig)
julia-parser.scm:                               (if (not (valid-func-sig? paren sig))
julia-parser.scm:                                       (error (string "ambiguous signature in " word " definition. Try adding a comma if this is a 1-argument anonymous function."))
julia-parser.scm:                     (body (parse-block s)))
julia-parser.scm:                (expect-end s word)
julia-parser.scm:                (list word def (add-line-number body loc))))))
julia-parser.scm:        (if (not (eq? (peek-token s) 'type))
julia-parser.scm:            (parse-call-chain s word #f)
julia-parser.scm:            (begin (take-token s)
julia-parser.scm:                   (let ((spec (parse-subtype-spec s)))
julia-parser.scm:                             (expect-end (take-lineendings s) "abstract type"))))))
julia-parser.scm:        (begin (take-token s)
julia-parser.scm:               (parse-struct-def s #f word)))
julia-parser.scm:        (if (not (eq? (peek-token s) 'struct))
julia-parser.scm:            (parse-call-chain s word #f)
julia-parser.scm:            (begin (take-token s)
julia-parser.scm:                   (parse-struct-def s #t word))))
julia-parser.scm:        (if (not (eq? (peek-token s) 'type))
julia-parser.scm:            (parse-call-chain s word #f)
julia-parser.scm:            (begin (take-token s)
julia-parser.scm:                   (let* ((spec (with-space-sensitive (parse-subtype-spec s)))
julia-parser.scm:                          (nb   (with-space-sensitive (parse-cond s))))
julia-parser.scm:                             (expect-end (take-lineendings s) "primitive type"))))))
julia-parser.scm:        (let ((try-block (if (memq (peek-token s) '(catch finally))
julia-parser.scm:                             (parse-block s))))
julia-parser.scm:          (let loop ((nxt    (peek-token s))
julia-parser.scm:            (take-token s)
julia-parser.scm:              (list* 'try try-block (or catchv '(false))
julia-parser.scm:              (let ((nl (memv (peek-token s) '(#\newline #\;))))
julia-parser.scm:                (if (eqv? (peek-token s) #\;)
julia-parser.scm:                    (take-token s))
julia-parser.scm:                (if (memq (require-token s) '(end finally))
julia-parser.scm:                    (loop (require-token s)
julia-parser.scm:                    (let* ((loc (line-number-node s))
julia-parser.scm:                           (var (if nl #f (parse-eq* s)))
julia-parser.scm:                           (catch-block (if (eq? (require-token s) 'finally)
julia-parser.scm:                                            `(block ,(line-number-node s))
julia-parser.scm:                                            (parse-block s))))
julia-parser.scm:                      (loop (require-token s)
julia-parser.scm:                                catch-block
julia-parser.scm:                                        ,@(if (and (length= catch-block 2)
julia-parser.scm:                                                   (linenum? (cadr catch-block)))
julia-parser.scm:                                              (cdr catch-block))))
julia-parser.scm:              (let ((fb (if (eq? (require-token s) 'catch)
julia-parser.scm:                            (parse-block s))))
julia-parser.scm:                (loop (require-token s)
julia-parser.scm:             (else (expect-end-error nxt 'try))))))
julia-parser.scm:       ((return)          (let ((t (peek-token s)))
julia-parser.scm:                            (if (or (eqv? t #\newline) (closing-token? t))
julia-parser.scm:                                (list 'return (parse-eq s)))))
julia-parser.scm:        (let ((t (peek-token s)))
julia-parser.scm:          (if (or (eof-object? t)
julia-parser.scm:                  (and (eq? t 'end) (not end-symbol))
julia-parser.scm:        (let* ((name (parse-unary-prefix s))
julia-parser.scm:               (loc  (line-number-node s))
julia-parser.scm:               (body (parse-block s (lambda (s) (parse-docstring s parse-eq)))))
julia-parser.scm:          (if (reserved-word? name)
julia-parser.scm:          (expect-end s word)
julia-parser.scm:        (let ((es (map macrocall-to-atsym
julia-parser.scm:                       (parse-comma-separated s parse-unary-prefix))))
julia-parser.scm:          (if (not (every symbol-or-interpolate? es))
julia-parser.scm:        (parse-imports s word))
julia-parser.scm:(define (parse-do s)
julia-parser.scm:  (with-bindings
julia-parser.scm:   ((expect-end-current-line (input-port-line (ts:port s))))
julia-parser.scm:   (with-normal-context
julia-parser.scm:    (let ((doargs (if (memv (peek-token s) '(#\newline #\;))
julia-parser.scm:                      (parse-comma-separated s parse-range))))
julia-parser.scm:      `(-> (tuple ,@doargs)
julia-parser.scm:           ,(begin0 (parse-block s)
julia-parser.scm:                    (expect-end s 'do)))))))
julia-parser.scm:(define (macrocall-to-atsym e)
julia-parser.scm:(define (parse-imports s word)
julia-parser.scm:  (let* ((first (parse-import s word #f))
julia-parser.scm:         (next  (peek-token s))
julia-parser.scm:                       (begin (take-token s) #f))
julia-parser.scm:                    (let ((ex (parse-comma-separated s (lambda (s)
julia-parser.scm:                                                         (parse-import s word from)))))
julia-parser.scm:                      (if (eq? (peek-token s) ':)
julia-parser.scm:                   (error (string "invalid syntax \"using " (deparse-import-path (cadr first)) " as ...\"")))
julia-parser.scm:(define (parse-macro-name s)
julia-parser.scm:  (let ((nxt (peek-token s)))
julia-parser.scm:    (disallow-space s '@ nxt))
julia-parser.scm:  (with-space-sensitive
julia-parser.scm:   (if (eq? (peek-token s) '|.|)
julia-parser.scm:       (begin (take-token s) '__dot__)
julia-parser.scm:       (parse-atom s #f))))
julia-parser.scm:(define (parse-atsym s)
julia-parser.scm:  (let ((t (peek-token s)))
julia-parser.scm:        (begin (take-token s)
julia-parser.scm:               (macroify-name (parse-macro-name s)))
julia-parser.scm:        (parse-unary-prefix s))))
julia-parser.scm:(define (parse-import-dots s)
julia-parser.scm:             (t (require-token s)))  ;; skip newlines
julia-parser.scm:           (begin (take-token s)
julia-parser.scm:                  (loop (list* '|.| l) (peek-token s))))
julia-parser.scm:           (begin (take-token s)
julia-parser.scm:                  (loop (list* '|.| '|.| l) (peek-token s))))
julia-parser.scm:           (begin (take-token s)
julia-parser.scm:                  (loop (list* '|.| '|.| '|.| l) (peek-token s))))
julia-parser.scm:           (begin (take-token s)
julia-parser.scm:                  (loop (list* '|.| '|.| '|.| '|.| l) (peek-token s))))
julia-parser.scm:           (cons (parse-atsym s) l)))))
julia-parser.scm:(define (parse-import-path s word)
julia-parser.scm:  (let loop ((path (parse-import-dots s)))
julia-parser.scm:    (if (not (symbol-or-interpolate? (car path)))
julia-parser.scm:    (let ((nxt (peek-token s)))
julia-parser.scm:        (disallow-space s (car path) nxt)
julia-parser.scm:        (take-token s)
julia-parser.scm:        (loop (cons (unquote (parse-atsym s)) path)))
julia-parser.scm:            (eof-object? nxt))
julia-parser.scm:        (take-token s)
julia-parser.scm:(define (parse-import s word from)
julia-parser.scm:  (let ((path (parse-import-path s word)))
julia-parser.scm:    (if (eq? (peek-token s) 'as)
julia-parser.scm:              (error (string "invalid syntax \"using " (deparse-import-path path) " as ...\"")))
julia-parser.scm:          (take-token s)
julia-parser.scm:          `(as ,path ,(parse-atsym s)))
julia-parser.scm:;; parse comma-separated assignments, like "i=1:n,j=1:m,..."
julia-parser.scm:(define (parse-comma-separated s what)
julia-parser.scm:      (case (peek-token s)
julia-parser.scm:         (take-token s)
julia-parser.scm:(define (parse-comma-separated-assignments s)
julia-parser.scm:  (parse-comma-separated s parse-eq*))
julia-parser.scm:(define (parse-iteration-spec s)
julia-parser.scm:  (define (peek-token- s)
julia-parser.scm:    (let ((t (peek-token s)))
julia-parser.scm:      (if (and for-generator (newline? t))
julia-parser.scm:          (begin (take-token s)
julia-parser.scm:                 (peek-token s))
julia-parser.scm:  (let* ((lhs (let ((lhs- (with-space-sensitive (parse-pipe< s))))
julia-parser.scm:                (if (eq? lhs- 'outer)
julia-parser.scm:                    (let ((nxt (peek-token- s)))
julia-parser.scm:                          lhs-
julia-parser.scm:                          `(outer ,(parse-pipe< s))))
julia-parser.scm:                    lhs-)))
julia-parser.scm:         (t (peek-token- s)))
julia-parser.scm:          (take-token s)
julia-parser.scm:          `(= ,lhs ,(parse-pipe< s)))
julia-parser.scm:(define (parse-comma-separated-iters s)
julia-parser.scm:    (let ((r (parse-iteration-spec s)))
julia-parser.scm:      (case (peek-token s)
julia-parser.scm:        ((#\,)  (take-token s) (loop (cons r ranges)))
julia-parser.scm:(define (parse-space-separated-exprs s)
julia-parser.scm:  (with-space-sensitive
julia-parser.scm:     (if (or (closing-token? (peek-token s))
julia-parser.scm:             (newline? (peek-token s))
julia-parser.scm:             (and for-generator (eq? (peek-token s) 'for)))
julia-parser.scm:         (let ((e (parse-eq s)))
julia-parser.scm:           (case (peek-token s)
julia-parser.scm:(define (has-parameters? lst)
julia-parser.scm:(define (to-kws lst)
julia-parser.scm:  (map =-to-kw lst))
julia-parser.scm:;; like parse-arglist, but with `for` parsed as a generator
julia-parser.scm:(define (parse-call-arglist s closer)
julia-parser.scm:  (with-bindings ((for-generator #t))
julia-parser.scm:   (parse-arglist s closer)))
julia-parser.scm:;; handle function call argument list, or any comma-delimited list.
julia-parser.scm:(define (parse-arglist s closer (add-linenums #f))
julia-parser.scm:(with-bindings ((range-colon-enabled #t)
julia-parser.scm:                (space-sensitive #f)
julia-parser.scm:                (where-enabled #t)
julia-parser.scm:                (whitespace-newline #t))
julia-parser.scm:    (let ((t (require-token s)))
julia-parser.scm:          (begin (take-token s)
julia-parser.scm:                     (to-kws (reverse! lst))
julia-parser.scm:              (begin (take-token s) (require-token s)
julia-parser.scm:                     (let ((loc (line-number-node s))
julia-parser.scm:                                       (to-kws (reverse lst))
julia-parser.scm:                               ,@(if add-linenums
julia-parser.scm:              (let* ((nxt (parse-eq* s))
julia-parser.scm:                     (c (require-token s)))
julia-parser.scm:                       (take-token s)
julia-parser.scm:                       (expect-space-before s 'for)
julia-parser.scm:                       (take-token s)
julia-parser.scm:                       (loop (cons (parse-generator s nxt) lst)))
julia-parser.scm:(define (parse-vect s first closer)
julia-parser.scm:    (let ((t (require-token s)))
julia-parser.scm:          (begin (take-token s)
julia-parser.scm:             (take-token s)
julia-parser.scm:             (cond ((eqv? (require-token s) closer)
julia-parser.scm:                    (begin (take-token s)
julia-parser.scm:                   ((eqv? (require-token s) #\;)
julia-parser.scm:                    (let ((params (parse-arglist s closer)))
julia-parser.scm:                    (loop (cons nxt lst) (parse-eq* s)))))
julia-parser.scm:             (if (eqv? (require-token s) closer)
julia-parser.scm:                 (let ((params (parse-call-arglist s closer)))
julia-parser.scm:(define (parse-generator s first)
julia-parser.scm:  (let ((iters (parse-comma-separated-iters s)))
julia-parser.scm:    (let ((iters (if (eq? (peek-token s) 'if)
julia-parser.scm:                     (begin (take-token s)
julia-parser.scm:                            (list `(filter ,(parse-cond s) ,@iters)))
julia-parser.scm:      (if (eq? (peek-token s) 'for)
julia-parser.scm:          (begin (expect-space-before s 'for)
julia-parser.scm:                 (take-token s)
julia-parser.scm:                 `(flatten (generator ,(parse-generator s first) ,@iters)))
julia-parser.scm:(define (parse-comprehension s first closer)
julia-parser.scm:  (with-bindings ((whitespace-newline #t)
julia-parser.scm:                  (space-sensitive #f))
julia-parser.scm:   (let ((gen (parse-generator s first)))
julia-parser.scm:     (if (not (eqv? (require-token s) closer))
julia-parser.scm:         (take-token s))
julia-parser.scm:(define (parse-array s first closer gotnewline last-end-symbol)
julia-parser.scm:        (ncons a (1- n) (cons a l))))
julia-parser.scm:  (define (fix-level ah n)
julia-parser.scm:             (fixcat 'nrow (1- n) ah))))
julia-parser.scm:  (define (collapse-level n l i)
julia-parser.scm:        (let* ((lhfix (fix-level (car l) i))
julia-parser.scm:          (collapse-level (1- n) lnew (1+ i)))
julia-parser.scm:  (define (parse-array-inner s a is-row-first semicolon-count max-level closer gotnewline gotlinesep)
julia-parser.scm:    (define (process-semicolon next)
julia-parser.scm:      (set! semicolon-count (1+ semicolon-count))
julia-parser.scm:      (set! max-level (max max-level semicolon-count))
julia-parser.scm:      (if (and (null? is-row-first) (= semicolon-count 2) (not (eqv? next #\;)))
julia-parser.scm:          ; finding ;; that isn't a row-separator makes it column-first
julia-parser.scm:          (set! is-row-first #f))
julia-parser.scm:      (set! a (collapse-level 1 a semicolon-count)))
julia-parser.scm:    (define (restore-lower-dim-lists next)
julia-parser.scm:          (set! a (ncons '() semicolon-count a))))
julia-parser.scm:    (let ((t (if (or gotnewline (eqv? (peek-token s) #\newline))
julia-parser.scm:                 (require-token s))))
julia-parser.scm:            (take-token s)
julia-parser.scm:            (set! a (collapse-level (- max-level semicolon-count) a (1+ semicolon-count)))
julia-parser.scm:            (cond ((= max-level 0)
julia-parser.scm:                  ((= max-level 1)
julia-parser.scm:                   (fixcat 'ncat max-level (car a)))))
julia-parser.scm:         (or gotnewline (take-token s))
julia-parser.scm:         (let ((next (peek-token s)))
julia-parser.scm:           (if (and (> semicolon-count 0) (eqv? next #\;))
julia-parser.scm:           (if (and (= semicolon-count 0)
julia-parser.scm:                (process-semicolon next))
julia-parser.scm:           (restore-lower-dim-lists next)
julia-parser.scm:           (parse-array-inner s a is-row-first semicolon-count max-level closer #f gotlinesep)))
julia-parser.scm:         (or gotnewline (take-token s))
julia-parser.scm:         (if (and (> semicolon-count 0) (ts:space? s)) ; disallow [a; ;b]
julia-parser.scm:         (let ((next (peek-token s)))
julia-parser.scm:           (let ((is-line-sep
julia-parser.scm:                 (if (and (not (null? is-row-first)) is-row-first (= semicolon-count 1))
julia-parser.scm:                           ((not (or (eof-object? next) (eqv? next #\;))) ; [a b ;;...
julia-parser.scm:             (if is-line-sep
julia-parser.scm:                        (set! max-level
julia-parser.scm:                                  max-level)))
julia-parser.scm:                 (begin (process-semicolon next)
julia-parser.scm:                        (restore-lower-dim-lists next)))
julia-parser.scm:           (parse-array-inner s a is-row-first semicolon-count max-level closer #f is-line-sep))))
julia-parser.scm:               ;;(expect-space-before s 'for)
julia-parser.scm:               (take-token s)
julia-parser.scm:               (parse-comprehension s (caar a) closer))
julia-parser.scm:         (let ((u (parse-eq* s)))
julia-parser.scm:               (if (null? is-row-first)
julia-parser.scm:                   (set! is-row-first #t)
julia-parser.scm:                   (if (not is-row-first)
julia-parser.scm:         (parse-array-inner s a is-row-first 0 max-level closer #f #f))))))
julia-parser.scm:  (with-bindings ((end-symbol last-end-symbol))
julia-parser.scm:    (parse-array-inner s (list (list first)) '() 0 0 closer gotnewline #f)))
julia-parser.scm:(define (expect-space-before s t)
julia-parser.scm:(define (parse-cat s closer last-end-symbol)
julia-parser.scm:  (with-bindings ((range-colon-enabled #t)
julia-parser.scm:                  (space-sensitive #t)
julia-parser.scm:                  (where-enabled #t)
julia-parser.scm:                  (whitespace-newline #f)
julia-parser.scm:                  (for-generator #t))
julia-parser.scm:    (if (eqv? (require-token s) closer)
julia-parser.scm:        (begin (take-token s)
julia-parser.scm:        (let* ((first (parse-eq* s))
julia-parser.scm:               (t (peek-token s)))
julia-parser.scm:                 (parse-vect s first closer))
julia-parser.scm:                 (expect-space-before s 'for)
julia-parser.scm:                 (take-token s)
julia-parser.scm:                 (parse-comprehension s first closer))
julia-parser.scm:                 (take-token s)
julia-parser.scm:                 (if (memv (peek-token s) (list #\, closer))
julia-parser.scm:                     (parse-vect s first closer)
julia-parser.scm:                     (parse-array s first closer #t last-end-symbol)))
julia-parser.scm:                 (parse-array s first closer #f last-end-symbol)))))))
julia-parser.scm:(define (kw-to-= e) (if (kwarg? e) (cons '= (cdr e)) e))
julia-parser.scm:(define (=-to-kw e) (if (assignment? e) (cons 'kw (cdr e)) e))
julia-parser.scm:;; this allows us to first parse tuples using parse-arglist
julia-parser.scm:(define (parameters-to-block e)
julia-parser.scm:               (let ((rec (parameters-to-block (cadr e2))))
julia-parser.scm:                     (let ((rec (parameters-to-block fst))
julia-parser.scm:                           (snd (parameters-to-block snd)))
julia-parser.scm:      (list (kw-to-= e))))
julia-parser.scm:(define (rm-linenums e)
julia-parser.scm:      (map rm-linenums
julia-parser.scm:;; leading-semi? means we saw (; ...)
julia-parser.scm:(define (arglist-to-tuple s leading-semi? comma? args . first)
julia-parser.scm:  (if (and (pair? first) (null? args) (not leading-semi?) (not comma?))
julia-parser.scm:               (let ((blk (parameters-to-block (car args))))
julia-parser.scm:                 (and blk (or (and (not leading-semi?)
julia-parser.scm:          (rm-linenums
julia-parser.scm:               `(tuple ,(car args) ,@first ,@(map kw-to-= (cdr args)))
julia-parser.scm:               `(tuple ,@first ,@(map kw-to-= args)))))))
julia-parser.scm:(define (tuple-to-arglist e)
julia-parser.scm:  (cond ((eq? (car e) 'tuple)  (map =-to-kw (cdr e)))
julia-parser.scm:               ((length= e 2) (list (=-to-kw (cadr e))))
julia-parser.scm:                `((parameters ,(=-to-kw (caddr e))) ,(=-to-kw (cadr e))))
julia-parser.scm:         (list (=-to-kw e)))))
julia-parser.scm:(define invalid-identifier? (Set (list* '.... '? '|.'| syntactic-operators)))
julia-parser.scm:(define-macro (check-identifier ex)
julia-parser.scm:  `(if (invalid-identifier? ,ex)
julia-parser.scm:(define (parse-paren s (checked #t)) (car (parse-paren- s checked)))
julia-parser.scm:(define (parse-paren- s checked)
julia-parser.scm:  (with-bindings
julia-parser.scm:   ((range-colon-enabled #t)
julia-parser.scm:    (space-sensitive #f)
julia-parser.scm:    (where-enabled #t)
julia-parser.scm:    (whitespace-newline #t))
julia-parser.scm:   (let ((nxt (require-token s)))
julia-parser.scm:       (begin (take-token s) '((tuple) . #t)))
julia-parser.scm:      ((syntactic-op? nxt)
julia-parser.scm:       (let ((tok (take-token s)))
julia-parser.scm:         (if (not (eqv? (require-token s) #\) ))
julia-parser.scm:             (take-token s))
julia-parser.scm:         (if checked (check-identifier tok))
julia-parser.scm:              (or (and (take-token s) (eqv? (require-token s) #\) ))
julia-parser.scm:                  (and (ts:put-back! s '|::| spc) #f))))
julia-parser.scm:       (take-token s)  ;; take #\)
julia-parser.scm:       (let ((ex (arglist-to-tuple s #t #f (parse-arglist s #\) ))))
julia-parser.scm:       (let* ((ex (parse-eq* s))
julia-parser.scm:              (t  (require-token s)))
julia-parser.scm:                (take-token s)
julia-parser.scm:                (take-token s)
julia-parser.scm:                (cons (arglist-to-tuple s #f #t (parse-arglist s #\) ) ex)
julia-parser.scm:                (cons (arglist-to-tuple
julia-parser.scm:                       (parse-arglist s #\) #t)
julia-parser.scm:                (expect-space-before s 'for)
julia-parser.scm:                (take-token s)
julia-parser.scm:                (let ((gen (parse-generator s ex)))
julia-parser.scm:                  (if (eqv? (require-token s) #\) )
julia-parser.scm:                      (take-token s)
julia-parser.scm:(define (not-eof-for delim c)
julia-parser.scm:  (if (eof-object? c)
julia-parser.scm:(define (take-char p)
julia-parser.scm:  (begin (read-char p) p))
julia-parser.scm:(define (map-first f lst)
julia-parser.scm:;; e.g., (map-at odd? (lambda (x) 0) '(a b c d)) -> '(a 0 c 0)
julia-parser.scm:(define (map-at pred f lst)
julia-parser.scm:  (define (map-at- pred f lst i r)
julia-parser.scm:          (map-at- pred f (cdr lst) (+ i 1) (cons y r)))))
julia-parser.scm:  (map-at- pred f lst 0 ()))
julia-parser.scm:(define (parse-raw-literal s delim)
julia-parser.scm:  (car (parse-string-literal s delim #t)))
julia-parser.scm:(define (unescape-parsed-string-literal strs)
julia-parser.scm:  (map-at even? unescape-string strs))
julia-parser.scm:(define (strip-escaped-newline s raw)
julia-parser.scm:                   (if (string? s) (strip-escaped-newline- s) s))
julia-parser.scm:(define (strip-escaped-newline- s)
julia-parser.scm:  (let ((in  (open-input-string s))
julia-parser.scm:        (out (open-output-string)))
julia-parser.scm:    (define (loop preceding-backslash?)
julia-parser.scm:          (let ((c (read-char in)))
julia-parser.scm:            (cond ((eof-object? c))
julia-parser.scm:                  (preceding-backslash?
julia-parser.scm:                       (begin (write-char #\\ out) (write-char c out))
julia-parser.scm:                       ((define (loop-)
julia-parser.scm:                          (if (memv (peek-char in) '(#\space #\tab))
julia-parser.scm:                              (begin (take-char in) (loop-))))))
julia-parser.scm:                  (else (write-char c out) (loop #f)))))
julia-parser.scm:(define (parse-string-literal s delim raw)
julia-parser.scm:         (str (if (eqv? (peek-char p) delim)
julia-parser.scm:                  (if (eqv? (peek-char (take-char p)) delim)
julia-parser.scm:                      (map-first strip-leading-newline
julia-parser.scm:                                 (dedent-triplequoted-string
julia-parser.scm:                                   (strip-escaped-newline
julia-parser.scm:                                     (parse-string-literal- 2 (take-char p) s delim raw)
julia-parser.scm:                  (strip-escaped-newline
julia-parser.scm:                    (parse-string-literal- 0 p s delim raw)
julia-parser.scm:    (if raw str (unescape-parsed-string-literal str))))
julia-parser.scm:(define (strip-leading-newline s)
julia-parser.scm:(define (dedent-triplequoted-string lst)
julia-parser.scm:  (let ((prefix (triplequoted-string-indentation lst)))
julia-parser.scm:        (map-at even?
julia-parser.scm:                  (string-replace s
julia-parser.scm:                                  (list->string (cons #\newline prefix))
julia-parser.scm:(define (triplequoted-string-indentation lst)
julia-parser.scm:  (longest-common-prefix
julia-parser.scm:                                      (triplequoted-string-indentation- s)
julia-parser.scm:(define (triplequoted-string-indentation- s)
julia-parser.scm:  (let ((p (open-input-string s)))
julia-parser.scm:    (let loop ((c (read-char p))
julia-parser.scm:        (loop (read-char p) 1 () prefixes))
julia-parser.scm:        (if (eof-object? c) prefixes
julia-parser.scm:            (loop (read-char p) 0 () prefixes)))
julia-parser.scm:        (loop (read-char p) 2 (cons c prefix) prefixes))
julia-parser.scm:        (loop (read-char p) 0 () (cons (reverse prefix) prefixes)))))))
julia-parser.scm:;; e.g., (longest-common-prefix ((1 2) (1 4))) -> (1)
julia-parser.scm:(define (longest-common-prefix l)
julia-parser.scm:     (else (longest-common-prefix
julia-parser.scm:            (cons (longest-common-prefix2 (car l) (cadr l))
julia-parser.scm:(define (longest-common-prefix2 a b)
julia-parser.scm:  (longest-common-prefix2- a b ()))
julia-parser.scm:(define (longest-common-prefix2- a b p)
julia-parser.scm:      (longest-common-prefix2- (cdr a) (cdr b) (cons (car a) p))
julia-parser.scm:(define (string-split s sep)
julia-parser.scm:  (string-split- s sep 0 ()))
julia-parser.scm:(define (string-split- s sep start splits)
julia-parser.scm:        (string-split- s sep (+ i (sizeof sep)) (cons (string.sub s start i) splits))
julia-parser.scm:(define (string-replace s a b)
julia-parser.scm:  (string.join (string-split s a) b))
julia-parser.scm:(define (ends-interpolated-atom? c)
julia-parser.scm:  (or (eof-object? c) (opchar? c) (never-identifier-char? c)))
julia-parser.scm:(define (parse-interpolate s)
julia-parser.scm:         (c (peek-char p)))
julia-parser.scm:    (cond ((identifier-start-char? c)
julia-parser.scm:           (let* ((t (require-token s))
julia-parser.scm:                  (c (peek-char p)))
julia-parser.scm:             (if (ends-interpolated-atom? c)
julia-parser.scm:                 (take-token s)
julia-parser.scm:           (read-char p)
julia-parser.scm:           (let ((ex (parse-eq* s))
julia-parser.scm:                 (t (require-token s)))
julia-parser.scm:                    (take-token s)
julia-parser.scm:(define (parse-string-literal- n p s delim raw)
julia-parser.scm:  (let loop ((c (read-char p))
julia-parser.scm:             (b (open-output-string))
julia-parser.scm:           (loop (read-char p) b e (+ quotes 1))
julia-parser.scm:       (if (not raw) (write-char #\\ b))
julia-parser.scm:       (write-char delim b)
julia-parser.scm:       (if (not raw) (write-char #\\ b))
julia-parser.scm:       (write-char delim b)
julia-parser.scm:       (if (not raw) (write-char #\\ b))
julia-parser.scm:       (write-char delim b)
julia-parser.scm:                             (nxch (not-eof-for delim (read-char p))))
julia-parser.scm:                                 (not-eof-for delim (read-char p))))
julia-parser.scm:                        (begin (write-char delim b)
julia-parser.scm:                               (loop (read-char p) b e 0))
julia-parser.scm:                    (write-char nxch b)
julia-parser.scm:                    (loop (read-char p) b e 0))))
julia-parser.scm:           (let ((nxch (not-eof-for delim (read-char p))))
julia-parser.scm:             (write-char #\\ b)
julia-parser.scm:                   (write-char nxch b)
julia-parser.scm:                   (loop (read-char p) b e 0))))))
julia-parser.scm:       (let* ((ex (parse-interpolate s))
julia-parser.scm:         (loop (read-char p)
julia-parser.scm:               (open-output-string)
julia-parser.scm:         (if (eqv? (peek-char p) #\linefeed) ; \r\n
julia-parser.scm:             (read-char p))
julia-parser.scm:         (write-char #\newline b)
julia-parser.scm:         (loop (read-char p) b e 0)))
julia-parser.scm:       (write-char (not-eof-for delim c) b)
julia-parser.scm:       (loop (read-char p) b e 0)))))
julia-parser.scm:(define (not-eof-1 c)
julia-parser.scm:  (if (eof-object? c)
julia-parser.scm:(define (unescape-string s)
julia-parser.scm:  (with-exception-catcher
julia-parser.scm:     (read (open-input-string (string #\" s #\"))))))
julia-parser.scm:(define (parse-atom s (checked #t))
julia-parser.scm:  (let ((t (require-token s)))
julia-parser.scm:           (take-token s)
julia-parser.scm:           (let ((firstch (read-char (ts:port s))))
julia-parser.scm:                        (not (eof-object? firstch))
julia-parser.scm:                        (eqv? (peek-char (ts:port s)) #\'))
julia-parser.scm:                   (begin (read-char (ts:port s)) firstch)
julia-parser.scm:                   (let ((b (open-output-string)))
julia-parser.scm:                                  (write-char (not-eof-1 c) b)
julia-parser.scm:                                      (write-char (not-eof-1 (read-char (ts:port s)))
julia-parser.scm:                                  (loop (read-char (ts:port s))))))
julia-parser.scm:                     (let ((str (unescape-string (io.tostring! b))))
julia-parser.scm:                       (let ((len (string-length str)))
julia-parser.scm:           (take-token s)
julia-parser.scm:           (let ((nxt (peek-token s)))
julia-parser.scm:             (if (and (closing-token? nxt)
julia-parser.scm:                           ;; being inside quote makes `end` non-special again. issue #27690
julia-parser.scm:                           (with-bindings ((end-symbol #f))
julia-parser.scm:                                          (parse-atom s #f))))))))
julia-parser.scm:               (begin (check-identifier t)
julia-parser.scm:                      (if (closing-token? t)
julia-parser.scm:                          (error (string "unexpected \"" (take-token s) "\"")))))
julia-parser.scm:           (take-token s)
julia-parser.scm:                       (if (or (ts:pbtok s) (ts:last-tok s))
julia-parser.scm:                           (and (eqv? (peek-token s) #\") (not (ts:space? s)))
julia-parser.scm:                           ;; Hack: avoid peek-token if possible to preserve
julia-parser.scm:                           ;; (io.pos (ts:port s)) for non-greedy Meta.parse
julia-parser.scm:                           (eqv? (peek-char (ts:port s)) #\")))
julia-parser.scm:                  (peek-token s)
julia-parser.scm:                  (take-token s) ;; leading "
julia-parser.scm:                  (let ((str (parse-raw-literal s #\"))
julia-parser.scm:                        (nxt (peek-token s)))
julia-parser.scm:           (take-token s)
julia-parser.scm:           (parse-paren s checked))
julia-parser.scm:           (take-token s)
julia-parser.scm:           (let ((vex (parse-cat s #\] end-symbol)))
julia-parser.scm:           (take-token s)
julia-parser.scm:           (if (eqv? (require-token s) #\})
julia-parser.scm:               (begin (take-token s)
julia-parser.scm:               (let ((vex (parse-cat s #\} end-symbol)))
julia-parser.scm:           (take-token s)
julia-parser.scm:           (let ((ps (parse-string-literal s #\" #f)))
julia-parser.scm:           (take-token s)
julia-parser.scm:           (with-space-sensitive
julia-parser.scm:            (let ((startloc  (line-number-node s))
julia-parser.scm:                  (head (parse-macro-name s)))
julia-parser.scm:              (peek-token s)
julia-parser.scm:                  (maybe-docstring
julia-parser.scm:                   s `(macrocall ,(macroify-name head)
julia-parser.scm:                                 ,@(parse-space-separated-exprs s)))
julia-parser.scm:                  (let ((call (parse-call-chain s head #t)))
julia-parser.scm:                    (macroify-call s call startloc))))))
julia-parser.scm:           (take-token s)
julia-parser.scm:           `(macrocall (core @cmd) ,(line-number-node s) ,(parse-raw-literal s #\`)))
julia-parser.scm:          ((or (string? t) (number? t) (large-number? t)) (take-token s))
julia-parser.scm:          ((closing-token? t) (error (string "unexpected \"" (take-token s) "\"")))
julia-parser.scm:          (else (error (string "invalid syntax: \"" (take-token s) "\""))))))
julia-parser.scm:(define (valid-modref? e)
julia-parser.scm:           (valid-modref? (cadr e)))))
julia-parser.scm:(define (macroify-name e . suffixes)
julia-parser.scm:        ((valid-modref? e)
julia-parser.scm:               (quote ,(apply macroify-name (cadr (caddr e)) suffixes))))
julia-parser.scm:(define (macroify-call s call startloc)
julia-parser.scm:         `(macrocall ,(macroify-name (cadr call))
julia-parser.scm:         `(do ,(macroify-call s (cadr call) startloc) ,(caddr call)))
julia-parser.scm:         (maybe-docstring
julia-parser.scm:          s `(macrocall ,(macroify-name call)
julia-parser.scm:                        ,@(parse-space-separated-exprs s))))))
julia-parser.scm:(define (called-macro-name e)
julia-parser.scm:      (called-macro-name (cadr (caddr e)))
julia-parser.scm:(define (maybe-docstring s e)
julia-parser.scm:           (eq? (called-macro-name (cadr e)) '@doc))
julia-parser.scm:        (let loop ((t  (peek-token s))
julia-parser.scm:          (cond ((closing-token? t) e)
julia-parser.scm:                     (begin (take-token s)
julia-parser.scm:                            (loop (peek-token s) 1))))
julia-parser.scm:                 `(,@e ,(parse-eq s))))))
julia-parser.scm:(define (simple-string-literal? e) (string? e))
julia-parser.scm:(define (doc-string-literal? s e)
julia-parser.scm:  (or (simple-string-literal? e)
julia-parser.scm:(define (parse-docstring s production)
julia-parser.scm:  (let ((startloc (line-number-node s)) ; be sure to use the line number from the head of the docstring
julia-parser.scm:    (if (and (doc-string-literal? s ex)
julia-parser.scm:             (let loop ((t  (peek-token s))
julia-parser.scm:               (cond ((closing-token? t) #f)
julia-parser.scm:                          (begin (take-token s)
julia-parser.scm:                                 (loop (peek-token s) 1))))
julia-parser.scm:;; --- main entry point ---
julia-parser.scm:;; default is parse-stmts.
julia-parser.scm:(define (julia-parse s . production)
julia-parser.scm:         (apply julia-parse (make-token-stream (open-input-string s))
julia-parser.scm:         (apply julia-parse (make-token-stream s) production))
julia-parser.scm:        ((eof-object? s)
julia-parser.scm:         (skip-ws-and-comments (ts:port s))
julia-parser.scm:         (let skip-loop ((tok (peek-token s)))
julia-parser.scm:               (begin (take-token s) (skip-loop (peek-token s)))))
julia-parser.scm:         (if (eof-object? (peek-token s))
julia-parser.scm:             (eof-object)
julia-parser.scm:             ((if (null? production) parse-stmts (car production))
init.c:    // Only use pthread_*_np functions to get stack address for non-master
init.c:    *stack_lo = (void*)((char*)*stack_hi - stacksize);
init.c:    item->h = handle;
init.c:    item->next = NULL;
init.c:    if (queue->last)
init.c:        queue->last->next = item;
init.c:    if (!queue->first)
init.c:        queue->first = item;
init.c:    queue->last = item;
init.c:    struct uv_shutdown_queue_item *rv = item->next;
init.c:    if (handle->type != UV_FILE && uv_is_closing(handle))
init.c:    switch(handle->type) {
init.c:        if (handle->data)
init.c:            jl_uv_call_close_callback((jl_value_t*)handle->data);
init.c:        ((uv_process_t*)handle)->pid = 0;
init.c:        // fall-through
init.c:                size_t last_age = ct->world_age;
init.c:                ct->world_age = jl_get_world_counter();
init.c:                ct->world_age = last_age;
init.c:                    jl_close_item_atexit(item->h);
init.c:                //error handling -- continue cleanup, as much as possible
init.c:                uv_unref(item->h);
init.c:            jl_close_item_atexit(item->h);
init.c:    loop->stop_flag = 0;
init.c:    /* _get_osfhandle will sometimes return -2 in case of an error. This seems */
init.c:    /* (HANDLE) -2, so this situation goes unnoticed until someone tries to */
init.c:    /* use the duplicate. Therefore we filter out known-invalid handles here. */
init.c:        fd == (HANDLE) -2) {
init.c:    if ((*dupfd = fcntl(fd, F_DUPFD_CLOEXEC, 3)) == -1)
init.c:        return -errno;
init.c:        ((uv_tty_t*)handle)->data = NULL;
init.c:            assert(nullfd != -1);
init.c:            file->loop = jl_io_loop;
init.c:            file->type = UV_FILE;
init.c:            file->file = fd;
init.c:            file->data = NULL;
init.c:        ((uv_pipe_t*)handle)->data = NULL;
init.c:        ((uv_tcp_t*)handle)->data = NULL;
init.c:// create an absolute-path copy of the input path format string
init.c:    for (i = 0; i < path_size; i++) { // copy-replace pwd portion
init.c:    ct->ptls->io_wait = v;
init.c:        jl_error("cannot generate code-coverage or track allocation information while generating a .o, .bc, or .s output file");
init.c:        jl_core_module->parent = jl_core_module;
init.c:        jl_type_typename->mt->module = jl_core_module;
init.c:            size_t last_age = ct->world_age;
init.c:            ct->world_age = jl_get_world_counter();
init.c:            ct->world_age = last_age;
init.c:    jl_bool_type->super = jl_integer_type;
init.c:    jl_uint8_type->super = jl_unsigned_type;
init.c:    jl_int32_type->super = jl_signed_type;
init.c:    jl_int64_type->super = jl_signed_type;
init.c:    jl_uint32_type->super = jl_unsigned_type;
init.c:    jl_uint64_type->super = jl_unsigned_type;
init.c:    jl_vecelement_typename = ((jl_datatype_t*)jl_unwrap_unionall(core("VecElement")))->name;
init.c:    void **table = jl_core_module->bindings.table;
init.c:    for (i = 1; i < jl_core_module->bindings.size; i += 2) {
init.c:            jl_value_t *v = jl_atomic_load_relaxed(&b->value);
init.c:                    tt->name->module = jl_core_module;
init.c:                    if (tt->name->mt)
init.c:                        tt->name->mt->module = jl_core_module;
signals-win.c:// Note that this file is `#include`d by "signal-handling.c"
signals-win.c:    if (force || (!ct->ptls->defer_signal && ct->ptls->io_wait)) {
signals-win.c:    stkerror_ptls->bt_size =
signals-win.c:        rec_backtrace_ctx(stkerror_ptls->bt_data, JL_MAX_BT_SIZE, stkerror_ctx,
signals-win.c:    // turn on ctrl-c handler
signals-win.c:    jl_ptls_t ptls = ct->ptls;
signals-win.c:    DWORD64 Rsp = (ctxThread->Rsp & (DWORD64)-16) - 8;
signals-win.c:    DWORD32 Esp = (ctxThread->Esp & (DWORD32)-16) - 4;
signals-win.c:        ptls->bt_size = 0;
signals-win.c:            ptls->bt_size = rec_backtrace_ctx(ptls->bt_data, JL_MAX_BT_SIZE, ctxThread,
signals-win.c:                                              ct->gcstack);
signals-win.c:        ptls->sig_exception = excpt;
signals-win.c:    ctxThread->Rsp = Rsp;
signals-win.c:    ctxThread->Rip = (DWORD64)&jl_sig_throw;
signals-win.c:    ctxThread->Esp = Esp;
signals-win.c:    ctxThread->Eip = (DWORD)&jl_sig_throw;
signals-win.c:    if ((DWORD)-1 == SuspendThread(hMainThread)) {
signals-win.c:    if (force || (!ptls2->defer_signal && ptls2->io_wait)) {
signals-win.c:    if ((DWORD)-1 == ResumeThread(hMainThread)) {
signals-win.c:    jl_ptls_t ptls = jl_current_task->ptls;
signals-win.c:    if (ExceptionInfo->ExceptionRecord->ExceptionFlags == 0) {
signals-win.c:        switch (ExceptionInfo->ExceptionRecord->ExceptionCode) {
signals-win.c:                jl_throw_in_ctx(jl_diverror_exception, ExceptionInfo->ContextRecord);
signals-win.c:                ptls->needs_resetstkoflw = 1;
signals-win.c:                jl_throw_in_ctx(jl_stackovf_exception, ExceptionInfo->ContextRecord);
signals-win.c:                if (jl_addr_is_safepoint(ExceptionInfo->ExceptionRecord->ExceptionInformation[1])) {
signals-win.c:                    if (ptls->tid != 0)
signals-win.c:                    if (ptls->defer_signal) {
signals-win.c:                        jl_throw_in_ctx(jl_interrupt_exception, ExceptionInfo->ContextRecord);
signals-win.c:                    jl_throw_in_ctx(NULL, ExceptionInfo->ContextRecord);
signals-win.c:                if (ExceptionInfo->ExceptionRecord->ExceptionInformation[0] == 1) { // writing to read-only memory (e.g. mmap)
signals-win.c:                    jl_throw_in_ctx(jl_readonlymemory_exception, ExceptionInfo->ContextRecord);
signals-win.c:        if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_ILLEGAL_INSTRUCTION) {
signals-win.c:            jl_show_sigill(ExceptionInfo->ContextRecord);
signals-win.c:        switch (ExceptionInfo->ExceptionRecord->ExceptionCode) {
signals-win.c:        jl_safe_printf(" at 0x%Ix -- ", (size_t)ExceptionInfo->ExceptionRecord->ExceptionAddress);
signals-win.c:        jl_print_native_codeloc((uintptr_t)ExceptionInfo->ExceptionRecord->ExceptionAddress);
signals-win.c:        jl_critical_error(0, ExceptionInfo->ContextRecord);
signals-win.c:    // Note: illegal to use jl_* functions from this thread except for profiling-specific functions
signals-win.c:                if ((DWORD)-1 == SuspendThread(hMainThread)) {
signals-win.c:                            bt_size_max - bt_size_cur - 1, &ctxThread, NULL);
signals-win.c:                    bt_data_prof[bt_size_cur++].uintptr = ptls->tid + 1;
signals-win.c:                    bt_data_prof[bt_size_cur++].uintptr = ptls->current_task;
signals-win.c:                    bt_data_prof[bt_size_cur++].uintptr = ptls->sleep_check_state + 1;
signals-win.c:                if ((DWORD)-1 == ResumeThread(hMainThread)) {
signals-win.c:            return -2;
signals-win.c:            return -1;
signals-win.c:        if ((DWORD)-1 == ResumeThread(hBtThread)) {
signals-win.c:            return -2;
simplevector.c:    jl_svec_t *v = (jl_svec_t*)jl_gc_alloc(ct->ptls, sizeof(void*) * 2,
simplevector.c:    jl_svec_t *v = (jl_svec_t*)jl_gc_alloc(ct->ptls, sizeof(void*) * 3,
simplevector.c:    jl_svec_t *jv = (jl_svec_t*)jl_gc_alloc(ct->ptls, (n + 1) * sizeof(void*),
processor.cpp:#include "llvm-version.h"
processor.cpp://     When used in negative form (i.e. `-clone_all`), this disables full clone that's
processor.cpp:// 2. `base([0-9]*)`
processor.cpp://     This specifies the (0-based) base target index. The base target is the target
processor.cpp://     Optimize for size with minimum performance impact. Clang/GCC's `-Os`.
processor.cpp://     Optimize only for size. Clang's `-Oz`.
processor.cpp:struct gen_seq : gen_seq<N-1, N-1, Is...>{};
processor.cpp:            features.emplace_back(start, p - start);
processor.cpp:        features.emplace_back(start, p - start);
processor.cpp:        for (ssize_t i = ndeps - 1; i >= 0; i--) {
processor.cpp:        for (ssize_t i = ndeps - 1; i >= 0; i--) {
processor.cpp:        return spec->name;
processor.cpp:    return (uint32_t)-1;
processor.cpp:// Try getting clone base argument. Return 1-based index. Return 0 if match failed.
processor.cpp:    if (end - start <= prefix_len)
processor.cpp:                arg.name.append(start, p - start);
processor.cpp:            if (*full == '-') {
processor.cpp:            if (llvm::StringRef(fname, p - fname) == "clone_all") {
processor.cpp:            else if (llvm::StringRef(fname, p - fname) == "opt_size") {
processor.cpp:            else if (llvm::StringRef(fname, p - fname) == "min_size") {
processor.cpp:                base -= 1;
processor.cpp:            else if (llvm::StringRef(fname, p - fname) == "help") {
processor.cpp:                if (!feature_cb(fname, p - fname, list)) {
processor.cpp:                    arg.ext_features += disable ? '-' : '+';
processor.cpp:                    arg.ext_features.append(fname, p - fname);
processor.cpp:        tag_len = clone_idxs[-1];
processor.cpp:                     "without a `--output-` flag specified");
processor.cpp:                     "without a `--output-` flag specified");
processor.cpp:                     "without a `--output-` flag specified");
processor.cpp:                     "without a `--output-` flag specified");
processor.cpp:    uint32_t best_idx{(uint32_t)-1};
processor.cpp:    if (match.best_idx == (uint32_t)-1)
subtype.c:  - Type variables can be restricted to range over only concrete types.
subtype.c:  - Diagonal rule: a type variable is concrete if it occurs more than once in
subtype.c:  - Unconstrained type vars (Bottom<:T<:Any) can match non-type values.
subtype.c:  - Vararg types have an int-valued length parameter N (in `Vararg{T,N}`).
subtype.c:  - Type{T}<:S if isa(T,S). Existing code assumes this, but it's not strictly
subtype.c:  - Free type variables are tolerated. This can hopefully be removed after a
subtype.c:    // 0 - var.ub <: type ? var : ub
subtype.c:    // 1 - var.ub = ub; return var
subtype.c:    // 2 - either (var.ub = ub; return var), or return ub
subtype.c:    int8_t intvalued;      // must be integer-valued; i.e. occurs as N in Vararg{_,N}
subtype.c:    // N.B.: envout is gc-rooted
subtype.c:    jl_value_t **envout;      // for passing caller the computed bounds of right-side variables
subtype.c:    jl_varbinding_t *b = e->vars;
subtype.c:        if (b->var == v) return b;
subtype.c:        b = b->prev;
subtype.c:    assert(i >= 0 && i < sizeof(st->stack) * 8);
subtype.c:    // get the `i`th bit in an array of 32-bit words
subtype.c:    return (st->stack[i>>5] & (1u<<(i&31))) != 0;
subtype.c:    assert(i >= 0 && i < sizeof(st->stack) * 8);
subtype.c:        st->stack[i>>5] |= (1u<<(i&31));
subtype.c:        st->stack[i>>5] &= ~(1u<<(i&31));
subtype.c:        (saved)->depth = (src)->depth;                                  \
subtype.c:        (saved)->more = (src)->more;                                    \
subtype.c:        (saved)->used = (src)->used;                                    \
subtype.c:        (saved)->stack = alloca(((src)->used+7)/8);                     \
subtype.c:        memcpy((saved)->stack, &(src)->stack, ((src)->used+7)/8);       \
subtype.c:        (dst)->depth = (saved)->depth;                                  \
subtype.c:        (dst)->more = (saved)->more;                                    \
subtype.c:        (dst)->used = (saved)->used;                                    \
subtype.c:        memcpy(&(dst)->stack, (saved)->stack, ((saved)->used+7)/8);     \
subtype.c:    jl_varbinding_t *v = e->vars;
subtype.c:        v = v->prev;
subtype.c:    se->buf = (int8_t*)(len > 8 ? malloc_s(len * 2) : &se->_space);
subtype.c:    memset(se->buf, 0, len * 2);
subtype.c:    int i=0, j=0; v = e->vars;
subtype.c:            jl_svecset(*root, i++, v->lb);
subtype.c:            jl_svecset(*root, i++, v->ub);
subtype.c:            jl_svecset(*root, i++, (jl_value_t*)v->innervars);
subtype.c:        se->buf[j++] = v->occurs_inv;
subtype.c:        se->buf[j++] = v->occurs_cov;
subtype.c:        v = v->prev;
subtype.c:    se->rdepth = e->Runions.depth;
subtype.c:    if (se->buf != se->_space)
subtype.c:        free(se->buf);
subtype.c:    se->buf = NULL;
subtype.c:    jl_varbinding_t *v = e->vars;
subtype.c:        if (root) v->lb = jl_svecref(root, i);
subtype.c:        if (root) v->ub = jl_svecref(root, i);
subtype.c:        if (root) v->innervars = (jl_array_t*)jl_svecref(root, i);
subtype.c:        v->occurs_inv = se->buf[j++];
subtype.c:        v->occurs_cov = se->buf[j++];
subtype.c:        v = v->prev;
subtype.c:    e->Runions.depth = se->rdepth;
subtype.c:    if (e->envout && e->envidx < e->envsz)
subtype.c:        memset(&e->envout[e->envidx], 0, (e->envsz - e->envidx)*sizeof(void*));
subtype.c:    if (a == (jl_value_t*)jl_typeofbottom_type->super)
subtype.c:    if (b == (jl_value_t*)jl_typeofbottom_type->super)
subtype.c:        if (ad->name != bd->name) return 0;
subtype.c:        if (ad->isconcretetype || bd->isconcretetype) return 0;
subtype.c:        return obviously_egal(((jl_uniontype_t*)a)->a, ((jl_uniontype_t*)b)->a) &&
subtype.c:            obviously_egal(((jl_uniontype_t*)a)->b, ((jl_uniontype_t*)b)->b);
subtype.c:        return ((jl_unionall_t*)a)->var == ((jl_unionall_t*)b)->var &&
subtype.c:            obviously_egal(((jl_unionall_t*)a)->body, ((jl_unionall_t*)b)->body);
subtype.c:            ((!vma->N && !vmb->N) || (vma->N && vmb->N && obviously_egal(vma->N, vmb->N)));
subtype.c:    if (a == (jl_value_t*)jl_typeofbottom_type->super)
subtype.c:    if (b == (jl_value_t*)jl_typeofbottom_type->super)
subtype.c:            if (a == (jl_value_t*)jl_typeofbottom_type && bd->name == jl_type_typename)
subtype.c:            if (ad->name == jl_type_typename && b == (jl_value_t*)jl_typeofbottom_type)
subtype.c:            if (ad->name != bd->name)
subtype.c:            int istuple = (ad->name == jl_tuple_typename);
subtype.c:                if (!istuple && ad->name != jl_type_typename) // HACK: can't properly normalize Tuple{Float64} == Tuple{<:Float64} like types or Type{T} types
subtype.c:                    na -= 1;
subtype.c:                        nb -= 1;
subtype.c:                    nb -= 1;
subtype.c:    if (jl_is_typevar(a) && jl_is_typevar(b) && obviously_unequal(((jl_tvar_t*)a)->ub, ((jl_tvar_t*)b)->ub))
subtype.c:    return in_union(((jl_uniontype_t*)u)->a, x) || in_union(((jl_uniontype_t*)u)->b, x);
subtype.c:        (((jl_datatype_t*)a)->name != jl_tuple_typename ||
subtype.c:         ((jl_datatype_t*)b)->name != jl_tuple_typename))
subtype.c:        if (ad->name != bd->name) {
subtype.c:            while (temp != jl_any_type && temp->name != bd->name)
subtype.c:                temp = temp->super;
subtype.c:                while (temp != jl_any_type && temp->name != ad->name)
subtype.c:                    temp = temp->super;
subtype.c:        int istuple = (ad->name == jl_tuple_typename);
subtype.c:                na -= 1;
subtype.c:                    nb -= 1;
subtype.c:                nb -= 1;
subtype.c:    if (jl_is_typevar(a) && obviously_egal(b, ((jl_tvar_t*)a)->lb))
subtype.c:    if (jl_is_typevar(b) && obviously_egal(a, ((jl_tvar_t*)b)->lb))
subtype.c:// in many cases, we need to over-estimate this by returning `b`.
subtype.c:    if (jl_is_typevar(a) && obviously_egal(b, ((jl_tvar_t*)a)->ub))
subtype.c:    if (jl_is_typevar(b) && obviously_egal(a, ((jl_tvar_t*)b)->ub))
subtype.c:    jl_tvar_t *v = jl_new_typevar(u->var->name, u->var->lb, u->var->ub);
subtype.c:    jl_unionstate_t *state = R ? &e->Runions : &e->Lunions;
subtype.c:        if (state->depth >= state->used) {
subtype.c:            statestack_set(state, state->used, 0);
subtype.c:            state->used++;
subtype.c:        int ui = statestack_get(state, state->depth);
subtype.c:        state->depth++;
subtype.c:            state->more = state->depth; // memorize that this was the deepest available choice
subtype.c:            u = ((jl_uniontype_t*)u)->a;
subtype.c:            u = ((jl_uniontype_t*)u)->b;
subtype.c:    jl_saved_unionstate_t oldLunions; push_unionstate(&oldLunions, &e->Lunions);
subtype.c:    jl_saved_unionstate_t oldRunions; push_unionstate(&oldRunions, &e->Runions);
subtype.c:    e->Lunions.used = e->Runions.used = 0;
subtype.c:    e->Runions.depth = 0;
subtype.c:    e->Runions.more = 0;
subtype.c:    e->Lunions.depth = 0;
subtype.c:    e->Lunions.more = 0;
subtype.c:    pop_unionstate(&e->Runions, &oldRunions);
subtype.c:    pop_unionstate(&e->Lunions, &oldLunions);
subtype.c:        if (param == 2 && (vb->right ? e->Rinvdepth : e->invdepth) > vb->depth0) {
subtype.c:            if (vb->occurs_inv < 2)
subtype.c:                vb->occurs_inv++;
subtype.c:        else if (vb->occurs_cov < 2) {
subtype.c:            vb->occurs_cov++;
subtype.c:    jl_varbinding_t *btemp = e->vars;
subtype.c:        if (btemp->var == x) return 0;
subtype.c:        if (btemp->var == y) return 1;
subtype.c:        btemp = btemp->prev;
subtype.c:        return e->ignore_free || subtype_left_var(b->ub, a, e, param);
subtype.c:    if (!bb->right)  // check b . b<:a
subtype.c:        return subtype_left_var(bb->ub, a, e, param);
subtype.c:    if (bb->ub == a)
subtype.c:    if (!((bb->lb == jl_bottom_type && !jl_is_type(a) && !jl_is_typevar(a)) || subtype_ccheck(bb->lb, a, e)))
subtype.c:    if (e->intersection) {
subtype.c:        jl_value_t *ub = intersect_aside(bb->ub, a, e, 0, bb->depth0);
subtype.c:            bb->ub = ub;
subtype.c:        bb->ub = simple_meet(bb->ub, a);
subtype.c:    assert(bb->ub != (jl_value_t*)b);
subtype.c:        if (aa && !aa->right && in_union(bb->lb, a) && bb->depth0 != aa->depth0 && var_outside(e, b, (jl_tvar_t*)a)) {
subtype.c:            return subtype_left_var(aa->ub, aa->lb, e, param);
subtype.c:        return e->ignore_free || subtype_left_var(a, b->lb, e, param);
subtype.c:    if (!bb->right)  // check b . b>:a
subtype.c:        return subtype_left_var(a, bb->lb, e, param);
subtype.c:    if (bb->lb == bb->ub) {
subtype.c:        if (jl_is_typevar(bb->lb) && !jl_is_type(a) && !jl_is_typevar(a))
subtype.c:            return var_gt((jl_tvar_t*)bb->lb, a, e, param);
subtype.c:        if (jl_is_typevar(a) && !jl_is_type(bb->lb) && !jl_is_typevar(bb->lb))
subtype.c:            return var_lt((jl_tvar_t*)a, bb->lb, e, param);
subtype.c:    if (!((bb->ub == (jl_value_t*)jl_any_type && !jl_is_type(a) && !jl_is_typevar(a)) || subtype_ccheck(a, bb->ub, e)))
subtype.c:    jl_value_t *lb = simple_join(bb->lb, a);
subtype.c:    if (!e->intersection || !subtype_by_bounds(lb, (jl_value_t*)b, e))
subtype.c:        bb->lb = lb;
subtype.c:    assert(bb->lb != (jl_value_t*)b);
subtype.c:        if (aa && !aa->right && bb->depth0 != aa->depth0 && param == 2 && var_outside(e, b, (jl_tvar_t*)a))
subtype.c:            return subtype_left_var(aa->ub, aa->lb, e, param);
subtype.c:// check that a type is concrete or quasi-concrete (Type{T}).
subtype.c:        if (((jl_datatype_t*)v)->name->abstract) {
subtype.c:        return ((jl_datatype_t*)v)->isconcretetype;
subtype.c:    return is_leaf_bound(v->lb);
subtype.c:        jl_value_t *a = widen_Type(((jl_uniontype_t*)t)->a);
subtype.c:        jl_value_t *b = widen_Type(((jl_uniontype_t*)t)->b);
subtype.c:// convert a type with free variables to a typevar bounded by a UnionAll-wrapped
subtype.c:        ans = (jl_value_t*)jl_new_typevar(var->name, jl_bottom_type, ans);
subtype.c:    jl_varbinding_t *btemp = e->vars;
subtype.c:        if (btemp->var == u->var ||
subtype.c:            (btemp->lb != btemp->var->lb && jl_has_typevar(btemp->lb, u->var)) ||
subtype.c:            (btemp->ub != btemp->var->ub && jl_has_typevar(btemp->ub, u->var))) {
subtype.c:        btemp = btemp->prev;
subtype.c:    jl_varbinding_t vb = { u->var, u->var->lb, u->var->ub, R, 0, 0, 0, 0, 0, 0,
subtype.c:                           R ? e->Rinvdepth : e->invdepth, 0, NULL, e->vars };
subtype.c:    e->vars = &vb;
subtype.c:        e->envidx++;
subtype.c:        ans = subtype(t, u->body, e, param);
subtype.c:        e->envidx--;
subtype.c:        if (e->envidx < e->envsz) {
subtype.c:                val = is_leaf_bound(vb.lb) ? vb.lb : (jl_value_t*)jl_new_typevar(u->var->name, jl_bottom_type, vb.lb);
subtype.c:            else if (vb.lb == u->var->lb && vb.ub == u->var->ub)
subtype.c:                val = (jl_value_t*)u->var;
subtype.c:                val = (jl_value_t*)jl_new_typevar(u->var->name, vb.lb, vb.ub);
subtype.c:            jl_value_t *oldval = e->envout[e->envidx];
subtype.c:                e->envout[e->envidx] = (jl_value_t*)u->var;
subtype.c:                e->envout[e->envidx] = fix_inferred_var_bound(u->var, val);
subtype.c:        ans = R ? subtype(t, u->body, e, param) :
subtype.c:                  subtype(u->body, t, e, param);
subtype.c:    int diagonal = vb.occurs_cov > 1 && !var_occurs_invariant(u->body, u->var, 0);
subtype.c:    if (ans && (vb.concrete || (diagonal && is_leaf_typevar(u->var)))) {
subtype.c:            // a non-diagonal var can only be a subtype of a diagonal var if its
subtype.c:                vlb->concrete = 1;
subtype.c:    e->vars = vb.prev;
subtype.c:    jl_varbinding_t *btemp = e->vars;
subtype.c:            jl_value_t *vu = btemp->ub;
subtype.c:            jl_value_t *vl = btemp->lb;
subtype.c:            if (btemp->depth0 != vb.depth0 &&
subtype.c:                ((vu != (jl_value_t*)vb.var && btemp->var->ub != vu && var_occurs_inside(vu, vb.var, 0, 1)) ||
subtype.c:                 (vl != (jl_value_t*)vb.var && btemp->var->lb != vl && var_occurs_inside(vl, vb.var, 0, 1)))) {
subtype.c:            btemp = btemp->prev;
subtype.c:        e->invdepth++;
subtype.c:        e->Rinvdepth++;
subtype.c:        e->invdepth--;
subtype.c:        e->Rinvdepth--;
subtype.c:                    yl = ylv->lb;
subtype.c:                xl = xlv->lb;
subtype.c:                            yl = ylv->lb;
subtype.c:                yl = ylv->lb;
subtype.c:            if (ylv->depth0 != e->invdepth || ylv->occurs_inv)
subtype.c:            ylv->intvalued = 1;
subtype.c:        e->invdepth++;
subtype.c:        e->Rinvdepth++;
subtype.c:        e->invdepth--;
subtype.c:        e->Rinvdepth--;
subtype.c:    e->invdepth++;
subtype.c:    e->Rinvdepth++;
subtype.c:        xp1 = jl_box_long(jl_unbox_long(xp1) - vx + 1);
subtype.c:        yp1 = jl_box_long(jl_unbox_long(yp1) - vy + 1);
subtype.c:    e->invdepth--;
subtype.c:    e->Rinvdepth--;
subtype.c:            if (i == lx-1 && (vx || jl_is_vararg(xi))) {
subtype.c:            if (j == ly-1 && (vy || jl_is_vararg(yi))) {
subtype.c:                xi = jl_tparam(xd, lx-1);
subtype.c:                    vy += lx - i;
subtype.c:        else if (x_same && e->Runions.depth == 0 &&
subtype.c:        else if (e->Runions.depth == 0 && e->Lunions.depth == 0 && !jl_has_free_typevars(xi) && !jl_has_free_typevars(yi)) {
subtype.c:            // fast path for separable sub-formulas
subtype.c:        if (i < lx-1 || !vx)
subtype.c:        if (j < ly-1 || !vy)
subtype.c:        // in Tuple{...,tn} <: Tuple{...,Vararg{T,N}}, check (lx+1-ly) <: N
subtype.c:        if (!check_vararg_length(yi, lx+1-ly, e))
subtype.c:    assert((lx + vx == ly + vy) || (vy && (lx >= (vx ? ly : (ly-1)))));
subtype.c:        xva = jl_tparam(xd, lx-1);
subtype.c:        yva = jl_tparam(yd, ly-1);
subtype.c:        (!xbb || !jl_is_long(xbb->lb))) {
subtype.c:        if (vvx == JL_VARARG_UNBOUND || (xbb && !xbb->right)) {
subtype.c:        else if (vvy == JL_VARARG_NONE && !check_vararg_length(xva, ly+1-lx, e)) {
subtype.c:            nx += jl_vararg_length(xva) - 1;
subtype.c:        else if (xbb && jl_is_long(xbb->lb))
subtype.c:            nx += jl_unbox_long(xbb->lb) - 1;
subtype.c:            ny += jl_vararg_length(yva) - 1;
subtype.c:            ny -= 1;
subtype.c:        if (x == ((jl_uniontype_t*)y)->a || x == ((jl_uniontype_t*)y)->b)
subtype.c:            jl_unionstate_t *state = &e->Runions;
subtype.c:            if (state->depth >= state->used) {
subtype.c:                statestack_set(state, state->used, 0);
subtype.c:                state->used++;
subtype.c:            ui = statestack_get(state, state->depth);
subtype.c:            state->depth++;
subtype.c:                state->more = state->depth; // memorize that this was the deepest available choice
subtype.c:            jl_value_t *xub = xx ? xx->ub : ((jl_tvar_t*)x)->ub;
subtype.c:            jl_value_t *ylb = yy ? yy->lb : ((jl_tvar_t*)y)->lb;
subtype.c:            if (e->intersection) {
subtype.c:                jl_value_t *xlb = xx ? xx->lb : ((jl_tvar_t*)x)->lb;
subtype.c:                jl_value_t *yub = yy ? yy->ub : ((jl_tvar_t*)y)->ub;
subtype.c:            int xr = xx && xx->right;  // treat free variables as "forall" (left)
subtype.c:            int yr = yy && yy->right;
subtype.c:                    return subtype(xx->lb, yy->ub, e, 0);
subtype.c:            // the bounds of left-side variables never change, and can only lead
subtype.c:            // to other left-side variables, so using || here is safe.
subtype.c:        while (xd != NULL && xd != jl_any_type && xd->name != yd->name) {
subtype.c:            xd = xd->super;
subtype.c:        if (x == y && !(e->envidx < e->envsz))
subtype.c:                // !(Type{Int} <: DataType), !isleaftype(Type{Int}), because non-DataTypes can
subtype.c:                // be type-equal to `Int`.
subtype.c:            // be checked at the same depth where `Type{T}` occurs --- the depth of the LHS
subtype.c:            int saved = e->invdepth;
subtype.c:            e->invdepth = e->Rinvdepth;
subtype.c:            e->invdepth = saved;
subtype.c:        while (xd != jl_any_type && xd->name != yd->name) {
subtype.c:            if (xd->super == NULL)
subtype.c:                jl_errorf("circular type parameter constraint in definition of %s", jl_symbol_name(xd->name->name));
subtype.c:            xd = xd->super;
subtype.c:        if (xd->name == jl_tuple_typename)
subtype.c:        e->invdepth++;
subtype.c:        e->Rinvdepth++;
subtype.c:        e->invdepth--;
subtype.c:        e->Rinvdepth--;
subtype.c:    return n > 0 && jl_vararg_kind(jl_tparam(x, n-1)) == JL_VARARG_UNBOUND;
subtype.c:        x = ((jl_tvar_t*)x)->ub;
subtype.c:    jl_vararg_kind_t k = jl_vararg_kind(jl_tparam(x, n-1));
subtype.c:    jl_saved_unionstate_t oldLunions; push_unionstate(&oldLunions, &e->Lunions);
subtype.c:    e->Lunions.used = 0;
subtype.c:        jl_saved_unionstate_t oldRunions; push_unionstate(&oldRunions, &e->Runions);
subtype.c:        e->Runions.used = 0;
subtype.c:        e->Runions.depth = 0;
subtype.c:        e->Runions.more = 0;
subtype.c:        e->Lunions.depth = 0;
subtype.c:        e->Lunions.more = 0;
subtype.c:        pop_unionstate(&e->Runions, &oldRunions);
subtype.c:            e->Lunions.more = 0;
subtype.c:            e->Lunions.depth = 0;
subtype.c:            int set = e->Lunions.more;
subtype.c:                statestack_set(&e->Lunions, i, 0);
subtype.c:            lastset = set - 1;
subtype.c:            statestack_set(&e->Lunions, lastset, 1);
subtype.c:    pop_unionstate(&e->Lunions, &oldLunions);
subtype.c:    e->Runions.used = 0;
subtype.c:        e->Runions.depth = 0;
subtype.c:        e->Runions.more = 0;
subtype.c:        e->Lunions.depth = 0;
subtype.c:        e->Lunions.more = 0;
subtype.c:        int set = e->Runions.more;
subtype.c:            statestack_set(&e->Runions, i, 0);
subtype.c:        lastset = set - 1;
subtype.c:        statestack_set(&e->Runions, lastset, 1);
subtype.c:    assert(e->Runions.depth == 0);
subtype.c:    assert(e->Lunions.depth == 0);
subtype.c:    e->Lunions.used = 0;
subtype.c:        int set = e->Lunions.more;
subtype.c:            statestack_set(&e->Lunions, i, 0);
subtype.c:        lastset = set - 1;
subtype.c:        statestack_set(&e->Lunions, lastset, 1);
subtype.c:    e->vars = NULL;
subtype.c:    e->envsz = envsz;
subtype.c:    e->envout = env;
subtype.c:    e->envidx = 0;
subtype.c:    e->invdepth = e->Rinvdepth = 0;
subtype.c:    e->ignore_free = 0;
subtype.c:    e->intersection = 0;
subtype.c:    e->emptiness_only = 0;
subtype.c:    e->triangular = 0;
subtype.c:    e->Lunions.depth = 0;      e->Runions.depth = 0;
subtype.c:    e->Lunions.more = 0;       e->Runions.more = 0;
subtype.c:    e->Lunions.used = 0;       e->Runions.used = 0;
subtype.c:        t = ((jl_unionall_t*)t)->body;
subtype.c:        int count = concrete_min(((jl_uniontype_t*)t)->a);
subtype.c:        return count + concrete_min(((jl_uniontype_t*)t)->b);
subtype.c:    return 1; // a non-Type is also considered concrete
subtype.c:        if (((jl_unionall_t*)t)->var == v)
subtype.c:            return ((jl_unionall_t*)t)->body;
subtype.c:        jl_value_t *b = find_var_body(((jl_unionall_t*)t)->var->lb, v);
subtype.c:        b = find_var_body(((jl_unionall_t*)t)->var->ub, v);
subtype.c:        return find_var_body(((jl_unionall_t*)t)->body, v);
subtype.c:        jl_value_t *b = find_var_body(((jl_uniontype_t*)t)->a, v);
subtype.c:        return find_var_body(((jl_uniontype_t*)t)->b, v);
subtype.c:        if (vm->T) {
subtype.c:            jl_value_t *b = find_var_body(vm->T, v);
subtype.c:            if (vm->N) {
subtype.c:                return find_var_body(vm->N, v);
subtype.c:// in the immediate caller--the caller must be conservative in handling the result
subtype.c:    if (x == (jl_value_t*)jl_typeofbottom_type->super)
subtype.c:    if (y == (jl_value_t*)jl_typeofbottom_type->super)
subtype.c:        if (((jl_tvar_t*)x)->lb != (jl_value_t*)jl_bottom_type)
subtype.c:        if (obvious_subtype(((jl_tvar_t*)x)->ub, y, y0, subtype) && *subtype)
subtype.c:        if (((jl_tvar_t*)y)->lb != (jl_value_t*)jl_bottom_type)
subtype.c:        if (obvious_subtype(x, ((jl_tvar_t*)y)->ub, y0, subtype) && !*subtype)
subtype.c:        if (obvious_subtype(((jl_uniontype_t*)x)->a, y, y0, subtype) && *subtype) {
subtype.c:            if (obvious_subtype(((jl_uniontype_t*)x)->b, y, y0, subtype) && *subtype)
subtype.c:        //if (obvious_subtype(((jl_uniontype_t*)x)->a, y, y0, subtype)) {
subtype.c:        //    if (obvious_subtype(((jl_uniontype_t*)x)->b, y, y0, subtype))
subtype.c:        //else if (obvious_subtype(((jl_uniontype_t*)x)->b, y, y0, subtype)) {
subtype.c:        if (obvious_subtype(x, ((jl_uniontype_t*)y)->a, y0, subtype)) {
subtype.c:            if (obvious_subtype(x, ((jl_uniontype_t*)y)->b, y0, subtype))
subtype.c:        else if (obvious_subtype(x, ((jl_uniontype_t*)y)->b, y0, subtype)) {
subtype.c:        int istuple = (((jl_datatype_t*)y)->name == jl_tuple_typename);
subtype.c:        // TODO: this would be a nice fast-path to have, unfortuanately,
subtype.c:        //       datatype allocation fails to correctly hash-cons them
subtype.c:        //if (!iscov && ((jl_datatype_t*)y)->isconcretetype && !jl_is_type_type(x)) {
subtype.c:            //if (((jl_datatype_t*)x)->isconcretetype && ((jl_datatype_t*)y)->isconcretetype && (!istuple || !istuple_x)) {
subtype.c:            if (((jl_datatype_t*)x)->name != ((jl_datatype_t*)y)->name) {
subtype.c:                while (temp->name != ((jl_datatype_t*)y)->name) {
subtype.c:                    temp = temp->super;
subtype.c:            if (!iscov && !((jl_datatype_t*)x)->hasfreetypevars) {
subtype.c:                if (obvious_subtype(((jl_datatype_t*)x)->name->wrapper, y, y0, subtype) && *subtype)
subtype.c:                    jl_value_t *xva = jl_tparam(x, npx - 1);
subtype.c:                        nparams_expanded_x -= 1;
subtype.c:                    jl_value_t *yva = jl_tparam(y, npy - 1);
subtype.c:                        nparams_expanded_y -= 1;
subtype.c:            for (i = 0; i < npy - (vy == JL_VARARG_NONE ? 0 : 1); i++) {
subtype.c:                jl_value_t *a = i >= (npx - (vx == JL_VARARG_NONE ? 0 : 1)) ? vxt : jl_tparam(x, i);
subtype.c:                jl_value_t *a1 = (vx != JL_VARARG_NONE && i >= npx - 1) ? vxt : jl_tparam(x, i);
subtype.c:                    jl_value_t *a = (vx != JL_VARARG_NONE && i >= npx - 1) ? vxt : jl_tparam(x, i);
subtype.c:                        // diagonal rule: all the later parameters are also constrained to be type-equal to the first
subtype.c:                env[i] = (jl_value_t*)ua->var;
subtype.c:                ua = (jl_unionall_t*)ua->body;
subtype.c:    e2.vars = e->vars;
subtype.c:    e2.intersection = e->intersection;
subtype.c:    e2.ignore_free = e->ignore_free;
subtype.c:    e2.envsz = e->envsz;
subtype.c:    e2.envout = e->envout;
subtype.c:    e2.envidx = e->envidx;
subtype.c:    return subtype_in_env_(x, y, e, e->invdepth, e->Rinvdepth);
subtype.c:    return subtype_in_env_(x, y, e, R ? e->invdepth : d, R ? d : e->Rinvdepth);
subtype.c:            if (!jl_isa(child[i - 1], jl_tparam(pdt, i)))
subtype.c:// returns true if the intersection of `t` and `Type` is non-empty and not a kind
subtype.c:        return jl_has_intersect_type_not_kind(((jl_uniontype_t*)t)->a) ||
subtype.c:               jl_has_intersect_type_not_kind(((jl_uniontype_t*)t)->b);
subtype.c:        return jl_has_intersect_type_not_kind(((jl_tvar_t*)t)->ub);
subtype.c:        if (((jl_datatype_t*)t)->name == jl_type_typename)
subtype.c:                if (((jl_datatype_t*)t2)->name == jl_type_typename) {
subtype.c:                        if (((jl_tvar_t*)tp)->lb == jl_bottom_type) {
subtype.c:                                tp = ((jl_tvar_t*)tp)->ub;
subtype.c:                        else if (((jl_tvar_t*)tp)->ub == (jl_value_t*)jl_any_type) {
subtype.c:                                tp = ((jl_tvar_t*)tp)->lb;
subtype.c:    // band-aid for #30335
subtype.c:    jl_saved_unionstate_t oldRunions; push_unionstate(&oldRunions, &e->Runions);
subtype.c:    int savedepth = e->invdepth, Rsavedepth = e->Rinvdepth;
subtype.c:    e->invdepth = e->Rinvdepth = d;
subtype.c:    pop_unionstate(&e->Runions, &oldRunions);
subtype.c:    e->invdepth = savedepth;
subtype.c:    e->Rinvdepth = Rsavedepth;
subtype.c:        jl_saved_unionstate_t oldRunions; push_unionstate(&oldRunions, &e->Runions);
subtype.c:        a = R ? intersect_all(x, u->a, e) : intersect_all(u->a, x, e);
subtype.c:        b = R ? intersect_all(x, u->b, e) : intersect_all(u->b, x, e);
subtype.c:        pop_unionstate(&e->Runions, &oldRunions);
subtype.c:// set a variable to a non-type constant
subtype.c:    int offset = bb->offset;
subtype.c:        offset = -othervar->offset;
subtype.c:    assert(!othervar || othervar->offset == -offset);
subtype.c:    if (bb->lb == jl_bottom_type && bb->ub == (jl_value_t*)jl_any_type) {
subtype.c:        bb->lb = bb->ub = v;
subtype.c:    else if (jl_is_long(v) && jl_is_long(bb->lb)) {
subtype.c:        if (jl_unbox_long(v) != jl_unbox_long(bb->lb))
subtype.c:    else if (!jl_egal(v, bb->lb)) {
subtype.c:    if (bb->depth0 != e->invdepth)
subtype.c:    if (jl_is_long(bb->lb)) {
subtype.c:        if (bb->offset == 0)
subtype.c:            return bb->lb;
subtype.c:        if (jl_unbox_long(bb->lb) < bb->offset)
subtype.c:        return jl_box_long(jl_unbox_long(bb->lb) - bb->offset);
subtype.c:    jl_varbinding_t *btemp = e->vars;
subtype.c:        if ((btemp->lb == (jl_value_t*)v || btemp->ub == (jl_value_t*)v) &&
subtype.c:            in_union(val, (jl_value_t*)btemp->var))
subtype.c:        btemp = btemp->prev;
subtype.c:    jl_varbinding_t *v = e->vars;
subtype.c:        v = v->prev;
subtype.c:    v = e->vars;
subtype.c:        rs[n++] = v->right;
subtype.c:        v->right = 1;
subtype.c:        v = v->prev;
subtype.c:    n = 0; v = e->vars;
subtype.c:        v->right = rs[n++];
subtype.c:        v = v->prev;
subtype.c:    return reachable_var(xv->ub, y, e) || reachable_var(xv->lb, y, e);
subtype.c:    jl_varbinding_t *btemp = e->vars;
subtype.c:        if (btemp->lb == (jl_value_t*)v && btemp->ub == (jl_value_t*)v &&
subtype.c:            var_occurs_inside(t, btemp->var, 0, 0))
subtype.c:        btemp = btemp->prev;
subtype.c:        return R ? intersect_aside(a, b->ub, e, 1, 0) : intersect_aside(b->ub, a, e, 0, 0);
subtype.c:    if (reachable_var(bb->lb, b, e) || reachable_var(bb->ub, b, e))
subtype.c:    if (bb->lb == bb->ub && jl_is_typevar(bb->lb)) {
subtype.c:        return intersect(a, bb->lb, e, param);
subtype.c:    int d = bb->depth0;
subtype.c:            int issub = subtype_in_env_existential(bb->lb, a, e, 0, d) && subtype_in_env_existential(a, bb->ub, e, 1, d);
subtype.c:            e->triangular++;
subtype.c:            ub = R ? intersect_aside(a, bb->ub, e, 1, d) : intersect_aside(bb->ub, a, e, 0, d);
subtype.c:            e->triangular--;
subtype.c:            int issub = subtype_in_env_existential(bb->lb, ub, e, 0, d);
subtype.c:            bb->ub = ub;
subtype.c:            bb->lb = ub;
subtype.c:    jl_value_t *ub = R ? intersect_aside(a, bb->ub, e, 1, d) : intersect_aside(bb->ub, a, e, 0, d);
subtype.c:    if (bb->constraintkind == 1 || e->triangular) {
subtype.c:        if (e->triangular && check_unsat_bound(ub, b, e))
subtype.c:        set_bound(&bb->ub, ub, b, e);
subtype.c:    else if (bb->constraintkind == 0) {
subtype.c:        if (!jl_is_typevar(a) && try_subtype_in_env(bb->ub, a, e, 0, d)) {
subtype.c:    assert(bb->constraintkind == 2);
subtype.c:        if (ub == a && bb->lb != jl_bottom_type)
subtype.c:        else if (jl_egal(bb->ub, bb->lb))
subtype.c:        set_bound(&bb->ub, ub, b, e);
subtype.c:        return var_occurs_inside(((jl_uniontype_t*)v)->a, var, inside, want_inv) ||
subtype.c:            var_occurs_inside(((jl_uniontype_t*)v)->b, var, inside, want_inv);
subtype.c:        if (ua->var == var)
subtype.c:        if (var_occurs_inside(ua->var->lb, var, inside, want_inv) || var_occurs_inside(ua->var->ub, var, inside, want_inv))
subtype.c:        return var_occurs_inside(ua->body, var, inside, want_inv);
subtype.c:        if (vm->T) {
subtype.c:            if (var_occurs_inside(vm->T, var, inside || !want_inv, want_inv))
subtype.c:            return vm->N && var_occurs_inside(vm->N, var, 1, want_inv);
subtype.c:    jl_tvar_t *newvar = vb->var;
subtype.c:    if (jl_is_long(vb->ub) && jl_is_typevar(vb->lb)) {
subtype.c:        varval = vb->ub;
subtype.c:    else if (obviously_egal(vb->lb, vb->ub)) {
subtype.c:        varval = vb->ub;
subtype.c:    else if ((/*vb->occurs_cov == 1 || */is_leaf_bound(vb->ub)) &&
subtype.c:             !var_occurs_invariant(u->body, u->var, 0)) {
subtype.c:        varval = vb->ub;
subtype.c:    if (vb->intvalued) {
subtype.c:            (vb->lb == jl_bottom_type && vb->ub == (jl_value_t*)jl_any_type) ||
subtype.c:            (jl_is_typevar(vb->lb) && vb->ub == vb->lb)) {
subtype.c:            // int-valued typevar must either be an Int, or have Bottom-Any bounds,
subtype.c:    if (!varval && (vb->lb != vb->var->lb || vb->ub != vb->var->ub))
subtype.c:        newvar = jl_new_typevar(vb->var->name, vb->lb, vb->ub);
subtype.c:    jl_varbinding_t *btemp = e->vars;
subtype.c:        if (jl_has_typevar(btemp->lb, vb->var)) {
subtype.c:            if (vb->lb == (jl_value_t*)btemp->var) {
subtype.c:                    btemp->lb = jl_substitute_var(btemp->lb, vb->var, varval);
subtype.c:            else if (btemp->lb == (jl_value_t*)vb->var)
subtype.c:                btemp->lb = vb->lb;
subtype.c:            else if (btemp->depth0 == vb->depth0 && !jl_has_typevar(vb->lb, btemp->var) &&
subtype.c:                     !jl_has_typevar(vb->ub, btemp->var) && jl_has_typevar(btemp->ub, vb->var)) {
subtype.c:                if (btemp->innervars == NULL)
subtype.c:                    btemp->innervars = jl_alloc_array_1d(jl_array_any_type, 0);
subtype.c:                if (newvar != vb->var) {
subtype.c:                    btemp->lb = jl_substitute_var(btemp->lb, vb->var, (jl_value_t*)newvar);
subtype.c:                    btemp->ub = jl_substitute_var(btemp->ub, vb->var, (jl_value_t*)newvar);
subtype.c:                jl_array_ptr_1d_push(btemp->innervars, (jl_value_t*)newvar);
subtype.c:                btemp = btemp->prev;
subtype.c:                btemp->lb = jl_new_struct(jl_unionall_type, vb->var, btemp->lb);
subtype.c:            assert((jl_value_t*)btemp->var != btemp->lb);
subtype.c:        if (jl_has_typevar(btemp->ub, vb->var)) {
subtype.c:            if (vb->ub == (jl_value_t*)btemp->var) {
subtype.c:                    btemp->ub = jl_substitute_var(btemp->ub, vb->var, varval);
subtype.c:            else if (btemp->ub == (jl_value_t*)vb->var)
subtype.c:                btemp->ub = vb->ub;
subtype.c:                btemp->ub = jl_new_struct(jl_unionall_type, vb->var, btemp->ub);
subtype.c:            assert((jl_value_t*)btemp->var != btemp->ub);
subtype.c:        btemp = btemp->prev;
subtype.c:    // if `v` still occurs, re-wrap body in `UnionAll v` or eliminate the UnionAll
subtype.c:    if (jl_has_typevar(res, vb->var)) {
subtype.c:                res = jl_substitute_var(res, vb->var, varval);
subtype.c:                while (jl_is_unionall(res) && obviously_egal(((jl_unionall_t*)res)->var->lb,
subtype.c:                                                             ((jl_unionall_t*)res)->var->ub))
subtype.c:                    res = jl_instantiate_unionall((jl_unionall_t*)res, ((jl_unionall_t*)res)->var->lb);
subtype.c:            if (newvar != vb->var)
subtype.c:                res = jl_substitute_var(res, vb->var, (jl_value_t*)newvar);
subtype.c:    if (res != jl_bottom_type && vb->innervars != NULL) {
subtype.c:        for(i=0; i < jl_array_len(vb->innervars); i++) {
subtype.c:            jl_tvar_t *var = (jl_tvar_t*)jl_array_ptr_ref(vb->innervars, i);
subtype.c:    if (vb->right && e->envidx < e->envsz) {
subtype.c:        jl_value_t *oldval = e->envout[e->envidx];
subtype.c:        if (!varval || (!is_leaf_bound(varval) && !vb->occurs_inv))
subtype.c:            e->envout[e->envidx] = (jl_value_t*)vb->var;
subtype.c:            e->envout[e->envidx] = fix_inferred_var_bound(vb->var, varval);
subtype.c:    jl_varbinding_t *btemp = e->vars;
subtype.c:    // TODO: might need to look inside types in btemp->lb and btemp->ub
subtype.c:            vb->limited = 1;
subtype.c:        if (btemp->var == u->var || btemp->lb == (jl_value_t*)u->var ||
subtype.c:            btemp->ub == (jl_value_t*)u->var) {
subtype.c:        btemp = btemp->prev;
subtype.c:    vb->var = u->var;
subtype.c:    e->vars = vb;
subtype.c:        e->envidx++;
subtype.c:        res = intersect(t, u->body, e, param);
subtype.c:        e->envidx--;
subtype.c:        res = intersect(u->body, t, e, param);
subtype.c:    vb->concrete |= (vb->occurs_cov > 1 && is_leaf_typevar(u->var) &&
subtype.c:                     !var_occurs_invariant(u->body, u->var, 0));
subtype.c:    if (res != jl_bottom_type && vb->concrete) {
subtype.c:        if (jl_is_typevar(vb->lb)) {
subtype.c:        else if (!is_leaf_bound(vb->lb)) {
subtype.c:    e->vars = vb->prev;
subtype.c:        if (vb->ub == jl_bottom_type && vb->occurs_cov) {
subtype.c:        else if (jl_has_typevar(vb->lb, u->var) || jl_has_typevar(vb->ub, u->var)) {
subtype.c:    jl_varbinding_t vb = { u->var, u->var->lb, u->var->ub, R, 0, 0, 0, 0, 0, 0,
subtype.c:                           R ? e->Rinvdepth : e->invdepth, 0, NULL, e->vars };
subtype.c:        if (e->vars)
subtype.c:            e->vars->limited = 1;
subtype.c:        if (vb.concrete || vb.occurs_inv>1 || u->var->lb != jl_bottom_type || (vb.occurs_inv && vb.occurs_cov)) {
subtype.c:        else if (vb.occurs_cov && !var_occurs_invariant(u->body, u->var, 0)) {
subtype.c:        if (xb) xb->intvalued = 1;
subtype.c:        if (yb) yb->intvalued = 1;
subtype.c:            !((jl_is_typevar(i2) && ((jl_tvar_t*)i2)->lb == jl_bottom_type &&
subtype.c:                ((jl_tvar_t*)i2)->ub == (jl_value_t*)jl_any_type) || jl_is_long(i2))) {
subtype.c:    int vx=0, vy=0, vvx = (lx > 0 && jl_is_vararg(jl_tparam(xd, lx-1)));
subtype.c:    int vvy = (ly > 0 && jl_is_vararg(jl_tparam(yd, ly-1)));
subtype.c:            if (vx && intersect_vararg_length(xi, ly+1-lx, e, 0))
subtype.c:            if (vy && intersect_vararg_length(yi, lx+1-ly, e, 1))
subtype.c:            // {A^n...,Vararg{T,N}}  {Vararg{S,M}} = {(AS)^n...,Vararg{TS,N}} plus N = M-n
subtype.c:                    xb->offset = ly-lx;
subtype.c:                    yb->offset = lx-ly;
subtype.c:            if (xb) xb->offset = 0;
subtype.c:            if (yb) yb->offset = 0;
subtype.c:                if ((xb && jl_is_long(xb->lb) && lx-1+jl_unbox_long(xb->lb) != len) ||
subtype.c:                    (yb && jl_is_long(yb->lb) && ly-1+jl_unbox_long(yb->lb) != len)) {
subtype.c:                    if (xb) set_var_to_const(xb, jl_box_long(len-lx+1), yb);
subtype.c:                    if (yb) set_var_to_const(yb, jl_box_long(len-ly+1), xb);
subtype.c:        if (i < lx-1 || !vx) i++;
subtype.c:        if (j < ly-1 || !vy) j++;
subtype.c:    jl_varbinding_t *btemp = e->vars;
subtype.c:        btemp->right = !btemp->right;
subtype.c:        btemp = btemp->prev;
subtype.c:    jl_value_t *isuper = R ? intersect((jl_value_t*)yd, (jl_value_t*)xd->super, e, param) :
subtype.c:                             intersect((jl_value_t*)xd->super, (jl_value_t*)yd, e, param);
subtype.c:    if (jl_nparams(xd) == 0 || jl_nparams(xd->super) == 0 || !jl_has_free_typevars((jl_value_t*)xd))
subtype.c:    jl_value_t *wrapper = xd->name->wrapper;
subtype.c:    super_pattern = jl_rewrap_unionall((jl_value_t*)((jl_datatype_t*)jl_unwrap_unionall(wrapper))->super,
subtype.c:                if (ei == (jl_value_t*)((jl_unionall_t*)wr)->var ||
subtype.c:                wr = ((jl_unionall_t*)wr)->body;
subtype.c:    e->invdepth++;
subtype.c:    e->Rinvdepth++;
subtype.c:    e->invdepth--;
subtype.c:    e->Rinvdepth--;
subtype.c:    if (!subtype_in_env_existential(x, y, e, 0, e->invdepth)) {
subtype.c:        if (!subtype_in_env_existential(y, x, e, 0, e->invdepth))
subtype.c:    if (y == (jl_value_t*)jl_typeofbottom_type && ((jl_tvar_t*)p0)->lb == jl_bottom_type)
subtype.c:    if (((jl_tvar_t*)p0)->ub == (jl_value_t*)jl_any_type)
subtype.c:    // here is a conservative over-estimate.
subtype.c:        ans &= compareto_var(xv->ub, y, e, cmp);
subtype.c:        ans &= compareto_var(xv->lb, y, e, cmp);
subtype.c:// Note this is a semi-predicate: 1 => is a subtype, 0 => unknown
subtype.c:    return compareto_var(x, (jl_tvar_t*)y, e, -1) || compareto_var(y, (jl_tvar_t*)x, e, 1);
subtype.c:                jl_value_t *xlb = xx ? xx->lb : ((jl_tvar_t*)x)->lb;
subtype.c:                jl_value_t *xub = xx ? xx->ub : ((jl_tvar_t*)x)->ub;
subtype.c:                jl_value_t *ylb = yy ? yy->lb : ((jl_tvar_t*)y)->lb;
subtype.c:                jl_value_t *yub = yy ? yy->ub : ((jl_tvar_t*)y)->ub;
subtype.c:                if (xx && yy && xx->depth0 != yy->depth0) {
subtype.c:                    return subtype_in_env(yy->ub, yy->lb, e) ? y : jl_bottom_type;
subtype.c:                ub = intersect_aside(xub, yub, e, 0, xx ? xx->depth0 : 0);
subtype.c:                    yy->lb = lb;
subtype.c:                        yy->ub = ub;
subtype.c:                    assert(yy->ub != y);
subtype.c:                    assert(yy->lb != y);
subtype.c:                    xx->lb = y;
subtype.c:                    xx->ub = y;
subtype.c:                    assert(xx->ub != x);
subtype.c:            if (xx && yy && xx->concrete && !yy->concrete) {
subtype.c:        if (y == ((jl_uniontype_t*)x)->a || y == ((jl_uniontype_t*)x)->b)
subtype.c:        if (x == ((jl_uniontype_t*)y)->a || x == ((jl_uniontype_t*)y)->b)
subtype.c:                if (jl_is_unionall(ua->body)) {
subtype.c:                    jl_unionall_t *ub = (jl_unionall_t*)ua->body;
subtype.c:                    if (jl_has_typevar(ub->var->ub, ua->var) ||
subtype.c:                        jl_has_typevar(ub->var->lb, ua->var)) {
subtype.c:        if (xd->name == yd->name) {
subtype.c:                    res = jl_apply_type(xd->name->wrapper, newparams, np);
subtype.c:        while (xd != jl_any_type && xd->name != yd->name)
subtype.c:            xd = xd->super;
subtype.c:            while (yd != jl_any_type && yd->name != xd->name)
subtype.c:                yd = yd->super;
subtype.c:    e->Runions.depth = 0;
subtype.c:    e->Runions.more = 0;
subtype.c:    e->Runions.used = 0;
subtype.c:    while (e->Runions.more) {
subtype.c:        if (e->emptiness_only && ii != jl_bottom_type)
subtype.c:        e->Runions.depth = 0;
subtype.c:        int set = e->Runions.more - 1;
subtype.c:        e->Runions.more = 0;
subtype.c:        statestack_set(&e->Runions, set, 1);
subtype.c:            statestack_set(&e->Runions, i, 0);
subtype.c:        jl_svecset(vec, i, ua->var);
subtype.c:        ua = (jl_unionall_t*)ua->body;
subtype.c:// If `a` and `b` are not (non va-)tuples of equal length (or unions or unionalls
subtype.c:            if (ub->var->lb == ua->var->lb && ub->var->ub == ua->var->ub) {
subtype.c:                jl_value_t *ub2 = jl_instantiate_unionall(ub, (jl_value_t*)ua->var);
subtype.c:                ans = switch_union_tuple(ua->body, ub2);
subtype.c:                    ans = jl_type_unionall(ua->var, ans);
subtype.c:        jl_value_t *ans = switch_union_tuple(ua->body, b);
subtype.c:        ans = jl_type_unionall(ua->var, ans);
subtype.c:        jl_value_t *ans = switch_union_tuple(a, ((jl_unionall_t*)b)->body);
subtype.c:        ans = jl_type_unionall(((jl_unionall_t*)b)->var, ans);
subtype.c:        a = switch_union_tuple(((jl_uniontype_t*)a)->a, ((jl_uniontype_t*)a)->b);
subtype.c:        b = switch_union_tuple(((jl_uniontype_t*)b)->a, ((jl_uniontype_t*)b)->b);
subtype.c:// `a` might have a non-empty intersection with some concrete type b even if !(a<:b) and !(b<:a)
subtype.c:        return might_intersect_concrete(((jl_uniontype_t*)a)->a) ||
subtype.c:               might_intersect_concrete(((jl_uniontype_t*)a)->b);
subtype.c:                ans_unwrapped = switch_union_tuple(((jl_uniontype_t*)ans_unwrapped)->a, ((jl_uniontype_t*)ans_unwrapped)->b);
subtype.c:            env[i++] = (jl_value_t*)((jl_unionall_t*)b)->var;
subtype.c:            b = ((jl_unionall_t*)b)->body;
subtype.c:        a = jl_type_unionall(e->var, a);
subtype.c:        b = jl_type_unionall(e->var, b);
subtype.c:        e = e->prev;
subtype.c:            a = jl_type_unionall(env->var, a);
subtype.c:            b = jl_type_unionall(env->var, b);
subtype.c:        env = env->prev;
subtype.c:    if (i < len-1)
subtype.c:    jl_value_t *last = jl_unwrap_unionall(jl_tparam(t, len-1));
subtype.c:        if (n && jl_is_long(n) && i >= len-1+jl_unbox_long(n))
subtype.c:    if (i == len-1)
subtype.c:    jl_value_t *clast = jl_tparam(cdt,clen-1);
subtype.c:    int pva = jl_vararg_kind(jl_tparam(pdt,plen-1)) > JL_VARARG_INT;
subtype.c:        if (cva && pva && i >= clen-1 && i >= plen-1 && (some_morespecific || (cdiag && !pdiag)))
subtype.c:        if (!cms && i == clen-1 && clen == plen && !cva && pva && eq_msp(ce, pe, env) &&
subtype.c:    jl_value_t *last = jl_unwrap_unionall(jl_tparam(t,n-1));
subtype.c:            n += jl_unbox_long(N)-1;
subtype.c:// Called when a is a bound-vararg and b is not a vararg. Sets the vararg length
subtype.c:    int taillen = tuple_full_length(b)-n+1;
subtype.c:        return -1;
subtype.c:    jl_value_t *e[2] = { jl_unwrap_vararg_num(jl_unwrap_unionall(jl_tparam(a, n-1))), jl_box_long(taillen) };
subtype.c:    for (size_t i = 0; i < n-1; i++) {
subtype.c:    int ret = -1;
subtype.c:        int a = count_occurs(((jl_uniontype_t*)t)->a, v);
subtype.c:        int b = count_occurs(((jl_uniontype_t*)t)->b, v);
subtype.c:        if (((jl_unionall_t*)t)->var == v)
subtype.c:        return count_occurs(((jl_unionall_t*)t)->body, v);
subtype.c:        if (vm->T) {
subtype.c:            return count_occurs(vm->T, v) + (vm->N ? count_occurs(vm->N, v) : 0);
subtype.c:        if (env->var == v)
subtype.c:            return (int)(ssize_t)env->val;
subtype.c:        env = env->prev;
subtype.c:    jl_typeenv_t newenv = { ua->var, 0x0, env };                        \
subtype.c:    newenv.val = (jl_value_t*)(intptr_t)count_occurs(ua->body, ua->var); \
subtype.c:    return type_morespecific_(ua->body, b, invariant, &newenv)
subtype.c:    jl_typeenv_t newenv = { ub->var, 0x0, env };                        \
subtype.c:    newenv.val = (jl_value_t*)(intptr_t)count_occurs(ub->body, ub->var); \
subtype.c:    return type_morespecific_(a, ub->body, invariant, &newenv)
subtype.c:        int ans = -1;
subtype.c:        // not vice-versa.
subtype.c:        if (type_morespecific_(u->a, b, invariant, env) || type_morespecific_(u->b, b, invariant, env)) {
subtype.c:                if (type_morespecific_(v->a, a, invariant, env) || type_morespecific_(v->b, a, invariant, env))
subtype.c:            jl_value_t *ub = ((jl_tvar_t*)tp0a)->ub;
subtype.c:        if (type_morespecific_(a, u->a, invariant, env) || type_morespecific_(a, u->b, invariant, env))
subtype.c:            if (tta->name == ttb->name) {
subtype.c:                    if (tta->name != jl_type_typename) return 1;
subtype.c:                        if (sub_msp((jl_value_t*)jl_any_type, ((jl_tvar_t*)tp0)->ub, env))
subtype.c:            tta = tta->super; super = 1;
subtype.c:            return (( type_morespecific_((jl_value_t*)((jl_tvar_t*)a)->ub,
subtype.c:                                         (jl_value_t*)((jl_tvar_t*)b)->ub, 0, env) &&
subtype.c:                     !type_morespecific_((jl_value_t*)((jl_tvar_t*)a)->lb,
subtype.c:                                         (jl_value_t*)((jl_tvar_t*)b)->lb, 0, env)) ||
subtype.c:                    ( type_morespecific_((jl_value_t*)((jl_tvar_t*)b)->lb,
subtype.c:                                         (jl_value_t*)((jl_tvar_t*)a)->lb, 0, env) &&
subtype.c:                     !type_morespecific_((jl_value_t*)((jl_tvar_t*)b)->ub,
subtype.c:                                         (jl_value_t*)((jl_tvar_t*)a)->ub, 0, env)));
subtype.c:            if (((jl_tvar_t*)a)->ub == jl_bottom_type)
subtype.c:            if (eq_msp(((jl_tvar_t*)a)->ub, b, env))
subtype.c:            if (b == (jl_value_t*)jl_any_type && ((jl_tvar_t*)a)->ub == (jl_value_t*)jl_any_type &&
subtype.c:        return type_morespecific_(((jl_tvar_t*)a)->ub, b, 0, env);
subtype.c:            if (((jl_tvar_t*)b)->ub == jl_bottom_type)
subtype.c:                if (type_morespecific_(a, ((jl_tvar_t*)b)->ub, 0, env))
subtype.c:                if (eq_msp(a, ((jl_tvar_t*)b)->ub, env))
subtype.c:                if (obviously_disjoint(a, ((jl_tvar_t*)b)->ub, 1))
subtype.c:                if (type_morespecific_(((jl_tvar_t*)b)->ub, a, 0, env))
subtype.c:        return type_morespecific_(a, ((jl_tvar_t*)b)->ub, 0, env);
aotcompile.cpp:#include "llvm-version.h"
aotcompile.cpp:    if (!G->isDeclaration()) {
aotcompile.cpp:        Comdat *jl_Comdat = G->getParent()->getOrInsertComdat(G->getName());
aotcompile.cpp:        jl_Comdat->setSelectionKind(Comdat::NoDuplicates);
aotcompile.cpp:        G->setComdat(jl_Comdat);
aotcompile.cpp:        if (G->getLinkage() == GlobalValue::ExternalLinkage)
aotcompile.cpp:            G->setDLLStorageClass(GlobalValue::DLLExportStorageClass);
aotcompile.cpp:            G->setDLLStorageClass(GlobalValue::DefaultStorageClass);
aotcompile.cpp:    std::map<void*, int32_t> jl_value_to_llvm; // uses 1-based indexing
aotcompile.cpp:        auto it = data->jl_fvar_map.find(codeinst);
aotcompile.cpp:        if (it != data->jl_fvar_map.end()) {
aotcompile.cpp:            std::tie(*func_idx, *specfunc_idx) = it->second;
aotcompile.cpp:        auto it = data->jl_value_to_llvm.find(p);
aotcompile.cpp:        if (it != data->jl_value_to_llvm.end()) {
aotcompile.cpp:            return it->second;
aotcompile.cpp:        return data->M.get();
aotcompile.cpp:        return data->jl_sysimg_fvars[idx];
aotcompile.cpp:        return &data->M->getContext();
aotcompile.cpp:// the only non-identifier characters we allow to appear are '.' and '$',
aotcompile.cpp:// and all of UTF-8 above code-point 128 (except 255)
aotcompile.cpp:        *src_out = (jl_code_info_t*)codeinst->inferred;
aotcompile.cpp:        jl_method_t *def = codeinst->def->def.method;
aotcompile.cpp:                codeinst = jl_get_method_inferred(mi, (*src_out)->rettype, (*src_out)->min_world, (*src_out)->max_world);
aotcompile.cpp:                if ((*src_out)->inferred && !codeinst->inferred)
aotcompile.cpp:                    codeinst->inferred = jl_nothing;
aotcompile.cpp:    // compile all methods for the current world and type-inference world
aotcompile.cpp:            // to compile, or an svec(rettype, sig) describing a C-callable alias to create.
aotcompile.cpp:            if (mi->def.method->primary_world <= params.world && params.world <= mi->def.method->deleted_world) {
aotcompile.cpp:                    JL_GC_PROMISE_ROOTED(codeinst->rettype);
aotcompile.cpp:                    jl_compile_result_t result = jl_emit_code(mi, src, codeinst->rettype, params);
aotcompile.cpp:        gvars.push_back(std::string(global.second->getName()));
aotcompile.cpp:        data->jl_value_to_llvm[global.first] = gvars.size();
aotcompile.cpp:            func_id = -1;
aotcompile.cpp:            func_id = -2;
aotcompile.cpp:            data->jl_sysimg_fvars.push_back(cast<Function>(clone->getNamedValue(func)));
aotcompile.cpp:            func_id = data->jl_sysimg_fvars.size();
aotcompile.cpp:            data->jl_sysimg_fvars.push_back(cast<Function>(clone->getNamedValue(cfunc)));
aotcompile.cpp:            cfunc_id = data->jl_sysimg_fvars.size();
aotcompile.cpp:        data->jl_fvar_map[this_code] = std::make_tuple(func_id, cfunc_id);
aotcompile.cpp:        GlobalVariable *G = cast<GlobalVariable>(clone->getNamedValue(global));
aotcompile.cpp:        G->setInitializer(ConstantPointerNull::get(cast<PointerType>(G->getValueType())));
aotcompile.cpp:        G->setLinkage(GlobalVariable::InternalLinkage);
aotcompile.cpp:        data->jl_sysimg_gvars.push_back(G);
aotcompile.cpp:    Type *T_int32 = Type::getInt32Ty(clone->getContext());
aotcompile.cpp:    juliapersonality_func->setDLLStorageClass(GlobalValue::DLLImportStorageClass);
aotcompile.cpp:        for (GlobalObject &G : clone->global_objects()) {
aotcompile.cpp:                    F->setPersonalityFn(juliapersonality_func);
aotcompile.cpp:    data->M = std::move(clone);
aotcompile.cpp:        jl_atomic_fetch_add_relaxed(&jl_cumulative_compile_time, (jl_hrtime() - compiler_start_time));
aotcompile.cpp:    LLVMContext &Context = data->M->getContext();
aotcompile.cpp:    Triple TheTriple = Triple(jl_TargetMachine->getTargetTriple());
aotcompile.cpp:        jl_TargetMachine->getTarget().createTargetMachine(
aotcompile.cpp:            jl_TargetMachine->getTargetCPU(),
aotcompile.cpp:            jl_TargetMachine->getTargetFeatureString(),
aotcompile.cpp:            jl_TargetMachine->Options,
aotcompile.cpp:            CodeGenOpt::Aggressive // -O3 TODO: respect command -O0 flag?
aotcompile.cpp:        if (TM->addPassesToEmitFile(PM, obj_OS, nullptr, CGFT_ObjectFile, false))
aotcompile.cpp:        if (TM->addPassesToEmitFile(PM, asm_OS, nullptr, CGFT_AssemblyFile, false))
aotcompile.cpp:    data->M->setTargetTriple(TM->getTargetTriple().str());
aotcompile.cpp:    DataLayout DL = TM->createDataLayout();
aotcompile.cpp:    DL.reset(DL.getStringRepresentation() + "-ni:10:11:12:13");
aotcompile.cpp:    data->M->setDataLayout(DL);
aotcompile.cpp:    Type *T_psize = T_size->getPointerTo();
aotcompile.cpp:        emit_offset_table(*data->M, data->jl_sysimg_gvars, "jl_sysimg_gvars", T_psize);
aotcompile.cpp:        emit_offset_table(*data->M, data->jl_sysimg_fvars, "jl_sysimg_fvars", T_psize);
aotcompile.cpp:        GlobalValue *jlRTLD_DEFAULT_var = jl_emit_RTLD_DEFAULT_var(data->M.get());
aotcompile.cpp:        addComdat(new GlobalVariable(*data->M,
aotcompile.cpp:                                     jlRTLD_DEFAULT_var->getType(),
aotcompile.cpp:    add_output(*data->M, "unopt.bc", "text.bc", "text.o", "text.s");
aotcompile.cpp:    sysimage->setTargetTriple(data->M->getTargetTriple());
aotcompile.cpp:    sysimage->setDataLayout(data->M->getDataLayout());
aotcompile.cpp:    data->M.reset(); // free memory for data->M
aotcompile.cpp:        addComdat(new GlobalVariable(*sysimage, data->getType(), false,
aotcompile.cpp:                                     data, "jl_system_image_data"))->setAlignment(Align(64));
aotcompile.cpp:        addComdat(new GlobalVariable(*sysimage, len->getType(), true,
aotcompile.cpp:    PM->add(new TargetLibraryInfoWrapperPass(Triple(TM->getTargetTriple())));
aotcompile.cpp:    PM->add(createTargetTransformInfoWrapperPass(TM->getTargetIRAnalysis()));
aotcompile.cpp:    PM->add(createDemoteFloat16Pass());
aotcompile.cpp:    PM->add(createGVNPass());
aotcompile.cpp:    PM->add(createGCInvariantVerifierPass(true));
aotcompile.cpp:    PM->add(createVerifierPass());
aotcompile.cpp:    PM->add(createConstantMergePass());
aotcompile.cpp:        PM->add(createCFGSimplificationPass(simplifyCFGOptions));
aotcompile.cpp:            PM->add(createSROAPass());
aotcompile.cpp:            PM->add(createInstructionCombiningPass());
aotcompile.cpp:            PM->add(createEarlyCSEPass());
aotcompile.cpp:        PM->add(createMemCpyOptPass());
aotcompile.cpp:        PM->add(createAlwaysInlinerLegacyPass()); // Respect always_inline
aotcompile.cpp:        PM->add(createLowerSimdLoopPass()); // Annotate loop marked with "loopinfo" as LLVM parallel loop
aotcompile.cpp:            PM->add(createBarrierNoopPass());
aotcompile.cpp:            PM->add(createLowerExcHandlersPass());
aotcompile.cpp:            PM->add(createGCInvariantVerifierPass(false));
aotcompile.cpp:            PM->add(createRemoveNIPass());
aotcompile.cpp:            PM->add(createLateLowerGCFramePass());
aotcompile.cpp:            PM->add(createFinalLowerGCPass());
aotcompile.cpp:            PM->add(createLowerPTLSPass(dump_native));
aotcompile.cpp:            PM->add(createRemoveNIPass());
aotcompile.cpp:        PM->add(createLowerSimdLoopPass()); // Annotate loop marked with "loopinfo" as LLVM parallel loop
aotcompile.cpp:            PM->add(createMultiVersioningPass());
aotcompile.cpp:        PM->add(createAddressSanitizerFunctionPass());
aotcompile.cpp:        PM->add(createMemorySanitizerPass(true));
aotcompile.cpp:        PM->add(createThreadSanitizerLegacyPassPass());
aotcompile.cpp:    PM->add(createPropagateJuliaAddrspaces());
aotcompile.cpp:    PM->add(createScopedNoAliasAAWrapperPass());
aotcompile.cpp:    PM->add(createTypeBasedAAWrapperPass());
aotcompile.cpp:        PM->add(createBasicAAWrapperPass());
aotcompile.cpp:    PM->add(createCFGSimplificationPass(simplifyCFGOptions));
aotcompile.cpp:    PM->add(createDeadCodeEliminationPass());
aotcompile.cpp:    PM->add(createSROAPass());
aotcompile.cpp:    //PM->add(createMemCpyOptPass());
aotcompile.cpp:    PM->add(createAlwaysInlinerLegacyPass()); // Respect always_inline
aotcompile.cpp:    PM->add(createAllocOptPass());
aotcompile.cpp:    PM->add(createInstructionCombiningPass());
aotcompile.cpp:    PM->add(createCFGSimplificationPass(simplifyCFGOptions));
aotcompile.cpp:        PM->add(createMultiVersioningPass());
aotcompile.cpp:    PM->add(createSROAPass());
aotcompile.cpp:    PM->add(createInstSimplifyLegacyPass());
aotcompile.cpp:    PM->add(createJumpThreadingPass());
aotcompile.cpp:    PM->add(createCorrelatedValuePropagationPass());
aotcompile.cpp:    PM->add(createReassociatePass());
aotcompile.cpp:    PM->add(createEarlyCSEPass());
aotcompile.cpp:    PM->add(createAllocOptPass());
aotcompile.cpp:    PM->add(createLoopRotatePass());
aotcompile.cpp:    // moving IndVarSimplify here prevented removing the loop in perf_sumcartesian(10:-1:1)
aotcompile.cpp:    PM->add(createLoopIdiomPass());
aotcompile.cpp:    PM->add(createInstructionCombiningPass());
aotcompile.cpp:    PM->add(polly::createCodePreparationPass());
aotcompile.cpp:    PM->add(polly::createCodegenCleanupPass());
aotcompile.cpp:    PM->add(createLowerSimdLoopPass()); // Annotate loop marked with "loopinfo" as LLVM parallel loop
aotcompile.cpp:    PM->add(createLICMPass());
aotcompile.cpp:    PM->add(createJuliaLICMPass());
aotcompile.cpp:    PM->add(createLoopUnswitchPass());
aotcompile.cpp:    PM->add(createLICMPass());
aotcompile.cpp:    PM->add(createJuliaLICMPass());
aotcompile.cpp:    PM->add(createInstSimplifyLegacyPass());
aotcompile.cpp:    PM->add(createIndVarSimplifyPass());
aotcompile.cpp:    PM->add(createLoopDeletionPass());
aotcompile.cpp:    PM->add(createSimpleLoopUnrollPass());
aotcompile.cpp:    PM->add(createAllocOptPass());
aotcompile.cpp:    // Re-run SROA after loop-unrolling (useful for small loops that operate,
aotcompile.cpp:    PM->add(createSROAPass());
aotcompile.cpp:    PM->add(createInstSimplifyLegacyPass());
aotcompile.cpp:    PM->add(createGVNPass());
aotcompile.cpp:    PM->add(createMemCpyOptPass());
aotcompile.cpp:    PM->add(createSCCPPass());
aotcompile.cpp:    // loops over Union-typed arrays to vectorize.
aotcompile.cpp:    PM->add(createInstructionCombiningPass());
aotcompile.cpp:    PM->add(createJumpThreadingPass());
aotcompile.cpp:    PM->add(createCorrelatedValuePropagationPass());
aotcompile.cpp:    PM->add(createDeadStoreEliminationPass());
aotcompile.cpp:    PM->add(createAllocOptPass());
aotcompile.cpp:    PM->add(createCFGSimplificationPass()); // See note above, don't hoist instructions before LV
aotcompile.cpp:    PM->add(createLoopDeletionPass());
aotcompile.cpp:    PM->add(createInstructionCombiningPass());
aotcompile.cpp:    PM->add(createLoopVectorizePass());
aotcompile.cpp:    PM->add(createLoopLoadEliminationPass());
aotcompile.cpp:    PM->add(createInstructionCombiningPass());
aotcompile.cpp:    PM->add(createCFGSimplificationPass( // Aggressive CFG simplification
aotcompile.cpp:            // .sinkCommonInsts(true) // FIXME: Causes assertion in llvm-late-lowering
aotcompile.cpp:    PM->add(createSLPVectorizerPass());
aotcompile.cpp:    //PM->add(createVectorCombinePass());
aotcompile.cpp:    PM->add(createAggressiveDCEPass());
aotcompile.cpp:        // pass pipeline being re-exectuted. Prevent this by inserting a barrier.
aotcompile.cpp:        PM->add(createBarrierNoopPass());
aotcompile.cpp:        PM->add(createLowerExcHandlersPass());
aotcompile.cpp:        PM->add(createGCInvariantVerifierPass(false));
aotcompile.cpp:        PM->add(createRemoveNIPass());
aotcompile.cpp:        PM->add(createLateLowerGCFramePass());
aotcompile.cpp:        PM->add(createFinalLowerGCPass());
aotcompile.cpp:        PM->add(createGVNPass());
aotcompile.cpp:        PM->add(createSCCPPass());
aotcompile.cpp:        PM->add(createDeadCodeEliminationPass());
aotcompile.cpp:        PM->add(createLowerPTLSPass(dump_native));
aotcompile.cpp:        PM->add(createInstructionCombiningPass());
aotcompile.cpp:        PM->add(createCFGSimplificationPass());
aotcompile.cpp:        PM->add(createRemoveNIPass());
aotcompile.cpp:    PM->add(createCombineMulAddPass());
aotcompile.cpp:    PM->add(createDivRemPairsPass());
aotcompile.cpp:    PM->add(createAddressSanitizerFunctionPass());
aotcompile.cpp:    PM->add(createMemorySanitizerPass(true));
aotcompile.cpp:    PM->add(createThreadSanitizerLegacyPassPass());
aotcompile.cpp:        void add(Pass *P) { TPM->schedulePass(P); }
aotcompile.cpp:        PMTopLevelManager *TPM = Stack.top()->getTopLevelManager();
aotcompile.cpp:static RegisterPass<JuliaPipeline<0>> X("juliaO0", "Runs the entire julia pipeline (at -O0)", false, false);
aotcompile.cpp:static RegisterPass<JuliaPipeline<2>> Y("julia", "Runs the entire julia pipeline (at -O2)", false, false);
aotcompile.cpp:static RegisterPass<JuliaPipeline<3>> Z("juliaO3", "Runs the entire julia pipeline (at -O3)", false, false);
aotcompile.cpp:// --- native code info, and dump function to IR and ASM ---
aotcompile.cpp:// misuse will leak memory or cause read-after-free
aotcompile.cpp:    if (jl_is_method(mi->def.method) && mi->def.method->source == NULL &&
aotcompile.cpp:            mi->def.method->generator == NULL) {
aotcompile.cpp:        src = (jl_code_info_t*)codeinst->inferred;
aotcompile.cpp:        if ((jl_value_t*)src != jl_nothing && !jl_is_code_info(src) && jl_is_method(mi->def.method))
aotcompile.cpp:            src = jl_uncompress_ir(mi->def.method, codeinst, (jl_array_t*)src);
aotcompile.cpp:        jlrettype = codeinst->rettype;
aotcompile.cpp:            jlrettype = src->rettype;
aotcompile.cpp:        else if (jl_is_method(mi->def.method)) {
aotcompile.cpp:            src = mi->def.method->generator ? jl_code_for_staged(mi) : (jl_code_info_t*)mi->def.method->source;
aotcompile.cpp:            if (src && !jl_is_code_info(src) && jl_is_method(mi->def.method))
aotcompile.cpp:                src = jl_uncompress_ir(mi->def.method, NULL, (jl_array_t*)src);
aotcompile.cpp:        // TODO: use mi->uninferred
aotcompile.cpp:                global.second->setLinkage(GlobalValue::ExternalLinkage);
aotcompile.cpp:                PM->run(*m.get());
aotcompile.cpp:            F = cast<Function>(m->getNamedValue(*fname));
aotcompile.cpp:            jl_atomic_fetch_add_relaxed(&jl_cumulative_compile_time, (jl_hrtime() - compiler_start_time));
partr.c:// thread should not be sleeping--it might need to do work.
partr.c:// information: Observing thread not-sleeping is sufficient to ensure the target thread will subsequently inspect its local queue.
partr.c:// information: Observing thread is-sleeping says it may be necessary to notify it at least once to wakeup. It may already be awake however for a variety of reasons.
partr.c:    int16_t was = jl_atomic_load_relaxed(&task->tid);
partr.c:    if (was == -1)
partr.c:        return jl_atomic_cmpswap(&task->tid, &was, tid);
partr.c:// ---
partr.c:        int32_t parent = (idx-1)/heap_d;
partr.c:        if (heap->tasks[idx]->prio < heap->tasks[parent]->prio) {
partr.c:            jl_task_t *t = heap->tasks[parent];
partr.c:            heap->tasks[parent] = heap->tasks[idx];
partr.c:            heap->tasks[idx] = t;
partr.c:    if (idx < heap->ntasks) {
partr.c:            if (heap->tasks[child]
partr.c:                    && heap->tasks[child]->prio < heap->tasks[idx]->prio) {
partr.c:                jl_task_t *t = heap->tasks[idx];
partr.c:                heap->tasks[idx] = heap->tasks[child];
partr.c:                heap->tasks[child] = t;
partr.c:    jl_ptls_t ptls = jl_current_task->ptls;
partr.c:    task->prio = priority;
partr.c:        rn = cong(heap_p, cong_unbias, &ptls->rngseed);
partr.c:        return -1;
partr.c:    sift_up(&heaps[rn], heaps[rn].ntasks-1);
partr.c:    if (task->prio < prio)
partr.c:        jl_atomic_store_relaxed(&heaps[rn].prio, task->prio);
partr.c:    jl_ptls_t ptls = jl_current_task->ptls;
partr.c:        rn1 = cong(heap_p, cong_unbias, &ptls->rngseed);
partr.c:        rn2 = cong(heap_p, cong_unbias, &ptls->rngseed);
partr.c:    if (!jl_set_task_tid(task, ptls->tid)) {
partr.c:    heaps[rn1].tasks[0] = heaps[rn1].tasks[--heaps[rn1].ntasks];
partr.c:        prio1 = heaps[rn1].tasks[0]->prio;
partr.c:// ---
partr.c:    jl_ptls_t ptls = jl_current_task->ptls;
partr.c:    uv_mutex_init(&ptls->sleep_lock);
partr.c:    uv_cond_init(&ptls->wake_signal);
partr.c:    jl_ptls_t ptls = jl_init_threadtls(targ->tid);
partr.c:    uv_mutex_init(&ptls->sleep_lock);
partr.c:    uv_cond_init(&ptls->wake_signal);
partr.c:    uv_barrier_wait(targ->barrier);
partr.c:    if (multiq_insert(task, task->prio) == -1)
partr.c:        if (ret == -1) {
partr.c://  sleep_check_after_threshold() -- if sleep_threshold ns have passed, return 1
partr.c:     * This wait loop is a bit of a worst case for rr - it needs timer access,
partr.c:    uint64_t elapsed_cycles = jl_hrtime() - (*start_cycles);
partr.c:    jl_atomic_cmpswap(&other->sleep_check_state, &state, not_sleeping);
partr.c:        uv_mutex_lock(&other->sleep_lock);
partr.c:        uv_cond_signal(&other->wake_signal);
partr.c:        uv_mutex_unlock(&other->sleep_lock);
partr.c:    jl_ptls_t ptls = jl_current_task->ptls;
partr.c:    int16_t self = ptls->tid;
partr.c:    jl_thread_t system_self = jl_all_tls_states[self]->system_id;
partr.c:    if (tid == self || tid == -1) {
partr.c:        if (jl_atomic_load_relaxed(&ptls->sleep_check_state) == sleeping)
partr.c:            jl_atomic_store(&ptls->sleep_check_state, not_sleeping);
partr.c:        // something added to the sticky-queue: notify that thread
partr.c:        jl_thread_t system_tid = jl_all_tls_states[tid]->system_id;
partr.c:    if (tid == -1) {
partr.c:        // something added to the multi-queue: notify all threads
partr.c:        int self = jl_atomic_load_relaxed(&jl_current_task->tid);
partr.c:    return jl_atomic_load_relaxed(&ptls->sleep_check_state) == sleeping;
partr.c:        // quick, race-y check to see if there seems to be any stuff in there
partr.c:        jl_ptls_t ptls = ct->ptls;
partr.c:        if (sleep_check_after_threshold(&start_cycles) || (!_threadedregion && ptls->tid == 0)) {
partr.c:            jl_atomic_store(&ptls->sleep_check_state, sleeping); // acquire sleep-check lock
partr.c:                if (jl_atomic_load_relaxed(&ptls->sleep_check_state) != not_sleeping)
partr.c:                    jl_atomic_store(&ptls->sleep_check_state, not_sleeping); // let other threads know they don't need to wake us
partr.c:            if (ptls != ct->ptls)
partr.c:                if (jl_atomic_load_relaxed(&ptls->sleep_check_state) != not_sleeping)
partr.c:                    jl_atomic_store(&ptls->sleep_check_state, not_sleeping); // let other threads know they don't need to wake us
partr.c:            else if (ptls->tid == 0) {
partr.c:                        loop->stop_flag = 0;
partr.c:                        JULIA_DEBUG_SLEEPWAKE( ptls->uv_run_enter = cycleclock() );
partr.c:                        JULIA_DEBUG_SLEEPWAKE( ptls->uv_run_leave = cycleclock() );
partr.c:                        assert(jl_atomic_load_relaxed(&ptls->sleep_check_state) == not_sleeping);
partr.c:                if (!_threadedregion && active && ptls->tid == 0) {
partr.c:                    if (jl_atomic_load_relaxed(&ptls->sleep_check_state) != not_sleeping)
partr.c:                        jl_atomic_store(&ptls->sleep_check_state, not_sleeping); // let other threads know they don't need to wake us
partr.c:            JULIA_DEBUG_SLEEPWAKE( ptls->sleep_enter = cycleclock() );
partr.c:            uv_mutex_lock(&ptls->sleep_lock);
partr.c:                uv_cond_wait(&ptls->wake_signal, &ptls->sleep_lock);
partr.c:            assert(jl_atomic_load_relaxed(&ptls->sleep_check_state) == not_sleeping);
partr.c:            uv_mutex_unlock(&ptls->sleep_lock);
partr.c:            JULIA_DEBUG_SLEEPWAKE( ptls->sleep_leave = cycleclock() );
runtime_ccall.cpp:#include "llvm-version.h"
runtime_ccall.cpp:// --- library symbol lookup ---
runtime_ccall.cpp:// map from user-specified lib names to handles
runtime_ccall.cpp:    // they are not re-enabled by other features that implies them by default.
runtime_ccall.cpp:                attr.append(",-");
runtime_ccall.cpp:                attr.append("-");
runtime_ccall.cpp:                    hostname[sizeof(hostname) - 1] = '\0'; /* Null terminate, just to be safe. */
runtime_ccall.cpp:                    hostname[sizeof(hostname) - 1] = '\0'; /* Null terminate, just to be safe. */
runtime_ccall.cpp:                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
runtime_ccall.cpp:JL_GCC_IGNORE_START("-Wclobbered")
runtime_ccall.cpp:    // call-site constants:
runtime_ccall.cpp:    if (!cache->table)
runtime_ccall.cpp:            (((jl_datatype_t*)jl_typeof(fobj))->instance == fobj);
runtime_ccall.cpp:            if (jl_is_datatype(uw) && ((jl_datatype_t*)uw)->name->wrapper == fobj)
runtime_ccall.cpp:            jl_gc_add_ptr_finalizer(ct->ptls, result, (void*)(uintptr_t)&trampoline_deleter);
llvm-simdloop.cpp:#include "llvm-version.h"
llvm-simdloop.cpp://    floating-point operations as fast-math. `See enableUnsafeAlgebraIfReduction`.
llvm-simdloop.cpp:#include <llvm-c/Core.h>
llvm-simdloop.cpp:#include <llvm-c/Types.h>
llvm-simdloop.cpp:    switch (J->getOpcode()) {
llvm-simdloop.cpp:        if (J->getOperand(0) != operand)
llvm-simdloop.cpp:        if (J->getOperand(0) != operand)
llvm-simdloop.cpp:        for (User *UI : I->users()) { /*}*/
llvm-simdloop.cpp:            if (L->contains(U)) {
llvm-simdloop.cpp:        (*K)->setFast(true);
llvm-simdloop.cpp:    for (User *U : marker->users()) {
llvm-simdloop.cpp:        LoopInfo &LI = GetLI(*I->getParent()->getParent());
llvm-simdloop.cpp:        Loop *L = LI.getLoopFor(I->getParent());
llvm-simdloop.cpp:        I->removeFromParent();
llvm-simdloop.cpp:        BasicBlock *Lh = L->getHeader();
llvm-simdloop.cpp:        TempMDTuple TempNode = MDNode::getTemporary(Lh->getContext(), None);
llvm-simdloop.cpp:        if (I->hasMetadataOtherThanDebugLoc()) {
llvm-simdloop.cpp:            MDNode *JLMD= I->getMetadata("julia.loopinfo");
llvm-simdloop.cpp:                LLVM_DEBUG(dbgs() << "LSL: has julia.loopinfo metadata with " << JLMD->getNumOperands() <<" operands\n");
llvm-simdloop.cpp:                for (unsigned i = 0, ie = JLMD->getNumOperands(); i < ie; ++i) {
llvm-simdloop.cpp:                    Metadata *Op = JLMD->getOperand(i);
llvm-simdloop.cpp:                        LLVM_DEBUG(dbgs() << "LSL: found " << S->getString() << "\n");
llvm-simdloop.cpp:                        if (S->getString().startswith("julia")) {
llvm-simdloop.cpp:                            if (S->getString().equals("julia.simdloop"))
llvm-simdloop.cpp:                            if (S->getString().equals("julia.ivdep"))
llvm-simdloop.cpp:        MDNode *n = L->getLoopID();
llvm-simdloop.cpp:            for (unsigned i = 1, ie = n->getNumOperands(); i < ie; ++i) {
llvm-simdloop.cpp:                Metadata *Op = n->getOperand(i);
llvm-simdloop.cpp:        MDNode *LoopID = MDNode::getDistinct(Lh->getContext(), MDs);
llvm-simdloop.cpp:        // Replace the temporary node with a self-reference.
llvm-simdloop.cpp:        LoopID->replaceOperandWith(0, LoopID);
llvm-simdloop.cpp:        L->setLoopID(LoopID);
llvm-simdloop.cpp:        assert(L->getLoopID());
llvm-simdloop.cpp:        MDNode *m = MDNode::get(Lh->getContext(), ArrayRef<Metadata *>(LoopID));
llvm-simdloop.cpp:            for (BasicBlock *BB : L->blocks()) {
llvm-simdloop.cpp:            assert(L->isAnnotatedParallel());
llvm-simdloop.cpp:            // Mark floating-point reductions as okay to reassociate/commute.
llvm-simdloop.cpp:            for (BasicBlock::iterator I = Lh->begin(), E = Lh->end(); I != E; ++I) {
llvm-simdloop.cpp:        I->deleteValue();
llvm-simdloop.cpp:    marker->eraseFromParent();
llvm-simdloop.cpp:/// otherwise floating-point reductions might not be recognized as such and
llvm-simdloop.cpp:    auto GetLI = [&FAM](Function &F) -> LoopInfo & {
llvm-simdloop.cpp:    auto GetLI = [this](Function &F) -> LoopInfo & {
llvm-simdloop.cpp:    unwrap(PM)->add(createLowerSimdLoopPass());
jl_uv.c:    JL_MUTEX_INIT(&jl_uv_mutex); // a file-scope initializer can be used instead
jl_uv.c:        jl_atomic_fetch_add(&jl_uv_n_waiters, -1);
jl_uv.c:    args[0] = jl_get_global(jl_base_relative_to(((jl_datatype_t*)jl_typeof(val))->name->module),
jl_uv.c:    jl_apply(args, 2); // TODO: wrap in try-catch?
jl_uv.c:    if (handle->type != UV_FILE && handle->data) {
jl_uv.c:        size_t last_age = ct->world_age;
jl_uv.c:        ct->world_age = jl_world_counter;
jl_uv.c:        jl_uv_call_close_callback((jl_value_t*)handle->data);
jl_uv.c:        ct->world_age = last_age;
jl_uv.c:    uv_stream_t *stream = req->handle;
jl_uv.c:    req->handle = NULL;
jl_uv.c:    if (stream->stream.conn.shutdown_req)
jl_uv.c:    if (stream->shutdown_req)
jl_uv.c:    if (status == 0 && uv_is_writable(stream) && stream->write_queue_size != 0) {
jl_uv.c:        req->data = NULL;
jl_uv.c:    if (!uv_is_closing((uv_handle_t*)stream)) { // avoid double-close on the stream
jl_uv.c:        if (stream->type == UV_TTY)
jl_uv.c:    *(int*)(req->data) = 1;
jl_uv.c:    uv_stop(req->handle->loop);
jl_uv.c:// Warning: This calls uv_run, so it can have unbounded side-effects.
jl_uv.c:// Be care where you call it from! - the libuv loop is also not reentrant.
jl_uv.c:    if (stream->type != UV_TTY &&
jl_uv.c:        stream->type != UV_TCP &&
jl_uv.c:        stream->type != UV_NAMED_PIPE)
jl_uv.c:    while (uv_is_writable(stream) && stream->write_queue_size != 0) {
jl_uv.c:        write_req->data = (void*)&fired;
jl_uv.c:// TODO: check if whoever calls these is thread-safe
jl_uv.c:JL_DLLEXPORT int jl_uv_process_pid(uv_process_t *p) { return p->pid; }
jl_uv.c:JL_DLLEXPORT void *jl_uv_process_data(uv_process_t *p) { return p->data; }
jl_uv.c:JL_DLLEXPORT void *jl_uv_buf_base(const uv_buf_t *buf) { return buf->base; }
jl_uv.c:JL_DLLEXPORT size_t jl_uv_buf_len(const uv_buf_t *buf) { return buf->len; }
jl_uv.c:JL_DLLEXPORT void jl_uv_buf_set_base(uv_buf_t *buf, char *b) { buf->base = b; }
jl_uv.c:JL_DLLEXPORT void jl_uv_buf_set_len(uv_buf_t *buf, size_t n) { buf->len = n; }
jl_uv.c:JL_DLLEXPORT void *jl_uv_connect_handle(uv_connect_t *connect) { return connect->handle; }
jl_uv.c:JL_DLLEXPORT uv_os_fd_t jl_uv_file_handle(jl_uv_file_t *f) { return f->file; }
jl_uv.c:JL_DLLEXPORT void *jl_uv_req_data(uv_req_t *req) { return req->data; }
jl_uv.c:JL_DLLEXPORT void jl_uv_req_set_data(uv_req_t *req, void *data) { req->data = data; }
jl_uv.c:JL_DLLEXPORT void *jl_uv_handle_data(uv_handle_t *handle) { return handle->data; }
jl_uv.c:JL_DLLEXPORT void *jl_uv_write_handle(uv_write_t *req) { return req->handle; }
jl_uv.c:    jl_gc_safepoint_(ct->ptls);
jl_uv.c:    if (loop && (_threadedregion || jl_atomic_load_relaxed(&ct->tid) == 0)) {
jl_uv.c:            loop->stop_flag = 0;
jl_uv.c:        jl_gc_safepoint_(ct->ptls);
jl_uv.c:    if (handle->type == UV_PROCESS && ((uv_process_t*)handle)->pid != 0) {
jl_uv.c:        assert(handle->data == NULL); // make sure Julia has forgotten about it already
jl_uv.c:        ((uv_process_t*)handle)->exit_cb = jl_proc_exit_cleanup_cb;
jl_uv.c:    if (handle->type == UV_FILE) {
jl_uv.c:        if ((ssize_t)fd->file != -1) {
jl_uv.c:            uv_fs_close(handle->loop, &req, fd->file, NULL);
jl_uv.c:            fd->file = (uv_os_fd_t)(ssize_t)-1;
jl_uv.c:    if (handle->type == UV_NAMED_PIPE || handle->type == UV_TCP || handle->type == UV_TTY) {
jl_uv.c:        req->handle = (uv_stream_t*)handle;
jl_uv.c:    // avoid double-closing the stream
jl_uv.c:    // avoid double-closing the stream
jl_uv.c:    handle->data = data;
jl_uv.c:    handle->data = NULL;
jl_uv.c:    while (nstdio--) {
jl_uv.c:            proc->type = UV_PROCESS;
jl_uv.c:            proc->loop = loop;
jl_uv.c:            proc->flags = UV_CLOSED;
jl_uv.c:    if (jl_get_safe_restore() || ct == NULL || jl_atomic_load_relaxed(&ct->tid) != 0)
jl_uv.c:    int ret = uv_fs_read(unused_uv_loop_arg, &req, handle, buf, 1, -1, NULL);
jl_uv.c:    int ret = uv_fs_read(unused_uv_loop_arg, &req, handle, buf, 1, -1, NULL);
jl_uv.c:    case -1: return ret;
jl_uv.c:        return -1;
jl_uv.c:        sizeof(((uv_stream_t*)0)->type) == sizeof(((ios_t*)0)->bm),
jl_uv.c:    uv_os_fd_t fd = (uv_os_fd_t)(ssize_t)-1;
jl_uv.c:    else if (stream->type == UV_FILE) {
jl_uv.c:        fd = ((jl_uv_file_t*)stream)->file;
jl_uv.c:    // TODO: Hack to make CoreIO thread-safer
jl_uv.c:    if (ct == NULL || jl_atomic_load_relaxed(&ct->tid) != 0) {
jl_uv.c:    if ((ssize_t)fd != -1) {
jl_uv.c:        jl_fs_write(fd, str, n, -1);
jl_uv.c:    else if (stream->type > UV_HANDLE_TYPE_MAX) {
jl_uv.c:        req->data = NULL;
jl_uv.c:        addr->v6.sin6_family = AF_INET6;
jl_uv.c:        memcpy(&addr->v6.sin6_addr, host, 16);
jl_uv.c:        addr->v6.sin6_port = port;
jl_uv.c:        addr->v4.sin_family = AF_INET;
jl_uv.c:        addr->v4.sin_addr.s_addr = *(uint32_t*)host;
jl_uv.c:        addr->v4.sin_port = port;
jl_uv.c://NOTE: These function expects port/host to be in network byte-order (Big Endian)
jl_uv.c:        *port = addr4->sin_port;
jl_uv.c:        memcpy(host, &(addr4->sin_addr), 4);
jl_uv.c:        *port = addr6->sin6_port;
jl_uv.c:        memcpy(host, &(addr6->sin6_addr), 16);
jl_uv.c:        *port = addr4->sin_port;
jl_uv.c:        memcpy(host, &(addr4->sin_addr), 4);
jl_uv.c:        *port = addr6->sin6_port;
jl_uv.c:        memcpy(host, &(addr6->sin6_addr), 16);
jl_uv.c:    return addr->is_internal;
jl_uv.c:    return &ifa->address.address4;
jl_uv.c:    req->data = NULL;
jl_uv.c:    return addrinfo->ai_addr;
jl_uv.c:    return addrinfo->ai_next;
jl_uv.c:    return (addr->sa_family == AF_INET);
jl_uv.c:    return (addr->sa_family == AF_INET6);
jl_uv.c:    return addr->sin_addr.s_addr;
jl_uv.c:    memcpy(host, &addr->sin6_addr, 16);
jl_uv.c:    return addr->sin6_scope_id;
jl_uv.c:    return addr->sin_port;
jl_uv.c:    return addr->sin6_port;
jl_uv.c:    if (addr->in.sa_family == AF_INET)
jl_uv.c:        addr->v4.sin_port = port;
jl_uv.c:        addr->v6.sin6_port = port;
jl_uv.c:    req->data = NULL;
jl_uv.c:    int fd = (handle)->io_watcher.fd;
jl_uv.c:    if (fd != -1) {
jl_uv.c:            return -1;
jl_uv.c:    int fd = (handle)->io_watcher.fd;
jl_uv.c:        return -1;
jl_uv.c:    return -1;
jl_uv.c:    if (fd >= loop->nwatchers) {
jl_uv.c:    if (loop->watchers[fd] == NULL) {
jl_uv.c:    if (handle && loop->watchers[fd] == &handle->io_watcher) {
jl_uv.c:    if (pipe->type != UV_NAMED_PIPE) return 0;
jl_uv.c:    // ^\\\\?\\pipe\\(msys|cygwin)-[0-9a-z]{16}-[pt]ty[1-9][0-9]*-
jl_uv.c:    if (!strncmp(name,"\\\\?\\pipe\\msys-",14))
jl_uv.c:    else if (!strncmp(name,"\\\\?\\pipe\\cygwin-",16))
jl_uv.c:    if ((*name++)!='-') return 0;
jl_uv.c:    return handle->type;
jl_uv.c:    if (handle->type != UV_TTY) return 0;
jl_uv.c:    struct work_baton *baton = (struct work_baton*) req->data;
jl_uv.c:    baton->work_func(baton->ccall_fptr, baton->work_args, baton->work_retval);
jl_uv.c:    struct work_baton *baton = (struct work_baton*) req->data;
jl_uv.c:    baton->notify_func(baton->notify_idx);
jl_uv.c:    baton->req.data = (void*) baton;
jl_uv.c:    baton->work_func = work_func;
jl_uv.c:    baton->ccall_fptr = ccall_fptr;
jl_uv.c:    baton->work_args = work_args;
jl_uv.c:    baton->work_retval = work_retval;
jl_uv.c:    baton->notify_func = notify_func;
jl_uv.c:    baton->notify_idx = notify_idx;
jl_uv.c:    uv_queue_work(jl_io_loop, &baton->req, jl_work_wrapper, jl_work_notifier);
jl_uv.c:#define uv__stream_fd(handle) ((handle)->io_watcher.fd)
jl_uv.c:    switch (handle->type) {
jl_uv.c:        return ((uv_tty_t*)handle)->handle;
jl_uv.c:        return ((uv_pipe_t*)handle)->handle;
opaque_closure.c:    size_t last_age = ct->world_age;
opaque_closure.c:    ct->world_age = oc->world;
opaque_closure.c:    ct->world_age = last_age;
opaque_closure.c:    jl_opaque_closure_t *oc = (jl_opaque_closure_t*)jl_gc_alloc(ct->ptls, sizeof(jl_opaque_closure_t), oc_type);
opaque_closure.c:    oc->source = (jl_method_t*)source;
opaque_closure.c:    oc->isva = jl_unbox_bool(isva);
opaque_closure.c:    oc->invoke = (jl_fptr_args_t)jl_invoke_opaque_closure;
opaque_closure.c:    oc->specptr = NULL;
opaque_closure.c:    oc->captures = captures;
opaque_closure.c:    oc->world = jl_world_counter;
opaque_closure.c:        args[1], args[2], args[3], args[4], &args[5], nargs-5);
opaque_closure.c:    jl_value_t *va = jl_tparam(v,nparams-1);
opaque_closure.c:            return nargs == nparams - 1 + jl_unbox_long(len);
opaque_closure.c:        return nargs >= nparams - 1;
opaque_closure.c:        jl_method_error(F, args, nargs + 1, oc->world);
opaque_closure.c:        jl_value_t *typ = i >= ntypes ? jl_svecref(types, ntypes-1) : jl_svecref(types, i);
opaque_closure.c:    return oc->invoke(F, args, nargs);
llvm-demote-float16.cpp:// This pass finds floating-point operations on 16-bit (half precision) values, and replaces
llvm-demote-float16.cpp:// them by equivalent operations on 32-bit (single precision) values surrounded by a fpext
llvm-demote-float16.cpp:// and fptrunc. This ensures that the exact semantics of IEEE floating-point are preserved.
llvm-demote-float16.cpp:// Without this pass, back-ends that do not natively support half-precision (e.g. x86_64)
llvm-demote-float16.cpp:// similarly pattern-match half-precision operations with single-precision equivalents, but
llvm-demote-float16.cpp:// without truncating after every operation. Doing so breaks floating-point operations that
llvm-demote-float16.cpp:// instcombine. A run of GVN is recommended to clean-up identical conversions.
llvm-demote-float16.cpp:#include "llvm-version.h"
llvm-demote-float16.cpp:            // TODO: more fine-grained check (afn?)
llvm-demote-float16.cpp:                if (Op->getType() == T_float16) {
llvm-demote-float16.cpp:                    NewI = builder.CreateFCmp(cast<FCmpInst>(&I)->getPredicate(),
llvm-demote-float16.cpp:                cast<Instruction>(NewI)->copyMetadata(I);
llvm-demote-float16.cpp:                cast<Instruction>(NewI)->copyFastMathFlags(&I);
llvm-demote-float16.cpp:                if (NewI->getType() != I.getType())
llvm-demote-float16.cpp:            V->eraseFromParent();
llvm-demote-float16.cpp:    unwrap(PM)->add(createDemoteFloat16Pass());
abi_aarch64.cpp://===----------------------------------------------------------------------===//
abi_aarch64.cpp://===----------------------------------------------------------------------===//
abi_aarch64.cpp://===----------------------------------------------------------------------===//
abi_aarch64.cpp:    // `!dt->name->mutabl && dt->pointerfree && !dt->haspadding && dt->nfields > 0`
abi_aarch64.cpp:    if (dt->layout == NULL || jl_is_layout_opaque(dt->layout))
abi_aarch64.cpp:    size_t nfields = dt->layout->nfields;
abi_aarch64.cpp:    if (ft0->name != jl_vecelement_typename ||
abi_aarch64.cpp:        ((jl_datatype_t*)jl_field_type(ft0, 0))->layout->nfields)
abi_aarch64.cpp:    // `!dt->name->mutabl && dt->pointerfree && !dt->haspadding && dt->nfields == 0`
abi_aarch64.cpp:    if (dt->name->mutabl || dt->layout->npointers || dt->layout->haspadding)
abi_aarch64.cpp:    return dt->layout->nfields ? get_llvm_vectype(dt, ctx) : get_llvm_fptype(dt, ctx);
abi_aarch64.cpp:// Whether a type is a homogeneous floating-point aggregates (HFA) or a
abi_aarch64.cpp:// homogeneous short-vector aggregates (HVA). Returns the element type.
abi_aarch64.cpp:    // GCC for zero-sized array members. GCC seems to treat structs with
abi_aarch64.cpp:    // zero sized array members as non-HFA and non-HVA. Clang (3.7 and 3.8)
abi_aarch64.cpp:    // An Homogeneous Floating-point Aggregate (HFA) is an Homogeneous Aggregate
abi_aarch64.cpp:    // with a Fundamental Data Type that is a Floating-Point type and at most
abi_aarch64.cpp:    // An Homogeneous Short-Vector Aggregate (HVA) is an Homogeneous Aggregate
abi_aarch64.cpp:    // with a Fundamental Data Type that is a Short-Vector type and at most four
abi_aarch64.cpp:    if (dsz > 64 || !dt->layout || dt->layout->npointers || dt->layout->haspadding)
abi_aarch64.cpp:// If the argument should be passed in SIMD and floating-point registers,
abi_aarch64.cpp:    //   If the argument is a Half-, Single-, Double- or Quad- precision
abi_aarch64.cpp:    //   Floating-point or Short Vector Type and the NSRN is less than 8, then
abi_aarch64.cpp:    //   unallocated SIMD and Floating-point registers (NSRN + number of
abi_aarch64.cpp:    //   Floating-point Registers (with one register per member of the HFA
abi_aarch64.cpp:    //   If the argument is an HFA, an HVA, a Quad-precision Floating-point or
abi_aarch64.cpp:    //   If the argument is a Half- or Single- precision Floating Point type,
abi_aarch64.cpp:    //   the argument had been copied to the least significant bits of a 64-bit
abi_aarch64.cpp:    //   If the argument is an HFA, an HVA, a Half-, Single-, Double- or
abi_aarch64.cpp:    //   Quad- precision Floating-point or Short Vector Type, then the argument
abi_aarch64.cpp:    //   and x[NGRN+1]. x[NGRN] shall contain the lower addressed double-word
abi_aarch64.cpp:    //   If the argument is a Composite Type and the size in double-words of
abi_aarch64.cpp:    //   copied into consecutive general-purpose registers, starting at x[NGRN].
abi_aarch64.cpp:    //   from a double-word-aligned address with an appropriate sequence of LDR
abi_aarch64.cpp:    // 0-size types (Nothing) won't be rewritten and that is what we want
abi_aarch64.cpp:    //   copied to the least significant bits of a 64-bit register and the
julia.expmap:    /* compiler run-time intrinsics */
dump.c:// type-rewriting of some sort
dump.c:// --- serialize ---
dump.c:    write_uint8(s->s, TAG_CNULL);
dump.c:// and thus does not need delayed unique-ing
dump.c:    if (module_in_worklist(dt->name->module))
dump.c:    int i, l = jl_svec_len(dt->parameters);
dump.c:    //    if (!type_parameter_recursively_external(((jl_unionall_t*)p)->var->lb))
dump.c:    //    if (!type_parameter_recursively_external(((jl_unionall_t*)p)->var->ub))
dump.c:    //    p = (jl_datatype_t*)((jl_unionall_t*)p)->body;
dump.c:    if (module_in_worklist(p->name->module))
dump.c:    if (p->name->wrapper != (jl_value_t*)p0) {
dump.c:    if (!dt->isconcretetype)
dump.c:    if (jl_svec_len(dt->parameters) == 0)
dump.c:    int i, l = jl_svec_len(dt->parameters);
dump.c:    int internal = module_in_worklist(dt->name->module);
dump.c:    if (!internal && jl_unwrap_unionall(dt->name->wrapper) == (jl_value_t*)dt) {
dump.c:    else if (jl_is_tuple_type(dt) ? !dt->isconcretetype : dt->hasfreetypevars) {
dump.c:        if (jl_unwrap_unionall(dt->name->wrapper) == (jl_value_t*)dt) // comes up often since functions create types
dump.c:        tag = 11; // external, but definitely new (still needs caching, but not full unique-ing)
dump.c:        // this is eligible for (and possibly requires) unique-ing later,
dump.c:    char *dtname = jl_symbol_name(dt->name->name);
dump.c:    if (dtnl > 4 && strcmp(&dtname[dtnl - 4], "##kw") == 0 && !internal && tag != 0) {
dump.c:        /* XXX: yuck, this is horrible, but the auto-generated kw types from the serializer isn't a real type, so we *must* be very careful */
dump.c:        if (jl_type_type_mt->kwsorter != NULL && dt == (jl_datatype_t*)jl_typeof(jl_type_type_mt->kwsorter)) {
dump.c:        else if (jl_nonfunction_mt->kwsorter != NULL && dt == (jl_datatype_t*)jl_typeof(jl_nonfunction_mt->kwsorter)) {
dump.c:            jl_methtable_t *mt = dt->name->mt;
dump.c:            size_t l = strlen(jl_symbol_name(mt->name));
dump.c:            strcpy(&prefixed[1], jl_symbol_name(mt->name));
dump.c:            prefixed[l-3] = 0;
dump.c:            jl_value_t *primarydt = jl_get_global(mt->module, tname);
dump.c:                primarydt = jl_get_global(mt->module, mt->name);
dump.c:            assert(primarydt == (jl_value_t*)jl_any_type || jl_typeof(((jl_datatype_t*)primarydt)->name->mt->kwsorter) == (jl_value_t*)dt);
dump.c:    write_uint8(s->s, TAG_DATATYPE);
dump.c:    write_uint8(s->s, tag);
dump.c:        jl_serialize_value(s, dt->name);
dump.c:        jl_serialize_value(s, dt->parameters);
dump.c:    write_int32(s->s, dt->size);
dump.c:    int has_instance = (dt->instance != NULL);
dump.c:    int has_layout = (dt->layout != NULL);
dump.c:    write_uint8(s->s, has_layout | (has_instance << 1));
dump.c:    write_uint8(s->s, dt->hasfreetypevars
dump.c:            | (dt->isconcretetype << 1)
dump.c:            | (dt->isdispatchtuple << 2)
dump.c:            | (dt->isbitstype << 3)
dump.c:            | (dt->zeroinit << 4)
dump.c:            | (dt->has_concrete_subtype << 5)
dump.c:            | (dt->cached_by_hash << 6));
dump.c:    write_int32(s->s, dt->hash);
dump.c:        if (dt->layout == ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_array_type))->layout) {
dump.c:        else if (dt->layout == jl_nothing_type->layout) {
dump.c:        else if (dt->layout == ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_pointer_type))->layout) {
dump.c:        write_uint8(s->s, layout);
dump.c:            uint32_t nf = dt->layout->nfields;
dump.c:            uint32_t np = dt->layout->npointers;
dump.c:            size_t fieldsize = jl_fielddesc_size(dt->layout->fielddesc_type);
dump.c:            ios_write(s->s, (const char*)dt->layout, sizeof(*dt->layout));
dump.c:            if (dt->layout->first_ptr != -1)
dump.c:                fldsize += np << dt->layout->fielddesc_type;
dump.c:            ios_write(s->s, (const char*)(dt->layout + 1), fldsize);
dump.c:        jl_serialize_value(s, dt->instance);
dump.c:    jl_serialize_value(s, dt->name);
dump.c:    jl_serialize_value(s, dt->parameters);
dump.c:    jl_serialize_value(s, dt->super);
dump.c:    jl_serialize_value(s, dt->types);
dump.c:    write_uint8(s->s, TAG_MODULE);
dump.c:    jl_serialize_value(s, m->name);
dump.c:        if (m == m->parent) {
dump.c:            // top-level module
dump.c:            write_int8(s->s, 2);
dump.c:            for (i = 0; i < jl_array_len(s->loaded_modules_array); i++) {
dump.c:                jl_module_t *mi = (jl_module_t*)jl_array_ptr_ref(s->loaded_modules_array, i);
dump.c:                        write_int32(s->s, j);
dump.c:            write_int8(s->s, 1);
dump.c:            jl_serialize_value(s, m->parent);
dump.c:    write_int8(s->s, 0);
dump.c:    jl_serialize_value(s, m->parent);
dump.c:    void **table = m->bindings.table;
dump.c:    for (i = 0; i < m->bindings.size; i += 2) {
dump.c:            jl_serialize_value(s, b->name);
dump.c:            jl_value_t *e = jl_atomic_load_relaxed(&b->value);
dump.c:            if (!b->constp && e && jl_is_cpointer(e) && jl_unbox_voidpointer(e) != (void*)-1 && jl_unbox_voidpointer(e) != NULL)
dump.c:            jl_serialize_value(s, jl_atomic_load_relaxed(&b->globalref));
dump.c:            jl_serialize_value(s, b->owner);
dump.c:            write_int8(s->s, (b->deprecated<<3) | (b->constp<<2) | (b->exportp<<1) | (b->imported));
dump.c:    write_int32(s->s, m->usings.len);
dump.c:    for(i=0; i < m->usings.len; i++) {
dump.c:        jl_serialize_value(s, (jl_value_t*)m->usings.items[i]);
dump.c:    write_uint8(s->s, m->istopmod);
dump.c:    write_uint64(s->s, m->uuid.hi);
dump.c:    write_uint64(s->s, m->uuid.lo);
dump.c:    write_uint64(s->s, m->build_id);
dump.c:    write_int32(s->s, m->counter);
dump.c:    write_int32(s->s, m->nospecialize);
dump.c:    write_uint8(s->s, m->optlevel);
dump.c:    write_uint8(s->s, m->compile);
dump.c:    write_uint8(s->s, m->infer);
dump.c:        write_uint8(s->s, TAG_NULL);
dump.c:            write_uint8(s->s, 0);
dump.c:        write_uint8(s->s, t8);
dump.c:            write_uint8(s->s, TAG_COMMONSYM);
dump.c:            write_uint8(s->s, (uint8_t)(size_t)idx);
dump.c:        write_uint8(s->s, TAG_CORE);
dump.c:        write_uint8(s->s, TAG_BASE);
dump.c:            uintptr_t pos = (char*)*bp - (char*)HT_NOTFOUND - 1;
dump.c:                write_uint8(s->s, TAG_SHORT_BACKREF);
dump.c:                write_uint16(s->s, pos);
dump.c:                write_uint8(s->s, TAG_BACKREF);
dump.c:                write_int32(s->s, pos);
dump.c:        if (((jl_datatype_t*)(jl_typeof(v)))->name == jl_idtable_typename) {
dump.c:            if (module_in_worklist(m) && !module_in_worklist(m->parent)) {
dump.c:    if (codeinst->max_world == ~(size_t)0)
dump.c:    if (codeinst->invoke == jl_fptr_const_return)
dump.c:    if (codeinst->precompile)
dump.c:    // be re-infered on reload.
dump.c:    int write_ret_type = validate || codeinst->min_world == 0;
dump.c:    if (write_ret_type && codeinst->rettype_const &&
dump.c:            jl_typeis(codeinst->rettype_const, jl_partial_opaque_type)) {
dump.c:            jl_serialize_code_instance(s, codeinst->next, skip_partial_opaque);
dump.c:    write_uint8(s->s, TAG_CODE_INSTANCE);
dump.c:    write_uint8(s->s, flags);
dump.c:    jl_serialize_value(s, (jl_value_t*)codeinst->def);
dump.c:        jl_serialize_value(s, codeinst->inferred);
dump.c:        jl_serialize_value(s, codeinst->rettype_const);
dump.c:        jl_serialize_value(s, codeinst->rettype);
dump.c:    jl_serialize_code_instance(s, codeinst->next, skip_partial_opaque);
dump.c:            write_uint8(s->s, TAG_SVEC);
dump.c:            write_uint8(s->s, (uint8_t)l);
dump.c:            write_uint8(s->s, TAG_LONG_SVEC);
dump.c:            write_int32(s->s, l);
dump.c:            write_uint8(s->s, TAG_SYMBOL);
dump.c:            write_uint8(s->s, (uint8_t)l);
dump.c:            write_uint8(s->s, TAG_LONG_SYMBOL);
dump.c:            write_int32(s->s, l);
dump.c:        ios_write(s->s, jl_symbol_name((jl_sym_t*)v), l);
dump.c:        if (ar->flags.ndims == 1 && ar->elsize <= 0x1f) {
dump.c:            write_uint8(s->s, TAG_ARRAY1D);
dump.c:            write_uint8(s->s, (ar->flags.ptrarray << 7) | (ar->flags.hasptr << 6) | (isunion << 5) | (ar->elsize & 0x1f));
dump.c:            write_uint8(s->s, TAG_ARRAY);
dump.c:            write_uint16(s->s, ar->flags.ndims);
dump.c:            write_uint16(s->s, (ar->flags.ptrarray << 15) | (ar->flags.hasptr << 14) | (isunion << 13) | (ar->elsize & 0x1fff));
dump.c:        for (i = 0; i < ar->flags.ndims; i++)
dump.c:        if (ar->flags.ptrarray) {
dump.c:                if (e && jl_is_cpointer(e) && jl_unbox_voidpointer(e) != (void*)-1 && jl_unbox_voidpointer(e) != NULL)
dump.c:        else if (ar->flags.hasptr) {
dump.c:            uint16_t elsz = ar->elsize;
dump.c:            size_t j, np = ((jl_datatype_t*)et)->layout->npointers;
dump.c:                        ios_write(s->s, start, (const char*)fld - start);
dump.c:                    ios_write(s->s, start, data - start);
dump.c:                if (e != (void*)-1)
dump.c:                ios_write(s->s, (const char*)&e, sizeof(e));
dump.c:            ios_write(s->s, (char*)jl_array_data(ar), l * ar->elsize);
dump.c:                ios_write(s->s, jl_array_typetagdata(ar), l);
dump.c:        write_uint8(s->s, TAG_UNIONALL);
dump.c:        if (jl_is_datatype(d) && d->name->wrapper == v &&
dump.c:            !module_in_worklist(d->name->module)) {
dump.c:            write_uint8(s->s, 1);
dump.c:            jl_serialize_value(s, d->name->module);
dump.c:            jl_serialize_value(s, d->name->name);
dump.c:            write_uint8(s->s, 0);
dump.c:            jl_serialize_value(s, ((jl_unionall_t*)v)->var);
dump.c:            jl_serialize_value(s, ((jl_unionall_t*)v)->body);
dump.c:        write_uint8(s->s, TAG_TVAR);
dump.c:        jl_serialize_value(s, ((jl_tvar_t*)v)->name);
dump.c:        jl_serialize_value(s, ((jl_tvar_t*)v)->lb);
dump.c:        jl_serialize_value(s, ((jl_tvar_t*)v)->ub);
dump.c:        write_uint8(s->s, TAG_METHOD);
dump.c:        if (m->is_for_opaque_closure || module_in_worklist(m->module))
dump.c:        jl_serialize_value(s, (jl_value_t*)m->sig);
dump.c:        jl_serialize_value(s, (jl_value_t*)m->module);
dump.c:        if (m->external_mt != NULL) {
dump.c:            assert(jl_typeis(m->external_mt, jl_methtable_type));
dump.c:            jl_methtable_t *mt = (jl_methtable_t*)m->external_mt;
dump.c:            if (!module_in_worklist(mt->module)) {
dump.c:        write_uint8(s->s, serialization_mode);
dump.c:            jl_methtable_t *mt = (jl_methtable_t*)m->external_mt;
dump.c:            jl_serialize_value(s, mt->module);
dump.c:            jl_serialize_value(s, mt->name);
dump.c:            jl_serialize_value(s, (jl_value_t*)m->external_mt);
dump.c:        jl_serialize_value(s, m->specializations);
dump.c:        jl_serialize_value(s, jl_atomic_load_relaxed(&m->speckeyset));
dump.c:        jl_serialize_value(s, (jl_value_t*)m->name);
dump.c:        jl_serialize_value(s, (jl_value_t*)m->file);
dump.c:        write_int32(s->s, m->line);
dump.c:        write_int32(s->s, m->called);
dump.c:        write_int32(s->s, m->nargs);
dump.c:        write_int32(s->s, m->nospecialize);
dump.c:        write_int32(s->s, m->nkw);
dump.c:        write_int8(s->s, m->isva);
dump.c:        write_int8(s->s, m->pure);
dump.c:        write_int8(s->s, m->is_for_opaque_closure);
dump.c:        write_int8(s->s, m->constprop);
dump.c:        jl_serialize_value(s, (jl_value_t*)m->slot_syms);
dump.c:        jl_serialize_value(s, (jl_value_t*)m->roots);
dump.c:        jl_serialize_value(s, (jl_value_t*)m->ccallable);
dump.c:        jl_serialize_value(s, (jl_value_t*)m->source);
dump.c:        jl_serialize_value(s, (jl_value_t*)m->unspecialized);
dump.c:        jl_serialize_value(s, (jl_value_t*)m->generator);
dump.c:        jl_serialize_value(s, (jl_value_t*)m->invokes);
dump.c:        jl_serialize_value(s, (jl_value_t*)m->recursion_relation);
dump.c:        if (jl_is_method(mi->def.value) && mi->def.method->is_for_opaque_closure) {
dump.c:        write_uint8(s->s, TAG_METHOD_INSTANCE);
dump.c:        if (!jl_is_method(mi->def.method))
dump.c:        else if (module_in_worklist(mi->def.method->module))
dump.c:        write_uint8(s->s, internal);
dump.c:            jl_serialize_value(s, (jl_value_t*)mi->uninferred);
dump.c:        jl_serialize_value(s, (jl_value_t*)mi->specTypes);
dump.c:        jl_serialize_value(s, mi->def.value);
dump.c:        jl_serialize_value(s, (jl_value_t*)mi->sparam_vals);
dump.c:        jl_array_t *backedges = mi->backedges;
dump.c:                if (module_in_worklist(backedge->def.method->module)) {
dump.c:                jl_array_del_end(backedges, l - ins);
dump.c:        jl_serialize_code_instance(s, mi->cache, 1);
dump.c:        write_uint8(s->s, TAG_STRING);
dump.c:        write_int32(s->s, jl_string_len(v));
dump.c:        ios_write(s->s, jl_string_data(v), jl_string_len(v));
dump.c:            write_uint8(s->s, TAG_SHORTER_INT64);
dump.c:            write_uint16(s->s, (uint16_t)*(int64_t*)data);
dump.c:            write_uint8(s->s, TAG_SHORT_INT64);
dump.c:            write_int32(s->s, (int32_t)*(int64_t*)data);
dump.c:            write_uint8(s->s, TAG_INT64);
dump.c:            write_int64(s->s, *(int64_t*)data);
dump.c:            write_uint8(s->s, TAG_SHORT_INT32);
dump.c:            write_uint16(s->s, (uint16_t)*(int32_t*)data);
dump.c:            write_uint8(s->s, TAG_INT32);
dump.c:            write_int32(s->s, *(int32_t*)data);
dump.c:        write_uint8(s->s, TAG_UINT8);
dump.c:        write_int8(s->s, *(int8_t*)jl_data_ptr(v));
dump.c:        write_uint8(s->s, TAG_CNULL);
dump.c:        write_uint8(s->s, TAG_SHORT_GENERAL);
dump.c:        write_uint8(s->s, jl_datatype_size(jl_bigint_type));
dump.c:        size_t nb = (sz == 0 ? 1 : (sz < 0 ? -sz : sz)) * gmp_limb_size;
dump.c:        ios_write(s->s, (char*)data, nb);
dump.c:        if (v == t->instance) {
dump.c:            write_uint8(s->s, TAG_SINGLETON);
dump.c:        assert(!t->instance && "detected singleton construction corruption");
dump.c:            void *bttag = ptrhash_get(&ser_tag, ((jl_typename_t*)t)->wrapper);
dump.c:                write_uint8(s->s, TAG_BITYPENAME);
dump.c:                write_uint8(s->s, (uint8_t)(intptr_t)bttag);
dump.c:        if (t->size <= 255) {
dump.c:            write_uint8(s->s, TAG_SHORT_GENERAL);
dump.c:            write_uint8(s->s, t->size);
dump.c:            write_uint8(s->s, TAG_GENERAL);
dump.c:            write_int32(s->s, t->size);
dump.c:            int internal = module_in_worklist(tn->module);
dump.c:            write_uint8(s->s, internal);
dump.c:            jl_serialize_value(s, tn->module);
dump.c:            jl_serialize_value(s, tn->name);
dump.c:                jl_serialize_value(s, tn->names);
dump.c:                jl_serialize_value(s, tn->wrapper);
dump.c:                jl_serialize_value(s, tn->mt);
dump.c:                ios_write(s->s, (char*)&tn->hash, sizeof(tn->hash));
dump.c:                write_uint8(s->s, tn->abstract | (tn->mutabl << 1) | (tn->mayinlinealloc << 2));
dump.c:                if (!tn->abstract)
dump.c:                    write_uint16(s->s, tn->n_uninitialized);
dump.c:                size_t nb = tn->atomicfields ? (jl_svec_len(tn->names) + 31) / 32 * sizeof(uint32_t) : 0;
dump.c:                write_int32(s->s, nb);
dump.c:                    ios_write(s->s, (char*)tn->atomicfields, nb);
dump.c:        size_t i, j, np = t->layout->npointers;
dump.c:        uint32_t nf = t->layout->nfields;
dump.c:                        ios_write(s->s, last, prevptr - last);
dump.c:                    if (t->name->mutabl && e && jl_field_isptr(t, i - 1) && jl_is_cpointer(e) &&
dump.c:                        jl_unbox_voidpointer(e) != (void*)-1 && jl_unbox_voidpointer(e) != NULL)
dump.c:            if (t->name->mutabl && jl_is_cpointer_type(jl_field_type(t, i)) && *(void**)ptr != (void*)-1) {
dump.c:                    ios_write(s->s, last, ptr - last);
dump.c:                ios_write(s->s, (char*)&n, sizeof(n));
dump.c:            ios_write(s->s, last, ptr - last);
dump.c:    jl_array_t *backedges = mt->backedges;
dump.c:            jl_value_t *missing_callee = jl_array_ptr_ref(backedges, i - 1);
dump.c:    jl_array_t *backedges = callee->backedges;
dump.c:    jl_method_t *m = ml->func.method;
dump.c:    if (module_in_worklist(m->module)) {
dump.c:        jl_array_ptr_1d_push(s, (jl_value_t*)ml->simplesig);
dump.c:        jl_svec_t *specializations = m->specializations;
dump.c:    jl_typemap_visitor(mt->defs, jl_collect_methcache_from_mod, (void*)s);
dump.c:    void **table = m->bindings.table;
dump.c:    for (i = 1; i < m->bindings.size; i += 2) {
dump.c:            if (b->owner == m && b->value && b->constp) {
dump.c:                jl_value_t *bv = jl_unwrap_unionall(b->value);
dump.c:                    jl_typename_t *tn = ((jl_datatype_t*)bv)->name;
dump.c:                    if (tn->module == m && tn->name == b->name && tn->wrapper == b->value) {
dump.c:                        jl_methtable_t *mt = tn->mt;
dump.c:                else if (jl_is_module(b->value)) {
dump.c:                    jl_module_t *child = (jl_module_t*)b->value;
dump.c:                    if (child != m && child->parent == m && child->name == b->name) {
dump.c:                        jl_collect_lambdas_from_mod(s, (jl_module_t*)b->value);
dump.c:                else if (jl_is_mtable(b->value)) {
dump.c:                    jl_methtable_t *mt = (jl_methtable_t*)b->value;
dump.c:                    if (mt->module == m && mt->name == b->name) {
dump.c:        if (callees != HT_NOTFOUND && module_in_worklist(caller->def.method->module)) {
dump.c:                            sig = callee_mi->specTypes;
dump.c:                        jl_value_t *matches = jl_matching_methods((jl_tupletype_t*)sig, jl_nothing, -1, 0, jl_world_counter, &min_valid, &max_valid, &ambig);
dump.c:                            jl_array_ptr_set(matches, k, match->method);
dump.c:                    ((int32_t*)jl_array_data(callees))[jl_array_len(callees) - 1] = (char*)target - (char*)HT_NOTFOUND - 1;
dump.c:            const char *modname = jl_symbol_name(m->name);
dump.c:            write_uint64(s, m->uuid.hi);
dump.c:            write_uint64(s, m->uuid.lo);
dump.c:            write_uint64(s, m->build_id);
dump.c:static const uint16_t BOM = 0xFEFF; // byte-order marker
dump.c:        if (workmod->parent == jl_main_module || workmod->parent == workmod) {
dump.c:            size_t l = strlen(jl_symbol_name(workmod->name));
dump.c:            ios_write(s, jl_symbol_name(workmod->name), l);
dump.c:            write_uint64(s, workmod->uuid.hi);
dump.c:            write_uint64(s, workmod->uuid.lo);
dump.c:            write_uint64(s, workmod->build_id);
dump.c:    if (depmod->parent == jl_main_module || depmod->parent == depmod)
dump.c:    const char *mname = jl_symbol_name(depmod->name);
dump.c:    write_module_path(s, depmod->parent);
dump.c:    size_t last_age = ct->world_age;
dump.c:    ct->world_age = jl_world_counter;
dump.c:    ct->world_age = last_age;
dump.c:            while (depmod_top->parent != jl_main_module && depmod_top->parent != depmod_top)
dump.c:                depmod_top = depmod_top->parent;
dump.c:                if (workmod->parent == jl_main_module || workmod->parent == workmod) {
dump.c:                size_t last_age = ct->world_age;
dump.c:                ct->world_age = jl_world_counter;
dump.c:                ct->world_age = last_age;
dump.c:            // We declare an empty list of preference names, followed by a zero-hash.
dump.c:            // The zero-hash is not what would be generated for an empty set of preferences,
dump.c:            // and so this `.ji` file will be invalidated by a future non-erroring pass
dump.c:        // write a dummy file position to indicate the beginning of the source-text
dump.c:        write_uint64(s, pos - initial_pos);
dump.c:// --- deserialize ---
dump.c:    assert(pos == backref_list.len - 1 && "nothing should have been deserialized since assigning pos");
dump.c:    int tag = read_uint8(s->s);
dump.c:        jl_value_t *dtv = name->wrapper;
dump.c:    size_t size = read_int32(s->s);
dump.c:    uint8_t flags = read_uint8(s->s);
dump.c:    uint8_t memflags = read_uint8(s->s);
dump.c:    dt->size = size;
dump.c:    dt->hasfreetypevars = memflags & 1;
dump.c:    dt->isconcretetype = (memflags >> 1) & 1;
dump.c:    dt->isdispatchtuple = (memflags >> 2) & 1;
dump.c:    dt->isbitstype = (memflags >> 3) & 1;
dump.c:    dt->zeroinit = (memflags >> 4) & 1;
dump.c:    dt->has_concrete_subtype = (memflags >> 5) & 1;
dump.c:    dt->cached_by_hash = (memflags >> 6) & 1;
dump.c:    dt->hash = read_int32(s->s);
dump.c:        uint8_t layout = read_uint8(s->s);
dump.c:            dt->layout = ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_array_type))->layout;
dump.c:            dt->layout = jl_nothing_type->layout;
dump.c:            dt->layout = ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_pointer_type))->layout;
dump.c:            ios_readall(s->s, (char*)&buffer, sizeof(buffer));
dump.c:            if (buffer.first_ptr != -1)
dump.c:            ios_readall(s->s, (char*)(layout + 1), fldsize);
dump.c:            dt->layout = layout;
dump.c:        assert(dt->isconcretetype && "there shouldn't be an instance on an abstract type");
dump.c:        dt->instance = jl_deserialize_value(s, &dt->instance);
dump.c:        jl_gc_wb(dt, dt->instance);
dump.c:    dt->name = (jl_typename_t*)jl_deserialize_value(s, (jl_value_t**)&dt->name);
dump.c:    jl_gc_wb(dt, dt->name);
dump.c:    dt->parameters = (jl_svec_t*)jl_deserialize_value(s, (jl_value_t**)&dt->parameters);
dump.c:    jl_gc_wb(dt, dt->parameters);
dump.c:    dt->super = (jl_datatype_t*)jl_deserialize_value(s, (jl_value_t**)&dt->super);
dump.c:    jl_gc_wb(dt, dt->super);
dump.c:    dt->types = (jl_svec_t*)jl_deserialize_value(s, (jl_value_t**)&dt->types);
dump.c:    if (dt->types) jl_gc_wb(dt, dt->types);
dump.c:        len = read_uint8(s->s);
dump.c:        len = read_int32(s->s);
dump.c:        len = read_uint8(s->s);
dump.c:        len = read_int32(s->s);
dump.c:    ios_readall(s->s, name, len);
dump.c:        elsize = read_uint8(s->s);
dump.c:        ndims = read_uint16(s->s);
dump.c:        elsize = read_uint16(s->s);
dump.c:    jl_value_t *aty = jl_deserialize_value(s, &jl_astaggedvalue(a)->type);
dump.c:    if (a->flags.ptrarray) {
dump.c:        assert(jl_astaggedvalue(a)->bits.gc == GC_CLEAN); // gc is disabled
dump.c:    else if (a->flags.hasptr) {
dump.c:        uint16_t elsz = a->elsize;
dump.c:        size_t j, np = et->layout->npointers;
dump.c:                    ios_readall(s->s, start, (const char*)fld - start);
dump.c:                ios_readall(s->s, start, data - start);
dump.c:        assert(jl_astaggedvalue(a)->bits.gc == GC_CLEAN); // gc is disabled
dump.c:        size_t tot = jl_array_len(a) * a->elsize + extra;
dump.c:        ios_readall(s->s, (char*)jl_array_data(a), tot);
dump.c:        (jl_method_t*)jl_gc_alloc(s->ptls, sizeof(jl_method_t),
dump.c:    m->sig = (jl_value_t*)jl_deserialize_value(s, (jl_value_t**)&m->sig);
dump.c:    jl_gc_wb(m, m->sig);
dump.c:    m->module = (jl_module_t*)jl_deserialize_value(s, (jl_value_t**)&m->module);
dump.c:    jl_gc_wb(m, m->module);
dump.c:    int serialization_mode = read_uint8(s->s);
dump.c:        m->external_mt = jl_get_global(mt_mod, mt_name);
dump.c:        jl_gc_wb(m, m->external_mt);
dump.c:        assert(jl_typeis(m->external_mt, jl_methtable_type));
dump.c:        m->external_mt = jl_deserialize_value(s, &m->external_mt);
dump.c:        jl_gc_wb(m, m->external_mt);
dump.c:    m->specializations = (jl_svec_t*)jl_deserialize_value(s, (jl_value_t**)&m->specializations);
dump.c:    jl_gc_wb(m, m->specializations);
dump.c:    jl_array_t *speckeyset = (jl_array_t*)jl_deserialize_value(s, (jl_value_t**)&m->speckeyset);
dump.c:    jl_atomic_store_relaxed(&m->speckeyset, speckeyset);
dump.c:    m->name = (jl_sym_t*)jl_deserialize_value(s, NULL);
dump.c:    jl_gc_wb(m, m->name);
dump.c:    m->file = (jl_sym_t*)jl_deserialize_value(s, NULL);
dump.c:    m->line = read_int32(s->s);
dump.c:    m->primary_world = jl_world_counter;
dump.c:    m->deleted_world = ~(size_t)0;
dump.c:    m->called = read_int32(s->s);
dump.c:    m->nargs = read_int32(s->s);
dump.c:    m->nospecialize = read_int32(s->s);
dump.c:    m->nkw = read_int32(s->s);
dump.c:    m->isva = read_int8(s->s);
dump.c:    m->pure = read_int8(s->s);
dump.c:    m->is_for_opaque_closure = read_int8(s->s);
dump.c:    m->constprop = read_int8(s->s);
dump.c:    m->slot_syms = jl_deserialize_value(s, (jl_value_t**)&m->slot_syms);
dump.c:    jl_gc_wb(m, m->slot_syms);
dump.c:    m->roots = (jl_array_t*)jl_deserialize_value(s, (jl_value_t**)&m->roots);
dump.c:    if (m->roots)
dump.c:        jl_gc_wb(m, m->roots);
dump.c:    m->ccallable = (jl_svec_t*)jl_deserialize_value(s, (jl_value_t**)&m->ccallable);
dump.c:    if (m->ccallable) {
dump.c:        jl_gc_wb(m, m->ccallable);
dump.c:        arraylist_push(&ccallable_list, m->ccallable);
dump.c:    m->source = jl_deserialize_value(s, &m->source);
dump.c:    if (m->source)
dump.c:        jl_gc_wb(m, m->source);
dump.c:    m->unspecialized = (jl_method_instance_t*)jl_deserialize_value(s, (jl_value_t**)&m->unspecialized);
dump.c:    if (m->unspecialized)
dump.c:        jl_gc_wb(m, m->unspecialized);
dump.c:    m->generator = jl_deserialize_value(s, (jl_value_t**)&m->generator);
dump.c:    if (m->generator)
dump.c:        jl_gc_wb(m, m->generator);
dump.c:    m->invokes = jl_deserialize_value(s, (jl_value_t**)&m->invokes);
dump.c:    jl_gc_wb(m, m->invokes);
dump.c:    m->recursion_relation = jl_deserialize_value(s, (jl_value_t**)&m->recursion_relation);
dump.c:    if (m->recursion_relation)
dump.c:        jl_gc_wb(m, m->recursion_relation);
dump.c:    JL_MUTEX_INIT(&m->writelock);
dump.c:        (jl_method_instance_t*)jl_gc_alloc(s->ptls, sizeof(jl_method_instance_t),
dump.c:    int internal = read_uint8(s->s);
dump.c:    mi->specTypes = (jl_value_t*)jl_deserialize_value(s, (jl_value_t**)&mi->specTypes);
dump.c:    jl_gc_wb(mi, mi->specTypes);
dump.c:    mi->def.value = jl_deserialize_value(s, &mi->def.value);
dump.c:    jl_gc_wb(mi, mi->def.value);
dump.c:        mi->uninferred = jl_deserialize_value(s, &mi->uninferred);
dump.c:        jl_gc_wb(mi, mi->uninferred);
dump.c:    mi->sparam_vals = (jl_svec_t*)jl_deserialize_value(s, (jl_value_t**)&mi->sparam_vals);
dump.c:    jl_gc_wb(mi, mi->sparam_vals);
dump.c:    mi->backedges = (jl_array_t*)jl_deserialize_value(s, (jl_value_t**)&mi->backedges);
dump.c:    if (mi->backedges)
dump.c:        jl_gc_wb(mi, mi->backedges);
dump.c:    mi->callbacks = (jl_array_t*)jl_deserialize_value(s, (jl_value_t**)&mi->callbacks);
dump.c:    if (mi->callbacks)
dump.c:        jl_gc_wb(mi, mi->callbacks);
dump.c:    mi->cache = (jl_code_instance_t*)jl_deserialize_value(s, (jl_value_t**)&mi->cache);
dump.c:    if (mi->cache)
dump.c:        jl_gc_wb(mi, mi->cache);
dump.c:        (jl_code_instance_t*)jl_gc_alloc(s->ptls, sizeof(jl_code_instance_t), jl_code_instance_type);
dump.c:    int flags = read_uint8(s->s);
dump.c:    codeinst->def = (jl_method_instance_t*)jl_deserialize_value(s, (jl_value_t**)&codeinst->def);
dump.c:    jl_gc_wb(codeinst, codeinst->def);
dump.c:    codeinst->inferred = jl_deserialize_value(s, &codeinst->inferred);
dump.c:    jl_gc_wb(codeinst, codeinst->inferred);
dump.c:    codeinst->rettype_const = jl_deserialize_value(s, &codeinst->rettype_const);
dump.c:    if (codeinst->rettype_const)
dump.c:        jl_gc_wb(codeinst, codeinst->rettype_const);
dump.c:    codeinst->rettype = jl_deserialize_value(s, &codeinst->rettype);
dump.c:    jl_gc_wb(codeinst, codeinst->rettype);
dump.c:        codeinst->invoke = jl_fptr_const_return;
dump.c:        codeinst->precompile = 1;
dump.c:    codeinst->next = (jl_code_instance_t*)jl_deserialize_value(s, (jl_value_t**)&codeinst->next);
dump.c:    jl_gc_wb(codeinst, codeinst->next);
dump.c:        codeinst->min_world = jl_world_counter;
dump.c:    int ref_only = read_uint8(s->s);
dump.c:            m_ref = jl_array_ptr_ref(s->loaded_modules_array, read_int32(s->s));
dump.c:    m->parent = (jl_module_t*)jl_deserialize_value(s, (jl_value_t**)&m->parent);
dump.c:    jl_gc_wb(m, m->parent);
dump.c:        b->name = (jl_sym_t*)jl_deserialize_value(s, (jl_value_t**)&b->name);
dump.c:        jl_value_t *bvalue = jl_deserialize_value(s, (jl_value_t**)&b->value);
dump.c:        *(jl_value_t**)&b->value = bvalue;
dump.c:        jl_value_t *bglobalref = jl_deserialize_value(s, (jl_value_t**)&b->globalref);
dump.c:        *(jl_value_t**)&b->globalref = bglobalref;
dump.c:        b->owner = (jl_module_t*)jl_deserialize_value(s, (jl_value_t**)&b->owner);
dump.c:        if (b->owner != NULL) jl_gc_wb(m, b->owner);
dump.c:        int8_t flags = read_int8(s->s);
dump.c:        b->deprecated = (flags>>3) & 1;
dump.c:        b->constp = (flags>>2) & 1;
dump.c:        b->exportp = (flags>>1) & 1;
dump.c:        b->imported = (flags) & 1;
dump.c:    size_t i = m->usings.len;
dump.c:    size_t ni = read_int32(s->s);
dump.c:    arraylist_grow(&m->usings, ni);
dump.c:        m->usings.items[i] = jl_deserialize_value(s, (jl_value_t**)&m->usings.items[i]);
dump.c:    m->istopmod = read_uint8(s->s);
dump.c:    m->uuid.hi = read_uint64(s->s);
dump.c:    m->uuid.lo = read_uint64(s->s);
dump.c:    m->build_id = read_uint64(s->s);
dump.c:    m->counter = read_int32(s->s);
dump.c:    m->nospecialize = read_int32(s->s);
dump.c:    m->optlevel = read_int8(s->s);
dump.c:    m->compile = read_int8(s->s);
dump.c:    m->infer = read_int8(s->s);
dump.c:    m->primary_world = jl_world_counter;
dump.c:    jl_value_t *v = (jl_value_t*)jl_gc_alloc(s->ptls, 0, NULL);
dump.c:    // from an external module (tag == 6) as dt->instance
dump.c:    // stored. this happens if a field might store a 0-size value, but the field itself is
dump.c:    jl_datatype_t *dt = (jl_datatype_t*)jl_deserialize_value(s, (jl_value_t**)HT_NOTFOUND); // no loc, since if dt is replaced, then dt->instance would be also
dump.c:    if (dt->instance == NULL)
dump.c:    return dt->instance;
dump.c:    size_t i, np = dt->layout->npointers;
dump.c:            ios_readall(s->s, start, (const char*)fld - start);
dump.c:        ios_readall(s->s, start, data - start);
dump.c:        if (entry->max_world == ~(size_t)0) {
dump.c:            if (entry->min_world > 1) {
dump.c:                entry->min_world = jl_world_counter;
dump.c:            // garbage entry - delete it :(
dump.c:            entry->min_world = 1;
dump.c:            entry->max_world = 0;
dump.c:    int32_t sz = (tag == TAG_SHORT_GENERAL ? read_uint8(s->s) : read_int32(s->s));
dump.c:    jl_value_t *v = jl_gc_alloc(s->ptls, sz, NULL);
dump.c:    jl_datatype_t *dt = (jl_datatype_t*)jl_deserialize_value(s, &jl_astaggedvalue(v)->type);
dump.c:        int internal = read_uint8(s->s);
dump.c:                    s->ptls, sizeof(jl_typename_t), jl_typename_type);
dump.c:            tn->cache = jl_emptysvec; // the cache is refilled later (tag 5)
dump.c:            tn->linearcache = jl_emptysvec; // the cache is refilled later (tag 5)
dump.c:            tn->module = m;
dump.c:            tn->name = sym;
dump.c:            tn->names = (jl_svec_t*)jl_deserialize_value(s, (jl_value_t**)&tn->names);
dump.c:            jl_gc_wb(tn, tn->names);
dump.c:            tn->wrapper = jl_deserialize_value(s, &tn->wrapper);
dump.c:            jl_gc_wb(tn, tn->wrapper);
dump.c:            tn->mt = (jl_methtable_t*)jl_deserialize_value(s, (jl_value_t**)&tn->mt);
dump.c:            jl_gc_wb(tn, tn->mt);
dump.c:            ios_read(s->s, (char*)&tn->hash, sizeof(tn->hash));
dump.c:            int8_t flags = read_int8(s->s);
dump.c:            tn->abstract = flags & 1;
dump.c:            tn->mutabl = (flags>>1) & 1;
dump.c:            tn->mayinlinealloc = (flags>>2) & 1;
dump.c:            if (tn->abstract)
dump.c:                tn->n_uninitialized = 0;
dump.c:                tn->n_uninitialized = read_uint16(s->s);
dump.c:            size_t nfields = read_int32(s->s);
dump.c:                tn->atomicfields = (uint32_t*)malloc(nfields);
dump.c:                ios_read(s->s, (char*)tn->atomicfields, nfields);
dump.c:            tn = dt->name;
dump.c:        int32_t nw = (sz == 0 ? 1 : (sz < 0 ? -sz : sz));
dump.c:        ios_readall(s->s, (char*)buf, nb);
dump.c:    assert(!ios_eof(s->s));
dump.c:    uint8_t tag = read_uint8(s->s);
dump.c:        tag = read_uint8(s->s);
dump.c:        uintptr_t offs = (tag == TAG_BACKREF) ? read_int32(s->s) : read_uint16(s->s);
dump.c:                arraylist_push(&flagref_list, (void*)(uintptr_t)-1);
dump.c:        return deser_symbols[read_uint8(s->s)];
dump.c:        if (read_uint8(s->s)) {
dump.c:        v = jl_gc_alloc(s->ptls, sizeof(jl_unionall_t), jl_unionall_type);
dump.c:        ((jl_unionall_t*)v)->var = (jl_tvar_t*)jl_deserialize_value(s, (jl_value_t**)&((jl_unionall_t*)v)->var);
dump.c:        jl_gc_wb(v, ((jl_unionall_t*)v)->var);
dump.c:        ((jl_unionall_t*)v)->body = jl_deserialize_value(s, &((jl_unionall_t*)v)->body);
dump.c:        jl_gc_wb(v, ((jl_unionall_t*)v)->body);
dump.c:        v = jl_gc_alloc(s->ptls, sizeof(jl_tvar_t), jl_tvar_type);
dump.c:        tv->name = (jl_sym_t*)jl_deserialize_value(s, NULL);
dump.c:        jl_gc_wb(tv, tv->name);
dump.c:        tv->lb = jl_deserialize_value(s, &tv->lb);
dump.c:        jl_gc_wb(tv, tv->lb);
dump.c:        tv->ub = jl_deserialize_value(s, &tv->ub);
dump.c:        jl_gc_wb(tv, tv->ub);
dump.c:        v = jl_box_int64((int16_t)read_uint16(s->s));
dump.c:        v = jl_box_int64(read_int32(s->s));
dump.c:        v = jl_box_int64((int64_t)read_uint64(s->s));
dump.c:        v = jl_box_int32((int16_t)read_uint16(s->s));
dump.c:        v = jl_box_int32(read_int32(s->s));
dump.c:        return jl_box_uint8(read_uint8(s->s));
dump.c:        v = jl_gc_alloc(s->ptls, sizeof(void*), NULL);
dump.c:        jl_set_typeof(v, jl_deserialize_value(s, &jl_astaggedvalue(v)->type));
dump.c:        v = deser_tag[read_uint8(s->s)];
dump.c:        return (jl_value_t*)((jl_datatype_t*)jl_unwrap_unionall(v))->name;
dump.c:        n = read_int32(s->s);
dump.c:        ios_readall(s->s, jl_string_data(v), n);
dump.c:        assert(!meth->is_for_opaque_closure);
dump.c:            sig = callee_mi->specTypes;
dump.c:        jl_value_t *matches = jl_matching_methods((jl_tupletype_t*)sig, jl_nothing, -1, 0, jl_world_counter, &min_valid, &max_valid, &ambig);
dump.c:                jl_method_t *m = match->method;
dump.c:                    // deleted--this is now probably no good, just invalidate
dump.c:        assert(jl_is_method_instance(caller) && jl_is_method(caller->def.method));
dump.c:        assert(caller->def.method->primary_world == jl_world_counter); // caller should be new
dump.c:            jl_code_instance_t *codeinst = caller->cache;
dump.c:                if (codeinst->min_world > 0)
dump.c:                    codeinst->max_world = ~(size_t)0;
dump.c:                codeinst = jl_atomic_load_relaxed(&codeinst->next);
dump.c:            jl_code_instance_t *codeinst = caller->cache;
dump.c:                codeinst = jl_atomic_load_relaxed(&codeinst->next);
dump.c:            ((jl_code_instance_t*)new_code_instance_validate.table[i])->max_world = ~(size_t)0;
dump.c:    if (!jl_main_module->build_id) {
dump.c:        if (!m || !jl_is_module(m) || m->uuid.hi != uuid.hi || m->uuid.lo != uuid.lo || m->name != sym || m->build_id != build_id) {
dump.c:        write_int32(s->s, (int)((uintptr_t) reinit_list.items[i]));
dump.c:        write_int32(s->s, (int)((uintptr_t) reinit_list.items[i+1]));
dump.c:    write_int32(s->s, -1);
dump.c:                if (mod->parent == mod) // top level modules handled by loader
dump.c:                jl_binding_t *b = jl_get_binding_wr(mod->parent, mod->name, 1);
dump.c:                if (b->value != NULL) {
dump.c:                    if (!jl_is_module(b->value)) {
dump.c:                                  jl_symbol_name(mod->name)); // this also throws
dump.c:                        jl_errorf("Cannot replace module %s during incremental precompile.", jl_symbol_name(mod->name));
dump.c:                    jl_printf(JL_STDERR, "WARNING: replacing module %s.\n", jl_symbol_name(mod->name));
dump.c:                b->value = v;
dump.c:    int pos = read_int32(s->s);
dump.c:    while (pos != -1) {
dump.c:        jl_reinit_item((jl_value_t*)backref_list.items[pos], read_int32(s->s), tracee_list);
dump.c:        pos = read_int32(s->s);
dump.c:// --- entry points ---
dump.c:    jl_idtable_typename = jl_base_module ? ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_idtable_type))->name : NULL;
dump.c:    int en = jl_gc_enable(0); // edges map is not gc-safe
dump.c:        if (m->parent == m) // some toplevel modules (really just Base) aren't actually
dump.c:        jl_current_task->ptls,
dump.c:    // Write the source-text for the dependent files
dump.c:        // Go back and update the source-text position to point to the current position
dump.c:        // Each source-text file is written as
dump.c:// one of these types is invalid - that's why we're doing the recache type operation
dump.c:            jl_svec_t *tt = pdt->parameters;
dump.c:        ptv->lb = recache_type(ptv->lb);
dump.c:        ptv->ub = recache_type(ptv->ub);
dump.c:        pu->a = recache_type(pu->a);
dump.c:        pu->b = recache_type(pu->b);
dump.c:        pa->var = (jl_tvar_t*)recache_type((jl_value_t*)pa->var);
dump.c:        pa->body = recache_type(pa->body);
dump.c:        if (cachep->instance)
dump.c:            p = cachep->instance;
dump.c:    jl_svec_t *tt = dt->parameters;
dump.c:        assert(t->hash == dt->hash);
dump.c:                v = dt->instance;
dump.c:            if (v == o && t->instance != v) {
dump.c:                assert(t->instance);
dump.c:                *loc = t->instance;
dump.c:                    backref_list.items[offs] = t->instance;
dump.c:            if (t->instance != o->instance)
dump.c:                jl_set_typeof(o->instance, (void*)(intptr_t)0x20);
dump.c:            // delete this item from the flagref list, so it won't be re-encountered later
dump.c:            flagref_list.len -= 2;
dump.c:    if (world < jl_main_module->primary_world)
dump.c:        world = jl_main_module->primary_world;
dump.c:    jl_typemap_entry_t *entry = jl_typemap_assoc_by_type(mt->defs, &search, /*offs*/0, /*subtype*/0);
dump.c:    return (jl_method_t*)entry->func.value;
dump.c:    assert(!m->is_for_opaque_closure);
dump.c:    jl_datatype_t *sig = (jl_datatype_t*)m->sig;
dump.c:    jl_method_t *_new = jl_lookup_method(mt, sig, m->module->primary_world);
dump.c:    jl_method_t *m = mi->def.method;
dump.c:    jl_datatype_t *argtypes = (jl_datatype_t*)mi->specTypes;
dump.c:    jl_value_t *ti = jl_type_intersection_env((jl_value_t*)argtypes, (jl_value_t*)m->sig, &env);
dump.c:    jl_call_tracer(jl_newmeth_tracer, (jl_value_t*)entry->func.method);
dump.c:        ct->ptls,
dump.c:    jl_gc_enable(en); // subtyping can allocate a lot, not valid before recache-other
dump.c:            jl_typemap_visitor(mt->defs, trace_method, NULL);
dump.c:// --- init ---
dump.c:                     jl_typeofbottom_type, jl_typeofbottom_type->super,
dump.c:                     ct->ptls->root_task,
dump.c:    // more common symbols, less common than those above. will get 2-byte encodings.
dump.c:    while (common_symbols[i-2] != NULL) {
dump.c:        ptrhash_put(&common_symbol_tag, common_symbols[i-2], (void*)i);
dump.c:        deser_symbols[i] = (jl_value_t*)common_symbols[i-2];
julia_fasttls.h:// Thread-local storage access
julia_fasttls.h:static __attribute__((tls_model("local-exec"))) __thread jl_gcframe_t **jl_pgcstack_localexec;  \
gc-debug.c:// re-include assert.h without NDEBUG,
gc-debug.c:    size_t ofs = p - page_begin;
gc-debug.c:    if (!(info.pagetable0->allocmap[info.pagetable0_i32] & (uint32_t)(1 << info.pagetable0_i)))
gc-debug.c:    int osize = info.meta->osize;
gc-debug.c:    char *tag = (char*)p - ofs % osize;
gc-debug.c: - Ensure that should_timeout() is deterministic instead of clock based.
gc-debug.c: - Once you have a completely deterministic program which crashes on gc_verify, the addresses
gc-debug.c: - If it went well you are now stopped at the exact point the problem is happening.
gc-debug.c:    jl_ptls_t ptls2 = jl_all_tls_states[pg->thread_n];
gc-debug.c:    jl_gc_pool_t *pool = &ptls2->heap.norm_pools[pg->pool_n];
gc-debug.c:    jl_taggedvalue_t *pv = (jl_taggedvalue_t*)(pg->data + GC_PAGE_OFFSET);
gc-debug.c:    char *lim = (char*)pv + GC_PAGE_SZ - GC_PAGE_OFFSET - pool->osize;
gc-debug.c:            arraylist_push(&bits_save[pv->bits.gc], pv);
gc-debug.c:        pv->bits.gc = bits;
gc-debug.c:        pv = (jl_taggedvalue_t*)((char*)pv + pool->osize);
gc-debug.c:        uint32_t line = pagetable0->allocmap[pg_i];
gc-debug.c:                    gc_clear_mark_page(pagetable0->meta[pg_i * 32 + j], bits);
gc-debug.c:        uint32_t line = pagetable1->allocmap0[pg_i];
gc-debug.c:                    gc_clear_mark_pagetable0(pagetable1->meta0[pg_i * 32 + j], bits);
gc-debug.c:        v = jl_all_tls_states[i]->heap.big_objects;
gc-debug.c:            void *gcv = &v->header;
gc-debug.c:                arraylist_push(&bits_save[v->bits.gc], gcv);
gc-debug.c:            v->bits.gc = bits;
gc-debug.c:            v = v->next;
gc-debug.c:        void *gcv = &v->header;
gc-debug.c:            arraylist_push(&bits_save[v->bits.gc], gcv);
gc-debug.c:        v->bits.gc = bits;
gc-debug.c:        v = v->next;
gc-debug.c:            ((jl_taggedvalue_t*)bits_save[b].items[i])->bits.gc = b;
gc-debug.c:    jl_gc_mark_cache_t *gc_cache = &ptls->gc_cache;
gc-debug.c:            gc_mark_queue_finlist(gc_cache, &sp, &ptls2->finalizers, 0);
gc-debug.c:                void *p = bits_save[j >= clean_len ? GC_OLD : GC_CLEAN].items[j >= clean_len ? j - clean_len : j];
gc-debug.c:    jl_gc_mark_cache_t *gc_cache = &ptls->gc_cache;
gc-debug.c:        gc_mark_queue_finlist(gc_cache, &sp, &ptls2->finalizers, 0);
gc-debug.c:        jl_taggedvalue_t *v = (jl_taggedvalue_t*)bits_save[i >= clean_len ? GC_OLD : GC_CLEAN].items[i >= clean_len ? i - clean_len : i];
gc-debug.c:        if (gc_marked(v->bits.gc)) {
gc-debug.c:    int p_n = pg->pool_n;
gc-debug.c:    int t_n = pg->thread_n;
gc-debug.c:    jl_gc_pool_t *p = &ptls2->heap.norm_pools[p_n];
gc-debug.c:    int osize = pg->osize;
gc-debug.c:    char *data = pg->data;
gc-debug.c:    char *lim = data + GC_PAGE_SZ - osize;
gc-debug.c:    jl_taggedvalue_t *halfpages = p->newpages;
gc-debug.c:        char *cur_page = gc_page_data((char*)halfpages - 1);
gc-debug.c:            lim = (char*)halfpages - 1;
gc-debug.c:    if (pg->nfree) {
gc-debug.c:        if (gc_page_data(p->freelist) == data) {
gc-debug.c:            next = p->freelist;
gc-debug.c:            assert(page_metadata(next)->osize == osize);
gc-debug.c:        else if (pg->fl_begin_offset != (uint16_t)-1) {
gc-debug.c:            int obj_idx = (((char*)next) - page_begin) / sizeof(void*);
gc-debug.c:            next = next->next;
gc-debug.c:        int obj_idx = (((char*)v) - page_begin) / sizeof(void*);
gc-debug.c:                    v->header != 0x10 && v->header != 0x20 &&
gc-debug.c:                    v->header != 0x30 && v->header != 0x40 &&
gc-debug.c:                    v->header != 0x50 && v->header != 0x60) {
gc-debug.c:        uint32_t line = pagetable0->allocmap[pg_i];
gc-debug.c:                    gc_verify_tags_page(pagetable0->meta[pg_i * 32 + j]);
gc-debug.c:        uint32_t line = pagetable1->allocmap0[pg_i];
gc-debug.c:                    gc_verify_tags_pagetable0(pagetable1->meta0[pg_i * 32 + j]);
gc-debug.c:            jl_gc_pool_t *p = &ptls2->heap.norm_pools[i];
gc-debug.c:            jl_taggedvalue_t *next = p->freelist;
gc-debug.c:                // and assert that the freelist values aren't gc-marked
gc-debug.c:                assert(next->bits.gc == 0);
gc-debug.c:                    assert(pg->osize == p->osize);
gc-debug.c:                next = next->next;
gc-debug.c:    uint64_t interv = num->interv;
gc-debug.c:    if (num->random[0] && num->interv != 1) {
gc-debug.c:        double scale = log(1.0 + 1.0 / (double)(num->interv - 1));
gc-debug.c:        double randinterv = floor(fabs(log(erand48(num->random))) / scale) + 1;
gc-debug.c:    uint64_t next = num->num + interv;
gc-debug.c:    if (!num->interv || next > num->max || interv > next)
gc-debug.c:    num->next = next;
gc-debug.c:            while (num->random[i] == 0) {
gc-debug.c:                num->random[i] = rand();
gc-debug.c:    num->interv = 1;
gc-debug.c:    num->max = UINT64_MAX;
gc-debug.c:           (int64_t*)&num->min, (int64_t*)&num->interv, (int64_t*)&num->max);
gc-debug.c:    if (num->interv == 0)
gc-debug.c:        num->interv = 1;
gc-debug.c:    num->next = num->min;
gc-debug.c:    if (++num->num < num->next)
gc-debug.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc-debug.c:    for (char **stack_p = ((char**)high) - 1; stack_p > (char**)low; stack_p--) {
gc-debug.c:        if (osize <= sizeof(jl_taggedvalue_t) || !tag || gc_marked(tag->bits.gc))
gc-debug.c:        pg->has_marked = 1;
gc-debug.c:        pg->has_young = 1;
gc-debug.c:        int obj_id = (((char*)tag) - page_begin) / osize;
gc-debug.c:        uint8_t *ages = pg->ages + obj_id / 8;
gc-debug.c:        // (especially on 32bit where it's more likely to have pointer-like
gc-debug.c:        tag->bits.gc = GC_MARKED;
gc-debug.c:    int16_t tid = ta->tid;
gc-debug.c:    jl_ptls_t ptls = jl_current_task->ptls;
gc-debug.c:    if (tid != -1)
gc-debug.c:    if (ta->copy_stack && ptls2 && ta == ptls2->current_task) {
gc-debug.c:        low  = (char*)ptls2->stackbase - ptls2->stacksize;
gc-debug.c:        high = (char*)ptls2->stackbase;
gc-debug.c:    else if (ta->stkbuf) {
gc-debug.c:        low  = (char*)ta->stkbuf;
gc-debug.c:        high = (char*)ta->stkbuf + ta->bufsz;
gc-debug.c:    if (ptls == ptls2 && ptls2 && ta == ptls2->current_task) {
gc-debug.c:             ((jl_datatype_t*)ty)->instance) {
gc-debug.c:            int num = (intptr_t)nums.table[i + 1] - 1;
gc-debug.c:            size_t sz = (uintptr_t)ptrhash_get(&sizes, ty) - 1;
gc-debug.c:    uint64_t post_time = gc_postmark_end - gc_premark_end;
gc-debug.c:    uint64_t sweep_pause = tend - gc_premark_end;
gc-debug.c:    uint64_t pause = tend - t0;
gc-debug.c:    total_sweep_time += sweep_pause - post_time;
gc-debug.c:    total_mark_time += gc_premark_end - t0;
gc-debug.c:        uint32_t line = pagetable0->allocmap[pg_i] | pagetable0->freemap[pg_i];
gc-debug.c:        uint32_t line = pagetable1->allocmap0[pg_i] | pagetable1->freemap0[pg_i];
gc-debug.c:                    gc_stats_pagetable0(pagetable1->meta0[pg_i * 32 + j], p0);
gc-debug.c:    double ptime = jl_clock_now() - process_t0;
gc-debug.c:    jl_safe_printf("page table max utilization : %u (%.1f%%) - %u (%.1f%%) - %u (%.1f%%)\n",
gc-debug.c:    double sweep_pool_sec = (jl_hrtime() - pool_sweep_start) / 1e9;
gc-debug.c:                   total_pages, total_pages - skipped_pages,
gc-debug.c:    double sweep_pool_sec = (jl_hrtime() - t0) / 1e9;
gc-debug.c:    double t_ms = jl_ns2ms(jl_hrtime() - big_sweep_start);
gc-debug.c:    double t_ms = jl_ns2ms(jl_hrtime() - mallocd_array_sweep_start);
gc-debug.c:        last_remset_len += ptls2->heap.last_remset->len;
gc-debug.c:        remset_nptr = ptls2->heap.remset_nptr;
gc-debug.c:                   jl_ns2ms(gc_premark_end - t0),
gc-debug.c:    uint64_t sweep_pause = gc_end_t - gc_premark_end;
gc-debug.c:    int pct = actual_allocd ? (gc_num.freed * 100) / actual_allocd : -1;
gc-debug.c:                   gc_num.freed - estimate_freed, pct, gc_num.since_sweep / 1024,
gc-debug.c:                   jl_ns2ms(gc_postmark_end - gc_premark_end),
gc-debug.c:                   sweep_full ? "full" : "quick", -gc_num.allocd / 1024);
gc-debug.c:    jl_taggedvalue_t *halfpages = p->newpages;
gc-debug.c:    size_t osize = p->osize;
gc-debug.c:        char *lim = (char*)halfpages - 1;
gc-debug.c:            if (!gc_marked(((jl_taggedvalue_t*)v)->bits.gc)) {
gc-debug.c:                if (((jl_taggedvalue_t*)v)->bits.gc == GC_OLD_MARKED) {
gc-debug.c:    *pwaste = npgs * GC_PAGE_SZ - (nused * p->osize);
gc-debug.c:                       p->osize,
gc-debug.c:                       (long long)((nused * p->osize) / 1024),
gc-debug.c:    return nused*p->osize;
gc-debug.c:            size_t b = pool_stats(&ptls2->heap.norm_pools[i], &w, &np, &nol);
gc-debug.c:            no += (b / ptls2->heap.norm_pools[i].osize);
gc-debug.c:            noldbytes += nol * ptls2->heap.norm_pools[i].osize;
gc-debug.c:        bigval_t *v = ptls2->heap.big_objects;
gc-debug.c:            if (gc_marked(v->bits.gc)) {
gc-debug.c:                nbytes += v->sz & ~3;
gc-debug.c:            v = v->next;
gc-debug.c:            if (gc_marked(v->bits.gc)) {
gc-debug.c:                nbytes_old += v->sz & ~3;
gc-debug.c:            v = v->next;
gc-debug.c:        mallocarray_t *ma = ptls2->heap.mallocarrays;
gc-debug.c:            if (gc_marked(jl_astaggedvalue(ma->a)->bits.gc)) {
gc-debug.c:                nbytes += jl_array_nbytes(ma->a);
gc-debug.c:            ma = ma->next;
gc-debug.c:// Use as ground truth for debugging memory-leak-like issues.
gc-debug.c:    int osize = pg->osize;
gc-debug.c:    char *data = pg->data;
gc-debug.c:    char *lim = (char*)v + GC_PAGE_SZ - GC_PAGE_OFFSET - osize;
gc-debug.c:        int bits = v->bits.gc;
gc-debug.c:        uint32_t line = pagetable0->allocmap[pg_i];
gc-debug.c:                    gc_count_pool_page(pagetable0->meta[pg_i * 32 + j]);
gc-debug.c:        uint32_t line = pagetable1->allocmap0[pg_i];
gc-debug.c:                    gc_count_pool_pagetable0(pagetable1->meta0[pg_i * 32 + j]);
gc-debug.c:    return -1;
gc-debug.c:        start = (char*)m->usings.items;
gc-debug.c:        len = m->usings.len;
gc-debug.c:    else if (vt->name == jl_array_typename) {
gc-debug.c:        if (!a->flags.ptrarray)
gc-debug.c:            return -1;
gc-debug.c:        start = (char*)a->data;
gc-debug.c:        elsize = a->elsize;
gc-debug.c:        return -1;
gc-debug.c:    return (slot - start) / elsize;
gc-debug.c:        jl_safe_printf("\n!!! ERROR when unwinding gc mark loop -- ABORTING !!!\n");
gc-debug.c:    sp.data = ptls->gc_cache.data_stack;
gc-debug.c:    sp.pc = ptls->gc_cache.pc_stack;
gc-debug.c:        const char *prefix = isroot ? "r--" : " `-";
gc-debug.c:                jl_safe_printf("Mark stack unwind overflow -- ABORTING !!!\n");
gc-debug.c:                           (void*)data, (void*)data->obj, (void*)data->tag, (int)data->bits);
gc-debug.c:            jl_((void*)data->tag);
gc-debug.c:                jl_safe_printf("Mark stack unwind overflow -- ABORTING !!!\n");
gc-debug.c:                           (void*)data, (void*)data->obj, (void*)data->tag, (int)data->bits);
gc-debug.c:            jl_((void*)data->tag);
gc-debug.c:                jl_safe_printf("Mark stack unwind overflow -- ABORTING !!!\n");
gc-debug.c:                           (void*)data, (void*)data->begin, (void*)data->end);
gc-debug.c:                jl_safe_printf("Mark stack unwind overflow -- ABORTING !!!\n");
gc-debug.c:            jl_safe_printf("%p:  %s Array in object %p :: %p -- [%p, %p)\n        of type ",
gc-debug.c:                           (void*)data, prefix, (void*)data->parent, ((void**)data->parent)[-1],
gc-debug.c:                           (void*)data->begin, (void*)data->end);
gc-debug.c:            jl_(jl_typeof(data->parent));
gc-debug.c:                jl_safe_printf("Mark stack unwind overflow -- ABORTING !!!\n");
gc-debug.c:            jl_datatype_t *vt = (jl_datatype_t*)jl_typeof(data->parent);
gc-debug.c:            uint8_t *desc = (uint8_t*)jl_dt_layout_ptrs(vt->layout);
gc-debug.c:            jl_safe_printf("%p:  %s Object (8bit) %p :: %p -- [%d, %d)\n        of type ",
gc-debug.c:                           (void*)data, prefix, (void*)data->parent, ((void**)data->parent)[-1],
gc-debug.c:                           (int)(data->begin - desc), (int)(data->end - desc));
gc-debug.c:            jl_(jl_typeof(data->parent));
gc-debug.c:                jl_safe_printf("Mark stack unwind overflow -- ABORTING !!!\n");
gc-debug.c:            jl_datatype_t *vt = (jl_datatype_t*)jl_typeof(data->parent);
gc-debug.c:            uint16_t *desc = (uint16_t*)jl_dt_layout_ptrs(vt->layout);
gc-debug.c:            jl_safe_printf("%p:  %s Object (16bit) %p :: %p -- [%d, %d)\n        of type ",
gc-debug.c:                           (void*)data, prefix, (void*)data->parent, ((void**)data->parent)[-1],
gc-debug.c:                           (int)(data->begin - desc), (int)(data->end - desc));
gc-debug.c:            jl_(jl_typeof(data->parent));
gc-debug.c:                jl_safe_printf("Mark stack unwind overflow -- ABORTING !!!\n");
gc-debug.c:            jl_datatype_t *vt = (jl_datatype_t*)jl_typeof(data->parent);
gc-debug.c:            uint32_t *desc = (uint32_t*)jl_dt_layout_ptrs(vt->layout);
gc-debug.c:            jl_safe_printf("%p:  %s Object (32bit) %p :: %p -- [%d, %d)\n        of type ",
gc-debug.c:                           (void*)data, prefix, (void*)data->parent, ((void**)data->parent)[-1],
gc-debug.c:                           (int)(data->begin - desc), (int)(data->end - desc));
gc-debug.c:            jl_(jl_typeof(data->parent));
gc-debug.c:                jl_safe_printf("Mark stack unwind overflow -- ABORTING !!!\n");
gc-debug.c:            jl_safe_printf("%p:  %s Stack frame %p -- %d of %d (%s)\n",
gc-debug.c:                           (void*)data, prefix, (void*)data->s, (int)data->i,
gc-debug.c:                           (int)data->nroots >> 1,
gc-debug.c:                           (data->nroots & 1) ? "indirect" : "direct");
gc-debug.c:                jl_safe_printf("Mark stack unwind overflow -- ABORTING !!!\n");
gc-debug.c:            jl_safe_printf("%p:  %s Module (bindings) %p (bits %d) -- [%p, %p)\n",
gc-debug.c:                           (void*)data, prefix, (void*)data->parent, (int)data->bits,
gc-debug.c:                           (void*)data->begin, (void*)data->end);
gc-debug.c:            jl_safe_printf("Unknown pc %p --- ABORTING !!!\n", pc);
processor_x86.cpp:    -1);
processor_x86.cpp:// We require cx16 on 64bit by default. This can be overwritten with `-cx16`
processor_x86.cpp:    {"goldmont-plus", CPU::intel_atom_goldmont_plus, CPU::generic, 0, Feature::goldmont_plus},
processor_x86.cpp:    {"skylake-avx512", CPU::intel_corei7_skylake_avx512, CPU::generic, 0, Feature::skx},
processor_x86.cpp:    {"icelake-client", CPU::intel_corei7_icelake_client, CPU::generic, 0, Feature::icelake},
processor_x86.cpp:    {"icelake-server", CPU::intel_corei7_icelake_server, CPU::generic, 0,
processor_x86.cpp:    {"athlon-fx", CPU::amd_athlon_fx, CPU::generic, 0, Feature::generic},
processor_x86.cpp:    {"athlon64-sse3", CPU::amd_athlon_64_sse3, CPU::generic, 0, Feature::k8_sse3},
processor_x86.cpp:    {"k8-sse3", CPU::amd_k8_sse3, CPU::generic, 0, Feature::k8_sse3},
processor_x86.cpp:    {"opteron-sse3", CPU::amd_opteron_sse3, CPU::generic, 0, Feature::k8_sse3},
processor_x86.cpp:            // Pentium Dual-Core processor, Intel Xeon processor, model
processor_x86.cpp:        case 0xa5: // Comet Lake-H/S
processor_x86.cpp:        case 0xa6: // Comet Lake-U
processor_x86.cpp:        case 2: // Pentium 4 processor, Mobile Intel Pentium 4 processor - M,
processor_x86.cpp:    auto family = (info1[0] >> 8) & 0xf; // Bits 8 - 11
processor_x86.cpp:    auto model = (info1[0] >> 4) & 0xf;  // Bits 4 - 7
processor_x86.cpp:            family += (info1[0] >> 20) & 0xff; // Bits 20 - 27
processor_x86.cpp:        model += ((info1[0] >> 16) & 0xf) << 4; // Bits 16 - 19
processor_x86.cpp:    // See https://github.com/llvm/llvm-project/commit/82921bf2baed96b700f90b090d5dc2530223d9c0
processor_x86.cpp:    // and https://github.com/apple/darwin-xnu/blob/a449c6a3b8014d9406c2ddbdc81795da24aa7443/osfmk/i386/fpu.c#L174
processor_x86.cpp:    if (name == "corei7-avx")
processor_x86.cpp:    if (name == "core-avx-i")
processor_x86.cpp:    if (name == "core-avx2")
processor_x86.cpp:        return "skylake-avx512";
processor_x86.cpp:    if (name == "x86-64" || name == "x86_64")
processor_x86.cpp:        if (fbit == (uint32_t)-1)
processor_x86.cpp:        cpu_features = &spec->features;
processor_x86.cpp:    // We translate `generic` to `pentium4` or `x86-64` before sending it to LLVM
processor_x86.cpp:    // We also track to see if the sysimg allows -cx16, however if the user does
processor_x86.cpp:        if (spec->llvmver <= JL_LLVM_VERSION)
processor_x86.cpp:        spec = find_cpu((uint32_t)spec->fallback);
processor_x86.cpp:        name = spec->name;
processor_x86.cpp:        name = "x86-64";
processor_x86.cpp:            features.push_back(std::string("-") + fename.name);
processor_x86.cpp:// -- set/clear the FZ/DAZ flags on x86 & x86-64 --
processor_x86.cpp:// Returns non-zero if subnormals go to 0; zero otherwise.
processor_x86.cpp:// Return zero on success, non-zero on failure.
abi_arm.cpp://===----------------------------------------------------------------------===//
abi_arm.cpp://===----------------------------------------------------------------------===//
abi_arm.cpp://===----------------------------------------------------------------------===//
abi_arm.cpp:    if (dt->name->mutabl || jl_datatype_nfields(dt) != 0)
abi_arm.cpp:    // single- or double-precision floating-point type
abi_arm.cpp:    // NOT SUPPORTED: 64- or 128-bit containerized vectors
abi_arm.cpp:// In case of a non-legal HA, the value of 'base' is undefined.
abi_arm.cpp:        if (jl_datatype_size(dt) > 64 || dt->layout->npointers || dt->layout->haspadding)
abi_arm.cpp:    // - A half-precision floating-point type.
abi_arm.cpp:    // - A single-precision floating-point type.
abi_arm.cpp:    // - A double-precision floating-point type.
abi_arm.cpp:    // NOT SUPPORTED: A 64-bit or 128-bit containerized vector type.
abi_arm.cpp:    // - A Homogeneous Aggregate
abi_arm.cpp:    // - A Half-precision Floating Point Type is returned in the least
abi_arm.cpp:    // - A Fundamental Data Type that is smaller than 4 bytes is zero- or
abi_arm.cpp:    //   sign-extended to a word and returned in r0.
abi_arm.cpp:    // - A double-word sized Fundamental Data Type (e.g., long long, double and
abi_arm.cpp:    //   64-bit containerized vectors) is returned in r0 and r1.
abi_arm.cpp:    // - A word-sized Fundamental Data Type (eg., int, float) is returned in r0.
abi_arm.cpp:    // these can be returned in r0-r3 as well.
abi_arm.cpp:    // - A Composite Type not larger than 4 bytes is returned in r0. The format
abi_arm.cpp:    //   is as if the result had been stored in memory at a word-aligned address
abi_arm.cpp:    // - A Composite Type larger than 4 bytes, or whose size cannot be
abi_arm.cpp:// If the argument should be passed in SIMD and floating-point registers,
abi_arm.cpp:    //   co-processor registers of the appropriate class, the argument is
abi_arm.cpp:    //   allocated to co-processor registers.
abi_arm.cpp:    // - The alignment of an aggregate shall be the alignment of its
abi_arm.cpp:    //   most-aligned component.
abi_arm.cpp:    // - The size of an aggregate shall be the smallest multiple of its
abi_arm.cpp:    //   For a Composite Type, the alignment of the copy will have 4-byte
abi_arm.cpp:    //   alignment if its natural alignment is <= 4 and 8-byte alignment if
abi_arm.cpp:    return ArrayType::get(T, (jl_datatype_size(dt) + align - 1) / align);
crc32c-tables.c:/* Pregenerated tables for crc32c.c, produced by compiling with -DGEN_CRC32C_TABLES. */
APInt-C.h://uint8_t getSwappedBytes_8(uint8_t Value); // no-op
llvm-propagate-addrspaces.cpp:#include "llvm-version.h"
llvm-propagate-addrspaces.cpp:#include <llvm-c/Core.h>
llvm-propagate-addrspaces.cpp:#include <llvm-c/Types.h>
llvm-propagate-addrspaces.cpp:      - Changing the address space of a load/store if the base pointer is
llvm-propagate-addrspaces.cpp:      - Commuting GEPs and addrspace casts
llvm-propagate-addrspaces.cpp:        it.first->insertBefore(it.second);
llvm-propagate-addrspaces.cpp:        I->eraseFromParent();
llvm-propagate-addrspaces.cpp:    return cast<PointerType>(V->getType())->getAddressSpace();
llvm-propagate-addrspaces.cpp:        for (Value *User : CurrentV->users()) {
llvm-propagate-addrspaces.cpp:                CurrentV = BCI->getOperand(0);
llvm-propagate-addrspaces.cpp:                CurrentV = ACI->getOperand(0);
llvm-propagate-addrspaces.cpp:                CurrentV = GEP->getOperand(0);
llvm-propagate-addrspaces.cpp:                for (Value *Incoming : Phi->incoming_values()) {
llvm-propagate-addrspaces.cpp:                Worklist.push_back(Select->getOperand(2));
llvm-propagate-addrspaces.cpp:                CurrentV = Select->getOperand(1);
llvm-propagate-addrspaces.cpp:                // Ok, we've reached a leaf - check if it is eligible for lifting
llvm-propagate-addrspaces.cpp:                if (!CurrentV->getType()->isPointerTy() ||
llvm-propagate-addrspaces.cpp:            Instruction *NewV = InstV->clone();
llvm-propagate-addrspaces.cpp:            Type *NewRetTy = cast<PointerType>(InstV->getType())->getElementType()->getPointerTo(0);
llvm-propagate-addrspaces.cpp:            NewV->mutateType(NewRetTy);
llvm-propagate-addrspaces.cpp:    auto CollapseCastsAndLift = [&](Value *CurrentV, Instruction *InsertPt) -> Value * {
llvm-propagate-addrspaces.cpp:        PointerType *TargetType = cast<PointerType>(CurrentV->getType())->getElementType()->getPointerTo(0);
llvm-propagate-addrspaces.cpp:                CurrentV = cast<BitCastInst>(CurrentV)->getOperand(0);
llvm-propagate-addrspaces.cpp:                CurrentV = cast<AddrSpaceCastInst>(CurrentV)->getOperand(0);
llvm-propagate-addrspaces.cpp:        if (CurrentV->getType() != TargetType) {
llvm-propagate-addrspaces.cpp:            NewGEP->setOperand(GetElementPtrInst::getPointerOperandIndex(),
llvm-propagate-addrspaces.cpp:                CollapseCastsAndLift(NewGEP->getOperand(GetElementPtrInst::getPointerOperandIndex()),
llvm-propagate-addrspaces.cpp:            for (size_t i = 0; i < NewPhi->getNumIncomingValues(); ++i) {
llvm-propagate-addrspaces.cpp:                NewPhi->setIncomingValue(i, CollapseCastsAndLift(NewPhi->getIncomingValue(i),
llvm-propagate-addrspaces.cpp:                    NewPhi->getIncomingBlock(i)->getTerminator()));
llvm-propagate-addrspaces.cpp:            NewSelect->setOperand(1, CollapseCastsAndLift(NewSelect->getOperand(1), NewSelect));
llvm-propagate-addrspaces.cpp:            NewSelect->setOperand(2, CollapseCastsAndLift(NewSelect->getOperand(2), NewSelect));
llvm-propagate-addrspaces.cpp:    unsigned AS = Original->getType()->getPointerAddressSpace();
llvm-propagate-addrspaces.cpp:    visitMemop(SI, SI.getValueOperand()->getType(), StoreInst::getPointerOperandIndex());
llvm-propagate-addrspaces.cpp:    visitMemop(SI, SI.getNewValOperand()->getType(), AtomicCmpXchgInst::getPointerOperandIndex());
llvm-propagate-addrspaces.cpp:        {Replacement->getType(), MI.getOperand(1)->getType()});
llvm-propagate-addrspaces.cpp:        Value *Replacement = LiftPointer(Dest, cast<PointerType>(Dest->getType())->getElementType(), &MTI);
llvm-propagate-addrspaces.cpp:        Value *Replacement = LiftPointer(Src, cast<PointerType>(Src->getType())->getElementType(), &MTI);
llvm-propagate-addrspaces.cpp:        {Dest->getType(), Src->getType(),
llvm-propagate-addrspaces.cpp:         MTI.getOperand(2)->getType()});
llvm-propagate-addrspaces.cpp:static RegisterPass<PropagateJuliaAddrspaces> X("PropagateJuliaAddrspaces", "Propagate (non-)rootedness information", false, false);
llvm-propagate-addrspaces.cpp:    unwrap(PM)->add(createPropagateJuliaAddrspaces());
jitlayers.h:    return ConstantExpr::getIntToPtr(ConstantInt::get(Type::getInt64Ty(T->getContext()), (uint64_t)p), T);
jitlayers.h:    return ConstantExpr::getIntToPtr(ConstantInt::get(Type::getInt32Ty(T->getContext()), (uint32_t)p), T);
jitlayers.h:        return jl_is_method(li->def.method) ? jl_symbol_name(li->def.method->name) : "top-level scope";
jitlayers.h:    legacy::PassManager PM0;  // per-optlevel pass managers
jitlayers.h:    return F->isIntrinsic() || F->getName().startswith("julia.");
signame.cpp:    return std::string( buf.get(), buf.get() + size - 1 ); // We don't want the '\0' inside
signame.cpp:        vt = vt->super;
signame.cpp:    jl_sym_t *globname = dv->name->mt != NULL ? dv->name->mt->name : NULL;
signame.cpp:        !strchr(jl_symbol_name(globname), '@') && dv->name->module &&
signame.cpp:        jl_binding_resolved_p(dv->name->module, globname)) {
signame.cpp:        jl_binding_t *b = jl_get_module_binding(dv->name->module, globname);
signame.cpp:        jl_value_t* bv = jl_atomic_load_relaxed(&(b->value));
signame.cpp:// convert operator to Module.:(+), convert non-identifier to Module.var""
signame.cpp:        if (start==start->parent){
signame.cpp:        start = start->parent;
signame.cpp:        mods[i] = mods[i-1]->parent;
signame.cpp:    for (int i = n-1;i > 0;i--){
signame.cpp:        s << jl_symbol_name(mods[i]->name);
signame.cpp:    s << jl_symbol_name(m->name);
signame.cpp:        s << jl_symbol_name(m->name);
signame.cpp:    // Case 2: Some builtin-in types defined in Core is widely used and exported everywhere
signame.cpp:        start = start->parent;
signame.cpp:            mods[i] = mods[i-1]->parent;
signame.cpp:        for (int i = n-1;i > 0;i--){
signame.cpp:            s << jl_symbol_name(mods[i]->name);
signame.cpp:            typevarlist[i].prev = i == 0 ? NULL : &typevarlist[i - 1];
signame.cpp:            typevarlist[i].v = ((jl_unionall_t*)type)->var;
signame.cpp:            type = ((jl_unionall_t*)type)->body;
signame.cpp:        depth = &(typevarlist[nvars - 1]);
signame.cpp:    // Type contains no type variables, or it's fully-unapplied type.
signame.cpp:    if (jl_nparams(ftype) == 0 || ftype == ((jl_datatype_t*)ftype)->name->wrapper) {
signame.cpp:        jl_module_to_string(s,((jl_datatype_t*)ftype)->name->module);
signame.cpp:        jl_sym_t *sym = globfunc ? globname : ((jl_datatype_t*)ftype)->name->name;
signame.cpp:        //jl_module_t* m = ((jl_datatype_t*)ftype)->name->module;
signame.cpp:        if (i != tl - 1) {
signame.cpp:        //depth -= nvars - 1;
signame.cpp:            if (i != (nvars-1)){
signame.cpp:        if (vm->T) {
signame.cpp:            jl_datatype_to_string(out, vm->T, (jl_datatype_t*)jl_typeof(vm->T), depth);
signame.cpp:            if (vm->N) {
signame.cpp:                jl_datatype_to_string(out, vm->N, (jl_datatype_t*)jl_typeof(vm->N), depth);
signame.cpp:        jl_sym_t *sym = globfunc ? globname : dv->name->name;
signame.cpp:        if (jl_core_module && (dv->name->module != jl_core_module || !jl_module_exports_p(jl_core_module, sym))) {
signame.cpp:            jl_module_to_string(out,dv->name->module);
signame.cpp:        if (dv->parameters && (jl_value_t*)dv != dv->name->wrapper &&
signame.cpp:                    if (j != tlen-1)
signame.cpp:            else if (dv->name == jl_tuple_typename) {
signame.cpp:            // tail-recurse on b to flatten the printing of the Union structure in the common case
signame.cpp:            jl_datatype_to_string(out, ((jl_uniontype_t*)v)->a, (jl_datatype_t*)jl_typeof(((jl_uniontype_t*)v)->a), depth);
signame.cpp:            v = ((jl_uniontype_t*)v)->b;
signame.cpp:        //struct recur_list * newdepth = {depth, (jl_value_t*)ua->var};
signame.cpp:        //jl_datatype_to_string(out, (jl_value_t*)ua->var, jl_tvar_type, depth);
signame.cpp:            start = ((jl_unionall_t*)start)->body;
signame.cpp:        // now start point to a non-unionall type
signame.cpp:        new_unionall_depth[0].v = ((jl_unionall_t*)typevar_start)->var;
signame.cpp:            typevar_start = ((jl_unionall_t*)typevar_start)->body;
signame.cpp:            new_unionall_depth[i].prev = &(new_unionall_depth[i-1]);
signame.cpp:            new_unionall_depth[i].v = ((jl_unionall_t*)typevar_start)->var;
signame.cpp:        jl_datatype_to_string(out, start, (jl_datatype_t*)jl_typeof(start), &(new_unionall_depth[typevarnum-1]));
signame.cpp:            if (i != (typevarnum-1)){
signame.cpp:        n += jl_static_show_x(out, jl_unwrap_unionall(((jl_typename_t*)v)->wrapper), depth);
signame.cpp:        // show type-var bounds only if they aren't going to be printed by UnionAll later
signame.cpp:        for (p = depth; p != NULL; p = p->prev) {
signame.cpp:            if ((jl_tvar_t*)p->v == var) {
signame.cpp:        jl_value_t *lb = var->lb, *ub = var->ub;
signame.cpp:            // show type-var lower bound if it is defined
signame.cpp:        jl_escaped_sym_to_string(out, var->name);
signame.cpp:            // show type-var upper bound if it is defined, or if we showed the lower bound
signame.cpp:        if (m->parent != m && m->parent != jl_main_module) {
signame.cpp:            n += jl_static_show_x(out, (jl_value_t*)m->parent, depth);
signame.cpp:        n += jl_printf(out, "%s", jl_symbol_name(m->name));
signame.cpp:                       (uintptr_t)((jl_ssavalue_t*)v)->id);
signame.cpp:        if (e->head == jl_assign_sym && jl_array_len(e->args) == 2) {
signame.cpp:            n += jl_printf(out, "Expr(:%s", jl_symbol_name(e->head));
signame.cpp:            size_t i, len = jl_array_len(e->args);
signame.cpp:        if (av->flags.ptrarray) {
signame.cpp:            if (av->flags.ptrarray) {
signame.cpp:                char *ptr = ((char*)av->data) + j * av->elsize;
signame.cpp:            if (j != tlen - 1)
signame.cpp:        jl_sym_t *sym = dv->name->mt->name;
signame.cpp:        if (jl_core_module && (dv->name->module != jl_core_module || !jl_module_exports_p(jl_core_module, sym))) {
signame.cpp:            jl_module_to_string(out, dv->name->module);
signame.cpp:            for(int i = nb - 1; i >= 0; --i){
signame.cpp:                        uint8_t sel = ((uint8_t*)fld_ptr)[jl_field_size(vt, i) - 1];
signame.cpp:                else if (i != tlen - 1)
signame.cpp:    if (jl_is_method(li->def.method)){
signame.cpp:        jl_value_t* fspec = li->specTypes;
signame.cpp:        jl_value_t* fsig = li->def.method->sig;
dlload.c:        size_t j = len - 1;
dlload.c:                j--;
dlload.c:        if ((j == len-1 || path[j+1] == '.') && memcmp(ext, path + j - extlen + 1, extlen) == 0) {
dlload.c:    res = WideCharToMultiByte(CP_UTF8, 0, errmsg, -1, reason, len, NULL, NULL);
dlload.c:    reason[len - 1] = '\0';
dlload.c:    size_t len = MultiByteToWideChar(CP_UTF8, 0, filename, -1, NULL, 0);
dlload.c:    if (!MultiByteToWideChar(CP_UTF8, 0, filename, -1, wfilename, len)) return NULL;
dlload.c:        return -1;
dlload.c:        return -1;
dlload.c:      this branch returns handle of libjulia-internal
dlload.c:        jl_array_t *DL_LOAD_PATH = (jl_array_t*)(b ? jl_atomic_load_relaxed(&b->value) : NULL);
dlload.c:                    len = len - 16 + strlen(jl_options.julia_bindir);
dlload.c:                    relocated[PATHBUF-1] = '\0';
dlload.c:                    if (relocated[len-1] == PATHSEPSTRING[0])
dlload.c:     * non-NULL returns from dlerror(). Since POSIX doesn't require `dlerror`
dlload.c:     * https://github.com/freebsd/freebsd-src/blob/12db51d20823a5e3b9e5f8a2ea73156fe1cbfc28/libexec/rtld-elf/rtld.c#L198
